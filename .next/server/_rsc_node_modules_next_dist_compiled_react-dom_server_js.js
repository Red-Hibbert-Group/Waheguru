"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_rsc_node_modules_next_dist_compiled_react-dom_server_js";
exports.ids = ["_rsc_node_modules_next_dist_compiled_react-dom_server_js"];
exports.modules = {

/***/ "(rsc)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-legacy.node.development.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-legacy.node.development.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * @license React\n * react-dom-server-legacy.node.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! next/dist/compiled/react */ \"(rsc)/./node_modules/next/dist/compiled/react/index.js\");\n        var ReactDOM = __webpack_require__(/*! react-dom */ \"(rsc)/./node_modules/next/dist/compiled/react-dom/server-rendering-stub.js\");\n        var stream = __webpack_require__(/*! stream */ \"stream\");\n        var ReactVersion = \"18.3.0-canary-1a001dac6-20230812\";\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        // by calls to these methods by a Babel plugin.\n        //\n        // In PROD (or in packages without access to React internals),\n        // they are left as they are instead.\n        function warn(format) {\n            {\n                {\n                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    printWarning(\"warn\", format, args);\n                }\n            }\n        }\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        function scheduleWork(callback) {\n            callback();\n        }\n        function beginWriting(destination) {}\n        function writeChunk(destination, chunk) {\n            writeChunkAndReturn(destination, chunk);\n        }\n        function writeChunkAndReturn(destination, chunk) {\n            return destination.push(chunk);\n        }\n        function completeWriting(destination) {}\n        function close(destination) {\n            destination.push(null);\n        }\n        function stringToChunk(content) {\n            return content;\n        }\n        function stringToPrecomputedChunk(content) {\n            return content;\n        }\n        function clonePrecomputedChunk(chunk) {\n            return chunk;\n        }\n        function closeWithError(destination, error) {\n            // $FlowFixMe[incompatible-call]: This is an Error object or the destination accepts other types.\n            destination.destroy(error);\n        }\n        function _defineProperty(obj, key, value) {\n            if (key in obj) {\n                Object.defineProperty(obj, key, {\n                    value: value,\n                    enumerable: true,\n                    configurable: true,\n                    writable: true\n                });\n            } else {\n                obj[key] = value;\n            }\n            return obj;\n        }\n        function _inheritsLoose(subClass, superClass) {\n            subClass.prototype = Object.create(superClass.prototype);\n            subClass.prototype.constructor = subClass;\n            subClass.__proto__ = superClass;\n        }\n        var assign = Object.assign;\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkAttributeStringCoercion(value, attributeName) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided `%s` attribute is an unsupported type %s.\" + \" This value must be coerced to a string before before using it here.\", attributeName, typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function checkCSSPropertyStringCoercion(value, propName) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided `%s` CSS property is an unsupported type %s.\" + \" This value must be coerced to a string before before using it here.\", propName, typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function checkHtmlStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided HTML markup uses a value of unsupported type %s.\" + \" This value must be coerced to a string before before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        // -----------------------------------------------------------------------------\n        var enableFloat = true; // Enables unstable_useMemoCache hook, intended as a compilation target for\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        /* eslint-disable max-len */ var ATTRIBUTE_NAME_START_CHAR = \":A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\n        /* eslint-enable max-len */ var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + \"\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\n        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp(\"^[\" + ATTRIBUTE_NAME_START_CHAR + \"][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        var illegalAttributeNameCache = {};\n        var validatedAttributeNameCache = {};\n        function isAttributeNameSafe(attributeName) {\n            if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {\n                return true;\n            }\n            if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {\n                return false;\n            }\n            if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {\n                validatedAttributeNameCache[attributeName] = true;\n                return true;\n            }\n            illegalAttributeNameCache[attributeName] = true;\n            {\n                error(\"Invalid attribute name: `%s`\", attributeName);\n            }\n            return false;\n        }\n        /**\n * CSS properties which accept numbers but are not in units of \"px\".\n */ var unitlessNumbers = new Set([\n            \"animationIterationCount\",\n            \"aspectRatio\",\n            \"borderImageOutset\",\n            \"borderImageSlice\",\n            \"borderImageWidth\",\n            \"boxFlex\",\n            \"boxFlexGroup\",\n            \"boxOrdinalGroup\",\n            \"columnCount\",\n            \"columns\",\n            \"flex\",\n            \"flexGrow\",\n            \"flexPositive\",\n            \"flexShrink\",\n            \"flexNegative\",\n            \"flexOrder\",\n            \"gridArea\",\n            \"gridRow\",\n            \"gridRowEnd\",\n            \"gridRowSpan\",\n            \"gridRowStart\",\n            \"gridColumn\",\n            \"gridColumnEnd\",\n            \"gridColumnSpan\",\n            \"gridColumnStart\",\n            \"fontWeight\",\n            \"lineClamp\",\n            \"lineHeight\",\n            \"opacity\",\n            \"order\",\n            \"orphans\",\n            \"scale\",\n            \"tabSize\",\n            \"widows\",\n            \"zIndex\",\n            \"zoom\",\n            \"fillOpacity\",\n            \"floodOpacity\",\n            \"stopOpacity\",\n            \"strokeDasharray\",\n            \"strokeDashoffset\",\n            \"strokeMiterlimit\",\n            \"strokeOpacity\",\n            \"strokeWidth\",\n            \"MozAnimationIterationCount\",\n            \"MozBoxFlex\",\n            \"MozBoxFlexGroup\",\n            \"MozLineClamp\",\n            \"msAnimationIterationCount\",\n            \"msFlex\",\n            \"msZoom\",\n            \"msFlexGrow\",\n            \"msFlexNegative\",\n            \"msFlexOrder\",\n            \"msFlexPositive\",\n            \"msFlexShrink\",\n            \"msGridColumn\",\n            \"msGridColumnSpan\",\n            \"msGridRow\",\n            \"msGridRowSpan\",\n            \"WebkitAnimationIterationCount\",\n            \"WebkitBoxFlex\",\n            \"WebKitBoxFlexGroup\",\n            \"WebkitBoxOrdinalGroup\",\n            \"WebkitColumnCount\",\n            \"WebkitColumns\",\n            \"WebkitFlex\",\n            \"WebkitFlexGrow\",\n            \"WebkitFlexPositive\",\n            \"WebkitFlexShrink\",\n            \"WebkitLineClamp\"\n        ]);\n        function isUnitlessNumber(name) {\n            return unitlessNumbers.has(name);\n        }\n        var aliases = new Map([\n            [\n                \"acceptCharset\",\n                \"accept-charset\"\n            ],\n            [\n                \"htmlFor\",\n                \"for\"\n            ],\n            [\n                \"httpEquiv\",\n                \"http-equiv\"\n            ],\n            [\n                \"crossOrigin\",\n                \"crossorigin\"\n            ],\n            // Regular attributes that just accept strings.],\n            [\n                \"accentHeight\",\n                \"accent-height\"\n            ],\n            [\n                \"alignmentBaseline\",\n                \"alignment-baseline\"\n            ],\n            [\n                \"arabicForm\",\n                \"arabic-form\"\n            ],\n            [\n                \"baselineShift\",\n                \"baseline-shift\"\n            ],\n            [\n                \"capHeight\",\n                \"cap-height\"\n            ],\n            [\n                \"clipPath\",\n                \"clip-path\"\n            ],\n            [\n                \"clipRule\",\n                \"clip-rule\"\n            ],\n            [\n                \"colorInterpolation\",\n                \"color-interpolation\"\n            ],\n            [\n                \"colorInterpolationFilters\",\n                \"color-interpolation-filters\"\n            ],\n            [\n                \"colorProfile\",\n                \"color-profile\"\n            ],\n            [\n                \"colorRendering\",\n                \"color-rendering\"\n            ],\n            [\n                \"dominantBaseline\",\n                \"dominant-baseline\"\n            ],\n            [\n                \"enableBackground\",\n                \"enable-background\"\n            ],\n            [\n                \"fillOpacity\",\n                \"fill-opacity\"\n            ],\n            [\n                \"fillRule\",\n                \"fill-rule\"\n            ],\n            [\n                \"floodColor\",\n                \"flood-color\"\n            ],\n            [\n                \"floodOpacity\",\n                \"flood-opacity\"\n            ],\n            [\n                \"fontFamily\",\n                \"font-family\"\n            ],\n            [\n                \"fontSize\",\n                \"font-size\"\n            ],\n            [\n                \"fontSizeAdjust\",\n                \"font-size-adjust\"\n            ],\n            [\n                \"fontStretch\",\n                \"font-stretch\"\n            ],\n            [\n                \"fontStyle\",\n                \"font-style\"\n            ],\n            [\n                \"fontVariant\",\n                \"font-variant\"\n            ],\n            [\n                \"fontWeight\",\n                \"font-weight\"\n            ],\n            [\n                \"glyphName\",\n                \"glyph-name\"\n            ],\n            [\n                \"glyphOrientationHorizontal\",\n                \"glyph-orientation-horizontal\"\n            ],\n            [\n                \"glyphOrientationVertical\",\n                \"glyph-orientation-vertical\"\n            ],\n            [\n                \"horizAdvX\",\n                \"horiz-adv-x\"\n            ],\n            [\n                \"horizOriginX\",\n                \"horiz-origin-x\"\n            ],\n            [\n                \"imageRendering\",\n                \"image-rendering\"\n            ],\n            [\n                \"letterSpacing\",\n                \"letter-spacing\"\n            ],\n            [\n                \"lightingColor\",\n                \"lighting-color\"\n            ],\n            [\n                \"markerEnd\",\n                \"marker-end\"\n            ],\n            [\n                \"markerMid\",\n                \"marker-mid\"\n            ],\n            [\n                \"markerStart\",\n                \"marker-start\"\n            ],\n            [\n                \"overlinePosition\",\n                \"overline-position\"\n            ],\n            [\n                \"overlineThickness\",\n                \"overline-thickness\"\n            ],\n            [\n                \"paintOrder\",\n                \"paint-order\"\n            ],\n            [\n                \"panose-1\",\n                \"panose-1\"\n            ],\n            [\n                \"pointerEvents\",\n                \"pointer-events\"\n            ],\n            [\n                \"renderingIntent\",\n                \"rendering-intent\"\n            ],\n            [\n                \"shapeRendering\",\n                \"shape-rendering\"\n            ],\n            [\n                \"stopColor\",\n                \"stop-color\"\n            ],\n            [\n                \"stopOpacity\",\n                \"stop-opacity\"\n            ],\n            [\n                \"strikethroughPosition\",\n                \"strikethrough-position\"\n            ],\n            [\n                \"strikethroughThickness\",\n                \"strikethrough-thickness\"\n            ],\n            [\n                \"strokeDasharray\",\n                \"stroke-dasharray\"\n            ],\n            [\n                \"strokeDashoffset\",\n                \"stroke-dashoffset\"\n            ],\n            [\n                \"strokeLinecap\",\n                \"stroke-linecap\"\n            ],\n            [\n                \"strokeLinejoin\",\n                \"stroke-linejoin\"\n            ],\n            [\n                \"strokeMiterlimit\",\n                \"stroke-miterlimit\"\n            ],\n            [\n                \"strokeOpacity\",\n                \"stroke-opacity\"\n            ],\n            [\n                \"strokeWidth\",\n                \"stroke-width\"\n            ],\n            [\n                \"textAnchor\",\n                \"text-anchor\"\n            ],\n            [\n                \"textDecoration\",\n                \"text-decoration\"\n            ],\n            [\n                \"textRendering\",\n                \"text-rendering\"\n            ],\n            [\n                \"transformOrigin\",\n                \"transform-origin\"\n            ],\n            [\n                \"underlinePosition\",\n                \"underline-position\"\n            ],\n            [\n                \"underlineThickness\",\n                \"underline-thickness\"\n            ],\n            [\n                \"unicodeBidi\",\n                \"unicode-bidi\"\n            ],\n            [\n                \"unicodeRange\",\n                \"unicode-range\"\n            ],\n            [\n                \"unitsPerEm\",\n                \"units-per-em\"\n            ],\n            [\n                \"vAlphabetic\",\n                \"v-alphabetic\"\n            ],\n            [\n                \"vHanging\",\n                \"v-hanging\"\n            ],\n            [\n                \"vIdeographic\",\n                \"v-ideographic\"\n            ],\n            [\n                \"vMathematical\",\n                \"v-mathematical\"\n            ],\n            [\n                \"vectorEffect\",\n                \"vector-effect\"\n            ],\n            [\n                \"vertAdvY\",\n                \"vert-adv-y\"\n            ],\n            [\n                \"vertOriginX\",\n                \"vert-origin-x\"\n            ],\n            [\n                \"vertOriginY\",\n                \"vert-origin-y\"\n            ],\n            [\n                \"wordSpacing\",\n                \"word-spacing\"\n            ],\n            [\n                \"writingMode\",\n                \"writing-mode\"\n            ],\n            [\n                \"xmlnsXlink\",\n                \"xmlns:xlink\"\n            ],\n            [\n                \"xHeight\",\n                \"x-height\"\n            ]\n        ]);\n        function getAttributeAlias(name) {\n            return aliases.get(name) || name;\n        }\n        var hasReadOnlyValue = {\n            button: true,\n            checkbox: true,\n            image: true,\n            hidden: true,\n            radio: true,\n            reset: true,\n            submit: true\n        };\n        function checkControlledValueProps(tagName, props) {\n            {\n                if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {\n                    error(\"You provided a `value` prop to a form field without an \" + \"`onChange` handler. This will render a read-only field. If \" + \"the field should be mutable use `defaultValue`. Otherwise, \" + \"set either `onChange` or `readOnly`.\");\n                }\n                if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {\n                    error(\"You provided a `checked` prop to a form field without an \" + \"`onChange` handler. This will render a read-only field. If \" + \"the field should be mutable use `defaultChecked`. Otherwise, \" + \"set either `onChange` or `readOnly`.\");\n                }\n            }\n        }\n        var ariaProperties = {\n            \"aria-current\": 0,\n            // state\n            \"aria-description\": 0,\n            \"aria-details\": 0,\n            \"aria-disabled\": 0,\n            // state\n            \"aria-hidden\": 0,\n            // state\n            \"aria-invalid\": 0,\n            // state\n            \"aria-keyshortcuts\": 0,\n            \"aria-label\": 0,\n            \"aria-roledescription\": 0,\n            // Widget Attributes\n            \"aria-autocomplete\": 0,\n            \"aria-checked\": 0,\n            \"aria-expanded\": 0,\n            \"aria-haspopup\": 0,\n            \"aria-level\": 0,\n            \"aria-modal\": 0,\n            \"aria-multiline\": 0,\n            \"aria-multiselectable\": 0,\n            \"aria-orientation\": 0,\n            \"aria-placeholder\": 0,\n            \"aria-pressed\": 0,\n            \"aria-readonly\": 0,\n            \"aria-required\": 0,\n            \"aria-selected\": 0,\n            \"aria-sort\": 0,\n            \"aria-valuemax\": 0,\n            \"aria-valuemin\": 0,\n            \"aria-valuenow\": 0,\n            \"aria-valuetext\": 0,\n            // Live Region Attributes\n            \"aria-atomic\": 0,\n            \"aria-busy\": 0,\n            \"aria-live\": 0,\n            \"aria-relevant\": 0,\n            // Drag-and-Drop Attributes\n            \"aria-dropeffect\": 0,\n            \"aria-grabbed\": 0,\n            // Relationship Attributes\n            \"aria-activedescendant\": 0,\n            \"aria-colcount\": 0,\n            \"aria-colindex\": 0,\n            \"aria-colspan\": 0,\n            \"aria-controls\": 0,\n            \"aria-describedby\": 0,\n            \"aria-errormessage\": 0,\n            \"aria-flowto\": 0,\n            \"aria-labelledby\": 0,\n            \"aria-owns\": 0,\n            \"aria-posinset\": 0,\n            \"aria-rowcount\": 0,\n            \"aria-rowindex\": 0,\n            \"aria-rowspan\": 0,\n            \"aria-setsize\": 0\n        };\n        var warnedProperties$1 = {};\n        var rARIA$1 = new RegExp(\"^(aria)-[\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        var rARIACamel$1 = new RegExp(\"^(aria)[A-Z][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        function validateProperty$1(tagName, name) {\n            {\n                if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {\n                    return true;\n                }\n                if (rARIACamel$1.test(name)) {\n                    var ariaName = \"aria-\" + name.slice(4).toLowerCase();\n                    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null; // If this is an aria-* attribute, but is not listed in the known DOM\n                    // DOM properties, then it is an invalid aria-* attribute.\n                    if (correctName == null) {\n                        error(\"Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.\", name);\n                        warnedProperties$1[name] = true;\n                        return true;\n                    } // aria-* attributes should be lowercase; suggest the lowercase version.\n                    if (name !== correctName) {\n                        error(\"Invalid ARIA attribute `%s`. Did you mean `%s`?\", name, correctName);\n                        warnedProperties$1[name] = true;\n                        return true;\n                    }\n                }\n                if (rARIA$1.test(name)) {\n                    var lowerCasedName = name.toLowerCase();\n                    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null; // If this is an aria-* attribute, but is not listed in the known DOM\n                    // DOM properties, then it is an invalid aria-* attribute.\n                    if (standardName == null) {\n                        warnedProperties$1[name] = true;\n                        return false;\n                    } // aria-* attributes should be lowercase; suggest the lowercase version.\n                    if (name !== standardName) {\n                        error(\"Unknown ARIA attribute `%s`. Did you mean `%s`?\", name, standardName);\n                        warnedProperties$1[name] = true;\n                        return true;\n                    }\n                }\n            }\n            return true;\n        }\n        function validateProperties$2(type, props) {\n            {\n                var invalidProps = [];\n                for(var key in props){\n                    var isValid = validateProperty$1(type, key);\n                    if (!isValid) {\n                        invalidProps.push(key);\n                    }\n                }\n                var unknownPropString = invalidProps.map(function(prop) {\n                    return \"`\" + prop + \"`\";\n                }).join(\", \");\n                if (invalidProps.length === 1) {\n                    error(\"Invalid aria prop %s on <%s> tag. \" + \"For details, see https://reactjs.org/link/invalid-aria-props\", unknownPropString, type);\n                } else if (invalidProps.length > 1) {\n                    error(\"Invalid aria props %s on <%s> tag. \" + \"For details, see https://reactjs.org/link/invalid-aria-props\", unknownPropString, type);\n                }\n            }\n        }\n        var didWarnValueNull = false;\n        function validateProperties$1(type, props) {\n            {\n                if (type !== \"input\" && type !== \"textarea\" && type !== \"select\") {\n                    return;\n                }\n                if (props != null && props.value === null && !didWarnValueNull) {\n                    didWarnValueNull = true;\n                    if (type === \"select\" && props.multiple) {\n                        error(\"`value` prop on `%s` should not be null. \" + \"Consider using an empty array when `multiple` is set to `true` \" + \"to clear the component or `undefined` for uncontrolled components.\", type);\n                    } else {\n                        error(\"`value` prop on `%s` should not be null. \" + \"Consider using an empty string to clear the component or `undefined` \" + \"for uncontrolled components.\", type);\n                    }\n                }\n            }\n        }\n        function isCustomElement(tagName, props) {\n            if (tagName.indexOf(\"-\") === -1) {\n                return false;\n            }\n            switch(tagName){\n                // These are reserved SVG and MathML elements.\n                // We don't mind this list too much because we expect it to never grow.\n                // The alternative is to track the namespace in a few places which is convoluted.\n                // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\n                case \"annotation-xml\":\n                case \"color-profile\":\n                case \"font-face\":\n                case \"font-face-src\":\n                case \"font-face-uri\":\n                case \"font-face-format\":\n                case \"font-face-name\":\n                case \"missing-glyph\":\n                    return false;\n                default:\n                    return true;\n            }\n        }\n        // When adding attributes to the HTML or SVG allowed attribute list, be sure to\n        // also add them to this module to ensure casing and incorrect name\n        // warnings.\n        var possibleStandardNames = {\n            // HTML\n            accept: \"accept\",\n            acceptcharset: \"acceptCharset\",\n            \"accept-charset\": \"acceptCharset\",\n            accesskey: \"accessKey\",\n            action: \"action\",\n            allowfullscreen: \"allowFullScreen\",\n            alt: \"alt\",\n            as: \"as\",\n            async: \"async\",\n            autocapitalize: \"autoCapitalize\",\n            autocomplete: \"autoComplete\",\n            autocorrect: \"autoCorrect\",\n            autofocus: \"autoFocus\",\n            autoplay: \"autoPlay\",\n            autosave: \"autoSave\",\n            capture: \"capture\",\n            cellpadding: \"cellPadding\",\n            cellspacing: \"cellSpacing\",\n            challenge: \"challenge\",\n            charset: \"charSet\",\n            checked: \"checked\",\n            children: \"children\",\n            cite: \"cite\",\n            class: \"className\",\n            classid: \"classID\",\n            classname: \"className\",\n            cols: \"cols\",\n            colspan: \"colSpan\",\n            content: \"content\",\n            contenteditable: \"contentEditable\",\n            contextmenu: \"contextMenu\",\n            controls: \"controls\",\n            controlslist: \"controlsList\",\n            coords: \"coords\",\n            crossorigin: \"crossOrigin\",\n            dangerouslysetinnerhtml: \"dangerouslySetInnerHTML\",\n            data: \"data\",\n            datetime: \"dateTime\",\n            default: \"default\",\n            defaultchecked: \"defaultChecked\",\n            defaultvalue: \"defaultValue\",\n            defer: \"defer\",\n            dir: \"dir\",\n            disabled: \"disabled\",\n            disablepictureinpicture: \"disablePictureInPicture\",\n            disableremoteplayback: \"disableRemotePlayback\",\n            download: \"download\",\n            draggable: \"draggable\",\n            enctype: \"encType\",\n            enterkeyhint: \"enterKeyHint\",\n            fetchpriority: \"fetchPriority\",\n            for: \"htmlFor\",\n            form: \"form\",\n            formmethod: \"formMethod\",\n            formaction: \"formAction\",\n            formenctype: \"formEncType\",\n            formnovalidate: \"formNoValidate\",\n            formtarget: \"formTarget\",\n            frameborder: \"frameBorder\",\n            headers: \"headers\",\n            height: \"height\",\n            hidden: \"hidden\",\n            high: \"high\",\n            href: \"href\",\n            hreflang: \"hrefLang\",\n            htmlfor: \"htmlFor\",\n            httpequiv: \"httpEquiv\",\n            \"http-equiv\": \"httpEquiv\",\n            icon: \"icon\",\n            id: \"id\",\n            imagesizes: \"imageSizes\",\n            imagesrcset: \"imageSrcSet\",\n            innerhtml: \"innerHTML\",\n            inputmode: \"inputMode\",\n            integrity: \"integrity\",\n            is: \"is\",\n            itemid: \"itemID\",\n            itemprop: \"itemProp\",\n            itemref: \"itemRef\",\n            itemscope: \"itemScope\",\n            itemtype: \"itemType\",\n            keyparams: \"keyParams\",\n            keytype: \"keyType\",\n            kind: \"kind\",\n            label: \"label\",\n            lang: \"lang\",\n            list: \"list\",\n            loop: \"loop\",\n            low: \"low\",\n            manifest: \"manifest\",\n            marginwidth: \"marginWidth\",\n            marginheight: \"marginHeight\",\n            max: \"max\",\n            maxlength: \"maxLength\",\n            media: \"media\",\n            mediagroup: \"mediaGroup\",\n            method: \"method\",\n            min: \"min\",\n            minlength: \"minLength\",\n            multiple: \"multiple\",\n            muted: \"muted\",\n            name: \"name\",\n            nomodule: \"noModule\",\n            nonce: \"nonce\",\n            novalidate: \"noValidate\",\n            open: \"open\",\n            optimum: \"optimum\",\n            pattern: \"pattern\",\n            placeholder: \"placeholder\",\n            playsinline: \"playsInline\",\n            poster: \"poster\",\n            preload: \"preload\",\n            profile: \"profile\",\n            radiogroup: \"radioGroup\",\n            readonly: \"readOnly\",\n            referrerpolicy: \"referrerPolicy\",\n            rel: \"rel\",\n            required: \"required\",\n            reversed: \"reversed\",\n            role: \"role\",\n            rows: \"rows\",\n            rowspan: \"rowSpan\",\n            sandbox: \"sandbox\",\n            scope: \"scope\",\n            scoped: \"scoped\",\n            scrolling: \"scrolling\",\n            seamless: \"seamless\",\n            selected: \"selected\",\n            shape: \"shape\",\n            size: \"size\",\n            sizes: \"sizes\",\n            span: \"span\",\n            spellcheck: \"spellCheck\",\n            src: \"src\",\n            srcdoc: \"srcDoc\",\n            srclang: \"srcLang\",\n            srcset: \"srcSet\",\n            start: \"start\",\n            step: \"step\",\n            style: \"style\",\n            summary: \"summary\",\n            tabindex: \"tabIndex\",\n            target: \"target\",\n            title: \"title\",\n            type: \"type\",\n            usemap: \"useMap\",\n            value: \"value\",\n            width: \"width\",\n            wmode: \"wmode\",\n            wrap: \"wrap\",\n            // SVG\n            about: \"about\",\n            accentheight: \"accentHeight\",\n            \"accent-height\": \"accentHeight\",\n            accumulate: \"accumulate\",\n            additive: \"additive\",\n            alignmentbaseline: \"alignmentBaseline\",\n            \"alignment-baseline\": \"alignmentBaseline\",\n            allowreorder: \"allowReorder\",\n            alphabetic: \"alphabetic\",\n            amplitude: \"amplitude\",\n            arabicform: \"arabicForm\",\n            \"arabic-form\": \"arabicForm\",\n            ascent: \"ascent\",\n            attributename: \"attributeName\",\n            attributetype: \"attributeType\",\n            autoreverse: \"autoReverse\",\n            azimuth: \"azimuth\",\n            basefrequency: \"baseFrequency\",\n            baselineshift: \"baselineShift\",\n            \"baseline-shift\": \"baselineShift\",\n            baseprofile: \"baseProfile\",\n            bbox: \"bbox\",\n            begin: \"begin\",\n            bias: \"bias\",\n            by: \"by\",\n            calcmode: \"calcMode\",\n            capheight: \"capHeight\",\n            \"cap-height\": \"capHeight\",\n            clip: \"clip\",\n            clippath: \"clipPath\",\n            \"clip-path\": \"clipPath\",\n            clippathunits: \"clipPathUnits\",\n            cliprule: \"clipRule\",\n            \"clip-rule\": \"clipRule\",\n            color: \"color\",\n            colorinterpolation: \"colorInterpolation\",\n            \"color-interpolation\": \"colorInterpolation\",\n            colorinterpolationfilters: \"colorInterpolationFilters\",\n            \"color-interpolation-filters\": \"colorInterpolationFilters\",\n            colorprofile: \"colorProfile\",\n            \"color-profile\": \"colorProfile\",\n            colorrendering: \"colorRendering\",\n            \"color-rendering\": \"colorRendering\",\n            contentscripttype: \"contentScriptType\",\n            contentstyletype: \"contentStyleType\",\n            cursor: \"cursor\",\n            cx: \"cx\",\n            cy: \"cy\",\n            d: \"d\",\n            datatype: \"datatype\",\n            decelerate: \"decelerate\",\n            descent: \"descent\",\n            diffuseconstant: \"diffuseConstant\",\n            direction: \"direction\",\n            display: \"display\",\n            divisor: \"divisor\",\n            dominantbaseline: \"dominantBaseline\",\n            \"dominant-baseline\": \"dominantBaseline\",\n            dur: \"dur\",\n            dx: \"dx\",\n            dy: \"dy\",\n            edgemode: \"edgeMode\",\n            elevation: \"elevation\",\n            enablebackground: \"enableBackground\",\n            \"enable-background\": \"enableBackground\",\n            end: \"end\",\n            exponent: \"exponent\",\n            externalresourcesrequired: \"externalResourcesRequired\",\n            fill: \"fill\",\n            fillopacity: \"fillOpacity\",\n            \"fill-opacity\": \"fillOpacity\",\n            fillrule: \"fillRule\",\n            \"fill-rule\": \"fillRule\",\n            filter: \"filter\",\n            filterres: \"filterRes\",\n            filterunits: \"filterUnits\",\n            floodopacity: \"floodOpacity\",\n            \"flood-opacity\": \"floodOpacity\",\n            floodcolor: \"floodColor\",\n            \"flood-color\": \"floodColor\",\n            focusable: \"focusable\",\n            fontfamily: \"fontFamily\",\n            \"font-family\": \"fontFamily\",\n            fontsize: \"fontSize\",\n            \"font-size\": \"fontSize\",\n            fontsizeadjust: \"fontSizeAdjust\",\n            \"font-size-adjust\": \"fontSizeAdjust\",\n            fontstretch: \"fontStretch\",\n            \"font-stretch\": \"fontStretch\",\n            fontstyle: \"fontStyle\",\n            \"font-style\": \"fontStyle\",\n            fontvariant: \"fontVariant\",\n            \"font-variant\": \"fontVariant\",\n            fontweight: \"fontWeight\",\n            \"font-weight\": \"fontWeight\",\n            format: \"format\",\n            from: \"from\",\n            fx: \"fx\",\n            fy: \"fy\",\n            g1: \"g1\",\n            g2: \"g2\",\n            glyphname: \"glyphName\",\n            \"glyph-name\": \"glyphName\",\n            glyphorientationhorizontal: \"glyphOrientationHorizontal\",\n            \"glyph-orientation-horizontal\": \"glyphOrientationHorizontal\",\n            glyphorientationvertical: \"glyphOrientationVertical\",\n            \"glyph-orientation-vertical\": \"glyphOrientationVertical\",\n            glyphref: \"glyphRef\",\n            gradienttransform: \"gradientTransform\",\n            gradientunits: \"gradientUnits\",\n            hanging: \"hanging\",\n            horizadvx: \"horizAdvX\",\n            \"horiz-adv-x\": \"horizAdvX\",\n            horizoriginx: \"horizOriginX\",\n            \"horiz-origin-x\": \"horizOriginX\",\n            ideographic: \"ideographic\",\n            imagerendering: \"imageRendering\",\n            \"image-rendering\": \"imageRendering\",\n            in2: \"in2\",\n            in: \"in\",\n            inlist: \"inlist\",\n            intercept: \"intercept\",\n            k1: \"k1\",\n            k2: \"k2\",\n            k3: \"k3\",\n            k4: \"k4\",\n            k: \"k\",\n            kernelmatrix: \"kernelMatrix\",\n            kernelunitlength: \"kernelUnitLength\",\n            kerning: \"kerning\",\n            keypoints: \"keyPoints\",\n            keysplines: \"keySplines\",\n            keytimes: \"keyTimes\",\n            lengthadjust: \"lengthAdjust\",\n            letterspacing: \"letterSpacing\",\n            \"letter-spacing\": \"letterSpacing\",\n            lightingcolor: \"lightingColor\",\n            \"lighting-color\": \"lightingColor\",\n            limitingconeangle: \"limitingConeAngle\",\n            local: \"local\",\n            markerend: \"markerEnd\",\n            \"marker-end\": \"markerEnd\",\n            markerheight: \"markerHeight\",\n            markermid: \"markerMid\",\n            \"marker-mid\": \"markerMid\",\n            markerstart: \"markerStart\",\n            \"marker-start\": \"markerStart\",\n            markerunits: \"markerUnits\",\n            markerwidth: \"markerWidth\",\n            mask: \"mask\",\n            maskcontentunits: \"maskContentUnits\",\n            maskunits: \"maskUnits\",\n            mathematical: \"mathematical\",\n            mode: \"mode\",\n            numoctaves: \"numOctaves\",\n            offset: \"offset\",\n            opacity: \"opacity\",\n            operator: \"operator\",\n            order: \"order\",\n            orient: \"orient\",\n            orientation: \"orientation\",\n            origin: \"origin\",\n            overflow: \"overflow\",\n            overlineposition: \"overlinePosition\",\n            \"overline-position\": \"overlinePosition\",\n            overlinethickness: \"overlineThickness\",\n            \"overline-thickness\": \"overlineThickness\",\n            paintorder: \"paintOrder\",\n            \"paint-order\": \"paintOrder\",\n            panose1: \"panose1\",\n            \"panose-1\": \"panose1\",\n            pathlength: \"pathLength\",\n            patterncontentunits: \"patternContentUnits\",\n            patterntransform: \"patternTransform\",\n            patternunits: \"patternUnits\",\n            pointerevents: \"pointerEvents\",\n            \"pointer-events\": \"pointerEvents\",\n            points: \"points\",\n            pointsatx: \"pointsAtX\",\n            pointsaty: \"pointsAtY\",\n            pointsatz: \"pointsAtZ\",\n            prefix: \"prefix\",\n            preservealpha: \"preserveAlpha\",\n            preserveaspectratio: \"preserveAspectRatio\",\n            primitiveunits: \"primitiveUnits\",\n            property: \"property\",\n            r: \"r\",\n            radius: \"radius\",\n            refx: \"refX\",\n            refy: \"refY\",\n            renderingintent: \"renderingIntent\",\n            \"rendering-intent\": \"renderingIntent\",\n            repeatcount: \"repeatCount\",\n            repeatdur: \"repeatDur\",\n            requiredextensions: \"requiredExtensions\",\n            requiredfeatures: \"requiredFeatures\",\n            resource: \"resource\",\n            restart: \"restart\",\n            result: \"result\",\n            results: \"results\",\n            rotate: \"rotate\",\n            rx: \"rx\",\n            ry: \"ry\",\n            scale: \"scale\",\n            security: \"security\",\n            seed: \"seed\",\n            shaperendering: \"shapeRendering\",\n            \"shape-rendering\": \"shapeRendering\",\n            slope: \"slope\",\n            spacing: \"spacing\",\n            specularconstant: \"specularConstant\",\n            specularexponent: \"specularExponent\",\n            speed: \"speed\",\n            spreadmethod: \"spreadMethod\",\n            startoffset: \"startOffset\",\n            stddeviation: \"stdDeviation\",\n            stemh: \"stemh\",\n            stemv: \"stemv\",\n            stitchtiles: \"stitchTiles\",\n            stopcolor: \"stopColor\",\n            \"stop-color\": \"stopColor\",\n            stopopacity: \"stopOpacity\",\n            \"stop-opacity\": \"stopOpacity\",\n            strikethroughposition: \"strikethroughPosition\",\n            \"strikethrough-position\": \"strikethroughPosition\",\n            strikethroughthickness: \"strikethroughThickness\",\n            \"strikethrough-thickness\": \"strikethroughThickness\",\n            string: \"string\",\n            stroke: \"stroke\",\n            strokedasharray: \"strokeDasharray\",\n            \"stroke-dasharray\": \"strokeDasharray\",\n            strokedashoffset: \"strokeDashoffset\",\n            \"stroke-dashoffset\": \"strokeDashoffset\",\n            strokelinecap: \"strokeLinecap\",\n            \"stroke-linecap\": \"strokeLinecap\",\n            strokelinejoin: \"strokeLinejoin\",\n            \"stroke-linejoin\": \"strokeLinejoin\",\n            strokemiterlimit: \"strokeMiterlimit\",\n            \"stroke-miterlimit\": \"strokeMiterlimit\",\n            strokewidth: \"strokeWidth\",\n            \"stroke-width\": \"strokeWidth\",\n            strokeopacity: \"strokeOpacity\",\n            \"stroke-opacity\": \"strokeOpacity\",\n            suppresscontenteditablewarning: \"suppressContentEditableWarning\",\n            suppresshydrationwarning: \"suppressHydrationWarning\",\n            surfacescale: \"surfaceScale\",\n            systemlanguage: \"systemLanguage\",\n            tablevalues: \"tableValues\",\n            targetx: \"targetX\",\n            targety: \"targetY\",\n            textanchor: \"textAnchor\",\n            \"text-anchor\": \"textAnchor\",\n            textdecoration: \"textDecoration\",\n            \"text-decoration\": \"textDecoration\",\n            textlength: \"textLength\",\n            textrendering: \"textRendering\",\n            \"text-rendering\": \"textRendering\",\n            to: \"to\",\n            transform: \"transform\",\n            transformorigin: \"transformOrigin\",\n            \"transform-origin\": \"transformOrigin\",\n            typeof: \"typeof\",\n            u1: \"u1\",\n            u2: \"u2\",\n            underlineposition: \"underlinePosition\",\n            \"underline-position\": \"underlinePosition\",\n            underlinethickness: \"underlineThickness\",\n            \"underline-thickness\": \"underlineThickness\",\n            unicode: \"unicode\",\n            unicodebidi: \"unicodeBidi\",\n            \"unicode-bidi\": \"unicodeBidi\",\n            unicoderange: \"unicodeRange\",\n            \"unicode-range\": \"unicodeRange\",\n            unitsperem: \"unitsPerEm\",\n            \"units-per-em\": \"unitsPerEm\",\n            unselectable: \"unselectable\",\n            valphabetic: \"vAlphabetic\",\n            \"v-alphabetic\": \"vAlphabetic\",\n            values: \"values\",\n            vectoreffect: \"vectorEffect\",\n            \"vector-effect\": \"vectorEffect\",\n            version: \"version\",\n            vertadvy: \"vertAdvY\",\n            \"vert-adv-y\": \"vertAdvY\",\n            vertoriginx: \"vertOriginX\",\n            \"vert-origin-x\": \"vertOriginX\",\n            vertoriginy: \"vertOriginY\",\n            \"vert-origin-y\": \"vertOriginY\",\n            vhanging: \"vHanging\",\n            \"v-hanging\": \"vHanging\",\n            videographic: \"vIdeographic\",\n            \"v-ideographic\": \"vIdeographic\",\n            viewbox: \"viewBox\",\n            viewtarget: \"viewTarget\",\n            visibility: \"visibility\",\n            vmathematical: \"vMathematical\",\n            \"v-mathematical\": \"vMathematical\",\n            vocab: \"vocab\",\n            widths: \"widths\",\n            wordspacing: \"wordSpacing\",\n            \"word-spacing\": \"wordSpacing\",\n            writingmode: \"writingMode\",\n            \"writing-mode\": \"writingMode\",\n            x1: \"x1\",\n            x2: \"x2\",\n            x: \"x\",\n            xchannelselector: \"xChannelSelector\",\n            xheight: \"xHeight\",\n            \"x-height\": \"xHeight\",\n            xlinkactuate: \"xlinkActuate\",\n            \"xlink:actuate\": \"xlinkActuate\",\n            xlinkarcrole: \"xlinkArcrole\",\n            \"xlink:arcrole\": \"xlinkArcrole\",\n            xlinkhref: \"xlinkHref\",\n            \"xlink:href\": \"xlinkHref\",\n            xlinkrole: \"xlinkRole\",\n            \"xlink:role\": \"xlinkRole\",\n            xlinkshow: \"xlinkShow\",\n            \"xlink:show\": \"xlinkShow\",\n            xlinktitle: \"xlinkTitle\",\n            \"xlink:title\": \"xlinkTitle\",\n            xlinktype: \"xlinkType\",\n            \"xlink:type\": \"xlinkType\",\n            xmlbase: \"xmlBase\",\n            \"xml:base\": \"xmlBase\",\n            xmllang: \"xmlLang\",\n            \"xml:lang\": \"xmlLang\",\n            xmlns: \"xmlns\",\n            \"xml:space\": \"xmlSpace\",\n            xmlnsxlink: \"xmlnsXlink\",\n            \"xmlns:xlink\": \"xmlnsXlink\",\n            xmlspace: \"xmlSpace\",\n            y1: \"y1\",\n            y2: \"y2\",\n            y: \"y\",\n            ychannelselector: \"yChannelSelector\",\n            z: \"z\",\n            zoomandpan: \"zoomAndPan\"\n        };\n        var warnedProperties = {};\n        var EVENT_NAME_REGEX = /^on./;\n        var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;\n        var rARIA = new RegExp(\"^(aria)-[\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        var rARIACamel = new RegExp(\"^(aria)[A-Z][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        function validateProperty(tagName, name, value, eventRegistry) {\n            {\n                if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {\n                    return true;\n                }\n                var lowerCasedName = name.toLowerCase();\n                if (lowerCasedName === \"onfocusin\" || lowerCasedName === \"onfocusout\") {\n                    error(\"React uses onFocus and onBlur instead of onFocusIn and onFocusOut. \" + \"All React events are normalized to bubble, so onFocusIn and onFocusOut \" + \"are not needed/supported by React.\");\n                    warnedProperties[name] = true;\n                    return true;\n                }\n                if (eventRegistry != null) {\n                    var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;\n                    if (registrationNameDependencies.hasOwnProperty(name)) {\n                        return true;\n                    }\n                    var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;\n                    if (registrationName != null) {\n                        error(\"Invalid event handler property `%s`. Did you mean `%s`?\", name, registrationName);\n                        warnedProperties[name] = true;\n                        return true;\n                    }\n                    if (EVENT_NAME_REGEX.test(name)) {\n                        error(\"Unknown event handler property `%s`. It will be ignored.\", name);\n                        warnedProperties[name] = true;\n                        return true;\n                    }\n                } else if (EVENT_NAME_REGEX.test(name)) {\n                    // If no event plugins have been injected, we are in a server environment.\n                    // So we can't tell if the event name is correct for sure, but we can filter\n                    // out known bad ones like `onclick`. We can't suggest a specific replacement though.\n                    if (INVALID_EVENT_NAME_REGEX.test(name)) {\n                        error(\"Invalid event handler property `%s`. \" + \"React events use the camelCase naming convention, for example `onClick`.\", name);\n                    }\n                    warnedProperties[name] = true;\n                    return true;\n                } // Let the ARIA attribute hook validate ARIA attributes\n                if (rARIA.test(name) || rARIACamel.test(name)) {\n                    return true;\n                }\n                if (lowerCasedName === \"innerhtml\") {\n                    error(\"Directly setting property `innerHTML` is not permitted. \" + \"For more information, lookup documentation on `dangerouslySetInnerHTML`.\");\n                    warnedProperties[name] = true;\n                    return true;\n                }\n                if (lowerCasedName === \"aria\") {\n                    error(\"The `aria` attribute is reserved for future use in React. \" + \"Pass individual `aria-` attributes instead.\");\n                    warnedProperties[name] = true;\n                    return true;\n                }\n                if (lowerCasedName === \"is\" && value !== null && value !== undefined && typeof value !== \"string\") {\n                    error(\"Received a `%s` for a string attribute `is`. If this is expected, cast \" + \"the value to a string.\", typeof value);\n                    warnedProperties[name] = true;\n                    return true;\n                }\n                if (typeof value === \"number\" && isNaN(value)) {\n                    error(\"Received NaN for the `%s` attribute. If this is expected, cast \" + \"the value to a string.\", name);\n                    warnedProperties[name] = true;\n                    return true;\n                } // Known attributes should match the casing specified in the property config.\n                if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n                    var standardName = possibleStandardNames[lowerCasedName];\n                    if (standardName !== name) {\n                        error(\"Invalid DOM property `%s`. Did you mean `%s`?\", name, standardName);\n                        warnedProperties[name] = true;\n                        return true;\n                    }\n                } else if (name !== lowerCasedName) {\n                    // Unknown attributes should have lowercase casing since that's how they\n                    // will be cased anyway with server rendering.\n                    error(\"React does not recognize the `%s` prop on a DOM element. If you \" + \"intentionally want it to appear in the DOM as a custom \" + \"attribute, spell it as lowercase `%s` instead. \" + \"If you accidentally passed it from a parent component, remove \" + \"it from the DOM element.\", name, lowerCasedName);\n                    warnedProperties[name] = true;\n                    return true;\n                } // Now that we've validated casing, do not validate\n                // data types for reserved props\n                switch(name){\n                    case \"dangerouslySetInnerHTML\":\n                    case \"children\":\n                    case \"style\":\n                    case \"suppressContentEditableWarning\":\n                    case \"suppressHydrationWarning\":\n                    case \"defaultValue\":\n                    case \"defaultChecked\":\n                    case \"innerHTML\":\n                        {\n                            return true;\n                        }\n                }\n                switch(typeof value){\n                    case \"boolean\":\n                        {\n                            switch(name){\n                                case \"autoFocus\":\n                                case \"checked\":\n                                case \"multiple\":\n                                case \"muted\":\n                                case \"selected\":\n                                case \"contentEditable\":\n                                case \"spellCheck\":\n                                case \"draggable\":\n                                case \"value\":\n                                case \"autoReverse\":\n                                case \"externalResourcesRequired\":\n                                case \"focusable\":\n                                case \"preserveAlpha\":\n                                case \"allowFullScreen\":\n                                case \"async\":\n                                case \"autoPlay\":\n                                case \"controls\":\n                                case \"default\":\n                                case \"defer\":\n                                case \"disabled\":\n                                case \"disablePictureInPicture\":\n                                case \"disableRemotePlayback\":\n                                case \"formNoValidate\":\n                                case \"hidden\":\n                                case \"loop\":\n                                case \"noModule\":\n                                case \"noValidate\":\n                                case \"open\":\n                                case \"playsInline\":\n                                case \"readOnly\":\n                                case \"required\":\n                                case \"reversed\":\n                                case \"scoped\":\n                                case \"seamless\":\n                                case \"itemScope\":\n                                case \"capture\":\n                                case \"download\":\n                                    {\n                                        // Boolean properties can accept boolean values\n                                        return true;\n                                    }\n                                default:\n                                    {\n                                        var prefix = name.toLowerCase().slice(0, 5);\n                                        if (prefix === \"data-\" || prefix === \"aria-\") {\n                                            return true;\n                                        }\n                                        if (value) {\n                                            error(\"Received `%s` for a non-boolean attribute `%s`.\\n\\n\" + \"If you want to write it to the DOM, pass a string instead: \" + '%s=\"%s\" or %s={value.toString()}.', value, name, name, value, name);\n                                        } else {\n                                            error(\"Received `%s` for a non-boolean attribute `%s`.\\n\\n\" + \"If you want to write it to the DOM, pass a string instead: \" + '%s=\"%s\" or %s={value.toString()}.\\n\\n' + \"If you used to conditionally omit it with %s={condition && value}, \" + \"pass %s={condition ? value : undefined} instead.\", value, name, name, value, name, name, name);\n                                        }\n                                        warnedProperties[name] = true;\n                                        return true;\n                                    }\n                            }\n                        }\n                    case \"function\":\n                    case \"symbol\":\n                        // eslint-disable-line\n                        // Warn when a known attribute is a bad type\n                        warnedProperties[name] = true;\n                        return false;\n                    case \"string\":\n                        {\n                            // Warn when passing the strings 'false' or 'true' into a boolean prop\n                            if (value === \"false\" || value === \"true\") {\n                                switch(name){\n                                    case \"checked\":\n                                    case \"selected\":\n                                    case \"multiple\":\n                                    case \"muted\":\n                                    case \"allowFullScreen\":\n                                    case \"async\":\n                                    case \"autoPlay\":\n                                    case \"controls\":\n                                    case \"default\":\n                                    case \"defer\":\n                                    case \"disabled\":\n                                    case \"disablePictureInPicture\":\n                                    case \"disableRemotePlayback\":\n                                    case \"formNoValidate\":\n                                    case \"hidden\":\n                                    case \"loop\":\n                                    case \"noModule\":\n                                    case \"noValidate\":\n                                    case \"open\":\n                                    case \"playsInline\":\n                                    case \"readOnly\":\n                                    case \"required\":\n                                    case \"reversed\":\n                                    case \"scoped\":\n                                    case \"seamless\":\n                                    case \"itemScope\":\n                                        {\n                                            break;\n                                        }\n                                    default:\n                                        {\n                                            return true;\n                                        }\n                                }\n                                error(\"Received the string `%s` for the boolean attribute `%s`. \" + \"%s \" + \"Did you mean %s={%s}?\", value, name, value === \"false\" ? \"The browser will interpret it as a truthy value.\" : 'Although this works, it will not work as expected if you pass the string \"false\".', name, value);\n                                warnedProperties[name] = true;\n                                return true;\n                            }\n                        }\n                }\n                return true;\n            }\n        }\n        function warnUnknownProperties(type, props, eventRegistry) {\n            {\n                var unknownProps = [];\n                for(var key in props){\n                    var isValid = validateProperty(type, key, props[key], eventRegistry);\n                    if (!isValid) {\n                        unknownProps.push(key);\n                    }\n                }\n                var unknownPropString = unknownProps.map(function(prop) {\n                    return \"`\" + prop + \"`\";\n                }).join(\", \");\n                if (unknownProps.length === 1) {\n                    error(\"Invalid value for prop %s on <%s> tag. Either remove it from the element, \" + \"or pass a string or number value to keep it in the DOM. \" + \"For details, see https://reactjs.org/link/attribute-behavior \", unknownPropString, type);\n                } else if (unknownProps.length > 1) {\n                    error(\"Invalid values for props %s on <%s> tag. Either remove them from the element, \" + \"or pass a string or number value to keep them in the DOM. \" + \"For details, see https://reactjs.org/link/attribute-behavior \", unknownPropString, type);\n                }\n            }\n        }\n        function validateProperties(type, props, eventRegistry) {\n            if (isCustomElement(type) || typeof props.is === \"string\") {\n                return;\n            }\n            warnUnknownProperties(type, props, eventRegistry);\n        }\n        // 'msTransform' is correct, but the other prefixes should be capitalized\n        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;\n        var msPattern$1 = /^-ms-/;\n        var hyphenPattern = /-(.)/g; // style values shouldn't contain a semicolon\n        var badStyleValueWithSemicolonPattern = /;\\s*$/;\n        var warnedStyleNames = {};\n        var warnedStyleValues = {};\n        var warnedForNaNValue = false;\n        var warnedForInfinityValue = false;\n        function camelize(string) {\n            return string.replace(hyphenPattern, function(_, character) {\n                return character.toUpperCase();\n            });\n        }\n        function warnHyphenatedStyleName(name) {\n            {\n                if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n                    return;\n                }\n                warnedStyleNames[name] = true;\n                error(\"Unsupported style property %s. Did you mean %s?\", name, // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n                // is converted to lowercase `ms`.\n                camelize(name.replace(msPattern$1, \"ms-\")));\n            }\n        }\n        function warnBadVendoredStyleName(name) {\n            {\n                if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n                    return;\n                }\n                warnedStyleNames[name] = true;\n                error(\"Unsupported vendor-prefixed style property %s. Did you mean %s?\", name, name.charAt(0).toUpperCase() + name.slice(1));\n            }\n        }\n        function warnStyleValueWithSemicolon(name, value) {\n            {\n                if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {\n                    return;\n                }\n                warnedStyleValues[value] = true;\n                error(\"Style property values shouldn't contain a semicolon. \" + 'Try \"%s: %s\" instead.', name, value.replace(badStyleValueWithSemicolonPattern, \"\"));\n            }\n        }\n        function warnStyleValueIsNaN(name, value) {\n            {\n                if (warnedForNaNValue) {\n                    return;\n                }\n                warnedForNaNValue = true;\n                error(\"`NaN` is an invalid value for the `%s` css style property.\", name);\n            }\n        }\n        function warnStyleValueIsInfinity(name, value) {\n            {\n                if (warnedForInfinityValue) {\n                    return;\n                }\n                warnedForInfinityValue = true;\n                error(\"`Infinity` is an invalid value for the `%s` css style property.\", name);\n            }\n        }\n        function warnValidStyle(name, value) {\n            {\n                if (name.indexOf(\"-\") > -1) {\n                    warnHyphenatedStyleName(name);\n                } else if (badVendoredStyleNamePattern.test(name)) {\n                    warnBadVendoredStyleName(name);\n                } else if (badStyleValueWithSemicolonPattern.test(value)) {\n                    warnStyleValueWithSemicolon(name, value);\n                }\n                if (typeof value === \"number\") {\n                    if (isNaN(value)) {\n                        warnStyleValueIsNaN(name);\n                    } else if (!isFinite(value)) {\n                        warnStyleValueIsInfinity(name);\n                    }\n                }\n            }\n        }\n        // code copied and modified from escape-html\n        var matchHtmlRegExp = /[\"'&<>]/;\n        /**\n * Escapes special characters and HTML entities in a given html string.\n *\n * @param  {string} string HTML string to escape for later insertion\n * @return {string}\n * @public\n */ function escapeHtml(string) {\n            {\n                checkHtmlStringCoercion(string);\n            }\n            var str = \"\" + string;\n            var match = matchHtmlRegExp.exec(str);\n            if (!match) {\n                return str;\n            }\n            var escape;\n            var html = \"\";\n            var index;\n            var lastIndex = 0;\n            for(index = match.index; index < str.length; index++){\n                switch(str.charCodeAt(index)){\n                    case 34:\n                        // \"\n                        escape = \"&quot;\";\n                        break;\n                    case 38:\n                        // &\n                        escape = \"&amp;\";\n                        break;\n                    case 39:\n                        // '\n                        escape = \"&#x27;\"; // modified from escape-html; used to be '&#39'\n                        break;\n                    case 60:\n                        // <\n                        escape = \"&lt;\";\n                        break;\n                    case 62:\n                        // >\n                        escape = \"&gt;\";\n                        break;\n                    default:\n                        continue;\n                }\n                if (lastIndex !== index) {\n                    html += str.slice(lastIndex, index);\n                }\n                lastIndex = index + 1;\n                html += escape;\n            }\n            return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\n        } // end code copied and modified from escape-html\n        /**\n * Escapes text to prevent scripting attacks.\n *\n * @param {*} text Text value to escape.\n * @return {string} An escaped string.\n */ function escapeTextForBrowser(text) {\n            if (typeof text === \"boolean\" || typeof text === \"number\") {\n                // this shortcircuit helps perf for types that we know will never have\n                // special characters, especially given that this function is used often\n                // for numeric dom ids.\n                return \"\" + text;\n            }\n            return escapeHtml(text);\n        }\n        var uppercasePattern = /([A-Z])/g;\n        var msPattern = /^ms-/;\n        /**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n */ function hyphenateStyleName(name) {\n            return name.replace(uppercasePattern, \"-$1\").toLowerCase().replace(msPattern, \"-ms-\");\n        }\n        // and any newline or tab are filtered out as if they're not part of the URL.\n        // https://url.spec.whatwg.org/#url-parsing\n        // Tab or newline are defined as \\r\\n\\t:\n        // https://infra.spec.whatwg.org/#ascii-tab-or-newline\n        // A C0 control is a code point in the range \\u0000 NULL to \\u001F\n        // INFORMATION SEPARATOR ONE, inclusive:\n        // https://infra.spec.whatwg.org/#c0-control-or-space\n        /* eslint-disable max-len */ var isJavaScriptProtocol = /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*\\:/i;\n        var didWarn = false;\n        function sanitizeURL(url) {\n            // We should never have symbols here because they get filtered out elsewhere.\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            var stringifiedURL = \"\" + url;\n            {\n                if (!didWarn && isJavaScriptProtocol.test(stringifiedURL)) {\n                    didWarn = true;\n                    error(\"A future version of React will block javascript: URLs as a security precaution. \" + \"Use event handlers instead if you can. If you need to generate unsafe HTML try \" + \"using dangerouslySetInnerHTML instead. React was passed %s.\", JSON.stringify(stringifiedURL));\n                }\n            }\n            return url;\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        // The build script is at scripts/rollup/generate-inline-fizz-runtime.js.\n        // Run `yarn generate-inline-fizz-runtime` to generate.\n        var clientRenderBoundary = '$RX=function(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data=\"$!\",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};';\n        var completeBoundary = '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data=\"$!\",a.setAttribute(\"data-dgst\",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if(\"/$\"===d)if(0===f)break;else f--;else\"$\"!==d&&\"$?\"!==d&&\"$!\"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data=\"$\"}b._reactRetry&&b._reactRetry()}};';\n        var completeBoundaryWithStyles = '$RM=new Map;\\n$RR=function(r,t,w){for(var u=$RC,n=$RM,p=new Map,q=document,g,b,h=q.querySelectorAll(\"link[data-precedence],style[data-precedence]\"),v=[],k=0;b=h[k++];)\"not all\"===b.getAttribute(\"media\")?v.push(b):(\"LINK\"===b.tagName&&n.set(b.getAttribute(\"href\"),b),p.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var f=w[b++];if(!f){k=!1;b=0;continue}var c=!1,m=0;var d=f[m++];if(a=n.get(d)){var e=a._p;c=!0}else{a=q.createElement(\"link\");a.href=d;a.rel=\"stylesheet\";for(a.dataset.precedence=\\nl=f[m++];e=f[m++];)a.setAttribute(e,f[m++]);e=a._p=new Promise(function(x,y){a.onload=x;a.onerror=y});n.set(d,a)}d=a.getAttribute(\"media\");!e||\"l\"===e.s||d&&!matchMedia(d).matches||h.push(e);if(c)continue}else{a=v[b++];if(!a)break;l=a.getAttribute(\"data-precedence\");a.removeAttribute(\"media\")}c=p.get(l)||g;c===g&&(g=a);p.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=q.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(u.bind(null,r,t,\"\"),u.bind(null,r,t,\"Resource failed to load\"))};';\n        var completeSegment = \"$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};\";\n        function getValueDescriptorExpectingObjectForWarning(thing) {\n            return thing === null ? \"`null`\" : thing === undefined ? \"`undefined`\" : thing === \"\" ? \"an empty string\" : 'something with type \"' + typeof thing + '\"';\n        }\n        function getValueDescriptorExpectingEnumForWarning(thing) {\n            return thing === null ? \"`null`\" : thing === undefined ? \"`undefined`\" : thing === \"\" ? \"an empty string\" : typeof thing === \"string\" ? JSON.stringify(thing) : 'something with type \"' + typeof thing + '\"';\n        }\n        function compareResourcePropsForWarning(newProps, currentProps) {\n            {\n                var propDiffs = null;\n                var allProps = Array.from(new Set(Object.keys(currentProps).concat(Object.keys(newProps))));\n                for(var i = 0; i < allProps.length; i++){\n                    var propName = allProps[i];\n                    var newValue = newProps[propName];\n                    var currentValue = currentProps[propName];\n                    if (newValue !== currentValue && !(newValue == null && currentValue == null)) {\n                        if (newValue == null) {\n                            if (propDiffs === null) {\n                                propDiffs = {\n                                    missing: {},\n                                    extra: {},\n                                    different: {}\n                                };\n                            }\n                            propDiffs.missing[propName] = currentValue;\n                        } else if (currentValue == null) {\n                            if (propDiffs === null) {\n                                propDiffs = {\n                                    missing: {},\n                                    extra: {},\n                                    different: {}\n                                };\n                            }\n                            propDiffs.extra[propName] = newValue;\n                        } else {\n                            if (propDiffs === null) {\n                                propDiffs = {\n                                    missing: {},\n                                    extra: {},\n                                    different: {}\n                                };\n                            }\n                            propDiffs.different[propName] = {\n                                original: currentValue,\n                                latest: newValue\n                            };\n                        }\n                    }\n                }\n                return propDiffs;\n            }\n        }\n        function describeDifferencesForStylesheets(newProps, currentProps) {\n            var diff = compareResourcePropsForWarning(newProps, currentProps);\n            if (!diff) return \"\";\n            var description = \"\";\n            for(var propName in diff.missing){\n                var propValue = diff.missing[propName];\n                if (propName === \"media\") {\n                    description += '\\n  \"' + propName + '\" missing for props, original value: ' + getValueDescriptorExpectingEnumForWarning(propValue);\n                }\n            }\n            for(var _propName in diff.extra){\n                var _propValue = diff.extra[_propName];\n                description += '\\n  \"' + _propName + '\" prop value: ' + getValueDescriptorExpectingEnumForWarning(_propValue) + \", missing from original props\";\n            }\n            for(var _propName2 in diff.different){\n                var latestValue = diff.different[_propName2].latest;\n                var originalValue = diff.different[_propName2].original;\n                description += '\\n  \"' + _propName2 + '\" prop value: ' + getValueDescriptorExpectingEnumForWarning(latestValue) + \", original value: \" + getValueDescriptorExpectingEnumForWarning(originalValue);\n            }\n            return description;\n        }\n        function describeDifferencesForStylesheetOverPreinit(newProps, currentProps) {\n            var diff = compareResourcePropsForWarning(newProps, currentProps);\n            if (!diff) return \"\";\n            var description = \"\";\n            for(var propName in diff.extra){\n                var propValue = diff.extra[propName];\n                if (propName === \"precedence\" || propName === \"crossOrigin\" || propName === \"integrity\") {\n                    description += '\\n  \"' + propName + '\" prop value: ' + getValueDescriptorExpectingEnumForWarning(propValue) + \", option missing\";\n                } else {\n                    description += '\\n  \"' + propName + '\" prop value: ' + getValueDescriptorExpectingEnumForWarning(propValue) + \", option not available with ReactDOM.preinit()\";\n                }\n            }\n            for(var _propName3 in diff.different){\n                var latestValue = diff.different[_propName3].latest;\n                var originalValue = diff.different[_propName3].original;\n                if (_propName3 === \"precedence\" && originalValue === \"default\") {\n                    description += '\\n  \"' + _propName3 + '\" prop value: ' + getValueDescriptorExpectingEnumForWarning(latestValue) + \", missing from options\";\n                } else {\n                    description += '\\n  \"' + _propName3 + '\" prop value: ' + getValueDescriptorExpectingEnumForWarning(latestValue) + \", option value: \" + getValueDescriptorExpectingEnumForWarning(originalValue);\n                }\n            }\n            return description;\n        }\n        function describeDifferencesForPreinitOverStylesheet(newProps, currentProps) {\n            var diff = compareResourcePropsForWarning(newProps, currentProps);\n            if (!diff) return \"\";\n            var description = \"\";\n            for(var propName in diff.missing){\n                var propValue = diff.missing[propName];\n                if (propName === \"precedence\" && propValue !== \"default\") {\n                    description += '\\n  \"' + propName + '\" missing from options, prop value: ' + getValueDescriptorExpectingEnumForWarning(propValue);\n                }\n            }\n            for(var _propName4 in diff.extra){\n                var _propValue2 = diff.extra[_propName4];\n                if (_propName4 === \"precedence\" || _propName4 === \"crossOrigin\" || _propName4 === \"integrity\") {\n                    description += '\\n  \"' + _propName4 + '\" option value: ' + getValueDescriptorExpectingEnumForWarning(_propValue2) + \", missing from props\";\n                }\n            }\n            for(var _propName5 in diff.different){\n                var latestValue = diff.different[_propName5].latest;\n                var originalValue = diff.different[_propName5].original;\n                description += '\\n  \"' + _propName5 + '\" option value: ' + getValueDescriptorExpectingEnumForWarning(latestValue) + \", prop value: \" + getValueDescriptorExpectingEnumForWarning(originalValue);\n            }\n            return description;\n        }\n        function describeDifferencesForPreinits(newProps, currentProps) {\n            var diff = compareResourcePropsForWarning(newProps, currentProps);\n            if (!diff) return \"\";\n            var description = \"\";\n            for(var propName in diff.missing){\n                var propValue = diff.missing[propName];\n                if (propName === \"precedence\" && propValue !== \"default\") {\n                    description += '\\n  \"' + propName + '\" missing from options, original option value: ' + getValueDescriptorExpectingEnumForWarning(propValue);\n                }\n            }\n            for(var _propName6 in diff.extra){\n                var _propValue3 = diff.extra[_propName6];\n                if (_propName6 === \"precedence\" && _propValue3 !== \"default\" || _propName6 === \"crossOrigin\" || _propName6 === \"integrity\") {\n                    description += '\\n  \"' + _propName6 + '\" option value: ' + getValueDescriptorExpectingEnumForWarning(_propValue3) + \", missing from original options\";\n                }\n            }\n            for(var _propName7 in diff.different){\n                var latestValue = diff.different[_propName7].latest;\n                var originalValue = diff.different[_propName7].original;\n                description += '\\n  \"' + _propName7 + '\" option value: ' + getValueDescriptorExpectingEnumForWarning(latestValue) + \", original option value: \" + getValueDescriptorExpectingEnumForWarning(originalValue);\n            }\n            return description;\n        }\n        var preloadOptionsForComparison = [\n            \"as\",\n            \"crossOrigin\",\n            \"integrity\",\n            \"media\"\n        ];\n        function describeDifferencesForPreloads(newProps, currentProps) {\n            var diff = compareResourcePropsForWarning(newProps, currentProps);\n            if (!diff) return \"\";\n            var description = \"\";\n            for(var propName in diff.missing){\n                var propValue = diff.missing[propName];\n                if (preloadOptionsForComparison.includes(propName)) {\n                    description += '\\n  \"' + propName + '\" missing from options, original option value: ' + getValueDescriptorExpectingEnumForWarning(propValue);\n                }\n            }\n            for(var _propName8 in diff.extra){\n                var _propValue4 = diff.extra[_propName8];\n                if (preloadOptionsForComparison.includes(_propName8)) {\n                    description += '\\n  \"' + _propName8 + '\" option value: ' + getValueDescriptorExpectingEnumForWarning(_propValue4) + \", missing from original options\";\n                }\n            }\n            for(var _propName9 in diff.different){\n                var latestValue = diff.different[_propName9].latest;\n                var originalValue = diff.different[_propName9].original;\n                if (preloadOptionsForComparison.includes(_propName9)) {\n                    description += '\\n  \"' + _propName9 + '\" option value: ' + getValueDescriptorExpectingEnumForWarning(latestValue) + \", original option value: \" + getValueDescriptorExpectingEnumForWarning(originalValue);\n                }\n            }\n            return description;\n        }\n        function describeDifferencesForPreloadOverImplicitPreload(newProps, currentProps) {\n            var diff = compareResourcePropsForWarning(newProps, currentProps);\n            if (!diff) return \"\";\n            var description = \"\";\n            for(var propName in diff.missing){\n                var propValue = diff.missing[propName];\n                if (preloadOptionsForComparison.includes(propName)) {\n                    description += '\\n  \"' + propName + '\" missing from options, underlying prop value: ' + getValueDescriptorExpectingEnumForWarning(propValue);\n                }\n            }\n            for(var _propName10 in diff.extra){\n                var _propValue5 = diff.extra[_propName10];\n                if (preloadOptionsForComparison.includes(_propName10)) {\n                    description += '\\n  \"' + _propName10 + '\" option value: ' + getValueDescriptorExpectingEnumForWarning(_propValue5) + \", missing from underlying props\";\n                }\n            }\n            for(var _propName11 in diff.different){\n                var latestValue = diff.different[_propName11].latest;\n                var originalValue = diff.different[_propName11].original;\n                if (preloadOptionsForComparison.includes(_propName11)) {\n                    description += '\\n  \"' + _propName11 + '\" option value: ' + getValueDescriptorExpectingEnumForWarning(latestValue) + \", underlying prop value: \" + getValueDescriptorExpectingEnumForWarning(originalValue);\n                }\n            }\n            return description;\n        }\n        function describeDifferencesForScripts(newProps, currentProps) {\n            var diff = compareResourcePropsForWarning(newProps, currentProps);\n            if (!diff) return \"\";\n            var description = \"\";\n            for(var propName in diff.missing){\n                var propValue = diff.missing[propName];\n                description += '\\n  \"' + propName + '\" missing for props, original value: ' + getValueDescriptorExpectingEnumForWarning(propValue);\n            }\n            for(var _propName12 in diff.extra){\n                var _propValue6 = diff.extra[_propName12];\n                description += '\\n  \"' + _propName12 + '\" prop value: ' + getValueDescriptorExpectingEnumForWarning(_propValue6) + \", missing from original props\";\n            }\n            for(var _propName13 in diff.different){\n                var latestValue = diff.different[_propName13].latest;\n                var originalValue = diff.different[_propName13].original;\n                description += '\\n  \"' + _propName13 + '\" prop value: ' + getValueDescriptorExpectingEnumForWarning(latestValue) + \", original value: \" + getValueDescriptorExpectingEnumForWarning(originalValue);\n            }\n            return description;\n        }\n        function describeDifferencesForScriptOverPreinit(newProps, currentProps) {\n            var diff = compareResourcePropsForWarning(newProps, currentProps);\n            if (!diff) return \"\";\n            var description = \"\";\n            for(var propName in diff.extra){\n                var propValue = diff.extra[propName];\n                if (propName === \"crossOrigin\" || propName === \"integrity\") {\n                    description += '\\n  \"' + propName + '\" prop value: ' + getValueDescriptorExpectingEnumForWarning(propValue) + \", option missing\";\n                } else {\n                    description += '\\n  \"' + propName + '\" prop value: ' + getValueDescriptorExpectingEnumForWarning(propValue) + \", option not available with ReactDOM.preinit()\";\n                }\n            }\n            for(var _propName14 in diff.different){\n                var latestValue = diff.different[_propName14].latest;\n                var originalValue = diff.different[_propName14].original;\n                description += '\\n  \"' + _propName14 + '\" prop value: ' + getValueDescriptorExpectingEnumForWarning(latestValue) + \", option value: \" + getValueDescriptorExpectingEnumForWarning(originalValue);\n            }\n            return description;\n        }\n        function describeDifferencesForPreinitOverScript(newProps, currentProps) {\n            var diff = compareResourcePropsForWarning(newProps, currentProps);\n            if (!diff) return \"\";\n            var description = \"\";\n            for(var propName in diff.extra){\n                var propValue = diff.extra[propName];\n                if (propName === \"crossOrigin\" || propName === \"integrity\") {\n                    description += '\\n  \"' + propName + '\" option value: ' + getValueDescriptorExpectingEnumForWarning(propValue) + \", missing from props\";\n                }\n            }\n            for(var _propName15 in diff.different){\n                var latestValue = diff.different[_propName15].latest;\n                var originalValue = diff.different[_propName15].original;\n                description += '\\n  \"' + _propName15 + '\" option value: ' + getValueDescriptorExpectingEnumForWarning(latestValue) + \", prop value: \" + getValueDescriptorExpectingEnumForWarning(originalValue);\n            }\n            return description;\n        }\n        var ReactDOMSharedInternals = ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        var ReactDOMCurrentDispatcher = ReactDOMSharedInternals.Dispatcher;\n        var ReactDOMServerDispatcher = {\n            prefetchDNS: prefetchDNS,\n            preconnect: preconnect,\n            preload: preload,\n            preinit: preinit\n        };\n        function prepareHostDispatcher() {\n            ReactDOMCurrentDispatcher.current = ReactDOMServerDispatcher;\n        } // Used to distinguish these contexts from ones used in other renderers.\n        var ScriptStreamingFormat = 0;\n        var DataStreamingFormat = 1;\n        var NothingSent = 0;\n        var SentCompleteSegmentFunction = 1;\n        var SentCompleteBoundaryFunction = 2;\n        var SentClientRenderFunction = 4;\n        var SentStyleInsertionFunction = 8;\n        var dataElementQuotedEnd = stringToPrecomputedChunk('\"></template>');\n        var startInlineScript = stringToPrecomputedChunk(\"<script>\");\n        var endInlineScript = stringToPrecomputedChunk(\"</script>\");\n        var startScriptSrc = stringToPrecomputedChunk('<script src=\"');\n        var startModuleSrc = stringToPrecomputedChunk('<script type=\"module\" src=\"');\n        var scriptNonce = stringToPrecomputedChunk('\" nonce=\"');\n        var scriptIntegirty = stringToPrecomputedChunk('\" integrity=\"');\n        var scriptCrossOrigin = stringToPrecomputedChunk('\" crossorigin=\"');\n        var endAsyncScript = stringToPrecomputedChunk('\" async=\"\"></script>');\n        /**\n * This escaping function is designed to work with bootstrapScriptContent only.\n * because we know we are escaping the entire script. We can avoid for instance\n * escaping html comment string sequences that are valid javascript as well because\n * if there are no sebsequent <script sequences the html parser will never enter\n * script data double escaped state (see: https://www.w3.org/TR/html53/syntax.html#script-data-double-escaped-state)\n *\n * While untrusted script content should be made safe before using this api it will\n * ensure that the script cannot be early terminated or never terminated state\n */ function escapeBootstrapScriptContent(scriptText) {\n            {\n                checkHtmlStringCoercion(scriptText);\n            }\n            return (\"\" + scriptText).replace(scriptRegex, scriptReplacer);\n        }\n        var scriptRegex = /(<\\/|<)(s)(cript)/gi;\n        var scriptReplacer = function(match, prefix, s, suffix) {\n            return \"\" + prefix + (s === \"s\" ? \"\\\\u0073\" : \"\\\\u0053\") + suffix;\n        }; // Allows us to keep track of what we've already written so we can refer back to it.\n        // if passed externalRuntimeConfig and the enableFizzExternalRuntime feature flag\n        // is set, the server will send instructions via data attributes (instead of inline scripts)\n        function createResponseState$1(resources, identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules, externalRuntimeConfig) {\n            var idPrefix = identifierPrefix === undefined ? \"\" : identifierPrefix;\n            var inlineScriptWithNonce = nonce === undefined ? startInlineScript : stringToPrecomputedChunk('<script nonce=\"' + escapeTextForBrowser(nonce) + '\">');\n            var bootstrapChunks = [];\n            var externalRuntimeScript = null;\n            var streamingFormat = ScriptStreamingFormat;\n            if (bootstrapScriptContent !== undefined) {\n                bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapScriptContent(bootstrapScriptContent)), endInlineScript);\n            }\n            {\n                if (externalRuntimeConfig !== undefined) {\n                    streamingFormat = DataStreamingFormat;\n                    if (typeof externalRuntimeConfig === \"string\") {\n                        externalRuntimeScript = {\n                            src: externalRuntimeConfig,\n                            chunks: []\n                        };\n                        pushScriptImpl(externalRuntimeScript.chunks, {\n                            src: externalRuntimeConfig,\n                            async: true,\n                            integrity: undefined,\n                            nonce: nonce\n                        });\n                    } else {\n                        externalRuntimeScript = {\n                            src: externalRuntimeConfig.src,\n                            chunks: []\n                        };\n                        pushScriptImpl(externalRuntimeScript.chunks, {\n                            src: externalRuntimeConfig.src,\n                            async: true,\n                            integrity: externalRuntimeConfig.integrity,\n                            nonce: nonce\n                        });\n                    }\n                }\n            }\n            if (bootstrapScripts !== undefined) {\n                for(var i = 0; i < bootstrapScripts.length; i++){\n                    var scriptConfig = bootstrapScripts[i];\n                    var src = typeof scriptConfig === \"string\" ? scriptConfig : scriptConfig.src;\n                    var integrity = typeof scriptConfig === \"string\" ? undefined : scriptConfig.integrity;\n                    var crossOrigin = typeof scriptConfig === \"string\" || scriptConfig.crossOrigin == null ? undefined : scriptConfig.crossOrigin === \"use-credentials\" ? \"use-credentials\" : \"\";\n                    preloadBootstrapScript(resources, src, nonce, integrity, crossOrigin);\n                    bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(src)));\n                    if (nonce) {\n                        bootstrapChunks.push(scriptNonce, stringToChunk(escapeTextForBrowser(nonce)));\n                    }\n                    if (integrity) {\n                        bootstrapChunks.push(scriptIntegirty, stringToChunk(escapeTextForBrowser(integrity)));\n                    }\n                    if (typeof crossOrigin === \"string\") {\n                        bootstrapChunks.push(scriptCrossOrigin, stringToChunk(escapeTextForBrowser(crossOrigin)));\n                    }\n                    bootstrapChunks.push(endAsyncScript);\n                }\n            }\n            if (bootstrapModules !== undefined) {\n                for(var _i = 0; _i < bootstrapModules.length; _i++){\n                    var _scriptConfig = bootstrapModules[_i];\n                    var _src = typeof _scriptConfig === \"string\" ? _scriptConfig : _scriptConfig.src;\n                    var _integrity = typeof _scriptConfig === \"string\" ? undefined : _scriptConfig.integrity;\n                    var _crossOrigin = typeof _scriptConfig === \"string\" || _scriptConfig.crossOrigin == null ? undefined : _scriptConfig.crossOrigin === \"use-credentials\" ? \"use-credentials\" : \"\";\n                    preloadBootstrapModule(resources, _src, nonce, _integrity, _crossOrigin);\n                    bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(_src)));\n                    if (nonce) {\n                        bootstrapChunks.push(scriptNonce, stringToChunk(escapeTextForBrowser(nonce)));\n                    }\n                    if (_integrity) {\n                        bootstrapChunks.push(scriptIntegirty, stringToChunk(escapeTextForBrowser(_integrity)));\n                    }\n                    if (typeof _crossOrigin === \"string\") {\n                        bootstrapChunks.push(scriptCrossOrigin, stringToChunk(escapeTextForBrowser(_crossOrigin)));\n                    }\n                    bootstrapChunks.push(endAsyncScript);\n                }\n            }\n            return {\n                bootstrapChunks: bootstrapChunks,\n                placeholderPrefix: stringToPrecomputedChunk(idPrefix + \"P:\"),\n                segmentPrefix: stringToPrecomputedChunk(idPrefix + \"S:\"),\n                boundaryPrefix: idPrefix + \"B:\",\n                idPrefix: idPrefix,\n                nextSuspenseID: 0,\n                streamingFormat: streamingFormat,\n                startInlineScript: inlineScriptWithNonce,\n                instructions: NothingSent,\n                externalRuntimeScript: externalRuntimeScript,\n                htmlChunks: null,\n                headChunks: null,\n                hasBody: false,\n                charsetChunks: [],\n                preconnectChunks: [],\n                preloadChunks: [],\n                hoistableChunks: [],\n                stylesToHoist: false,\n                nonce: nonce\n            };\n        } // Constants for the insertion mode we're currently writing in. We don't encode all HTML5 insertion\n        // modes. We only include the variants as they matter for the sake of our purposes.\n        // We don't actually provide the namespace therefore we use constants instead of the string.\n        var ROOT_HTML_MODE = 0; // Used for the root most element tag.\n        // We have a less than HTML_HTML_MODE check elsewhere. If you add more cases here, make sure it\n        // still makes sense\n        var HTML_HTML_MODE = 1; // Used for the <html> if it is at the top level.\n        var HTML_MODE = 2;\n        var SVG_MODE = 3;\n        var MATHML_MODE = 4;\n        var HTML_TABLE_MODE = 5;\n        var HTML_TABLE_BODY_MODE = 6;\n        var HTML_TABLE_ROW_MODE = 7;\n        var HTML_COLGROUP_MODE = 8; // We have a greater than HTML_TABLE_MODE check elsewhere. If you add more cases here, make sure it\n        // still makes sense\n        // Lets us keep track of contextual state and pick it back up after suspending.\n        function createFormatContext(insertionMode, selectedValue, noscriptTagInScope) {\n            return {\n                insertionMode: insertionMode,\n                selectedValue: selectedValue,\n                noscriptTagInScope: noscriptTagInScope\n            };\n        }\n        function getChildFormatContext(parentContext, type, props) {\n            switch(type){\n                case \"noscript\":\n                    return createFormatContext(HTML_MODE, null, true);\n                case \"select\":\n                    return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue, parentContext.noscriptTagInScope);\n                case \"svg\":\n                    return createFormatContext(SVG_MODE, null, parentContext.noscriptTagInScope);\n                case \"math\":\n                    return createFormatContext(MATHML_MODE, null, parentContext.noscriptTagInScope);\n                case \"foreignObject\":\n                    return createFormatContext(HTML_MODE, null, parentContext.noscriptTagInScope);\n                // Table parents are special in that their children can only be created at all if they're\n                // wrapped in a table parent. So we need to encode that we're entering this mode.\n                case \"table\":\n                    return createFormatContext(HTML_TABLE_MODE, null, parentContext.noscriptTagInScope);\n                case \"thead\":\n                case \"tbody\":\n                case \"tfoot\":\n                    return createFormatContext(HTML_TABLE_BODY_MODE, null, parentContext.noscriptTagInScope);\n                case \"colgroup\":\n                    return createFormatContext(HTML_COLGROUP_MODE, null, parentContext.noscriptTagInScope);\n                case \"tr\":\n                    return createFormatContext(HTML_TABLE_ROW_MODE, null, parentContext.noscriptTagInScope);\n            }\n            if (parentContext.insertionMode >= HTML_TABLE_MODE) {\n                // Whatever tag this was, it wasn't a table parent or other special parent, so we must have\n                // entered plain HTML again.\n                return createFormatContext(HTML_MODE, null, parentContext.noscriptTagInScope);\n            }\n            if (parentContext.insertionMode === ROOT_HTML_MODE) {\n                if (type === \"html\") {\n                    // We've emitted the root and is now in <html> mode.\n                    return createFormatContext(HTML_HTML_MODE, null, false);\n                } else {\n                    // We've emitted the root and is now in plain HTML mode.\n                    return createFormatContext(HTML_MODE, null, false);\n                }\n            } else if (parentContext.insertionMode === HTML_HTML_MODE) {\n                // We've emitted the document element and is now in plain HTML mode.\n                return createFormatContext(HTML_MODE, null, false);\n            }\n            return parentContext;\n        }\n        var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;\n        function assignSuspenseBoundaryID(responseState) {\n            var generatedID = responseState.nextSuspenseID++;\n            return stringToPrecomputedChunk(responseState.boundaryPrefix + generatedID.toString(16));\n        }\n        function makeId(responseState, treeId, localId) {\n            var idPrefix = responseState.idPrefix;\n            var id = \":\" + idPrefix + \"R\" + treeId; // Unless this is the first id at this level, append a number at the end\n            // that represents the position of this useId hook among all the useId\n            // hooks for this fiber.\n            if (localId > 0) {\n                id += \"H\" + localId.toString(32);\n            }\n            return id + \":\";\n        }\n        function encodeHTMLTextNode(text) {\n            return escapeTextForBrowser(text);\n        }\n        var textSeparator = stringToPrecomputedChunk(\"<!-- -->\");\n        function pushTextInstance$1(target, text, responseState, textEmbedded) {\n            if (text === \"\") {\n                // Empty text doesn't have a DOM node representation and the hydration is aware of this.\n                return textEmbedded;\n            }\n            if (textEmbedded) {\n                target.push(textSeparator);\n            }\n            target.push(stringToChunk(encodeHTMLTextNode(text)));\n            return true;\n        } // Called when Fizz is done with a Segment. Currently the only purpose is to conditionally\n        // emit a text separator when we don't know for sure it is safe to omit\n        function pushSegmentFinale$1(target, responseState, lastPushedText, textEmbedded) {\n            if (lastPushedText && textEmbedded) {\n                target.push(textSeparator);\n            }\n        }\n        var styleNameCache = new Map();\n        function processStyleName(styleName) {\n            var chunk = styleNameCache.get(styleName);\n            if (chunk !== undefined) {\n                return chunk;\n            }\n            var result = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));\n            styleNameCache.set(styleName, result);\n            return result;\n        }\n        var styleAttributeStart = stringToPrecomputedChunk(' style=\"');\n        var styleAssign = stringToPrecomputedChunk(\":\");\n        var styleSeparator = stringToPrecomputedChunk(\";\");\n        function pushStyleAttribute(target, style) {\n            if (typeof style !== \"object\") {\n                throw new Error(\"The `style` prop expects a mapping from style properties to values, \" + \"not a string. For example, style={{marginRight: spacing + 'em'}} when \" + \"using JSX.\");\n            }\n            var isFirst = true;\n            for(var styleName in style){\n                if (!hasOwnProperty.call(style, styleName)) {\n                    continue;\n                } // If you provide unsafe user data here they can inject arbitrary CSS\n                // which may be problematic (I couldn't repro this):\n                // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n                // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n                // This is not an XSS hole but instead a potential CSS injection issue\n                // which has lead to a greater discussion about how we're going to\n                // trust URLs moving forward. See #2115901\n                var styleValue = style[styleName];\n                if (styleValue == null || typeof styleValue === \"boolean\" || styleValue === \"\") {\n                    continue;\n                }\n                var nameChunk = void 0;\n                var valueChunk = void 0;\n                var isCustomProperty = styleName.indexOf(\"--\") === 0;\n                if (isCustomProperty) {\n                    nameChunk = stringToChunk(escapeTextForBrowser(styleName));\n                    {\n                        checkCSSPropertyStringCoercion(styleValue, styleName);\n                    }\n                    valueChunk = stringToChunk(escapeTextForBrowser((\"\" + styleValue).trim()));\n                } else {\n                    {\n                        warnValidStyle(styleName, styleValue);\n                    }\n                    nameChunk = processStyleName(styleName);\n                    if (typeof styleValue === \"number\") {\n                        if (styleValue !== 0 && !isUnitlessNumber(styleName)) {\n                            valueChunk = stringToChunk(styleValue + \"px\"); // Presumes implicit 'px' suffix for unitless numbers\n                        } else {\n                            valueChunk = stringToChunk(\"\" + styleValue);\n                        }\n                    } else {\n                        {\n                            checkCSSPropertyStringCoercion(styleValue, styleName);\n                        }\n                        valueChunk = stringToChunk(escapeTextForBrowser((\"\" + styleValue).trim()));\n                    }\n                }\n                if (isFirst) {\n                    isFirst = false; // If it's first, we don't need any separators prefixed.\n                    target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);\n                } else {\n                    target.push(styleSeparator, nameChunk, styleAssign, valueChunk);\n                }\n            }\n            if (!isFirst) {\n                target.push(attributeEnd);\n            }\n        }\n        var attributeSeparator = stringToPrecomputedChunk(\" \");\n        var attributeAssign = stringToPrecomputedChunk('=\"');\n        var attributeEnd = stringToPrecomputedChunk('\"');\n        var attributeEmptyString = stringToPrecomputedChunk('=\"\"');\n        function pushBooleanAttribute(target, name, value) {\n            if (value && typeof value !== \"function\" && typeof value !== \"symbol\") {\n                target.push(attributeSeparator, stringToChunk(name), attributeEmptyString);\n            }\n        }\n        function pushStringAttribute(target, name, value) {\n            if (typeof value !== \"function\" && typeof value !== \"symbol\" && typeof value !== \"boolean\") {\n                target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n            }\n        }\n        // than on the client and hopefully it's googleable.\n        stringToPrecomputedChunk(escapeTextForBrowser(\"javascript:throw new Error('A React form was unexpectedly submitted.')\"));\n        var startHiddenInputChunk = stringToPrecomputedChunk('<input type=\"hidden\"');\n        function pushAdditionalFormField(value, key) {\n            var target = this;\n            target.push(startHiddenInputChunk);\n            if (typeof value !== \"string\") {\n                throw new Error(\"File/Blob fields are not yet supported in progressive forms. \" + \"It probably means you are closing over binary data or FormData in a Server Action.\");\n            }\n            pushStringAttribute(target, \"name\", key);\n            pushStringAttribute(target, \"value\", value);\n            target.push(endOfStartTagSelfClosing);\n        }\n        function pushAdditionalFormFields(target, formData) {\n            if (formData !== null) {\n                // $FlowFixMe[prop-missing]: FormData has forEach.\n                formData.forEach(pushAdditionalFormField, target);\n            }\n        }\n        function pushFormActionAttribute(target, responseState, formAction, formEncType, formMethod, formTarget, name) {\n            var formData = null;\n            if (name != null) {\n                pushAttribute(target, \"name\", name);\n            }\n            if (formAction != null) {\n                pushAttribute(target, \"formAction\", formAction);\n            }\n            if (formEncType != null) {\n                pushAttribute(target, \"formEncType\", formEncType);\n            }\n            if (formMethod != null) {\n                pushAttribute(target, \"formMethod\", formMethod);\n            }\n            if (formTarget != null) {\n                pushAttribute(target, \"formTarget\", formTarget);\n            }\n            return formData;\n        }\n        function pushAttribute(target, name, value) {\n            switch(name){\n                // These are very common props and therefore are in the beginning of the switch.\n                // TODO: aria-label is a very common prop but allows booleans so is not like the others\n                // but should ideally go in this list too.\n                case \"className\":\n                    {\n                        pushStringAttribute(target, \"class\", value);\n                        break;\n                    }\n                case \"tabIndex\":\n                    {\n                        pushStringAttribute(target, \"tabindex\", value);\n                        break;\n                    }\n                case \"dir\":\n                case \"role\":\n                case \"viewBox\":\n                case \"width\":\n                case \"height\":\n                    {\n                        pushStringAttribute(target, name, value);\n                        break;\n                    }\n                case \"style\":\n                    {\n                        pushStyleAttribute(target, value);\n                        return;\n                    }\n                case \"src\":\n                case \"href\":\n                // Fall through to the last case which shouldn't remove empty strings.\n                case \"action\":\n                case \"formAction\":\n                    {\n                        // TODO: Consider only special casing these for each tag.\n                        if (value == null || typeof value === \"function\" || typeof value === \"symbol\" || typeof value === \"boolean\") {\n                            return;\n                        }\n                        {\n                            checkAttributeStringCoercion(value, name);\n                        }\n                        var sanitizedValue = sanitizeURL(\"\" + value);\n                        target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(sanitizedValue)), attributeEnd);\n                        return;\n                    }\n                case \"defaultValue\":\n                case \"defaultChecked\":\n                case \"innerHTML\":\n                case \"suppressContentEditableWarning\":\n                case \"suppressHydrationWarning\":\n                    // Ignored. These are built-in to React on the client.\n                    return;\n                case \"autoFocus\":\n                case \"multiple\":\n                case \"muted\":\n                    {\n                        pushBooleanAttribute(target, name.toLowerCase(), value);\n                        return;\n                    }\n                case \"xlinkHref\":\n                    {\n                        if (typeof value === \"function\" || typeof value === \"symbol\" || typeof value === \"boolean\") {\n                            return;\n                        }\n                        {\n                            checkAttributeStringCoercion(value, name);\n                        }\n                        var _sanitizedValue = sanitizeURL(\"\" + value);\n                        target.push(attributeSeparator, stringToChunk(\"xlink:href\"), attributeAssign, stringToChunk(escapeTextForBrowser(_sanitizedValue)), attributeEnd);\n                        return;\n                    }\n                case \"contentEditable\":\n                case \"spellCheck\":\n                case \"draggable\":\n                case \"value\":\n                case \"autoReverse\":\n                case \"externalResourcesRequired\":\n                case \"focusable\":\n                case \"preserveAlpha\":\n                    {\n                        // Booleanish String\n                        // These are \"enumerated\" attributes that accept \"true\" and \"false\".\n                        // In React, we let users pass `true` and `false` even though technically\n                        // these aren't boolean attributes (they are coerced to strings).\n                        if (typeof value !== \"function\" && typeof value !== \"symbol\") {\n                            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                        }\n                        return;\n                    }\n                case \"allowFullScreen\":\n                case \"async\":\n                case \"autoPlay\":\n                case \"controls\":\n                case \"default\":\n                case \"defer\":\n                case \"disabled\":\n                case \"disablePictureInPicture\":\n                case \"disableRemotePlayback\":\n                case \"formNoValidate\":\n                case \"hidden\":\n                case \"loop\":\n                case \"noModule\":\n                case \"noValidate\":\n                case \"open\":\n                case \"playsInline\":\n                case \"readOnly\":\n                case \"required\":\n                case \"reversed\":\n                case \"scoped\":\n                case \"seamless\":\n                case \"itemScope\":\n                    {\n                        // Boolean\n                        if (value && typeof value !== \"function\" && typeof value !== \"symbol\") {\n                            target.push(attributeSeparator, stringToChunk(name), attributeEmptyString);\n                        }\n                        return;\n                    }\n                case \"capture\":\n                case \"download\":\n                    {\n                        // Overloaded Boolean\n                        if (value === true) {\n                            target.push(attributeSeparator, stringToChunk(name), attributeEmptyString);\n                        } else if (value === false) ;\n                        else if (typeof value !== \"function\" && typeof value !== \"symbol\") {\n                            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                        }\n                        return;\n                    }\n                case \"cols\":\n                case \"rows\":\n                case \"size\":\n                case \"span\":\n                    {\n                        // These are HTML attributes that must be positive numbers.\n                        if (typeof value !== \"function\" && typeof value !== \"symbol\" && !isNaN(value) && value >= 1) {\n                            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                        }\n                        return;\n                    }\n                case \"rowSpan\":\n                case \"start\":\n                    {\n                        // These are HTML attributes that must be numbers.\n                        if (typeof value !== \"function\" && typeof value !== \"symbol\" && !isNaN(value)) {\n                            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                        }\n                        return;\n                    }\n                case \"xlinkActuate\":\n                    pushStringAttribute(target, \"xlink:actuate\", value);\n                    return;\n                case \"xlinkArcrole\":\n                    pushStringAttribute(target, \"xlink:arcrole\", value);\n                    return;\n                case \"xlinkRole\":\n                    pushStringAttribute(target, \"xlink:role\", value);\n                    return;\n                case \"xlinkShow\":\n                    pushStringAttribute(target, \"xlink:show\", value);\n                    return;\n                case \"xlinkTitle\":\n                    pushStringAttribute(target, \"xlink:title\", value);\n                    return;\n                case \"xlinkType\":\n                    pushStringAttribute(target, \"xlink:type\", value);\n                    return;\n                case \"xmlBase\":\n                    pushStringAttribute(target, \"xml:base\", value);\n                    return;\n                case \"xmlLang\":\n                    pushStringAttribute(target, \"xml:lang\", value);\n                    return;\n                case \"xmlSpace\":\n                    pushStringAttribute(target, \"xml:space\", value);\n                    return;\n                default:\n                    if (// We have already filtered out null/undefined and reserved words.\n                    name.length > 2 && (name[0] === \"o\" || name[0] === \"O\") && (name[1] === \"n\" || name[1] === \"N\")) {\n                        return;\n                    }\n                    var attributeName = getAttributeAlias(name);\n                    if (isAttributeNameSafe(attributeName)) {\n                        // shouldRemoveAttribute\n                        switch(typeof value){\n                            case \"function\":\n                            case \"symbol\":\n                                // eslint-disable-line\n                                return;\n                            case \"boolean\":\n                                {\n                                    var prefix = attributeName.toLowerCase().slice(0, 5);\n                                    if (prefix !== \"data-\" && prefix !== \"aria-\") {\n                                        return;\n                                    }\n                                }\n                        }\n                        target.push(attributeSeparator, stringToChunk(attributeName), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                    }\n            }\n        }\n        var endOfStartTag = stringToPrecomputedChunk(\">\");\n        var endOfStartTagSelfClosing = stringToPrecomputedChunk(\"/>\");\n        function pushInnerHTML(target, innerHTML, children) {\n            if (innerHTML != null) {\n                if (children != null) {\n                    throw new Error(\"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\");\n                }\n                if (typeof innerHTML !== \"object\" || !(\"__html\" in innerHTML)) {\n                    throw new Error(\"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. \" + \"Please visit https://reactjs.org/link/dangerously-set-inner-html \" + \"for more information.\");\n                }\n                var html = innerHTML.__html;\n                if (html !== null && html !== undefined) {\n                    {\n                        checkHtmlStringCoercion(html);\n                    }\n                    target.push(stringToChunk(\"\" + html));\n                }\n            }\n        } // TODO: Move these to ResponseState so that we warn for every request.\n        // It would help debugging in stateful servers (e.g. service worker).\n        var didWarnDefaultInputValue = false;\n        var didWarnDefaultChecked = false;\n        var didWarnDefaultSelectValue = false;\n        var didWarnDefaultTextareaValue = false;\n        var didWarnInvalidOptionChildren = false;\n        var didWarnInvalidOptionInnerHTML = false;\n        var didWarnSelectedSetOnOption = false;\n        var didWarnFormActionType = false;\n        function checkSelectProp(props, propName) {\n            {\n                var value = props[propName];\n                if (value != null) {\n                    var array = isArray(value);\n                    if (props.multiple && !array) {\n                        error(\"The `%s` prop supplied to <select> must be an array if \" + \"`multiple` is true.\", propName);\n                    } else if (!props.multiple && array) {\n                        error(\"The `%s` prop supplied to <select> must be a scalar \" + \"value if `multiple` is false.\", propName);\n                    }\n                }\n            }\n        }\n        function pushStartSelect(target, props) {\n            {\n                checkControlledValueProps(\"select\", props);\n                checkSelectProp(props, \"value\");\n                checkSelectProp(props, \"defaultValue\");\n                if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultSelectValue) {\n                    error(\"Select elements must be either controlled or uncontrolled \" + \"(specify either the value prop, or the defaultValue prop, but not \" + \"both). Decide between using a controlled or uncontrolled select \" + \"element and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\");\n                    didWarnDefaultSelectValue = true;\n                }\n            }\n            target.push(startChunkForTag(\"select\"));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            // TODO: This doesn't really make sense for select since it can't use the controlled\n                            // value in the innerHTML.\n                            innerHTML = propValue;\n                            break;\n                        case \"defaultValue\":\n                        case \"value\":\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            return children;\n        }\n        function flattenOptionChildren(children) {\n            var content = \"\"; // Flatten children and warn if they aren't strings or numbers;\n            // invalid types are ignored.\n            React.Children.forEach(children, function(child) {\n                if (child == null) {\n                    return;\n                }\n                content += child;\n                {\n                    if (!didWarnInvalidOptionChildren && typeof child !== \"string\" && typeof child !== \"number\") {\n                        didWarnInvalidOptionChildren = true;\n                        error(\"Cannot infer the option value of complex children. \" + \"Pass a `value` prop or use a plain string as children to <option>.\");\n                    }\n                }\n            });\n            return content;\n        }\n        var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=\"\"');\n        function pushStartOption(target, props, formatContext) {\n            var selectedValue = formatContext.selectedValue;\n            target.push(startChunkForTag(\"option\"));\n            var children = null;\n            var value = null;\n            var selected = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"selected\":\n                            // ignore\n                            selected = propValue;\n                            {\n                                // TODO: Remove support for `selected` in <option>.\n                                if (!didWarnSelectedSetOnOption) {\n                                    error(\"Use the `defaultValue` or `value` props on <select> instead of \" + \"setting `selected` on <option>.\");\n                                    didWarnSelectedSetOnOption = true;\n                                }\n                            }\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        case \"value\":\n                            value = propValue;\n                        // We intentionally fallthrough to also set the attribute on the node.\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            if (selectedValue != null) {\n                var stringValue;\n                if (value !== null) {\n                    {\n                        checkAttributeStringCoercion(value, \"value\");\n                    }\n                    stringValue = \"\" + value;\n                } else {\n                    {\n                        if (innerHTML !== null) {\n                            if (!didWarnInvalidOptionInnerHTML) {\n                                didWarnInvalidOptionInnerHTML = true;\n                                error(\"Pass a `value` prop if you set dangerouslyInnerHTML so React knows \" + \"which value should be selected.\");\n                            }\n                        }\n                    }\n                    stringValue = flattenOptionChildren(children);\n                }\n                if (isArray(selectedValue)) {\n                    // multiple\n                    for(var i = 0; i < selectedValue.length; i++){\n                        {\n                            checkAttributeStringCoercion(selectedValue[i], \"value\");\n                        }\n                        var v = \"\" + selectedValue[i];\n                        if (v === stringValue) {\n                            target.push(selectedMarkerAttribute);\n                            break;\n                        }\n                    }\n                } else {\n                    {\n                        checkAttributeStringCoercion(selectedValue, \"select.value\");\n                    }\n                    if (\"\" + selectedValue === stringValue) {\n                        target.push(selectedMarkerAttribute);\n                    }\n                }\n            } else if (selected) {\n                target.push(selectedMarkerAttribute);\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            return children;\n        }\n        function pushStartForm(target, props, responseState) {\n            target.push(startChunkForTag(\"form\"));\n            var children = null;\n            var innerHTML = null;\n            var formAction = null;\n            var formEncType = null;\n            var formMethod = null;\n            var formTarget = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        case \"action\":\n                            formAction = propValue;\n                            break;\n                        case \"encType\":\n                            formEncType = propValue;\n                            break;\n                        case \"method\":\n                            formMethod = propValue;\n                            break;\n                        case \"target\":\n                            formTarget = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            if (formAction != null) {\n                pushAttribute(target, \"action\", formAction);\n            }\n            if (formEncType != null) {\n                pushAttribute(target, \"encType\", formEncType);\n            }\n            if (formMethod != null) {\n                pushAttribute(target, \"method\", formMethod);\n            }\n            if (formTarget != null) {\n                pushAttribute(target, \"target\", formTarget);\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            if (typeof children === \"string\") {\n                // Special case children as a string to avoid the unnecessary comment.\n                // TODO: Remove this special case after the general optimization is in place.\n                target.push(stringToChunk(encodeHTMLTextNode(children)));\n                return null;\n            }\n            return children;\n        }\n        function pushInput(target, props, responseState) {\n            {\n                checkControlledValueProps(\"input\", props);\n            }\n            target.push(startChunkForTag(\"input\"));\n            var name = null;\n            var formAction = null;\n            var formEncType = null;\n            var formMethod = null;\n            var formTarget = null;\n            var value = null;\n            var defaultValue = null;\n            var checked = null;\n            var defaultChecked = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"input\" + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        case \"name\":\n                            name = propValue;\n                            break;\n                        case \"formAction\":\n                            formAction = propValue;\n                            break;\n                        case \"formEncType\":\n                            formEncType = propValue;\n                            break;\n                        case \"formMethod\":\n                            formMethod = propValue;\n                            break;\n                        case \"formTarget\":\n                            formTarget = propValue;\n                            break;\n                        case \"defaultChecked\":\n                            defaultChecked = propValue;\n                            break;\n                        case \"defaultValue\":\n                            defaultValue = propValue;\n                            break;\n                        case \"checked\":\n                            checked = propValue;\n                            break;\n                        case \"value\":\n                            value = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            {\n                if (formAction !== null && props.type !== \"image\" && props.type !== \"submit\" && !didWarnFormActionType) {\n                    didWarnFormActionType = true;\n                    error('An input can only specify a formAction along with type=\"submit\" or type=\"image\".');\n                }\n            }\n            var formData = pushFormActionAttribute(target, responseState, formAction, formEncType, formMethod, formTarget, name);\n            {\n                if (checked !== null && defaultChecked !== null && !didWarnDefaultChecked) {\n                    error(\"%s contains an input of type %s with both checked and defaultChecked props. \" + \"Input elements must be either controlled or uncontrolled \" + \"(specify either the checked prop, or the defaultChecked prop, but not \" + \"both). Decide between using a controlled or uncontrolled input \" + \"element and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\", \"A component\", props.type);\n                    didWarnDefaultChecked = true;\n                }\n                if (value !== null && defaultValue !== null && !didWarnDefaultInputValue) {\n                    error(\"%s contains an input of type %s with both value and defaultValue props. \" + \"Input elements must be either controlled or uncontrolled \" + \"(specify either the value prop, or the defaultValue prop, but not \" + \"both). Decide between using a controlled or uncontrolled input \" + \"element and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\", \"A component\", props.type);\n                    didWarnDefaultInputValue = true;\n                }\n            }\n            if (checked !== null) {\n                pushBooleanAttribute(target, \"checked\", checked);\n            } else if (defaultChecked !== null) {\n                pushBooleanAttribute(target, \"checked\", defaultChecked);\n            }\n            if (value !== null) {\n                pushAttribute(target, \"value\", value);\n            } else if (defaultValue !== null) {\n                pushAttribute(target, \"value\", defaultValue);\n            }\n            target.push(endOfStartTagSelfClosing); // We place any additional hidden form fields after the input.\n            pushAdditionalFormFields(target, formData);\n            return null;\n        }\n        function pushStartButton(target, props, responseState) {\n            target.push(startChunkForTag(\"button\"));\n            var children = null;\n            var innerHTML = null;\n            var name = null;\n            var formAction = null;\n            var formEncType = null;\n            var formMethod = null;\n            var formTarget = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        case \"name\":\n                            name = propValue;\n                            break;\n                        case \"formAction\":\n                            formAction = propValue;\n                            break;\n                        case \"formEncType\":\n                            formEncType = propValue;\n                            break;\n                        case \"formMethod\":\n                            formMethod = propValue;\n                            break;\n                        case \"formTarget\":\n                            formTarget = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            {\n                if (formAction !== null && props.type != null && props.type !== \"submit\" && !didWarnFormActionType) {\n                    didWarnFormActionType = true;\n                    error('A button can only specify a formAction along with type=\"submit\" or no type.');\n                }\n            }\n            var formData = pushFormActionAttribute(target, responseState, formAction, formEncType, formMethod, formTarget, name);\n            target.push(endOfStartTag); // We place any additional hidden form fields we need to include inside the button itself.\n            pushAdditionalFormFields(target, formData);\n            pushInnerHTML(target, innerHTML, children);\n            if (typeof children === \"string\") {\n                // Special case children as a string to avoid the unnecessary comment.\n                // TODO: Remove this special case after the general optimization is in place.\n                target.push(stringToChunk(encodeHTMLTextNode(children)));\n                return null;\n            }\n            return children;\n        }\n        function pushStartTextArea(target, props) {\n            {\n                checkControlledValueProps(\"textarea\", props);\n                if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultTextareaValue) {\n                    error(\"Textarea elements must be either controlled or uncontrolled \" + \"(specify either the value prop, or the defaultValue prop, but not \" + \"both). Decide between using a controlled or uncontrolled textarea \" + \"and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\");\n                    didWarnDefaultTextareaValue = true;\n                }\n            }\n            target.push(startChunkForTag(\"textarea\"));\n            var value = null;\n            var defaultValue = null;\n            var children = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"value\":\n                            value = propValue;\n                            break;\n                        case \"defaultValue\":\n                            defaultValue = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"`dangerouslySetInnerHTML` does not make sense on <textarea>.\");\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            if (value === null && defaultValue !== null) {\n                value = defaultValue;\n            }\n            target.push(endOfStartTag); // TODO (yungsters): Remove support for children content in <textarea>.\n            if (children != null) {\n                {\n                    error(\"Use the `defaultValue` or `value` props instead of setting \" + \"children on <textarea>.\");\n                }\n                if (value != null) {\n                    throw new Error(\"If you supply `defaultValue` on a <textarea>, do not pass children.\");\n                }\n                if (isArray(children)) {\n                    if (children.length > 1) {\n                        throw new Error(\"<textarea> can only have at most one child.\");\n                    } // TODO: remove the coercion and the DEV check below because it will\n                    // always be overwritten by the coercion several lines below it. #22309\n                    {\n                        checkHtmlStringCoercion(children[0]);\n                    }\n                    value = \"\" + children[0];\n                }\n                {\n                    checkHtmlStringCoercion(children);\n                }\n                value = \"\" + children;\n            }\n            if (typeof value === \"string\" && value[0] === \"\\n\") {\n                // text/html ignores the first character in these tags if it's a newline\n                // Prefer to break application/xml over text/html (for now) by adding\n                // a newline specifically to get eaten by the parser. (Alternately for\n                // textareas, replacing \"^\\n\" with \"\\r\\n\" doesn't get eaten, and the first\n                // \\r is normalized out by HTMLTextAreaElement#value.)\n                // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>\n                // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>\n                // See: <http://www.w3.org/TR/html5/syntax.html#newlines>\n                // See: Parsing of \"textarea\" \"listing\" and \"pre\" elements\n                //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>\n                target.push(leadingNewline);\n            } // ToString and push directly instead of recurse over children.\n            // We don't really support complex children in the value anyway.\n            // This also currently avoids a trailing comment node which breaks textarea.\n            if (value !== null) {\n                {\n                    checkAttributeStringCoercion(value, \"value\");\n                }\n                target.push(stringToChunk(encodeHTMLTextNode(\"\" + value)));\n            }\n            return null;\n        }\n        function pushMeta(target, props, responseState, textEmbedded, insertionMode, noscriptTagInScope) {\n            {\n                if (insertionMode === SVG_MODE || noscriptTagInScope || props.itemProp != null) {\n                    return pushSelfClosing(target, props, \"meta\");\n                } else {\n                    if (textEmbedded) {\n                        // This link follows text but we aren't writing a tag. while not as efficient as possible we need\n                        // to be safe and assume text will follow by inserting a textSeparator\n                        target.push(textSeparator);\n                    }\n                    if (typeof props.charSet === \"string\") {\n                        return pushSelfClosing(responseState.charsetChunks, props, \"meta\");\n                    } else if (props.name === \"viewport\") {\n                        // \"viewport\" isn't related to preconnect but it has the right priority\n                        return pushSelfClosing(responseState.preconnectChunks, props, \"meta\");\n                    } else {\n                        return pushSelfClosing(responseState.hoistableChunks, props, \"meta\");\n                    }\n                }\n            }\n        }\n        function pushLink(target, props, responseState, resources, textEmbedded, insertionMode, noscriptTagInScope) {\n            {\n                var rel = props.rel;\n                var href = props.href;\n                var precedence = props.precedence;\n                if (insertionMode === SVG_MODE || noscriptTagInScope || props.itemProp != null || typeof rel !== \"string\" || typeof href !== \"string\" || href === \"\") {\n                    {\n                        if (rel === \"stylesheet\" && typeof props.precedence === \"string\") {\n                            if (typeof href !== \"string\" || !href) {\n                                error('React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and expected the `href` prop to be a non-empty string but ecountered %s instead. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop ensure there is a non-empty string `href` prop as well, otherwise remove the `precedence` prop.', getValueDescriptorExpectingObjectForWarning(href));\n                            }\n                        }\n                    }\n                    pushLinkImpl(target, props);\n                    return null;\n                }\n                if (props.rel === \"stylesheet\") {\n                    // This <link> may hoistable as a Stylesheet Resource, otherwise it will emit in place\n                    var key = getResourceKey(\"style\", href);\n                    if (typeof precedence !== \"string\" || props.disabled != null || props.onLoad || props.onError) {\n                        // This stylesheet is either not opted into Resource semantics or has conflicting properties which\n                        // disqualify it for such. We can still create a preload resource to help it load faster on the\n                        // client\n                        {\n                            if (typeof precedence === \"string\") {\n                                if (props.disabled != null) {\n                                    error('React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and a `disabled` prop. The presence of the `disabled` prop indicates an intent to manage the stylesheet active state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the `disabled` prop, otherwise remove the `precedence` prop.');\n                                } else if (props.onLoad || props.onError) {\n                                    var propDescription = props.onLoad && props.onError ? \"`onLoad` and `onError` props\" : props.onLoad ? \"`onLoad` prop\" : \"`onError` prop\";\n                                    error('React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.', propDescription, propDescription);\n                                }\n                            }\n                        }\n                        return pushLinkImpl(target, props);\n                    } else {\n                        // This stylesheet refers to a Resource and we create a new one if necessary\n                        var resource = resources.stylesMap.get(key);\n                        {\n                            var devResource = getAsResourceDEV(resource);\n                            if (devResource) {\n                                switch(devResource.__provenance){\n                                    case \"rendered\":\n                                        {\n                                            var differenceDescription = describeDifferencesForStylesheets(props, devResource.__originalProps);\n                                            if (differenceDescription) {\n                                                error('React encountered a <link rel=\"stylesheet\" href=\"%s\" .../> with a `precedence` prop that has props that conflict' + ' with another hoistable stylesheet with the same `href`. When using `precedence` with <link rel=\"stylsheet\" .../>' + \" the props from the first encountered instance will be used and props from later instances will be ignored.\" + ' Update the props on either <link rel=\"stylesheet\" .../> instance so they agree.%s', href, differenceDescription);\n                                            }\n                                            break;\n                                        }\n                                    case \"preinit\":\n                                        {\n                                            var _differenceDescription = describeDifferencesForStylesheetOverPreinit(props, devResource.__propsEquivalent);\n                                            if (_differenceDescription) {\n                                                error('React encountered a <link rel=\"stylesheet\" precedence=\"%s\" href=\"%s\" .../> with props that conflict' + ' with the options provided to `ReactDOM.preinit(\"%s\", { as: \"style\", ... })`. React will use the first props or preinitialization' + \" options encountered when rendering a hoistable stylesheet with a particular `href` and will ignore any newer props or\" + \" options. The first instance of this stylesheet resource was created using the `ReactDOM.preinit()` function.\" + \" Please note, `ReactDOM.preinit()` is modeled off of module import assertions capabilities and does not support\" + \" arbitrary props. If you need to have props not included with the preinit options you will need to rely on rendering\" + \" <link> tags only.%s\", precedence, href, href, _differenceDescription);\n                                            }\n                                            break;\n                                        }\n                                }\n                            }\n                        }\n                        if (!resource) {\n                            var resourceProps = stylesheetPropsFromRawProps(props);\n                            var preloadResource = resources.preloadsMap.get(key);\n                            var state = NoState;\n                            if (preloadResource) {\n                                // If we already had a preload we don't want that resource to flush directly.\n                                // We let the newly created resource govern flushing.\n                                preloadResource.state |= Blocked;\n                                adoptPreloadPropsForStylesheetProps(resourceProps, preloadResource.props);\n                                if (preloadResource.state & Flushed) {\n                                    state = PreloadFlushed;\n                                }\n                            }\n                            resource = {\n                                type: \"stylesheet\",\n                                chunks: [],\n                                state: state,\n                                props: resourceProps\n                            };\n                            resources.stylesMap.set(key, resource);\n                            {\n                                markAsRenderedResourceDEV(resource, props);\n                            }\n                            var precedenceSet = resources.precedences.get(precedence);\n                            if (!precedenceSet) {\n                                precedenceSet = new Set();\n                                resources.precedences.set(precedence, precedenceSet);\n                                var emptyStyleResource = {\n                                    type: \"style\",\n                                    chunks: [],\n                                    state: NoState,\n                                    props: {\n                                        precedence: precedence,\n                                        hrefs: []\n                                    }\n                                };\n                                precedenceSet.add(emptyStyleResource);\n                                {\n                                    if (resources.stylePrecedences.has(precedence)) {\n                                        error('React constructed an empty style resource when a style resource already exists for this precedence: \"%s\". This is a bug in React.', precedence);\n                                    }\n                                }\n                                resources.stylePrecedences.set(precedence, emptyStyleResource);\n                            }\n                            precedenceSet.add(resource);\n                        }\n                        if (resources.boundaryResources) {\n                            resources.boundaryResources.add(resource);\n                        }\n                        if (textEmbedded) {\n                            // This link follows text but we aren't writing a tag. while not as efficient as possible we need\n                            // to be safe and assume text will follow by inserting a textSeparator\n                            target.push(textSeparator);\n                        }\n                        return null;\n                    }\n                } else if (props.onLoad || props.onError) {\n                    // When using load handlers we cannot hoist and need to emit links in place\n                    return pushLinkImpl(target, props);\n                } else {\n                    // We can hoist this link so we may need to emit a text separator.\n                    // @TODO refactor text separators so we don't have to defensively add\n                    // them when we don't end up emitting a tag as a result of pushStartInstance\n                    if (textEmbedded) {\n                        // This link follows text but we aren't writing a tag. while not as efficient as possible we need\n                        // to be safe and assume text will follow by inserting a textSeparator\n                        target.push(textSeparator);\n                    }\n                    switch(props.rel){\n                        case \"preconnect\":\n                        case \"dns-prefetch\":\n                            return pushLinkImpl(responseState.preconnectChunks, props);\n                        case \"preload\":\n                            return pushLinkImpl(responseState.preloadChunks, props);\n                        default:\n                            return pushLinkImpl(responseState.hoistableChunks, props);\n                    }\n                }\n            }\n        }\n        function pushLinkImpl(target, props) {\n            target.push(startChunkForTag(\"link\"));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"link\" + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTagSelfClosing);\n            return null;\n        }\n        function pushStyle(target, props, resources, textEmbedded, insertionMode, noscriptTagInScope) {\n            {\n                if (hasOwnProperty.call(props, \"children\")) {\n                    var children = props.children;\n                    var child = Array.isArray(children) ? children.length < 2 ? children[0] : null : children;\n                    if (typeof child === \"function\" || typeof child === \"symbol\" || Array.isArray(child)) {\n                        var childType = typeof child === \"function\" ? \"a Function\" : typeof child === \"symbol\" ? \"a Sybmol\" : \"an Array\";\n                        error(\"React expect children of <style> tags to be a string, number, or object with a `toString` method but found %s instead. \" + \"In browsers style Elements can only have `Text` Nodes as children.\", childType);\n                    }\n                }\n            }\n            {\n                var precedence = props.precedence;\n                var href = props.href;\n                if (insertionMode === SVG_MODE || noscriptTagInScope || props.itemProp != null || typeof precedence !== \"string\" || typeof href !== \"string\" || href === \"\") {\n                    // This style tag is not able to be turned into a Style Resource\n                    return pushStyleImpl(target, props);\n                }\n                {\n                    if (href.includes(\" \")) {\n                        error('React expected the `href` prop for a <style> tag opting into hoisting semantics using the `precedence` prop to not have any spaces but ecountered spaces instead. using spaces in this prop will cause hydration of this style to fail on the client. The href for the <style> where this ocurred is \"%s\".', href);\n                    }\n                }\n                var key = getResourceKey(\"style\", href);\n                var resource = resources.stylesMap.get(key);\n                if (!resource) {\n                    resource = resources.stylePrecedences.get(precedence);\n                    if (!resource) {\n                        resource = {\n                            type: \"style\",\n                            chunks: [],\n                            state: NoState,\n                            props: {\n                                precedence: precedence,\n                                hrefs: [\n                                    href\n                                ]\n                            }\n                        };\n                        resources.stylePrecedences.set(precedence, resource);\n                        var precedenceSet = new Set();\n                        precedenceSet.add(resource);\n                        {\n                            if (resources.precedences.has(precedence)) {\n                                error('React constructed a new style precedence set when one already exists for this precedence: \"%s\". This is a bug in React.', precedence);\n                            }\n                        }\n                        resources.precedences.set(precedence, precedenceSet);\n                    } else {\n                        resource.props.hrefs.push(href);\n                    }\n                    resources.stylesMap.set(key, resource);\n                    if (resources.boundaryResources) {\n                        resources.boundaryResources.add(resource);\n                    }\n                    pushStyleContents(resource.chunks, props);\n                }\n                if (textEmbedded) {\n                    // This link follows text but we aren't writing a tag. while not as efficient as possible we need\n                    // to be safe and assume text will follow by inserting a textSeparator\n                    target.push(textSeparator);\n                }\n            }\n        }\n        function pushStyleImpl(target, props) {\n            target.push(startChunkForTag(\"style\"));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            var child = Array.isArray(children) ? children.length < 2 ? children[0] : null : children;\n            if (typeof child !== \"function\" && typeof child !== \"symbol\" && child !== null && child !== undefined) {\n                // eslint-disable-next-line react-internal/safe-string-coercion\n                target.push(stringToChunk(escapeTextForBrowser(\"\" + child)));\n            }\n            pushInnerHTML(target, innerHTML, children);\n            target.push(endTag1, stringToChunk(\"style\"), endTag2);\n            return null;\n        }\n        function pushStyleContents(target, props) {\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                    }\n                }\n            }\n            var child = Array.isArray(children) ? children.length < 2 ? children[0] : null : children;\n            if (typeof child !== \"function\" && typeof child !== \"symbol\" && child !== null && child !== undefined) {\n                // eslint-disable-next-line react-internal/safe-string-coercion\n                target.push(stringToChunk(escapeTextForBrowser(\"\" + child)));\n            }\n            pushInnerHTML(target, innerHTML, children);\n            return;\n        }\n        function getImagePreloadKey(href, imageSrcSet, imageSizes) {\n            var uniquePart = \"\";\n            if (typeof imageSrcSet === \"string\" && imageSrcSet !== \"\") {\n                uniquePart += \"[\" + imageSrcSet + \"]\";\n                if (typeof imageSizes === \"string\") {\n                    uniquePart += \"[\" + imageSizes + \"]\";\n                }\n            } else {\n                uniquePart += \"[][]\" + href;\n            }\n            return getResourceKey(\"image\", uniquePart);\n        }\n        function pushImg(target, props, resources) {\n            var src = props.src, srcSet = props.srcSet;\n            if (props.loading !== \"lazy\" && (typeof src === \"string\" || typeof srcSet === \"string\") && props.fetchPriority !== \"low\" && // We exclude data URIs in src and srcSet since these should not be preloaded\n            !(typeof src === \"string\" && src[4] === \":\" && (src[0] === \"d\" || src[0] === \"D\") && (src[1] === \"a\" || src[1] === \"A\") && (src[2] === \"t\" || src[2] === \"T\") && (src[3] === \"a\" || src[3] === \"A\")) && !(typeof srcSet === \"string\" && srcSet[4] === \":\" && (srcSet[0] === \"d\" || srcSet[0] === \"D\") && (srcSet[1] === \"a\" || srcSet[1] === \"A\") && (srcSet[2] === \"t\" || srcSet[2] === \"T\") && (srcSet[3] === \"a\" || srcSet[3] === \"A\"))) {\n                // We have a suspensey image and ought to preload it to optimize the loading of display blocking\n                // resources.\n                var sizes = props.sizes;\n                var key = getImagePreloadKey(src, srcSet, sizes);\n                var resource = resources.preloadsMap.get(key);\n                if (!resource) {\n                    resource = {\n                        type: \"preload\",\n                        chunks: [],\n                        state: NoState,\n                        props: {\n                            rel: \"preload\",\n                            as: \"image\",\n                            // There is a bug in Safari where imageSrcSet is not respected on preload links\n                            // so we omit the href here if we have imageSrcSet b/c safari will load the wrong image.\n                            // This harms older browers that do not support imageSrcSet by making their preloads not work\n                            // but this population is shrinking fast and is already small so we accept this tradeoff.\n                            href: srcSet ? undefined : src,\n                            imageSrcSet: srcSet,\n                            imageSizes: sizes,\n                            crossOrigin: props.crossOrigin,\n                            integrity: props.integrity,\n                            type: props.type,\n                            fetchPriority: props.fetchPriority,\n                            referrerPolicy: props.referrerPolicy\n                        }\n                    };\n                    resources.preloadsMap.set(key, resource);\n                    {\n                        markAsRenderedResourceDEV(resource, props);\n                    }\n                    pushLinkImpl(resource.chunks, resource.props);\n                }\n                if (props.fetchPriority === \"high\" || resources.highImagePreloads.size < 10) {\n                    resources.highImagePreloads.add(resource);\n                } else {\n                    resources.bulkPreloads.add(resource);\n                }\n            }\n            return pushSelfClosing(target, props, \"img\");\n        }\n        function pushSelfClosing(target, props, tag) {\n            target.push(startChunkForTag(tag));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(tag + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTagSelfClosing);\n            return null;\n        }\n        function pushStartMenuItem(target, props) {\n            target.push(startChunkForTag(\"menuitem\"));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"menuitems cannot have `children` nor `dangerouslySetInnerHTML`.\");\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            return null;\n        }\n        function pushTitle(target, props, responseState, insertionMode, noscriptTagInScope) {\n            {\n                if (hasOwnProperty.call(props, \"children\")) {\n                    var children = props.children;\n                    var child = Array.isArray(children) ? children.length < 2 ? children[0] : null : children;\n                    if (Array.isArray(children) && children.length > 1) {\n                        error(\"React expects the `children` prop of <title> tags to be a string, number, or object with a novel `toString` method but found an Array with length %s instead.\" + \" Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert `children` of <title> tags to a single string value\" + \" which is why Arrays of length greater than 1 are not supported. When using JSX it can be commong to combine text nodes and value nodes.\" + \" For example: <title>hello {nameOfUser}</title>. While not immediately apparent, `children` in this case is an Array with length 2. If your `children` prop\" + \" is using this form try rewriting it using a template string: <title>{`hello ${nameOfUser}`}</title>.\", children.length);\n                    } else if (typeof child === \"function\" || typeof child === \"symbol\") {\n                        var childType = typeof child === \"function\" ? \"a Function\" : \"a Sybmol\";\n                        error(\"React expect children of <title> tags to be a string, number, or object with a novel `toString` method but found %s instead.\" + \" Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title>\" + \" tags to a single string value.\", childType);\n                    } else if (child && child.toString === ({}).toString) {\n                        if (child.$$typeof != null) {\n                            error(\"React expects the `children` prop of <title> tags to be a string, number, or object with a novel `toString` method but found an object that appears to be\" + \" a React element which never implements a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to\" + \" be able to convert children of <title> tags to a single string value which is why rendering React elements is not supported. If the `children` of <title> is\" + \" a React Component try moving the <title> tag into that component. If the `children` of <title> is some HTML markup change it to be Text only to be valid HTML.\");\n                        } else {\n                            error(\"React expects the `children` prop of <title> tags to be a string, number, or object with a novel `toString` method but found an object that does not implement\" + \" a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags\" + \" to a single string value. Using the default `toString` method available on every object is almost certainly an error. Consider whether the `children` of this <title>\" + \" is an object in error and change it to a string or number value if so. Otherwise implement a `toString` method that React can use to produce a valid <title>.\");\n                        }\n                    }\n                }\n            }\n            {\n                if (insertionMode !== SVG_MODE && !noscriptTagInScope && props.itemProp == null) {\n                    pushTitleImpl(responseState.hoistableChunks, props);\n                    return null;\n                } else {\n                    return pushTitleImpl(target, props);\n                }\n            }\n        }\n        function pushTitleImpl(target, props) {\n            target.push(startChunkForTag(\"title\"));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            var child = Array.isArray(children) ? children.length < 2 ? children[0] : null : children;\n            if (typeof child !== \"function\" && typeof child !== \"symbol\" && child !== null && child !== undefined) {\n                // eslint-disable-next-line react-internal/safe-string-coercion\n                target.push(stringToChunk(escapeTextForBrowser(\"\" + child)));\n            }\n            pushInnerHTML(target, innerHTML, children);\n            target.push(endTag1, stringToChunk(\"title\"), endTag2);\n            return null;\n        }\n        function pushStartHead(target, props, responseState, insertionMode) {\n            {\n                if (insertionMode < HTML_MODE && responseState.headChunks === null) {\n                    // This <head> is the Document.head and should be part of the preamble\n                    responseState.headChunks = [];\n                    return pushStartGenericElement(responseState.headChunks, props, \"head\");\n                } else {\n                    // This <head> is deep and is likely just an error. we emit it inline though.\n                    // Validation should warn that this tag is the the wrong spot.\n                    return pushStartGenericElement(target, props, \"head\");\n                }\n            }\n        }\n        function pushStartHtml(target, props, responseState, insertionMode) {\n            {\n                if (insertionMode === ROOT_HTML_MODE && responseState.htmlChunks === null) {\n                    // This <html> is the Document.documentElement and should be part of the preamble\n                    responseState.htmlChunks = [\n                        DOCTYPE\n                    ];\n                    return pushStartGenericElement(responseState.htmlChunks, props, \"html\");\n                } else {\n                    // This <html> is deep and is likely just an error. we emit it inline though.\n                    // Validation should warn that this tag is the the wrong spot.\n                    return pushStartGenericElement(target, props, \"html\");\n                }\n            }\n        }\n        function pushScript(target, props, resources, textEmbedded, insertionMode, noscriptTagInScope) {\n            {\n                var asyncProp = props.async;\n                if (typeof props.src !== \"string\" || !props.src || !(asyncProp && typeof asyncProp !== \"function\" && typeof asyncProp !== \"symbol\") || props.onLoad || props.onError || insertionMode === SVG_MODE || noscriptTagInScope || props.itemProp != null) {\n                    // This script will not be a resource, we bailout early and emit it in place.\n                    return pushScriptImpl(target, props);\n                }\n                var src = props.src;\n                var key = getResourceKey(\"script\", src); // We can make this <script> into a ScriptResource\n                var resource = resources.scriptsMap.get(key);\n                {\n                    var devResource = getAsResourceDEV(resource);\n                    if (devResource) {\n                        switch(devResource.__provenance){\n                            case \"rendered\":\n                                {\n                                    var differenceDescription = describeDifferencesForScripts(props, devResource.__originalProps);\n                                    if (differenceDescription) {\n                                        error('React encountered a <script async={true} src=\"%s\" .../> that has props that conflict' + \" with another hoistable script with the same `src`. When rendering hoistable scripts (async scripts without any loading handlers)\" + \" the props from the first encountered instance will be used and props from later instances will be ignored.\" + \" Update the props on both <script async={true} .../> instance so they agree.%s\", src, differenceDescription);\n                                    }\n                                    break;\n                                }\n                            case \"preinit\":\n                                {\n                                    var _differenceDescription2 = describeDifferencesForScriptOverPreinit(props, devResource.__propsEquivalent);\n                                    if (_differenceDescription2) {\n                                        error('React encountered a <script async={true} src=\"%s\" .../> with props that conflict' + ' with the options provided to `ReactDOM.preinit(\"%s\", { as: \"script\", ... })`. React will use the first props or preinitialization' + \" options encountered when rendering a hoistable script with a particular `src` and will ignore any newer props or\" + \" options. The first instance of this script resource was created using the `ReactDOM.preinit()` function.\" + \" Please note, `ReactDOM.preinit()` is modeled off of module import assertions capabilities and does not support\" + \" arbitrary props. If you need to have props not included with the preinit options you will need to rely on rendering\" + \" <script> tags only.%s\", src, src, _differenceDescription2);\n                                    }\n                                    break;\n                                }\n                        }\n                    }\n                }\n                if (!resource) {\n                    resource = {\n                        type: \"script\",\n                        chunks: [],\n                        state: NoState,\n                        props: null\n                    };\n                    resources.scriptsMap.set(key, resource);\n                    {\n                        markAsRenderedResourceDEV(resource, props);\n                    }\n                    resources.scripts.add(resource);\n                    var scriptProps = props;\n                    var preloadResource = resources.preloadsMap.get(key);\n                    if (preloadResource) {\n                        // If we already had a preload we don't want that resource to flush directly.\n                        // We let the newly created resource govern flushing.\n                        preloadResource.state |= Blocked;\n                        scriptProps = assign({}, props);\n                        adoptPreloadPropsForScriptProps(scriptProps, preloadResource.props);\n                    } // encode the tag as Chunks\n                    pushScriptImpl(resource.chunks, scriptProps);\n                }\n                if (textEmbedded) {\n                    // This script follows text but we aren't writing a tag. while not as efficient as possible we need\n                    // to be safe and assume text will follow by inserting a textSeparator\n                    target.push(textSeparator);\n                }\n                return null;\n            }\n        }\n        function pushScriptImpl(target, props) {\n            target.push(startChunkForTag(\"script\"));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            {\n                if (children != null && typeof children !== \"string\") {\n                    var descriptiveStatement = typeof children === \"number\" ? \"a number for children\" : Array.isArray(children) ? \"an array for children\" : \"something unexpected for children\";\n                    error(\"A script element was rendered with %s. If script element has children it must be a single string.\" + \" Consider using dangerouslySetInnerHTML or passing a plain string as children.\", descriptiveStatement);\n                }\n            }\n            pushInnerHTML(target, innerHTML, children);\n            if (typeof children === \"string\") {\n                target.push(stringToChunk(encodeHTMLTextNode(children)));\n            }\n            target.push(endTag1, stringToChunk(\"script\"), endTag2);\n            return null;\n        }\n        function pushStartGenericElement(target, props, tag) {\n            target.push(startChunkForTag(tag));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            if (typeof children === \"string\") {\n                // Special case children as a string to avoid the unnecessary comment.\n                // TODO: Remove this special case after the general optimization is in place.\n                target.push(stringToChunk(encodeHTMLTextNode(children)));\n                return null;\n            }\n            return children;\n        }\n        function pushStartCustomElement(target, props, tag) {\n            target.push(startChunkForTag(tag));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        case \"style\":\n                            pushStyleAttribute(target, propValue);\n                            break;\n                        case \"suppressContentEditableWarning\":\n                        case \"suppressHydrationWarning\":\n                            break;\n                        default:\n                            if (isAttributeNameSafe(propKey) && typeof propValue !== \"function\" && typeof propValue !== \"symbol\") {\n                                target.push(attributeSeparator, stringToChunk(propKey), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);\n                            }\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            return children;\n        }\n        var leadingNewline = stringToPrecomputedChunk(\"\\n\");\n        function pushStartPreformattedElement(target, props, tag) {\n            target.push(startChunkForTag(tag));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag); // text/html ignores the first character in these tags if it's a newline\n            // Prefer to break application/xml over text/html (for now) by adding\n            // a newline specifically to get eaten by the parser. (Alternately for\n            // textareas, replacing \"^\\n\" with \"\\r\\n\" doesn't get eaten, and the first\n            // \\r is normalized out by HTMLTextAreaElement#value.)\n            // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>\n            // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>\n            // See: <http://www.w3.org/TR/html5/syntax.html#newlines>\n            // See: Parsing of \"textarea\" \"listing\" and \"pre\" elements\n            //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>\n            // TODO: This doesn't deal with the case where the child is an array\n            // or component that returns a string.\n            if (innerHTML != null) {\n                if (children != null) {\n                    throw new Error(\"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\");\n                }\n                if (typeof innerHTML !== \"object\" || !(\"__html\" in innerHTML)) {\n                    throw new Error(\"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. \" + \"Please visit https://reactjs.org/link/dangerously-set-inner-html \" + \"for more information.\");\n                }\n                var html = innerHTML.__html;\n                if (html !== null && html !== undefined) {\n                    if (typeof html === \"string\" && html.length > 0 && html[0] === \"\\n\") {\n                        target.push(leadingNewline, stringToChunk(html));\n                    } else {\n                        {\n                            checkHtmlStringCoercion(html);\n                        }\n                        target.push(stringToChunk(\"\" + html));\n                    }\n                }\n            }\n            if (typeof children === \"string\" && children[0] === \"\\n\") {\n                target.push(leadingNewline);\n            }\n            return children;\n        } // We accept any tag to be rendered but since this gets injected into arbitrary\n        // HTML, we want to make sure that it's a safe tag.\n        // http://www.w3.org/TR/REC-xml/#NT-Name\n        var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\\.\\-\\d]*$/; // Simplified subset\n        var validatedTagCache = new Map();\n        function startChunkForTag(tag) {\n            var tagStartChunk = validatedTagCache.get(tag);\n            if (tagStartChunk === undefined) {\n                if (!VALID_TAG_REGEX.test(tag)) {\n                    throw new Error(\"Invalid tag: \" + tag);\n                }\n                tagStartChunk = stringToPrecomputedChunk(\"<\" + tag);\n                validatedTagCache.set(tag, tagStartChunk);\n            }\n            return tagStartChunk;\n        }\n        var DOCTYPE = stringToPrecomputedChunk(\"<!DOCTYPE html>\");\n        function pushStartInstance(target, type, props, resources, responseState, formatContext, textEmbedded) {\n            {\n                validateProperties$2(type, props);\n                validateProperties$1(type, props);\n                validateProperties(type, props, null);\n                if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {\n                    error(\"A component is `contentEditable` and contains `children` managed by \" + \"React. It is now your responsibility to guarantee that none of \" + \"those nodes are unexpectedly modified or duplicated. This is \" + \"probably not intentional.\");\n                }\n                if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {\n                    if (type.indexOf(\"-\") === -1 && type.toLowerCase() !== type) {\n                        error(\"<%s /> is using incorrect casing. \" + \"Use PascalCase for React components, \" + \"or lowercase for HTML elements.\", type);\n                    }\n                }\n            }\n            switch(type){\n                case \"div\":\n                case \"span\":\n                case \"svg\":\n                case \"path\":\n                case \"a\":\n                case \"g\":\n                case \"p\":\n                case \"li\":\n                    break;\n                // Special tags\n                case \"select\":\n                    return pushStartSelect(target, props);\n                case \"option\":\n                    return pushStartOption(target, props, formatContext);\n                case \"textarea\":\n                    return pushStartTextArea(target, props);\n                case \"input\":\n                    return pushInput(target, props, responseState);\n                case \"button\":\n                    return pushStartButton(target, props, responseState);\n                case \"form\":\n                    return pushStartForm(target, props);\n                case \"menuitem\":\n                    return pushStartMenuItem(target, props);\n                case \"title\":\n                    return pushTitle(target, props, responseState, formatContext.insertionMode, formatContext.noscriptTagInScope);\n                case \"link\":\n                    return pushLink(target, props, responseState, resources, textEmbedded, formatContext.insertionMode, formatContext.noscriptTagInScope);\n                case \"script\":\n                    return pushScript(target, props, resources, textEmbedded, formatContext.insertionMode, formatContext.noscriptTagInScope);\n                case \"style\":\n                    return pushStyle(target, props, resources, textEmbedded, formatContext.insertionMode, formatContext.noscriptTagInScope);\n                case \"meta\":\n                    return pushMeta(target, props, responseState, textEmbedded, formatContext.insertionMode, formatContext.noscriptTagInScope);\n                // Newline eating tags\n                case \"listing\":\n                case \"pre\":\n                    {\n                        return pushStartPreformattedElement(target, props, type);\n                    }\n                case \"img\":\n                    {\n                        return pushImg(target, props, resources);\n                    }\n                // Omitted close tags\n                case \"base\":\n                case \"area\":\n                case \"br\":\n                case \"col\":\n                case \"embed\":\n                case \"hr\":\n                case \"keygen\":\n                case \"param\":\n                case \"source\":\n                case \"track\":\n                case \"wbr\":\n                    {\n                        return pushSelfClosing(target, props, type);\n                    }\n                // These are reserved SVG and MathML elements, that are never custom elements.\n                // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\n                case \"annotation-xml\":\n                case \"color-profile\":\n                case \"font-face\":\n                case \"font-face-src\":\n                case \"font-face-uri\":\n                case \"font-face-format\":\n                case \"font-face-name\":\n                case \"missing-glyph\":\n                    {\n                        break;\n                    }\n                // Preamble start tags\n                case \"head\":\n                    return pushStartHead(target, props, responseState, formatContext.insertionMode);\n                case \"html\":\n                    {\n                        return pushStartHtml(target, props, responseState, formatContext.insertionMode);\n                    }\n                default:\n                    {\n                        if (type.indexOf(\"-\") !== -1) {\n                            // Custom element\n                            return pushStartCustomElement(target, props, type);\n                        }\n                    }\n            } // Generic element\n            return pushStartGenericElement(target, props, type);\n        }\n        var endTag1 = stringToPrecomputedChunk(\"</\");\n        var endTag2 = stringToPrecomputedChunk(\">\");\n        function pushEndInstance(target, type, props, responseState, formatContext) {\n            switch(type){\n                // When float is on we expect title and script tags to always be pushed in\n                // a unit and never return children. when we end up pushing the end tag we\n                // want to ensure there is no extra closing tag pushed\n                case \"title\":\n                case \"style\":\n                case \"script\":\n                // Omitted close tags\n                // TODO: Instead of repeating this switch we could try to pass a flag from above.\n                // That would require returning a tuple. Which might be ok if it gets inlined.\n                case \"area\":\n                case \"base\":\n                case \"br\":\n                case \"col\":\n                case \"embed\":\n                case \"hr\":\n                case \"img\":\n                case \"input\":\n                case \"keygen\":\n                case \"link\":\n                case \"meta\":\n                case \"param\":\n                case \"source\":\n                case \"track\":\n                case \"wbr\":\n                    {\n                        // No close tag needed.\n                        return;\n                    }\n                // Postamble end tags\n                // When float is enabled we omit the end tags for body and html when\n                // they represent the Document.body and Document.documentElement Nodes.\n                // This is so we can withhold them until the postamble when we know\n                // we won't emit any more tags\n                case \"body\":\n                    {\n                        if (formatContext.insertionMode <= HTML_HTML_MODE) {\n                            responseState.hasBody = true;\n                            return;\n                        }\n                        break;\n                    }\n                case \"html\":\n                    if (formatContext.insertionMode === ROOT_HTML_MODE) {\n                        return;\n                    }\n                    break;\n            }\n            target.push(endTag1, stringToChunk(type), endTag2);\n        }\n        function writeBootstrap(destination, responseState) {\n            var bootstrapChunks = responseState.bootstrapChunks;\n            var i = 0;\n            for(; i < bootstrapChunks.length - 1; i++){\n                writeChunk(destination, bootstrapChunks[i]);\n            }\n            if (i < bootstrapChunks.length) {\n                var lastChunk = bootstrapChunks[i];\n                bootstrapChunks.length = 0;\n                return writeChunkAndReturn(destination, lastChunk);\n            }\n            return true;\n        }\n        function writeCompletedRoot(destination, responseState) {\n            return writeBootstrap(destination, responseState);\n        } // Structural Nodes\n        // A placeholder is a node inside a hidden partial tree that can be filled in later, but before\n        // display. It's never visible to users. We use the template tag because it can be used in every\n        // type of parent. <script> tags also work in every other tag except <colgroup>.\n        var placeholder1 = stringToPrecomputedChunk('<template id=\"');\n        var placeholder2 = stringToPrecomputedChunk('\"></template>');\n        function writePlaceholder(destination, responseState, id) {\n            writeChunk(destination, placeholder1);\n            writeChunk(destination, responseState.placeholderPrefix);\n            var formattedID = stringToChunk(id.toString(16));\n            writeChunk(destination, formattedID);\n            return writeChunkAndReturn(destination, placeholder2);\n        } // Suspense boundaries are encoded as comments.\n        var startCompletedSuspenseBoundary = stringToPrecomputedChunk(\"<!--$-->\");\n        var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id=\"');\n        var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('\"></template>');\n        var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk(\"<!--$!-->\");\n        var endSuspenseBoundary = stringToPrecomputedChunk(\"<!--/$-->\");\n        var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk(\"<template\");\n        var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('\"');\n        var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst=\"');\n        var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg=\"');\n        var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck=\"');\n        var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk(\"></template>\");\n        function writeStartCompletedSuspenseBoundary$1(destination, responseState) {\n            return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);\n        }\n        function writeStartPendingSuspenseBoundary(destination, responseState, id) {\n            writeChunk(destination, startPendingSuspenseBoundary1);\n            if (id === null) {\n                throw new Error(\"An ID must have been assigned before we can complete the boundary.\");\n            }\n            writeChunk(destination, id);\n            return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);\n        }\n        function writeStartClientRenderedSuspenseBoundary$1(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {\n            var result;\n            result = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);\n            writeChunk(destination, clientRenderedSuspenseBoundaryError1);\n            if (errorDigest) {\n                writeChunk(destination, clientRenderedSuspenseBoundaryError1A);\n                writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));\n                writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);\n            }\n            {\n                if (errorMesssage) {\n                    writeChunk(destination, clientRenderedSuspenseBoundaryError1B);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));\n                    writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);\n                }\n                if (errorComponentStack) {\n                    writeChunk(destination, clientRenderedSuspenseBoundaryError1C);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));\n                    writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);\n                }\n            }\n            result = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);\n            return result;\n        }\n        function writeEndCompletedSuspenseBoundary$1(destination, responseState) {\n            return writeChunkAndReturn(destination, endSuspenseBoundary);\n        }\n        function writeEndPendingSuspenseBoundary(destination, responseState) {\n            return writeChunkAndReturn(destination, endSuspenseBoundary);\n        }\n        function writeEndClientRenderedSuspenseBoundary$1(destination, responseState) {\n            return writeChunkAndReturn(destination, endSuspenseBoundary);\n        }\n        var startSegmentHTML = stringToPrecomputedChunk('<div hidden id=\"');\n        var startSegmentHTML2 = stringToPrecomputedChunk('\">');\n        var endSegmentHTML = stringToPrecomputedChunk(\"</div>\");\n        var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden=\"true\" style=\"display:none\" id=\"');\n        var startSegmentSVG2 = stringToPrecomputedChunk('\">');\n        var endSegmentSVG = stringToPrecomputedChunk(\"</svg>\");\n        var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden=\"true\" style=\"display:none\" id=\"');\n        var startSegmentMathML2 = stringToPrecomputedChunk('\">');\n        var endSegmentMathML = stringToPrecomputedChunk(\"</math>\");\n        var startSegmentTable = stringToPrecomputedChunk('<table hidden id=\"');\n        var startSegmentTable2 = stringToPrecomputedChunk('\">');\n        var endSegmentTable = stringToPrecomputedChunk(\"</table>\");\n        var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id=\"');\n        var startSegmentTableBody2 = stringToPrecomputedChunk('\">');\n        var endSegmentTableBody = stringToPrecomputedChunk(\"</tbody></table>\");\n        var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id=\"');\n        var startSegmentTableRow2 = stringToPrecomputedChunk('\">');\n        var endSegmentTableRow = stringToPrecomputedChunk(\"</tr></table>\");\n        var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id=\"');\n        var startSegmentColGroup2 = stringToPrecomputedChunk('\">');\n        var endSegmentColGroup = stringToPrecomputedChunk(\"</colgroup></table>\");\n        function writeStartSegment(destination, responseState, formatContext, id) {\n            switch(formatContext.insertionMode){\n                case ROOT_HTML_MODE:\n                case HTML_HTML_MODE:\n                case HTML_MODE:\n                    {\n                        writeChunk(destination, startSegmentHTML);\n                        writeChunk(destination, responseState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentHTML2);\n                    }\n                case SVG_MODE:\n                    {\n                        writeChunk(destination, startSegmentSVG);\n                        writeChunk(destination, responseState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentSVG2);\n                    }\n                case MATHML_MODE:\n                    {\n                        writeChunk(destination, startSegmentMathML);\n                        writeChunk(destination, responseState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentMathML2);\n                    }\n                case HTML_TABLE_MODE:\n                    {\n                        writeChunk(destination, startSegmentTable);\n                        writeChunk(destination, responseState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentTable2);\n                    }\n                // TODO: For the rest of these, there will be extra wrapper nodes that never\n                // get deleted from the document. We need to delete the table too as part\n                // of the injected scripts. They are invisible though so it's not too terrible\n                // and it's kind of an edge case to suspend in a table. Totally supported though.\n                case HTML_TABLE_BODY_MODE:\n                    {\n                        writeChunk(destination, startSegmentTableBody);\n                        writeChunk(destination, responseState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentTableBody2);\n                    }\n                case HTML_TABLE_ROW_MODE:\n                    {\n                        writeChunk(destination, startSegmentTableRow);\n                        writeChunk(destination, responseState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentTableRow2);\n                    }\n                case HTML_COLGROUP_MODE:\n                    {\n                        writeChunk(destination, startSegmentColGroup);\n                        writeChunk(destination, responseState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentColGroup2);\n                    }\n                default:\n                    {\n                        throw new Error(\"Unknown insertion mode. This is a bug in React.\");\n                    }\n            }\n        }\n        function writeEndSegment(destination, formatContext) {\n            switch(formatContext.insertionMode){\n                case ROOT_HTML_MODE:\n                case HTML_HTML_MODE:\n                case HTML_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentHTML);\n                    }\n                case SVG_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentSVG);\n                    }\n                case MATHML_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentMathML);\n                    }\n                case HTML_TABLE_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentTable);\n                    }\n                case HTML_TABLE_BODY_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentTableBody);\n                    }\n                case HTML_TABLE_ROW_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentTableRow);\n                    }\n                case HTML_COLGROUP_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentColGroup);\n                    }\n                default:\n                    {\n                        throw new Error(\"Unknown insertion mode. This is a bug in React.\");\n                    }\n            }\n        }\n        var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegment + ';$RS(\"');\n        var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS(\"');\n        var completeSegmentScript2 = stringToPrecomputedChunk('\",\"');\n        var completeSegmentScriptEnd = stringToPrecomputedChunk('\")</script>');\n        var completeSegmentData1 = stringToPrecomputedChunk('<template data-rsi=\"\" data-sid=\"');\n        var completeSegmentData2 = stringToPrecomputedChunk('\" data-pid=\"');\n        var completeSegmentDataEnd = dataElementQuotedEnd;\n        function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {\n            var scriptFormat = responseState.streamingFormat === ScriptStreamingFormat;\n            if (scriptFormat) {\n                writeChunk(destination, responseState.startInlineScript);\n                if ((responseState.instructions & SentCompleteSegmentFunction) === NothingSent) {\n                    // The first time we write this, we'll need to include the full implementation.\n                    responseState.instructions |= SentCompleteSegmentFunction;\n                    writeChunk(destination, completeSegmentScript1Full);\n                } else {\n                    // Future calls can just reuse the same function.\n                    writeChunk(destination, completeSegmentScript1Partial);\n                }\n            } else {\n                writeChunk(destination, completeSegmentData1);\n            } // Write function arguments, which are string literals\n            writeChunk(destination, responseState.segmentPrefix);\n            var formattedID = stringToChunk(contentSegmentID.toString(16));\n            writeChunk(destination, formattedID);\n            if (scriptFormat) {\n                writeChunk(destination, completeSegmentScript2);\n            } else {\n                writeChunk(destination, completeSegmentData2);\n            }\n            writeChunk(destination, responseState.placeholderPrefix);\n            writeChunk(destination, formattedID);\n            if (scriptFormat) {\n                return writeChunkAndReturn(destination, completeSegmentScriptEnd);\n            } else {\n                return writeChunkAndReturn(destination, completeSegmentDataEnd);\n            }\n        }\n        var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundary + '$RC(\"');\n        var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC(\"');\n        var completeBoundaryWithStylesScript1FullBoth = stringToPrecomputedChunk(completeBoundary + completeBoundaryWithStyles + '$RR(\"');\n        var completeBoundaryWithStylesScript1FullPartial = stringToPrecomputedChunk(completeBoundaryWithStyles + '$RR(\"');\n        var completeBoundaryWithStylesScript1Partial = stringToPrecomputedChunk('$RR(\"');\n        var completeBoundaryScript2 = stringToPrecomputedChunk('\",\"');\n        var completeBoundaryScript3a = stringToPrecomputedChunk('\",');\n        var completeBoundaryScript3b = stringToPrecomputedChunk('\"');\n        var completeBoundaryScriptEnd = stringToPrecomputedChunk(\")</script>\");\n        var completeBoundaryData1 = stringToPrecomputedChunk('<template data-rci=\"\" data-bid=\"');\n        var completeBoundaryWithStylesData1 = stringToPrecomputedChunk('<template data-rri=\"\" data-bid=\"');\n        var completeBoundaryData2 = stringToPrecomputedChunk('\" data-sid=\"');\n        var completeBoundaryData3a = stringToPrecomputedChunk('\" data-sty=\"');\n        var completeBoundaryDataEnd = dataElementQuotedEnd;\n        function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID, boundaryResources) {\n            var requiresStyleInsertion;\n            {\n                requiresStyleInsertion = responseState.stylesToHoist; // If necessary stylesheets will be flushed with this instruction.\n                // Any style tags not yet hoisted in the Document will also be hoisted.\n                // We reset this state since after this instruction executes all styles\n                // up to this point will have been hoisted\n                responseState.stylesToHoist = false;\n            }\n            var scriptFormat = responseState.streamingFormat === ScriptStreamingFormat;\n            if (scriptFormat) {\n                writeChunk(destination, responseState.startInlineScript);\n                if (requiresStyleInsertion) {\n                    if ((responseState.instructions & SentCompleteBoundaryFunction) === NothingSent) {\n                        responseState.instructions |= SentStyleInsertionFunction | SentCompleteBoundaryFunction;\n                        writeChunk(destination, clonePrecomputedChunk(completeBoundaryWithStylesScript1FullBoth));\n                    } else if ((responseState.instructions & SentStyleInsertionFunction) === NothingSent) {\n                        responseState.instructions |= SentStyleInsertionFunction;\n                        writeChunk(destination, completeBoundaryWithStylesScript1FullPartial);\n                    } else {\n                        writeChunk(destination, completeBoundaryWithStylesScript1Partial);\n                    }\n                } else {\n                    if ((responseState.instructions & SentCompleteBoundaryFunction) === NothingSent) {\n                        responseState.instructions |= SentCompleteBoundaryFunction;\n                        writeChunk(destination, completeBoundaryScript1Full);\n                    } else {\n                        writeChunk(destination, completeBoundaryScript1Partial);\n                    }\n                }\n            } else {\n                if (requiresStyleInsertion) {\n                    writeChunk(destination, completeBoundaryWithStylesData1);\n                } else {\n                    writeChunk(destination, completeBoundaryData1);\n                }\n            }\n            if (boundaryID === null) {\n                throw new Error(\"An ID must have been assigned before we can complete the boundary.\");\n            } // Write function arguments, which are string and array literals\n            var formattedContentID = stringToChunk(contentSegmentID.toString(16));\n            writeChunk(destination, boundaryID);\n            if (scriptFormat) {\n                writeChunk(destination, completeBoundaryScript2);\n            } else {\n                writeChunk(destination, completeBoundaryData2);\n            }\n            writeChunk(destination, responseState.segmentPrefix);\n            writeChunk(destination, formattedContentID);\n            if (requiresStyleInsertion) {\n                // Script and data writers must format this differently:\n                //  - script writer emits an array literal, whose string elements are\n                //    escaped for javascript  e.g. [\"A\", \"B\"]\n                //  - data writer emits a string literal, which is escaped as html\n                //    e.g. [&#34;A&#34;, &#34;B&#34;]\n                if (scriptFormat) {\n                    writeChunk(destination, completeBoundaryScript3a); // boundaryResources encodes an array literal\n                    writeStyleResourceDependenciesInJS(destination, boundaryResources);\n                } else {\n                    writeChunk(destination, completeBoundaryData3a);\n                    writeStyleResourceDependenciesInAttr(destination, boundaryResources);\n                }\n            } else {\n                if (scriptFormat) {\n                    writeChunk(destination, completeBoundaryScript3b);\n                }\n            }\n            var writeMore;\n            if (scriptFormat) {\n                writeMore = writeChunkAndReturn(destination, completeBoundaryScriptEnd);\n            } else {\n                writeMore = writeChunkAndReturn(destination, completeBoundaryDataEnd);\n            }\n            return writeBootstrap(destination, responseState) && writeMore;\n        }\n        var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderBoundary + ';$RX(\"');\n        var clientRenderScript1Partial = stringToPrecomputedChunk('$RX(\"');\n        var clientRenderScript1A = stringToPrecomputedChunk('\"');\n        var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(\",\");\n        var clientRenderScriptEnd = stringToPrecomputedChunk(\")</script>\");\n        var clientRenderData1 = stringToPrecomputedChunk('<template data-rxi=\"\" data-bid=\"');\n        var clientRenderData2 = stringToPrecomputedChunk('\" data-dgst=\"');\n        var clientRenderData3 = stringToPrecomputedChunk('\" data-msg=\"');\n        var clientRenderData4 = stringToPrecomputedChunk('\" data-stck=\"');\n        var clientRenderDataEnd = dataElementQuotedEnd;\n        function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {\n            var scriptFormat = responseState.streamingFormat === ScriptStreamingFormat;\n            if (scriptFormat) {\n                writeChunk(destination, responseState.startInlineScript);\n                if ((responseState.instructions & SentClientRenderFunction) === NothingSent) {\n                    // The first time we write this, we'll need to include the full implementation.\n                    responseState.instructions |= SentClientRenderFunction;\n                    writeChunk(destination, clientRenderScript1Full);\n                } else {\n                    // Future calls can just reuse the same function.\n                    writeChunk(destination, clientRenderScript1Partial);\n                }\n            } else {\n                // <template data-rxi=\"\" data-bid=\"\n                writeChunk(destination, clientRenderData1);\n            }\n            if (boundaryID === null) {\n                throw new Error(\"An ID must have been assigned before we can complete the boundary.\");\n            }\n            writeChunk(destination, boundaryID);\n            if (scriptFormat) {\n                // \" needs to be inserted for scripts, since ArgInterstitual does not contain\n                // leading or trailing quotes\n                writeChunk(destination, clientRenderScript1A);\n            }\n            if (errorDigest || errorMessage || errorComponentStack) {\n                if (scriptFormat) {\n                    // ,\"JSONString\"\n                    writeChunk(destination, clientRenderErrorScriptArgInterstitial);\n                    writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || \"\")));\n                } else {\n                    // \" data-dgst=\"HTMLString\n                    writeChunk(destination, clientRenderData2);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest || \"\")));\n                }\n            }\n            if (errorMessage || errorComponentStack) {\n                if (scriptFormat) {\n                    // ,\"JSONString\"\n                    writeChunk(destination, clientRenderErrorScriptArgInterstitial);\n                    writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || \"\")));\n                } else {\n                    // \" data-msg=\"HTMLString\n                    writeChunk(destination, clientRenderData3);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMessage || \"\")));\n                }\n            }\n            if (errorComponentStack) {\n                // ,\"JSONString\"\n                if (scriptFormat) {\n                    writeChunk(destination, clientRenderErrorScriptArgInterstitial);\n                    writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));\n                } else {\n                    // \" data-stck=\"HTMLString\n                    writeChunk(destination, clientRenderData4);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));\n                }\n            }\n            if (scriptFormat) {\n                // ></script>\n                return writeChunkAndReturn(destination, clientRenderScriptEnd);\n            } else {\n                // \"></template>\n                return writeChunkAndReturn(destination, clientRenderDataEnd);\n            }\n        }\n        var regexForJSStringsInInstructionScripts = /[<\\u2028\\u2029]/g;\n        function escapeJSStringsForInstructionScripts(input) {\n            var escaped = JSON.stringify(input);\n            return escaped.replace(regexForJSStringsInInstructionScripts, function(match) {\n                switch(match){\n                    // santizing breaking out of strings and script tags\n                    case \"<\":\n                        return \"\\\\u003c\";\n                    case \"\\u2028\":\n                        return \"\\\\u2028\";\n                    case \"\\u2029\":\n                        return \"\\\\u2029\";\n                    default:\n                        {\n                            // eslint-disable-next-line react-internal/prod-error-codes\n                            throw new Error(\"escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\");\n                        }\n                }\n            });\n        }\n        var regexForJSStringsInScripts = /[&><\\u2028\\u2029]/g;\n        function escapeJSObjectForInstructionScripts(input) {\n            var escaped = JSON.stringify(input);\n            return escaped.replace(regexForJSStringsInScripts, function(match) {\n                switch(match){\n                    // santizing breaking out of strings and script tags\n                    case \"&\":\n                        return \"\\\\u0026\";\n                    case \">\":\n                        return \"\\\\u003e\";\n                    case \"<\":\n                        return \"\\\\u003c\";\n                    case \"\\u2028\":\n                        return \"\\\\u2028\";\n                    case \"\\u2029\":\n                        return \"\\\\u2029\";\n                    default:\n                        {\n                            // eslint-disable-next-line react-internal/prod-error-codes\n                            throw new Error(\"escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\");\n                        }\n                }\n            });\n        }\n        var lateStyleTagResourceOpen1 = stringToPrecomputedChunk('<style media=\"not all\" data-precedence=\"');\n        var lateStyleTagResourceOpen2 = stringToPrecomputedChunk('\" data-href=\"');\n        var lateStyleTagResourceOpen3 = stringToPrecomputedChunk('\">');\n        var lateStyleTagTemplateClose = stringToPrecomputedChunk(\"</style>\"); // Tracks whether the boundary currently flushing is flushign style tags or has any\n        // stylesheet dependencies not flushed in the Preamble.\n        var currentlyRenderingBoundaryHasStylesToHoist = false; // Acts as a return value for the forEach execution of style tag flushing.\n        var destinationHasCapacity = true;\n        function flushStyleTagsLateForBoundary(resource) {\n            if (resource.type === \"stylesheet\" && (resource.state & FlushedInPreamble) === NoState) {\n                currentlyRenderingBoundaryHasStylesToHoist = true;\n            } else if (resource.type === \"style\") {\n                var chunks = resource.chunks;\n                var hrefs = resource.props.hrefs;\n                var i = 0;\n                if (chunks.length) {\n                    writeChunk(this, lateStyleTagResourceOpen1);\n                    writeChunk(this, stringToChunk(escapeTextForBrowser(resource.props.precedence)));\n                    if (hrefs.length) {\n                        writeChunk(this, lateStyleTagResourceOpen2);\n                        for(; i < hrefs.length - 1; i++){\n                            writeChunk(this, stringToChunk(escapeTextForBrowser(hrefs[i])));\n                            writeChunk(this, spaceSeparator);\n                        }\n                        writeChunk(this, stringToChunk(escapeTextForBrowser(hrefs[i])));\n                    }\n                    writeChunk(this, lateStyleTagResourceOpen3);\n                    for(i = 0; i < chunks.length; i++){\n                        writeChunk(this, chunks[i]);\n                    }\n                    destinationHasCapacity = writeChunkAndReturn(this, lateStyleTagTemplateClose); // We wrote style tags for this boundary and we may need to emit a script\n                    // to hoist them.\n                    currentlyRenderingBoundaryHasStylesToHoist = true; // style resources can flush continuously since more rules may be written into\n                    // them with new hrefs. Instead of marking it flushed, we simply reset the chunks\n                    // and hrefs\n                    chunks.length = 0;\n                    hrefs.length = 0;\n                }\n            }\n        }\n        function writeResourcesForBoundary(destination, boundaryResources, responseState) {\n            // Reset these on each invocation, they are only safe to read in this function\n            currentlyRenderingBoundaryHasStylesToHoist = false;\n            destinationHasCapacity = true; // Flush each Boundary resource\n            boundaryResources.forEach(flushStyleTagsLateForBoundary, destination);\n            if (currentlyRenderingBoundaryHasStylesToHoist) {\n                responseState.stylesToHoist = true;\n            }\n            return destinationHasCapacity;\n        }\n        function flushResourceInPreamble(resource) {\n            if ((resource.state & (Flushed | Blocked)) === NoState) {\n                var chunks = resource.chunks;\n                for(var i = 0; i < chunks.length; i++){\n                    writeChunk(this, chunks[i]);\n                }\n                resource.state |= FlushedInPreamble;\n            }\n        }\n        function flushResourceLate(resource) {\n            if ((resource.state & (Flushed | Blocked)) === NoState) {\n                var chunks = resource.chunks;\n                for(var i = 0; i < chunks.length; i++){\n                    writeChunk(this, chunks[i]);\n                }\n                resource.state |= FlushedLate;\n            }\n        } // This must always be read after flushing stylesheet styles. we know we will encounter a style resource\n        // per precedence and it will be set before ready so we cast this to avoid an extra check at runtime\n        var precedenceStyleTagResource = null; // This flags let's us opt out of flushing a placeholder style tag to emit the precedence in the right order.\n        // If a stylesheet was flushed then we have the precedence order preserved and only need to emit <style> tags\n        // if there are actual chunks to flush\n        var didFlushPrecedence = false;\n        function flushStyleInPreamble(resource, key, set) {\n            var chunks = resource.chunks;\n            if (resource.state & Flushed) {\n                // In theory this should never happen because we clear from the\n                // Set on flush but to ensure correct semantics we don't emit\n                // anything if we are in this state.\n                set.delete(resource);\n            } else {\n                // We can emit this style or stylesheet as is.\n                if (resource.type === \"style\") {\n                    precedenceStyleTagResource = resource;\n                    return;\n                } // We still need to encode stylesheet chunks\n                // because unlike most Hoistables and Resources we do not eagerly encode\n                // them during render. This is because if we flush late we have to send a\n                // different encoding and we don't want to encode multiple times\n                pushLinkImpl(chunks, resource.props);\n                for(var i = 0; i < chunks.length; i++){\n                    writeChunk(this, chunks[i]);\n                }\n                resource.state |= FlushedInPreamble;\n                didFlushPrecedence = true;\n            }\n        }\n        var styleTagResourceOpen1 = stringToPrecomputedChunk('<style data-precedence=\"');\n        var styleTagResourceOpen2 = stringToPrecomputedChunk('\" data-href=\"');\n        var spaceSeparator = stringToPrecomputedChunk(\" \");\n        var styleTagResourceOpen3 = stringToPrecomputedChunk('\">');\n        var styleTagResourceClose = stringToPrecomputedChunk(\"</style>\");\n        function flushAllStylesInPreamble(set, precedence) {\n            didFlushPrecedence = false;\n            set.forEach(flushStyleInPreamble, this);\n            set.clear();\n            var chunks = precedenceStyleTagResource.chunks;\n            var hrefs = precedenceStyleTagResource.props.hrefs;\n            if (didFlushPrecedence === false || chunks.length) {\n                writeChunk(this, styleTagResourceOpen1);\n                writeChunk(this, stringToChunk(escapeTextForBrowser(precedence)));\n                var i = 0;\n                if (hrefs.length) {\n                    writeChunk(this, styleTagResourceOpen2);\n                    for(; i < hrefs.length - 1; i++){\n                        writeChunk(this, stringToChunk(escapeTextForBrowser(hrefs[i])));\n                        writeChunk(this, spaceSeparator);\n                    }\n                    writeChunk(this, stringToChunk(escapeTextForBrowser(hrefs[i])));\n                }\n                writeChunk(this, styleTagResourceOpen3);\n                for(i = 0; i < chunks.length; i++){\n                    writeChunk(this, chunks[i]);\n                }\n                writeChunk(this, styleTagResourceClose); // style resources can flush continuously since more rules may be written into\n                // them with new hrefs. Instead of marking it flushed, we simply reset the chunks\n                // and hrefs\n                chunks.length = 0;\n                hrefs.length = 0;\n            }\n        }\n        function preloadLateStyle(resource) {\n            if (resource.state & PreloadFlushed) {\n                // This resource has already had a preload flushed\n                return;\n            }\n            if (resource.type === \"style\") {\n                // <style> tags do not need to be preloaded\n                return;\n            }\n            var chunks = resource.chunks;\n            var preloadProps = preloadAsStylePropsFromProps(resource.props.href, resource.props);\n            pushLinkImpl(chunks, preloadProps);\n            for(var i = 0; i < chunks.length; i++){\n                writeChunk(this, chunks[i]);\n            }\n            resource.state |= PreloadFlushed;\n            chunks.length = 0;\n        }\n        function preloadLateStyles(set, precedence) {\n            set.forEach(preloadLateStyle, this);\n            set.clear();\n        } // We don't bother reporting backpressure at the moment because we expect to\n        // flush the entire preamble in a single pass. This probably should be modified\n        // in the future to be backpressure sensitive but that requires a larger refactor\n        // of the flushing code in Fizz.\n        function writePreamble(destination, resources, responseState, willFlushAllSegments) {\n            // This function must be called exactly once on every request\n            if (!willFlushAllSegments && responseState.externalRuntimeScript) {\n                // If the root segment is incomplete due to suspended tasks\n                // (e.g. willFlushAllSegments = false) and we are using data\n                // streaming format, ensure the external runtime is sent.\n                // (User code could choose to send this even earlier by calling\n                //  preinit(...), if they know they will suspend).\n                var _responseState$extern = responseState.externalRuntimeScript, src = _responseState$extern.src, chunks = _responseState$extern.chunks;\n                internalPreinitScript(resources, src, chunks);\n            }\n            var htmlChunks = responseState.htmlChunks;\n            var headChunks = responseState.headChunks;\n            var i = 0; // Emit open tags before Hoistables and Resources\n            if (htmlChunks) {\n                // We have an <html> to emit as part of the preamble\n                for(i = 0; i < htmlChunks.length; i++){\n                    writeChunk(destination, htmlChunks[i]);\n                }\n                if (headChunks) {\n                    for(i = 0; i < headChunks.length; i++){\n                        writeChunk(destination, headChunks[i]);\n                    }\n                } else {\n                    // We did not render a head but we emitted an <html> so we emit one now\n                    writeChunk(destination, startChunkForTag(\"head\"));\n                    writeChunk(destination, endOfStartTag);\n                }\n            } else if (headChunks) {\n                // We do not have an <html> but we do have a <head>\n                for(i = 0; i < headChunks.length; i++){\n                    writeChunk(destination, headChunks[i]);\n                }\n            } // Emit high priority Hoistables\n            var charsetChunks = responseState.charsetChunks;\n            for(i = 0; i < charsetChunks.length; i++){\n                writeChunk(destination, charsetChunks[i]);\n            }\n            charsetChunks.length = 0; // emit preconnect resources\n            resources.preconnects.forEach(flushResourceInPreamble, destination);\n            resources.preconnects.clear();\n            var preconnectChunks = responseState.preconnectChunks;\n            for(i = 0; i < preconnectChunks.length; i++){\n                writeChunk(destination, preconnectChunks[i]);\n            }\n            preconnectChunks.length = 0;\n            resources.fontPreloads.forEach(flushResourceInPreamble, destination);\n            resources.fontPreloads.clear();\n            resources.highImagePreloads.forEach(flushResourceInPreamble, destination);\n            resources.highImagePreloads.clear(); // Flush unblocked stylesheets by precedence\n            resources.precedences.forEach(flushAllStylesInPreamble, destination);\n            resources.bootstrapScripts.forEach(flushResourceInPreamble, destination);\n            resources.scripts.forEach(flushResourceInPreamble, destination);\n            resources.scripts.clear();\n            resources.bulkPreloads.forEach(flushResourceInPreamble, destination);\n            resources.bulkPreloads.clear(); // Write embedding preloadChunks\n            var preloadChunks = responseState.preloadChunks;\n            for(i = 0; i < preloadChunks.length; i++){\n                writeChunk(destination, preloadChunks[i]);\n            }\n            preloadChunks.length = 0; // Write embedding hoistableChunks\n            var hoistableChunks = responseState.hoistableChunks;\n            for(i = 0; i < hoistableChunks.length; i++){\n                writeChunk(destination, hoistableChunks[i]);\n            }\n            hoistableChunks.length = 0; // Flush closing head if necessary\n            if (htmlChunks && headChunks === null) {\n                // We have an <html> rendered but no <head> rendered. We however inserted\n                // a <head> up above so we need to emit the </head> now. This is safe because\n                // if the main content contained the </head> it would also have provided a\n                // <head>. This means that all the content inside <html> is either <body> or\n                // invalid HTML\n                writeChunk(destination, endTag1);\n                writeChunk(destination, stringToChunk(\"head\"));\n                writeChunk(destination, endTag2);\n            }\n        } // We don't bother reporting backpressure at the moment because we expect to\n        // flush the entire preamble in a single pass. This probably should be modified\n        // in the future to be backpressure sensitive but that requires a larger refactor\n        // of the flushing code in Fizz.\n        function writeHoistables(destination, resources, responseState) {\n            var i = 0; // Emit high priority Hoistables\n            // We omit charsetChunks because we have already sent the shell and if it wasn't\n            // already sent it is too late now.\n            resources.preconnects.forEach(flushResourceLate, destination);\n            resources.preconnects.clear();\n            var preconnectChunks = responseState.preconnectChunks;\n            for(i = 0; i < preconnectChunks.length; i++){\n                writeChunk(destination, preconnectChunks[i]);\n            }\n            preconnectChunks.length = 0;\n            resources.fontPreloads.forEach(flushResourceLate, destination);\n            resources.fontPreloads.clear();\n            resources.highImagePreloads.forEach(flushResourceInPreamble, destination);\n            resources.highImagePreloads.clear(); // Preload any stylesheets. these will emit in a render instruction that follows this\n            // but we want to kick off preloading as soon as possible\n            resources.precedences.forEach(preloadLateStyles, destination); // bootstrap scripts should flush above script priority but these can only flush in the preamble\n            // so we elide the code here for performance\n            resources.scripts.forEach(flushResourceLate, destination);\n            resources.scripts.clear();\n            resources.bulkPreloads.forEach(flushResourceLate, destination);\n            resources.bulkPreloads.clear(); // Write embedding preloadChunks\n            var preloadChunks = responseState.preloadChunks;\n            for(i = 0; i < preloadChunks.length; i++){\n                writeChunk(destination, preloadChunks[i]);\n            }\n            preloadChunks.length = 0; // Write embedding hoistableChunks\n            var hoistableChunks = responseState.hoistableChunks;\n            for(i = 0; i < hoistableChunks.length; i++){\n                writeChunk(destination, hoistableChunks[i]);\n            }\n            hoistableChunks.length = 0;\n        }\n        function writePostamble(destination, responseState) {\n            if (responseState.hasBody) {\n                writeChunk(destination, endTag1);\n                writeChunk(destination, stringToChunk(\"body\"));\n                writeChunk(destination, endTag2);\n            }\n            if (responseState.htmlChunks) {\n                writeChunk(destination, endTag1);\n                writeChunk(destination, stringToChunk(\"html\"));\n                writeChunk(destination, endTag2);\n            }\n        }\n        var arrayFirstOpenBracket = stringToPrecomputedChunk(\"[\");\n        var arraySubsequentOpenBracket = stringToPrecomputedChunk(\",[\");\n        var arrayInterstitial = stringToPrecomputedChunk(\",\");\n        var arrayCloseBracket = stringToPrecomputedChunk(\"]\"); // This function writes a 2D array of strings to be embedded in javascript.\n        // E.g.\n        //  [[\"JS_escaped_string1\", \"JS_escaped_string2\"]]\n        function writeStyleResourceDependenciesInJS(destination, boundaryResources) {\n            writeChunk(destination, arrayFirstOpenBracket);\n            var nextArrayOpenBrackChunk = arrayFirstOpenBracket;\n            boundaryResources.forEach(function(resource) {\n                if (resource.type === \"style\") ;\n                else if (resource.state & FlushedInPreamble) ;\n                else if (resource.state & Flushed) {\n                    // We only need to emit the href because this resource flushed in an earlier\n                    // boundary already which encoded the attributes necessary to construct\n                    // the resource instance on the client.\n                    writeChunk(destination, nextArrayOpenBrackChunk);\n                    writeStyleResourceDependencyHrefOnlyInJS(destination, resource.props.href);\n                    writeChunk(destination, arrayCloseBracket);\n                    nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n                } else if (resource.type === \"stylesheet\") {\n                    // We need to emit the whole resource for insertion on the client\n                    writeChunk(destination, nextArrayOpenBrackChunk);\n                    writeStyleResourceDependencyInJS(destination, resource.props.href, resource.props[\"data-precedence\"], resource.props);\n                    writeChunk(destination, arrayCloseBracket);\n                    nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n                    resource.state |= FlushedLate;\n                }\n            });\n            writeChunk(destination, arrayCloseBracket);\n        }\n        /* Helper functions */ function writeStyleResourceDependencyHrefOnlyInJS(destination, href) {\n            // We should actually enforce this earlier when the resource is created but for\n            // now we make sure we are actually dealing with a string here.\n            {\n                checkAttributeStringCoercion(href, \"href\");\n            }\n            var coercedHref = \"\" + href;\n            writeChunk(destination, stringToChunk(escapeJSObjectForInstructionScripts(coercedHref)));\n        }\n        function writeStyleResourceDependencyInJS(destination, href, precedence, props) {\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            var coercedHref = sanitizeURL(\"\" + href);\n            writeChunk(destination, stringToChunk(escapeJSObjectForInstructionScripts(coercedHref)));\n            {\n                checkAttributeStringCoercion(precedence, \"precedence\");\n            }\n            var coercedPrecedence = \"\" + precedence;\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeJSObjectForInstructionScripts(coercedPrecedence)));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"href\":\n                        case \"rel\":\n                        case \"precedence\":\n                        case \"data-precedence\":\n                            {\n                                break;\n                            }\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"link\" + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        default:\n                            writeStyleResourceAttributeInJS(destination, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            return null;\n        }\n        function writeStyleResourceAttributeInJS(destination, name, value) {\n            var attributeName = name.toLowerCase();\n            var attributeValue;\n            switch(typeof value){\n                case \"function\":\n                case \"symbol\":\n                    return;\n            }\n            switch(name){\n                // Reserved names\n                case \"innerHTML\":\n                case \"dangerouslySetInnerHTML\":\n                case \"suppressContentEditableWarning\":\n                case \"suppressHydrationWarning\":\n                case \"style\":\n                    // Ignored\n                    return;\n                // Attribute renames\n                case \"className\":\n                    {\n                        attributeName = \"class\";\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                        break;\n                    }\n                // Booleans\n                case \"hidden\":\n                    {\n                        if (value === false) {\n                            return;\n                        }\n                        attributeValue = \"\";\n                        break;\n                    }\n                // Santized URLs\n                case \"src\":\n                case \"href\":\n                    {\n                        value = sanitizeURL(value);\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                        break;\n                    }\n                default:\n                    {\n                        if (// use on* as hueristic for these handler props\n                        name.length > 2 && (name[0] === \"o\" || name[0] === \"O\") && (name[1] === \"n\" || name[1] === \"N\")) {\n                            return;\n                        }\n                        if (!isAttributeNameSafe(name)) {\n                            return;\n                        }\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                    }\n            }\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeJSObjectForInstructionScripts(attributeName)));\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeJSObjectForInstructionScripts(attributeValue)));\n        } // This function writes a 2D array of strings to be embedded in an attribute\n        // value and read with JSON.parse in ReactDOMServerExternalRuntime.js\n        // E.g.\n        //  [[&quot;JSON_escaped_string1&quot;, &quot;JSON_escaped_string2&quot;]]\n        function writeStyleResourceDependenciesInAttr(destination, boundaryResources) {\n            writeChunk(destination, arrayFirstOpenBracket);\n            var nextArrayOpenBrackChunk = arrayFirstOpenBracket;\n            boundaryResources.forEach(function(resource) {\n                if (resource.type === \"style\") ;\n                else if (resource.state & FlushedInPreamble) ;\n                else if (resource.state & Flushed) {\n                    // We only need to emit the href because this resource flushed in an earlier\n                    // boundary already which encoded the attributes necessary to construct\n                    // the resource instance on the client.\n                    writeChunk(destination, nextArrayOpenBrackChunk);\n                    writeStyleResourceDependencyHrefOnlyInAttr(destination, resource.props.href);\n                    writeChunk(destination, arrayCloseBracket);\n                    nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n                } else if (resource.type === \"stylesheet\") {\n                    // We need to emit the whole resource for insertion on the client\n                    writeChunk(destination, nextArrayOpenBrackChunk);\n                    writeStyleResourceDependencyInAttr(destination, resource.props.href, resource.props[\"data-precedence\"], resource.props);\n                    writeChunk(destination, arrayCloseBracket);\n                    nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n                    resource.state |= FlushedLate;\n                }\n            });\n            writeChunk(destination, arrayCloseBracket);\n        }\n        /* Helper functions */ function writeStyleResourceDependencyHrefOnlyInAttr(destination, href) {\n            // We should actually enforce this earlier when the resource is created but for\n            // now we make sure we are actually dealing with a string here.\n            {\n                checkAttributeStringCoercion(href, \"href\");\n            }\n            var coercedHref = \"\" + href;\n            writeChunk(destination, stringToChunk(escapeTextForBrowser(JSON.stringify(coercedHref))));\n        }\n        function writeStyleResourceDependencyInAttr(destination, href, precedence, props) {\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            var coercedHref = sanitizeURL(\"\" + href);\n            writeChunk(destination, stringToChunk(escapeTextForBrowser(JSON.stringify(coercedHref))));\n            {\n                checkAttributeStringCoercion(precedence, \"precedence\");\n            }\n            var coercedPrecedence = \"\" + precedence;\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeTextForBrowser(JSON.stringify(coercedPrecedence))));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"href\":\n                        case \"rel\":\n                        case \"precedence\":\n                        case \"data-precedence\":\n                            {\n                                break;\n                            }\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"link\" + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        default:\n                            writeStyleResourceAttributeInAttr(destination, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            return null;\n        }\n        function writeStyleResourceAttributeInAttr(destination, name, value) {\n            var attributeName = name.toLowerCase();\n            var attributeValue;\n            switch(typeof value){\n                case \"function\":\n                case \"symbol\":\n                    return;\n            }\n            switch(name){\n                // Reserved names\n                case \"innerHTML\":\n                case \"dangerouslySetInnerHTML\":\n                case \"suppressContentEditableWarning\":\n                case \"suppressHydrationWarning\":\n                case \"style\":\n                    // Ignored\n                    return;\n                // Attribute renames\n                case \"className\":\n                    {\n                        attributeName = \"class\";\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                        break;\n                    }\n                // Booleans\n                case \"hidden\":\n                    {\n                        if (value === false) {\n                            return;\n                        }\n                        attributeValue = \"\";\n                        break;\n                    }\n                // Santized URLs\n                case \"src\":\n                case \"href\":\n                    {\n                        value = sanitizeURL(value);\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                        break;\n                    }\n                default:\n                    {\n                        if (// use on* as hueristic for these handler props\n                        name.length > 2 && (name[0] === \"o\" || name[0] === \"O\") && (name[1] === \"n\" || name[1] === \"N\")) {\n                            return;\n                        }\n                        if (!isAttributeNameSafe(name)) {\n                            return;\n                        }\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                    }\n            }\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeTextForBrowser(JSON.stringify(attributeName))));\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeTextForBrowser(JSON.stringify(attributeValue))));\n        }\n        /**\n * Resources\n */ var NoState = 0; // These tags indicate whether the Resource was flushed and in which phase\n        var FlushedInPreamble = 1;\n        var FlushedLate = 2;\n        var Flushed = 3; // This tag indicates whether this Resource is blocked from flushing.\n        // This currently is only used with stylesheets that are blocked by a Boundary\n        var Blocked = 4; // This tag indicates whether this Resource has been preloaded.\n        // This generally only makes sense for Resources other than PreloadResource\n        var PreloadFlushed = 8; // Dev extensions.\n        // Stylesheets and Scripts rendered with jsx\n        // Preloads, Stylesheets, and Scripts from ReactDOM.preload or ReactDOM.preinit\n        // Preloads created for normal components we rendered but know we can preload early such as\n        // sync Scripts and stylesheets without precedence or with onLoad/onError handlers\n        // @TODO add bootstrap script to implicit preloads\n        function createResources() {\n            return {\n                // persistent\n                preloadsMap: new Map(),\n                preconnectsMap: new Map(),\n                stylesMap: new Map(),\n                scriptsMap: new Map(),\n                // cleared on flush\n                preconnects: new Set(),\n                fontPreloads: new Set(),\n                highImagePreloads: new Set(),\n                // usedImagePreloads: new Set(),\n                precedences: new Map(),\n                stylePrecedences: new Map(),\n                bootstrapScripts: new Set(),\n                scripts: new Set(),\n                bulkPreloads: new Set(),\n                // like a module global for currently rendering boundary\n                boundaryResources: null\n            };\n        }\n        function createBoundaryResources() {\n            return new Set();\n        }\n        function setCurrentlyRenderingBoundaryResourcesTarget(resources, boundaryResources) {\n            resources.boundaryResources = boundaryResources;\n        }\n        function getResourceKey(as, href) {\n            return \"[\" + as + \"]\" + href;\n        }\n        function prefetchDNS(href, options) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resources = getResources(request);\n            {\n                if (typeof href !== \"string\" || !href) {\n                    error(\"ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.\", getValueDescriptorExpectingObjectForWarning(href));\n                } else if (options != null) {\n                    if (typeof options === \"object\" && options.hasOwnProperty(\"crossOrigin\")) {\n                        error(\"ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.\", getValueDescriptorExpectingEnumForWarning(options));\n                    } else {\n                        error(\"ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.\", getValueDescriptorExpectingEnumForWarning(options));\n                    }\n                }\n            }\n            if (typeof href === \"string\" && href) {\n                var key = getResourceKey(\"prefetchDNS\", href);\n                var resource = resources.preconnectsMap.get(key);\n                if (!resource) {\n                    resource = {\n                        type: \"preconnect\",\n                        chunks: [],\n                        state: NoState,\n                        props: null\n                    };\n                    resources.preconnectsMap.set(key, resource);\n                    pushLinkImpl(resource.chunks, {\n                        href: href,\n                        rel: \"dns-prefetch\"\n                    });\n                }\n                resources.preconnects.add(resource);\n                flushResources(request);\n            }\n        }\n        function preconnect(href, options) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resources = getResources(request);\n            {\n                if (typeof href !== \"string\" || !href) {\n                    error(\"ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.\", getValueDescriptorExpectingObjectForWarning(href));\n                } else if (options != null && typeof options !== \"object\") {\n                    error(\"ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.\", getValueDescriptorExpectingEnumForWarning(options));\n                } else if (options != null && typeof options.crossOrigin !== \"string\") {\n                    error(\"ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.\", getValueDescriptorExpectingObjectForWarning(options.crossOrigin));\n                }\n            }\n            if (typeof href === \"string\" && href) {\n                var crossOrigin = options == null || typeof options.crossOrigin !== \"string\" ? null : options.crossOrigin === \"use-credentials\" ? \"use-credentials\" : \"\";\n                var key = \"[preconnect][\" + (crossOrigin === null ? \"null\" : crossOrigin) + \"]\" + href;\n                var resource = resources.preconnectsMap.get(key);\n                if (!resource) {\n                    resource = {\n                        type: \"preconnect\",\n                        chunks: [],\n                        state: NoState,\n                        props: null\n                    };\n                    resources.preconnectsMap.set(key, resource);\n                    pushLinkImpl(resource.chunks, {\n                        rel: \"preconnect\",\n                        href: href,\n                        crossOrigin: crossOrigin\n                    });\n                }\n                resources.preconnects.add(resource);\n                flushResources(request);\n            }\n        }\n        function preload(href, options) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resources = getResources(request);\n            {\n                var encountered = \"\";\n                if (typeof href !== \"string\" || !href) {\n                    encountered += \" The `href` argument encountered was \" + getValueDescriptorExpectingObjectForWarning(href) + \".\";\n                }\n                if (options == null || typeof options !== \"object\") {\n                    encountered += \" The `options` argument encountered was \" + getValueDescriptorExpectingObjectForWarning(options) + \".\";\n                } else if (typeof options.as !== \"string\" || !options.as) {\n                    encountered += \" The `as` option encountered was \" + getValueDescriptorExpectingObjectForWarning(options.as) + \".\";\n                }\n                if (encountered) {\n                    error('ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel=\"preload\" as=\"...\" />` tag.%s', encountered);\n                }\n            }\n            if (typeof href === \"string\" && href && typeof options === \"object\" && options !== null && typeof options.as === \"string\" && options.as) {\n                var as = options.as;\n                var key;\n                if (as === \"image\") {\n                    // For image preloads the key contains either the imageSrcSet + imageSizes or the href but not\n                    // both. This is to prevent identical calls with the same srcSet and sizes to be duplicated\n                    // by varying the href. this is an edge case but it is the most correct behavior.\n                    var imageSrcSet = options.imageSrcSet, imageSizes = options.imageSizes;\n                    key = getImagePreloadKey(href, imageSrcSet, imageSizes);\n                } else {\n                    key = getResourceKey(as, href);\n                }\n                var resource = resources.preloadsMap.get(key);\n                {\n                    var devResource = getAsResourceDEV(resource);\n                    if (devResource) {\n                        switch(devResource.__provenance){\n                            case \"preload\":\n                                {\n                                    var differenceDescription = describeDifferencesForPreloads(options, devResource.__originalOptions);\n                                    if (differenceDescription) {\n                                        error('ReactDOM.preload(): The options provided conflict with another call to `ReactDOM.preload(\"%s\", { as: \"%s\", ...})`.' + \" React will always use the options it first encounters when preloading a resource for a given `href` and `as` type, and any later options will be ignored if different.\" + \" Try updating all calls to `ReactDOM.preload()` with the same `href` and `as` type to use the same options, or eliminate one of the calls.%s\", href, as, differenceDescription);\n                                    }\n                                    break;\n                                }\n                            case \"implicit\":\n                                {\n                                    var _differenceDescription3 = describeDifferencesForPreloadOverImplicitPreload(options, devResource.__impliedProps);\n                                    if (_differenceDescription3) {\n                                        var elementDescription = as === \"style\" ? '<link rel=\"stylesheet\" ... />' : as === \"script\" ? \"<script ... />\" : null;\n                                        if (elementDescription) {\n                                            error('ReactDOM.preload(): For `href` \"%s\", The options provided conflict with props on a matching %s element. When the preload' + \" options disagree with the underlying resource it usually means the browser will not be able to use the preload when the resource\" + \" is fetched, negating any benefit the preload would provide. React will preload the resource using props derived from the resource instead\" + \" and ignore the options provided to the `ReactDOM.preload()` call. In general, preloading is useful when you expect to\" + \" render a resource soon but have not yet done so. In this case since the underlying resource was already rendered the preload call\" + \" may be extraneous. Try removing the call, otherwise try adjusting both the props on the %s and the options\" + \" passed to `ReactDOM.preload()` to agree.%s\", href, elementDescription, elementDescription, _differenceDescription3);\n                                        }\n                                    }\n                                    break;\n                                }\n                        }\n                    }\n                }\n                if (!resource) {\n                    resource = {\n                        type: \"preload\",\n                        chunks: [],\n                        state: NoState,\n                        props: preloadPropsFromPreloadOptions(href, as, options)\n                    };\n                    resources.preloadsMap.set(key, resource);\n                    {\n                        markAsImperativeResourceDEV(resource, \"preload\", href, options, resource.props);\n                    }\n                    pushLinkImpl(resource.chunks, resource.props);\n                }\n                if (as === \"font\") {\n                    resources.fontPreloads.add(resource);\n                } else if (as === \"image\" && options.fetchPriority === \"high\") {\n                    resources.highImagePreloads.add(resource);\n                } else {\n                    resources.bulkPreloads.add(resource);\n                }\n                flushResources(request);\n            }\n        }\n        function preinit(href, options) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resources = getResources(request);\n            {\n                if (typeof href !== \"string\" || !href) {\n                    error(\"ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.\", getValueDescriptorExpectingObjectForWarning(href));\n                } else if (options == null || typeof options !== \"object\") {\n                    error(\"ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.\", getValueDescriptorExpectingEnumForWarning(options));\n                } else if (options.as !== \"style\" && options.as !== \"script\") {\n                    error('ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are \"style\" and \"script\".', getValueDescriptorExpectingEnumForWarning(options.as));\n                }\n            }\n            if (typeof href === \"string\" && href && typeof options === \"object\" && options !== null) {\n                var as = options.as;\n                switch(as){\n                    case \"style\":\n                        {\n                            var key = getResourceKey(as, href);\n                            var resource = resources.stylesMap.get(key);\n                            var precedence = options.precedence || \"default\";\n                            {\n                                var devResource = getAsResourceDEV(resource);\n                                if (devResource) {\n                                    var resourceProps = stylesheetPropsFromPreinitOptions(href, precedence, options);\n                                    var propsEquivalent = assign({}, resourceProps, _defineProperty({\n                                        precedence: options.precedence\n                                    }, \"data-precedence\", null));\n                                    switch(devResource.__provenance){\n                                        case \"rendered\":\n                                            {\n                                                var differenceDescription = describeDifferencesForPreinitOverStylesheet(propsEquivalent, devResource.__originalProps);\n                                                if (differenceDescription) {\n                                                    error('ReactDOM.preinit(): For `href` \"%s\", the options provided conflict with props found on a <link rel=\"stylesheet\" precedence=\"%s\" href=\"%s\" .../> that was already rendered.' + \" React will always use the props or options it first encounters for a hoistable stylesheet for a given `href` and any later props or options will be ignored if different.\" + \" Generally, ReactDOM.preinit() is useful when you are not yet rendering a stylesheet but you anticipate it will be used soon.\" + \" In this case the stylesheet was already rendered so preinitializing it does not provide any additional benefit.\" + ' To resolve, try making the props and options agree between the <link rel=\"stylesheet\" .../> and the `ReactDOM.preinit()` call or' + \" remove the `ReactDOM.preinit()` call.%s\", href, devResource.__originalProps.precedence, href, differenceDescription);\n                                                }\n                                                break;\n                                            }\n                                        case \"preinit\":\n                                            {\n                                                var _differenceDescription4 = describeDifferencesForPreinits(propsEquivalent, devResource.__propsEquivalent);\n                                                if (_differenceDescription4) {\n                                                    error('ReactDOM.preinit(): For `href` \"%s\", the options provided conflict with another call to `ReactDOM.preinit(\"%s\", { as: \"style\", ... })`.' + \" React will always use the options it first encounters when preinitializing a hoistable stylesheet for a given `href` and any later options will be ignored if different.\" + \" Try updating all calls to `ReactDOM.preinit()` for a given `href` to use the same options, or only call `ReactDOM.preinit()` once per `href`.%s\", href, href, _differenceDescription4);\n                                                }\n                                                break;\n                                            }\n                                    }\n                                }\n                            }\n                            if (!resource) {\n                                var state = NoState;\n                                var preloadResource = resources.preloadsMap.get(key);\n                                if (preloadResource && preloadResource.state & Flushed) {\n                                    state = PreloadFlushed;\n                                }\n                                resource = {\n                                    type: \"stylesheet\",\n                                    chunks: [],\n                                    state: state,\n                                    props: stylesheetPropsFromPreinitOptions(href, precedence, options)\n                                };\n                                resources.stylesMap.set(key, resource);\n                                {\n                                    markAsImperativeResourceDEV(resource, \"preinit\", href, options, assign({}, resource.props, _defineProperty({\n                                        precedence: precedence\n                                    }, \"data-precedence\", undefined)));\n                                }\n                                var precedenceSet = resources.precedences.get(precedence);\n                                if (!precedenceSet) {\n                                    precedenceSet = new Set();\n                                    resources.precedences.set(precedence, precedenceSet);\n                                    var emptyStyleResource = {\n                                        type: \"style\",\n                                        chunks: [],\n                                        state: NoState,\n                                        props: {\n                                            precedence: precedence,\n                                            hrefs: []\n                                        }\n                                    };\n                                    precedenceSet.add(emptyStyleResource);\n                                    {\n                                        if (resources.stylePrecedences.has(precedence)) {\n                                            error('React constructed an empty style resource when a style resource already exists for this precedence: \"%s\". This is a bug in React.', precedence);\n                                        }\n                                    }\n                                    resources.stylePrecedences.set(precedence, emptyStyleResource);\n                                }\n                                precedenceSet.add(resource);\n                                flushResources(request);\n                            }\n                            return;\n                        }\n                    case \"script\":\n                        {\n                            var src = href;\n                            var _key = getResourceKey(as, src);\n                            var _resource = resources.scriptsMap.get(_key);\n                            {\n                                var _devResource = getAsResourceDEV(_resource);\n                                if (_devResource) {\n                                    var _propsEquivalent = scriptPropsFromPreinitOptions(src, options);\n                                    switch(_devResource.__provenance){\n                                        case \"rendered\":\n                                            {\n                                                var _differenceDescription5 = describeDifferencesForPreinitOverScript(_propsEquivalent, _devResource.__originalProps);\n                                                if (_differenceDescription5) {\n                                                    error('ReactDOM.preinit(): For `href` \"%s\", the options provided conflict with props found on a <script async={true} src=\"%s\" .../> that was already rendered.' + \" React will always use the props or options it first encounters for a hoistable script for a given `href` and any later props or options will be ignored if different.\" + \" Generally, ReactDOM.preinit() is useful when you are not yet rendering a script but you anticipate it will be used soon and want to go beyond preloading it and have it\" + \" execute early. In this case the script was already rendered so preinitializing it does not provide any additional benefit.\" + \" To resolve, try making the props and options agree between the <script .../> and the `ReactDOM.preinit()` call or remove the `ReactDOM.preinit()` call.%s\", href, href, _differenceDescription5);\n                                                }\n                                                break;\n                                            }\n                                        case \"preinit\":\n                                            {\n                                                var _differenceDescription6 = describeDifferencesForPreinits(_propsEquivalent, _devResource.__propsEquivalent);\n                                                if (_differenceDescription6) {\n                                                    error('ReactDOM.preinit(): For `href` \"%s\", the options provided conflict with another call to `ReactDOM.preinit(\"%s\", { as: \"script\", ... })`.' + \" React will always use the options it first encounters when preinitializing a hoistable script for a given `href` and any later options will be ignored if different.\" + \" Try updating all calls to `ReactDOM.preinit()` for a given `href` to use the same options, or only call `ReactDOM.preinit()` once per `href`.%s\", href, href, _differenceDescription6);\n                                                }\n                                                break;\n                                            }\n                                    }\n                                }\n                            }\n                            if (!_resource) {\n                                _resource = {\n                                    type: \"script\",\n                                    chunks: [],\n                                    state: NoState,\n                                    props: null\n                                };\n                                resources.scriptsMap.set(_key, _resource);\n                                var _resourceProps = scriptPropsFromPreinitOptions(src, options);\n                                {\n                                    markAsImperativeResourceDEV(_resource, \"preinit\", href, options, _resourceProps);\n                                }\n                                resources.scripts.add(_resource);\n                                pushScriptImpl(_resource.chunks, _resourceProps);\n                                flushResources(request);\n                            }\n                            return;\n                        }\n                }\n            }\n        } // This function is only safe to call at Request start time since it assumes\n        // that each script has not already been preloaded. If we find a need to preload\n        // scripts at any other point in time we will need to check whether the preload\n        // already exists and not assume it\n        function preloadBootstrapScript(resources, src, nonce, integrity, crossOrigin) {\n            var key = getResourceKey(\"script\", src);\n            {\n                if (resources.preloadsMap.has(key)) {\n                    // This is coded as a React error because it should be impossible for a userspace preload to preempt this call\n                    // If a userspace preload can preempt it then this assumption is broken and we need to reconsider this strategy\n                    // rather than instruct the user to not preload their bootstrap scripts themselves\n                    error('Internal React Error: React expected bootstrap script with src \"%s\" to not have been preloaded already. please file an issue', src);\n                }\n            }\n            var props = {\n                rel: \"preload\",\n                href: src,\n                as: \"script\",\n                fetchPriority: \"low\",\n                nonce: nonce,\n                integrity: integrity,\n                crossOrigin: crossOrigin\n            };\n            var resource = {\n                type: \"preload\",\n                chunks: [],\n                state: NoState,\n                props: props\n            };\n            resources.preloadsMap.set(key, resource);\n            resources.bootstrapScripts.add(resource);\n            pushLinkImpl(resource.chunks, props);\n        } // This function is only safe to call at Request start time since it assumes\n        // that each module has not already been preloaded. If we find a need to preload\n        // scripts at any other point in time we will need to check whether the preload\n        // already exists and not assume it\n        function preloadBootstrapModule(resources, src, nonce, integrity, crossOrigin) {\n            var key = getResourceKey(\"script\", src);\n            {\n                if (resources.preloadsMap.has(key)) {\n                    // This is coded as a React error because it should be impossible for a userspace preload to preempt this call\n                    // If a userspace preload can preempt it then this assumption is broken and we need to reconsider this strategy\n                    // rather than instruct the user to not preload their bootstrap scripts themselves\n                    error('Internal React Error: React expected bootstrap module with src \"%s\" to not have been preloaded already. please file an issue', src);\n                }\n            }\n            var props = {\n                rel: \"modulepreload\",\n                href: src,\n                fetchPriority: \"low\",\n                nonce: nonce,\n                integrity: integrity,\n                crossOrigin: crossOrigin\n            };\n            var resource = {\n                type: \"preload\",\n                chunks: [],\n                state: NoState,\n                props: props\n            };\n            resources.preloadsMap.set(key, resource);\n            resources.bootstrapScripts.add(resource);\n            pushLinkImpl(resource.chunks, props);\n            return;\n        }\n        function internalPreinitScript(resources, src, chunks) {\n            var key = getResourceKey(\"script\", src);\n            var resource = resources.scriptsMap.get(key);\n            if (!resource) {\n                resource = {\n                    type: \"script\",\n                    chunks: chunks,\n                    state: NoState,\n                    props: null\n                };\n                resources.scriptsMap.set(key, resource);\n                resources.scripts.add(resource);\n            }\n            return;\n        }\n        function preloadPropsFromPreloadOptions(href, as, options) {\n            return {\n                rel: \"preload\",\n                as: as,\n                // There is a bug in Safari where imageSrcSet is not respected on preload links\n                // so we omit the href here if we have imageSrcSet b/c safari will load the wrong image.\n                // This harms older browers that do not support imageSrcSet by making their preloads not work\n                // but this population is shrinking fast and is already small so we accept this tradeoff.\n                href: as === \"image\" && options.imageSrcSet ? undefined : href,\n                crossOrigin: as === \"font\" ? \"\" : options.crossOrigin,\n                integrity: options.integrity,\n                type: options.type,\n                nonce: options.nonce,\n                fetchPriority: options.fetchPriority,\n                imageSrcSet: options.imageSrcSet,\n                imageSizes: options.imageSizes,\n                referrerPolicy: options.referrerPolicy\n            };\n        }\n        function preloadAsStylePropsFromProps(href, props) {\n            return {\n                rel: \"preload\",\n                as: \"style\",\n                href: href,\n                crossOrigin: props.crossOrigin,\n                fetchPriority: props.fetchPriority,\n                integrity: props.integrity,\n                media: props.media,\n                hrefLang: props.hrefLang,\n                referrerPolicy: props.referrerPolicy\n            };\n        }\n        function stylesheetPropsFromPreinitOptions(href, precedence, options) {\n            return {\n                rel: \"stylesheet\",\n                href: href,\n                \"data-precedence\": precedence,\n                crossOrigin: options.crossOrigin,\n                integrity: options.integrity,\n                fetchPriority: options.fetchPriority\n            };\n        }\n        function stylesheetPropsFromRawProps(rawProps) {\n            return assign({}, rawProps, {\n                \"data-precedence\": rawProps.precedence,\n                precedence: null\n            });\n        }\n        function adoptPreloadPropsForStylesheetProps(resourceProps, preloadProps) {\n            if (resourceProps.crossOrigin == null) resourceProps.crossOrigin = preloadProps.crossOrigin;\n            if (resourceProps.integrity == null) resourceProps.integrity = preloadProps.integrity;\n        }\n        function scriptPropsFromPreinitOptions(src, options) {\n            return {\n                src: src,\n                async: true,\n                crossOrigin: options.crossOrigin,\n                integrity: options.integrity,\n                nonce: options.nonce,\n                fetchPriority: options.fetchPriority\n            };\n        }\n        function adoptPreloadPropsForScriptProps(resourceProps, preloadProps) {\n            if (resourceProps.crossOrigin == null) resourceProps.crossOrigin = preloadProps.crossOrigin;\n            if (resourceProps.integrity == null) resourceProps.integrity = preloadProps.integrity;\n        }\n        function hoistStyleResource(resource) {\n            this.add(resource);\n        }\n        function hoistResources(resources, source) {\n            var currentBoundaryResources = resources.boundaryResources;\n            if (currentBoundaryResources) {\n                source.forEach(hoistStyleResource, currentBoundaryResources);\n            }\n        }\n        function markAsRenderedResourceDEV(resource, originalProps) {\n            {\n                var devResource = resource;\n                if (typeof devResource.__provenance === \"string\") {\n                    error(\"Resource already marked for DEV type. This is a bug in React.\");\n                }\n                devResource.__provenance = \"rendered\";\n                devResource.__originalProps = originalProps;\n            }\n        }\n        function markAsImperativeResourceDEV(resource, provenance, originalHref, originalOptions, propsEquivalent) {\n            {\n                var devResource = resource;\n                if (typeof devResource.__provenance === \"string\") {\n                    error(\"Resource already marked for DEV type. This is a bug in React.\");\n                }\n                devResource.__provenance = provenance;\n                devResource.__originalHref = originalHref;\n                devResource.__originalOptions = originalOptions;\n                devResource.__propsEquivalent = propsEquivalent;\n            }\n        }\n        function getAsResourceDEV(resource) {\n            {\n                if (resource) {\n                    if (typeof resource.__provenance === \"string\") {\n                        return resource;\n                    }\n                    error(\"Resource was not marked for DEV type. This is a bug in React.\");\n                }\n                return null;\n            }\n        }\n        function createResponseState(resources, generateStaticMarkup, identifierPrefix, externalRuntimeConfig) {\n            var responseState = createResponseState$1(resources, identifierPrefix, undefined, undefined, undefined, undefined, externalRuntimeConfig);\n            return {\n                // Keep this in sync with ReactFizzConfigDOM\n                bootstrapChunks: responseState.bootstrapChunks,\n                placeholderPrefix: responseState.placeholderPrefix,\n                segmentPrefix: responseState.segmentPrefix,\n                boundaryPrefix: responseState.boundaryPrefix,\n                idPrefix: responseState.idPrefix,\n                nextSuspenseID: responseState.nextSuspenseID,\n                streamingFormat: responseState.streamingFormat,\n                startInlineScript: responseState.startInlineScript,\n                instructions: responseState.instructions,\n                externalRuntimeScript: responseState.externalRuntimeScript,\n                htmlChunks: responseState.htmlChunks,\n                headChunks: responseState.headChunks,\n                hasBody: responseState.hasBody,\n                charsetChunks: responseState.charsetChunks,\n                preconnectChunks: responseState.preconnectChunks,\n                preloadChunks: responseState.preloadChunks,\n                hoistableChunks: responseState.hoistableChunks,\n                stylesToHoist: responseState.stylesToHoist,\n                // This is an extra field for the legacy renderer\n                generateStaticMarkup: generateStaticMarkup\n            };\n        }\n        function createRootFormatContext() {\n            return {\n                insertionMode: HTML_MODE,\n                // We skip the root mode because we don't want to emit the DOCTYPE in legacy mode.\n                selectedValue: null,\n                noscriptTagInScope: false\n            };\n        }\n        function pushTextInstance(target, text, responseState, textEmbedded) {\n            if (responseState.generateStaticMarkup) {\n                target.push(stringToChunk(escapeTextForBrowser(text)));\n                return false;\n            } else {\n                return pushTextInstance$1(target, text, responseState, textEmbedded);\n            }\n        }\n        function pushSegmentFinale(target, responseState, lastPushedText, textEmbedded) {\n            if (responseState.generateStaticMarkup) {\n                return;\n            } else {\n                return pushSegmentFinale$1(target, responseState, lastPushedText, textEmbedded);\n            }\n        }\n        function writeStartCompletedSuspenseBoundary(destination, responseState) {\n            if (responseState.generateStaticMarkup) {\n                // A completed boundary is done and doesn't need a representation in the HTML\n                // if we're not going to be hydrating it.\n                return true;\n            }\n            return writeStartCompletedSuspenseBoundary$1(destination);\n        }\n        function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMessage, errorComponentStack) {\n            if (responseState.generateStaticMarkup) {\n                // A client rendered boundary is done and doesn't need a representation in the HTML\n                // since we'll never hydrate it. This is arguably an error in static generation.\n                return true;\n            }\n            return writeStartClientRenderedSuspenseBoundary$1(destination, responseState, errorDigest, errorMessage, errorComponentStack);\n        }\n        function writeEndCompletedSuspenseBoundary(destination, responseState) {\n            if (responseState.generateStaticMarkup) {\n                return true;\n            }\n            return writeEndCompletedSuspenseBoundary$1(destination);\n        }\n        function writeEndClientRenderedSuspenseBoundary(destination, responseState) {\n            if (responseState.generateStaticMarkup) {\n                return true;\n            }\n            return writeEndClientRenderedSuspenseBoundary$1(destination);\n        }\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_SERVER_CONTEXT_TYPE = Symbol.for(\"react.server_context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_SCOPE_TYPE = Symbol.for(\"react.scope\");\n        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for(\"react.debug_trace_mode\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for(\"react.legacy_hidden\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for(\"react.default_value\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            {\n                if (typeof type.tag === \"number\") {\n                    error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                }\n            }\n            if (typeof type === \"function\") {\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                    case REACT_SERVER_CONTEXT_TYPE:\n                        {\n                            var context2 = type;\n                            return (context2.displayName || context2._globalName) + \".Provider\";\n                        }\n                }\n            }\n            return null;\n        }\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            var control;\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher$1.current = null;\n                disableLogs();\n            }\n            try {\n                // This should throw.\n                if (construct) {\n                    // Something should be setting the props in the constructor.\n                    var Fake = function() {\n                        throw Error();\n                    }; // $FlowFixMe[prop-missing]\n                    Object.defineProperty(Fake.prototype, \"props\", {\n                        set: function() {\n                            // We use a throwing setter instead of frozen or non-writable props\n                            // because that won't throw in a non-strict mode function.\n                            throw Error();\n                        }\n                    });\n                    if (typeof Reflect === \"object\" && Reflect.construct) {\n                        // We construct a different control for this case to include any extra\n                        // frames added by the construct call.\n                        try {\n                            Reflect.construct(Fake, []);\n                        } catch (x) {\n                            control = x;\n                        }\n                        Reflect.construct(fn, [], Fake);\n                    } else {\n                        try {\n                            Fake.call();\n                        } catch (x) {\n                            control = x;\n                        } // $FlowFixMe[prop-missing] found when upgrading Flow\n                        fn.call(Fake.prototype);\n                    }\n                } else {\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        control = x;\n                    } // TODO(luna): This will currently only throw if the function component\n                    // tries to access React/ReactDOM/props. We should probably make this throw\n                    // in simple components too\n                    var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                    // component, which we don't yet support. Attach a noop catch handler to\n                    // silence the error.\n                    // TODO: Implement component stacks for async client components?\n                    if (maybePromise && typeof maybePromise.catch === \"function\") {\n                        maybePromise.catch(function() {});\n                    }\n                }\n            } catch (sample) {\n                // This is inlined manually because closure doesn't do it for us.\n                if (sample && control && typeof sample.stack === \"string\") {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sample.stack.split(\"\\n\");\n                    var controlLines = control.stack.split(\"\\n\");\n                    var s = sampleLines.length - 1;\n                    var c = controlLines.length - 1;\n                    while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                        // We expect at least one stack frame to be shared.\n                        // Typically this will be the root most one. However, stack frames may be\n                        // cut off due to maximum stack limits. In this case, one maybe cut off\n                        // earlier than the other. We assume that the sample is longer or the same\n                        // and there for cut off earlier. So we should find the root most frame in\n                        // the sample somewhere in the control.\n                        c--;\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        }\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher$1.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeClassComponentFrame(ctor, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(ctor, true);\n            }\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct$1(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct$1(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement(null);\n                        }\n                    }\n                }\n            }\n        }\n        var warnedAboutMissingGetChildContext;\n        {\n            warnedAboutMissingGetChildContext = {};\n        }\n        var emptyContextObject = {};\n        {\n            Object.freeze(emptyContextObject);\n        }\n        function getMaskedContext(type, unmaskedContext) {\n            {\n                var contextTypes = type.contextTypes;\n                if (!contextTypes) {\n                    return emptyContextObject;\n                }\n                var context = {};\n                for(var key in contextTypes){\n                    context[key] = unmaskedContext[key];\n                }\n                {\n                    var name = getComponentNameFromType(type) || \"Unknown\";\n                    checkPropTypes(contextTypes, context, \"context\", name);\n                }\n                return context;\n            }\n        }\n        function processChildContext(instance, type, parentContext, childContextTypes) {\n            {\n                // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n                // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n                if (typeof instance.getChildContext !== \"function\") {\n                    {\n                        var componentName = getComponentNameFromType(type) || \"Unknown\";\n                        if (!warnedAboutMissingGetChildContext[componentName]) {\n                            warnedAboutMissingGetChildContext[componentName] = true;\n                            error(\"%s.childContextTypes is specified but there is no getChildContext() method \" + \"on the instance. You can either define getChildContext() on %s or remove \" + \"childContextTypes from it.\", componentName, componentName);\n                        }\n                    }\n                    return parentContext;\n                }\n                var childContext = instance.getChildContext();\n                for(var contextKey in childContext){\n                    if (!(contextKey in childContextTypes)) {\n                        throw new Error((getComponentNameFromType(type) || \"Unknown\") + '.getChildContext(): key \"' + contextKey + '\" is not defined in childContextTypes.');\n                    }\n                }\n                {\n                    var name = getComponentNameFromType(type) || \"Unknown\";\n                    checkPropTypes(childContextTypes, childContext, \"child context\", name);\n                }\n                return assign({}, parentContext, childContext);\n            }\n        }\n        var rendererSigil;\n        {\n            // Use this to detect multiple renderers using the same context\n            rendererSigil = {};\n        }\n        // Forming a reverse tree.\n        // The structure of a context snapshot is an implementation of this file.\n        // Currently, it's implemented as tracking the current active node.\n        var rootContextSnapshot = null; // We assume that this runtime owns the \"current\" field on all ReactContext instances.\n        // This global (actually thread local) state represents what state all those \"current\",\n        // fields are currently in.\n        var currentActiveSnapshot = null;\n        function popNode(prev) {\n            {\n                prev.context._currentValue2 = prev.parentValue;\n            }\n        }\n        function pushNode(next) {\n            {\n                next.context._currentValue2 = next.value;\n            }\n        }\n        function popToNearestCommonAncestor(prev, next) {\n            if (prev === next) ;\n            else {\n                popNode(prev);\n                var parentPrev = prev.parent;\n                var parentNext = next.parent;\n                if (parentPrev === null) {\n                    if (parentNext !== null) {\n                        throw new Error(\"The stacks must reach the root at the same time. This is a bug in React.\");\n                    }\n                } else {\n                    if (parentNext === null) {\n                        throw new Error(\"The stacks must reach the root at the same time. This is a bug in React.\");\n                    }\n                    popToNearestCommonAncestor(parentPrev, parentNext);\n                } // On the way back, we push the new ones that weren't common.\n                pushNode(next);\n            }\n        }\n        function popAllPrevious(prev) {\n            popNode(prev);\n            var parentPrev = prev.parent;\n            if (parentPrev !== null) {\n                popAllPrevious(parentPrev);\n            }\n        }\n        function pushAllNext(next) {\n            var parentNext = next.parent;\n            if (parentNext !== null) {\n                pushAllNext(parentNext);\n            }\n            pushNode(next);\n        }\n        function popPreviousToCommonLevel(prev, next) {\n            popNode(prev);\n            var parentPrev = prev.parent;\n            if (parentPrev === null) {\n                throw new Error(\"The depth must equal at least at zero before reaching the root. This is a bug in React.\");\n            }\n            if (parentPrev.depth === next.depth) {\n                // We found the same level. Now we just need to find a shared ancestor.\n                popToNearestCommonAncestor(parentPrev, next);\n            } else {\n                // We must still be deeper.\n                popPreviousToCommonLevel(parentPrev, next);\n            }\n        }\n        function popNextToCommonLevel(prev, next) {\n            var parentNext = next.parent;\n            if (parentNext === null) {\n                throw new Error(\"The depth must equal at least at zero before reaching the root. This is a bug in React.\");\n            }\n            if (prev.depth === parentNext.depth) {\n                // We found the same level. Now we just need to find a shared ancestor.\n                popToNearestCommonAncestor(prev, parentNext);\n            } else {\n                // We must still be deeper.\n                popNextToCommonLevel(prev, parentNext);\n            }\n            pushNode(next);\n        } // Perform context switching to the new snapshot.\n        // To make it cheap to read many contexts, while not suspending, we make the switch eagerly by\n        // updating all the context's current values. That way reads, always just read the current value.\n        // At the cost of updating contexts even if they're never read by this subtree.\n        function switchContext(newSnapshot) {\n            // The basic algorithm we need to do is to pop back any contexts that are no longer on the stack.\n            // We also need to update any new contexts that are now on the stack with the deepest value.\n            // The easiest way to update new contexts is to just reapply them in reverse order from the\n            // perspective of the backpointers. To avoid allocating a lot when switching, we use the stack\n            // for that. Therefore this algorithm is recursive.\n            // 1) First we pop which ever snapshot tree was deepest. Popping old contexts as we go.\n            // 2) Then we find the nearest common ancestor from there. Popping old contexts as we go.\n            // 3) Then we reapply new contexts on the way back up the stack.\n            var prev = currentActiveSnapshot;\n            var next = newSnapshot;\n            if (prev !== next) {\n                if (prev === null) {\n                    // $FlowFixMe[incompatible-call]: This has to be non-null since it's not equal to prev.\n                    pushAllNext(next);\n                } else if (next === null) {\n                    popAllPrevious(prev);\n                } else if (prev.depth === next.depth) {\n                    popToNearestCommonAncestor(prev, next);\n                } else if (prev.depth > next.depth) {\n                    popPreviousToCommonLevel(prev, next);\n                } else {\n                    popNextToCommonLevel(prev, next);\n                }\n                currentActiveSnapshot = next;\n            }\n        }\n        function pushProvider(context, nextValue) {\n            var prevValue;\n            {\n                prevValue = context._currentValue2;\n                context._currentValue2 = nextValue;\n                {\n                    if (context._currentRenderer2 !== undefined && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {\n                        error(\"Detected multiple renderers concurrently rendering the \" + \"same context provider. This is currently unsupported.\");\n                    }\n                    context._currentRenderer2 = rendererSigil;\n                }\n            }\n            var prevNode = currentActiveSnapshot;\n            var newNode = {\n                parent: prevNode,\n                depth: prevNode === null ? 0 : prevNode.depth + 1,\n                context: context,\n                parentValue: prevValue,\n                value: nextValue\n            };\n            currentActiveSnapshot = newNode;\n            return newNode;\n        }\n        function popProvider(context) {\n            var prevSnapshot = currentActiveSnapshot;\n            if (prevSnapshot === null) {\n                throw new Error(\"Tried to pop a Context at the root of the app. This is a bug in React.\");\n            }\n            {\n                if (prevSnapshot.context !== context) {\n                    error(\"The parent context is not the expected context. This is probably a bug in React.\");\n                }\n            }\n            {\n                var _value = prevSnapshot.parentValue;\n                if (_value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {\n                    prevSnapshot.context._currentValue2 = prevSnapshot.context._defaultValue;\n                } else {\n                    prevSnapshot.context._currentValue2 = _value;\n                }\n                {\n                    if (context._currentRenderer2 !== undefined && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {\n                        error(\"Detected multiple renderers concurrently rendering the \" + \"same context provider. This is currently unsupported.\");\n                    }\n                    context._currentRenderer2 = rendererSigil;\n                }\n            }\n            return currentActiveSnapshot = prevSnapshot.parent;\n        }\n        function getActiveContext() {\n            return currentActiveSnapshot;\n        }\n        function readContext$1(context) {\n            var value = context._currentValue2;\n            return value;\n        }\n        /**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */ function get(key) {\n            return key._reactInternals;\n        }\n        function set(key, value) {\n            key._reactInternals = value;\n        }\n        var didWarnAboutNoopUpdateForComponent = {};\n        var didWarnAboutDeprecatedWillMount = {};\n        var didWarnAboutUninitializedState;\n        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\n        var didWarnAboutLegacyLifecyclesAndDerivedState;\n        var didWarnAboutUndefinedDerivedState;\n        var didWarnAboutDirectlyAssigningPropsToState;\n        var didWarnAboutContextTypeAndContextTypes;\n        var didWarnAboutInvalidateContextType;\n        var didWarnOnInvalidCallback;\n        {\n            didWarnAboutUninitializedState = new Set();\n            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n            didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n            didWarnAboutDirectlyAssigningPropsToState = new Set();\n            didWarnAboutUndefinedDerivedState = new Set();\n            didWarnAboutContextTypeAndContextTypes = new Set();\n            didWarnAboutInvalidateContextType = new Set();\n            didWarnOnInvalidCallback = new Set();\n        }\n        function warnOnInvalidCallback(callback, callerName) {\n            {\n                if (callback === null || typeof callback === \"function\") {\n                    return;\n                }\n                var key = callerName + \"_\" + callback;\n                if (!didWarnOnInvalidCallback.has(key)) {\n                    didWarnOnInvalidCallback.add(key);\n                    error(\"%s(...): Expected the last optional `callback` argument to be a \" + \"function. Instead received: %s.\", callerName, callback);\n                }\n            }\n        }\n        function warnOnUndefinedDerivedState(type, partialState) {\n            {\n                if (partialState === undefined) {\n                    var componentName = getComponentNameFromType(type) || \"Component\";\n                    if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n                        didWarnAboutUndefinedDerivedState.add(componentName);\n                        error(\"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. \" + \"You have returned undefined.\", componentName);\n                    }\n                }\n            }\n        }\n        function warnNoop(publicInstance, callerName) {\n            {\n                var _constructor = publicInstance.constructor;\n                var componentName = _constructor && getComponentNameFromType(_constructor) || \"ReactClass\";\n                var warningKey = componentName + \".\" + callerName;\n                if (didWarnAboutNoopUpdateForComponent[warningKey]) {\n                    return;\n                }\n                error(\"%s(...): Can only update a mounting component. \" + \"This usually means you called %s() outside componentWillMount() on the server. \" + \"This is a no-op.\\n\\nPlease check the code for the %s component.\", callerName, callerName, componentName);\n                didWarnAboutNoopUpdateForComponent[warningKey] = true;\n            }\n        }\n        var classComponentUpdater = {\n            isMounted: function(inst) {\n                return false;\n            },\n            // $FlowFixMe[missing-local-annot]\n            enqueueSetState: function(inst, payload, callback) {\n                var internals = get(inst);\n                if (internals.queue === null) {\n                    warnNoop(inst, \"setState\");\n                } else {\n                    internals.queue.push(payload);\n                    {\n                        if (callback !== undefined && callback !== null) {\n                            warnOnInvalidCallback(callback, \"setState\");\n                        }\n                    }\n                }\n            },\n            enqueueReplaceState: function(inst, payload, callback) {\n                var internals = get(inst);\n                internals.replace = true;\n                internals.queue = [\n                    payload\n                ];\n                {\n                    if (callback !== undefined && callback !== null) {\n                        warnOnInvalidCallback(callback, \"setState\");\n                    }\n                }\n            },\n            // $FlowFixMe[missing-local-annot]\n            enqueueForceUpdate: function(inst, callback) {\n                var internals = get(inst);\n                if (internals.queue === null) {\n                    warnNoop(inst, \"forceUpdate\");\n                } else {\n                    {\n                        if (callback !== undefined && callback !== null) {\n                            warnOnInvalidCallback(callback, \"setState\");\n                        }\n                    }\n                }\n            }\n        };\n        function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {\n            var partialState = getDerivedStateFromProps(nextProps, prevState);\n            {\n                warnOnUndefinedDerivedState(ctor, partialState);\n            }\n            var newState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);\n            return newState;\n        }\n        function constructClassInstance(ctor, props, maskedLegacyContext) {\n            var context = emptyContextObject;\n            var contextType = ctor.contextType;\n            {\n                if (\"contextType\" in ctor) {\n                    var isValid = contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>\n                    if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n                        didWarnAboutInvalidateContextType.add(ctor);\n                        var addendum = \"\";\n                        if (contextType === undefined) {\n                            addendum = \" However, it is set to undefined. \" + \"This can be caused by a typo or by mixing up named and default imports. \" + \"This can also happen due to a circular dependency, so \" + \"try moving the createContext() call to a separate file.\";\n                        } else if (typeof contextType !== \"object\") {\n                            addendum = \" However, it is set to a \" + typeof contextType + \".\";\n                        } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {\n                            addendum = \" Did you accidentally pass the Context.Provider instead?\";\n                        } else if (contextType._context !== undefined) {\n                            // <Context.Consumer>\n                            addendum = \" Did you accidentally pass the Context.Consumer instead?\";\n                        } else {\n                            addendum = \" However, it is set to an object with keys {\" + Object.keys(contextType).join(\", \") + \"}.\";\n                        }\n                        error(\"%s defines an invalid contextType. \" + \"contextType should point to the Context object returned by React.createContext().%s\", getComponentNameFromType(ctor) || \"Component\", addendum);\n                    }\n                }\n            }\n            if (typeof contextType === \"object\" && contextType !== null) {\n                context = readContext$1(contextType);\n            } else {\n                context = maskedLegacyContext;\n            }\n            var instance = new ctor(props, context);\n            {\n                if (typeof ctor.getDerivedStateFromProps === \"function\" && (instance.state === null || instance.state === undefined)) {\n                    var componentName = getComponentNameFromType(ctor) || \"Component\";\n                    if (!didWarnAboutUninitializedState.has(componentName)) {\n                        didWarnAboutUninitializedState.add(componentName);\n                        error(\"`%s` uses `getDerivedStateFromProps` but its initial state is \" + \"%s. This is not recommended. Instead, define the initial state by \" + \"assigning an object to `this.state` in the constructor of `%s`. \" + \"This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\", componentName, instance.state === null ? \"null\" : \"undefined\", componentName);\n                    }\n                } // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n                // Warn about these lifecycles if they are present.\n                // Don't warn about react-lifecycles-compat polyfilled methods though.\n                if (typeof ctor.getDerivedStateFromProps === \"function\" || typeof instance.getSnapshotBeforeUpdate === \"function\") {\n                    var foundWillMountName = null;\n                    var foundWillReceivePropsName = null;\n                    var foundWillUpdateName = null;\n                    if (typeof instance.componentWillMount === \"function\" && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                        foundWillMountName = \"componentWillMount\";\n                    } else if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n                        foundWillMountName = \"UNSAFE_componentWillMount\";\n                    }\n                    if (typeof instance.componentWillReceiveProps === \"function\" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n                        foundWillReceivePropsName = \"componentWillReceiveProps\";\n                    } else if (typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n                        foundWillReceivePropsName = \"UNSAFE_componentWillReceiveProps\";\n                    }\n                    if (typeof instance.componentWillUpdate === \"function\" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n                        foundWillUpdateName = \"componentWillUpdate\";\n                    } else if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n                        foundWillUpdateName = \"UNSAFE_componentWillUpdate\";\n                    }\n                    if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n                        var _componentName = getComponentNameFromType(ctor) || \"Component\";\n                        var newApiName = typeof ctor.getDerivedStateFromProps === \"function\" ? \"getDerivedStateFromProps()\" : \"getSnapshotBeforeUpdate()\";\n                        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n                            didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n                            error(\"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n\" + \"%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n\" + \"The above lifecycles should be removed. Learn more about this warning here:\\n\" + \"https://reactjs.org/link/unsafe-component-lifecycles\", _componentName, newApiName, foundWillMountName !== null ? \"\\n  \" + foundWillMountName : \"\", foundWillReceivePropsName !== null ? \"\\n  \" + foundWillReceivePropsName : \"\", foundWillUpdateName !== null ? \"\\n  \" + foundWillUpdateName : \"\");\n                        }\n                    }\n                }\n            }\n            return instance;\n        }\n        function checkClassInstance(instance, ctor, newProps) {\n            {\n                var name = getComponentNameFromType(ctor) || \"Component\";\n                var renderPresent = instance.render;\n                if (!renderPresent) {\n                    if (ctor.prototype && typeof ctor.prototype.render === \"function\") {\n                        error(\"%s(...): No `render` method found on the returned component \" + \"instance: did you accidentally return an object from the constructor?\", name);\n                    } else {\n                        error(\"%s(...): No `render` method found on the returned component \" + \"instance: you may have forgotten to define `render`.\", name);\n                    }\n                }\n                if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {\n                    error(\"getInitialState was defined on %s, a plain JavaScript class. \" + \"This is only supported for classes created using React.createClass. \" + \"Did you mean to define a state property instead?\", name);\n                }\n                if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps was defined on %s, a plain JavaScript class. \" + \"This is only supported for classes created using React.createClass. \" + \"Use a static property to define defaultProps instead.\", name);\n                }\n                if (instance.propTypes) {\n                    error(\"propTypes was defined as an instance property on %s. Use a static \" + \"property to define propTypes instead.\", name);\n                }\n                if (instance.contextType) {\n                    error(\"contextType was defined as an instance property on %s. Use a static \" + \"property to define contextType instead.\", name);\n                }\n                {\n                    if (instance.contextTypes) {\n                        error(\"contextTypes was defined as an instance property on %s. Use a static \" + \"property to define contextTypes instead.\", name);\n                    }\n                    if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {\n                        didWarnAboutContextTypeAndContextTypes.add(ctor);\n                        error(\"%s declares both contextTypes and contextType static properties. \" + \"The legacy contextTypes property will be ignored.\", name);\n                    }\n                }\n                if (typeof instance.componentShouldUpdate === \"function\") {\n                    error(\"%s has a method called \" + \"componentShouldUpdate(). Did you mean shouldComponentUpdate()? \" + \"The name is phrased as a question because the function is \" + \"expected to return a value.\", name);\n                }\n                if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== \"undefined\") {\n                    error(\"%s has a method called shouldComponentUpdate(). \" + \"shouldComponentUpdate should not be used when extending React.PureComponent. \" + \"Please extend React.Component if shouldComponentUpdate is used.\", getComponentNameFromType(ctor) || \"A pure component\");\n                }\n                if (typeof instance.componentDidUnmount === \"function\") {\n                    error(\"%s has a method called \" + \"componentDidUnmount(). But there is no such lifecycle method. \" + \"Did you mean componentWillUnmount()?\", name);\n                }\n                if (typeof instance.componentDidReceiveProps === \"function\") {\n                    error(\"%s has a method called \" + \"componentDidReceiveProps(). But there is no such lifecycle method. \" + \"If you meant to update the state in response to changing props, \" + \"use componentWillReceiveProps(). If you meant to fetch data or \" + \"run side-effects or mutations after React has updated the UI, use componentDidUpdate().\", name);\n                }\n                if (typeof instance.componentWillRecieveProps === \"function\") {\n                    error(\"%s has a method called \" + \"componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\", name);\n                }\n                if (typeof instance.UNSAFE_componentWillRecieveProps === \"function\") {\n                    error(\"%s has a method called \" + \"UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\", name);\n                }\n                var hasMutatedProps = instance.props !== newProps;\n                if (instance.props !== undefined && hasMutatedProps) {\n                    error(\"%s(...): When calling super() in `%s`, make sure to pass \" + \"up the same props that your component's constructor was passed.\", name, name);\n                }\n                if (instance.defaultProps) {\n                    error(\"Setting defaultProps as an instance property on %s is not supported and will be ignored.\" + \" Instead, define defaultProps as a static property on %s.\", name, name);\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === \"function\" && typeof instance.componentDidUpdate !== \"function\" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {\n                    didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n                    error(\"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). \" + \"This component defines getSnapshotBeforeUpdate() only.\", getComponentNameFromType(ctor));\n                }\n                if (typeof instance.getDerivedStateFromProps === \"function\") {\n                    error(\"%s: getDerivedStateFromProps() is defined as an instance method \" + \"and will be ignored. Instead, declare it as a static method.\", name);\n                }\n                if (typeof instance.getDerivedStateFromError === \"function\") {\n                    error(\"%s: getDerivedStateFromError() is defined as an instance method \" + \"and will be ignored. Instead, declare it as a static method.\", name);\n                }\n                if (typeof ctor.getSnapshotBeforeUpdate === \"function\") {\n                    error(\"%s: getSnapshotBeforeUpdate() is defined as a static method \" + \"and will be ignored. Instead, declare it as an instance method.\", name);\n                }\n                var state = instance.state;\n                if (state && (typeof state !== \"object\" || isArray(state))) {\n                    error(\"%s.state: must be set to an object or null\", name);\n                }\n                if (typeof instance.getChildContext === \"function\" && typeof ctor.childContextTypes !== \"object\") {\n                    error(\"%s.getChildContext(): childContextTypes must be defined in order to \" + \"use getChildContext().\", name);\n                }\n            }\n        }\n        function callComponentWillMount(type, instance) {\n            var oldState = instance.state;\n            if (typeof instance.componentWillMount === \"function\") {\n                {\n                    if (instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                        var componentName = getComponentNameFromType(type) || \"Unknown\";\n                        if (!didWarnAboutDeprecatedWillMount[componentName]) {\n                            warn(\"componentWillMount has been renamed, and is not recommended for use. \" + \"See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n\" + \"* Move code from componentWillMount to componentDidMount (preferred in most cases) \" + \"or the constructor.\\n\" + \"\\nPlease update the following components: %s\", componentName);\n                            didWarnAboutDeprecatedWillMount[componentName] = true;\n                        }\n                    }\n                }\n                instance.componentWillMount();\n            }\n            if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n                instance.UNSAFE_componentWillMount();\n            }\n            if (oldState !== instance.state) {\n                {\n                    error(\"%s.componentWillMount(): Assigning directly to this.state is \" + \"deprecated (except inside a component's \" + \"constructor). Use setState instead.\", getComponentNameFromType(type) || \"Component\");\n                }\n                classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n            }\n        }\n        function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {\n            if (internalInstance.queue !== null && internalInstance.queue.length > 0) {\n                var oldQueue = internalInstance.queue;\n                var oldReplace = internalInstance.replace;\n                internalInstance.queue = null;\n                internalInstance.replace = false;\n                if (oldReplace && oldQueue.length === 1) {\n                    inst.state = oldQueue[0];\n                } else {\n                    var nextState = oldReplace ? oldQueue[0] : inst.state;\n                    var dontMutate = true;\n                    for(var i = oldReplace ? 1 : 0; i < oldQueue.length; i++){\n                        var partial = oldQueue[i];\n                        var partialState = typeof partial === \"function\" ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;\n                        if (partialState != null) {\n                            if (dontMutate) {\n                                dontMutate = false;\n                                nextState = assign({}, nextState, partialState);\n                            } else {\n                                assign(nextState, partialState);\n                            }\n                        }\n                    }\n                    inst.state = nextState;\n                }\n            } else {\n                internalInstance.queue = null;\n            }\n        } // Invokes the mount life-cycles on a previously never rendered instance.\n        function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {\n            {\n                checkClassInstance(instance, ctor, newProps);\n            }\n            var initialState = instance.state !== undefined ? instance.state : null;\n            instance.updater = classComponentUpdater;\n            instance.props = newProps;\n            instance.state = initialState; // We don't bother initializing the refs object on the server, since we're not going to resolve them anyway.\n            // The internal instance will be used to manage updates that happen during this mount.\n            var internalInstance = {\n                queue: [],\n                replace: false\n            };\n            set(instance, internalInstance);\n            var contextType = ctor.contextType;\n            if (typeof contextType === \"object\" && contextType !== null) {\n                instance.context = readContext$1(contextType);\n            } else {\n                instance.context = maskedLegacyContext;\n            }\n            {\n                if (instance.state === newProps) {\n                    var componentName = getComponentNameFromType(ctor) || \"Component\";\n                    if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n                        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n                        error(\"%s: It is not recommended to assign props directly to state \" + \"because updates to props won't be reflected in state. \" + \"In most cases, it is better to use props directly.\", componentName);\n                    }\n                }\n            }\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n            if (typeof getDerivedStateFromProps === \"function\") {\n                instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);\n            } // In order to support react-lifecycles-compat polyfilled components,\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\n            if (typeof ctor.getDerivedStateFromProps !== \"function\" && typeof instance.getSnapshotBeforeUpdate !== \"function\" && (typeof instance.UNSAFE_componentWillMount === \"function\" || typeof instance.componentWillMount === \"function\")) {\n                callComponentWillMount(ctor, instance); // If we had additional state updates during this life-cycle, let's\n                // process them now.\n                processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);\n            }\n        }\n        // Ids are base 32 strings whose binary representation corresponds to the\n        // position of a node in a tree.\n        // Every time the tree forks into multiple children, we add additional bits to\n        // the left of the sequence that represent the position of the child within the\n        // current level of children.\n        //\n        //      00101       00010001011010101\n        //      ╰─┬─╯       ╰───────┬───────╯\n        //   Fork 5 of 20       Parent id\n        //\n        // The leading 0s are important. In the above example, you only need 3 bits to\n        // represent slot 5. However, you need 5 bits to represent all the forks at\n        // the current level, so we must account for the empty bits at the end.\n        //\n        // For this same reason, slots are 1-indexed instead of 0-indexed. Otherwise,\n        // the zeroth id at a level would be indistinguishable from its parent.\n        //\n        // If a node has only one child, and does not materialize an id (i.e. does not\n        // contain a useId hook), then we don't need to allocate any space in the\n        // sequence. It's treated as a transparent indirection. For example, these two\n        // trees produce the same ids:\n        //\n        // <>                          <>\n        //   <Indirection>               <A />\n        //     <A />                     <B />\n        //   </Indirection>            </>\n        //   <B />\n        // </>\n        //\n        // However, we cannot skip any node that materializes an id. Otherwise, a parent\n        // id that does not fork would be indistinguishable from its child id. For\n        // example, this tree does not fork, but the parent and child must have\n        // different ids.\n        //\n        // <Parent>\n        //   <Child />\n        // </Parent>\n        //\n        // To handle this scenario, every time we materialize an id, we allocate a\n        // new level with a single slot. You can think of this as a fork with only one\n        // prong, or an array of children with length 1.\n        //\n        // It's possible for the size of the sequence to exceed 32 bits, the max\n        // size for bitwise operations. When this happens, we make more room by\n        // converting the right part of the id to a string and storing it in an overflow\n        // variable. We use a base 32 string representation, because 32 is the largest\n        // power of 2 that is supported by toString(). We want the base to be large so\n        // that the resulting ids are compact, and we want the base to be a power of 2\n        // because every log2(base) bits corresponds to a single character, i.e. every\n        // log2(32) = 5 bits. That means we can lop bits off the end 5 at a time without\n        // affecting the final result.\n        var emptyTreeContext = {\n            id: 1,\n            overflow: \"\"\n        };\n        function getTreeId(context) {\n            var overflow = context.overflow;\n            var idWithLeadingBit = context.id;\n            var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);\n            return id.toString(32) + overflow;\n        }\n        function pushTreeContext(baseContext, totalChildren, index) {\n            var baseIdWithLeadingBit = baseContext.id;\n            var baseOverflow = baseContext.overflow; // The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n            // of the id; we use it to account for leading 0s.\n            var baseLength = getBitLength(baseIdWithLeadingBit) - 1;\n            var baseId = baseIdWithLeadingBit & ~(1 << baseLength);\n            var slot = index + 1;\n            var length = getBitLength(totalChildren) + baseLength; // 30 is the max length we can store without overflowing, taking into\n            // consideration the leading 1 we use to mark the end of the sequence.\n            if (length > 30) {\n                // We overflowed the bitwise-safe range. Fall back to slower algorithm.\n                // This branch assumes the length of the base id is greater than 5; it won't\n                // work for smaller ids, because you need 5 bits per character.\n                //\n                // We encode the id in multiple steps: first the base id, then the\n                // remaining digits.\n                //\n                // Each 5 bit sequence corresponds to a single base 32 character. So for\n                // example, if the current id is 23 bits long, we can convert 20 of those\n                // bits into a string of 4 characters, with 3 bits left over.\n                //\n                // First calculate how many bits in the base id represent a complete\n                // sequence of characters.\n                var numberOfOverflowBits = baseLength - baseLength % 5; // Then create a bitmask that selects only those bits.\n                var newOverflowBits = (1 << numberOfOverflowBits) - 1; // Select the bits, and convert them to a base 32 string.\n                var newOverflow = (baseId & newOverflowBits).toString(32); // Now we can remove those bits from the base id.\n                var restOfBaseId = baseId >> numberOfOverflowBits;\n                var restOfBaseLength = baseLength - numberOfOverflowBits; // Finally, encode the rest of the bits using the normal algorithm. Because\n                // we made more room, this time it won't overflow.\n                var restOfLength = getBitLength(totalChildren) + restOfBaseLength;\n                var restOfNewBits = slot << restOfBaseLength;\n                var id = restOfNewBits | restOfBaseId;\n                var overflow = newOverflow + baseOverflow;\n                return {\n                    id: 1 << restOfLength | id,\n                    overflow: overflow\n                };\n            } else {\n                // Normal path\n                var newBits = slot << baseLength;\n                var _id = newBits | baseId;\n                var _overflow = baseOverflow;\n                return {\n                    id: 1 << length | _id,\n                    overflow: _overflow\n                };\n            }\n        }\n        function getBitLength(number) {\n            return 32 - clz32(number);\n        }\n        function getLeadingBit(id) {\n            return 1 << getBitLength(id) - 1;\n        } // TODO: Math.clz32 is supported in Node 12+. Maybe we can drop the fallback.\n        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros.\n        // Based on:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n        var log = Math.log;\n        var LN2 = Math.LN2;\n        function clz32Fallback(x) {\n            var asUint = x >>> 0;\n            if (asUint === 0) {\n                return 32;\n            }\n            return 31 - (log(asUint) / LN2 | 0) | 0;\n        }\n        // Corresponds to ReactFiberWakeable and ReactFlightWakeable modules. Generally,\n        // changes to one module should be reflected in the others.\n        // TODO: Rename this module and the corresponding Fiber one to \"Thenable\"\n        // instead of \"Wakeable\". Or some other more appropriate name.\n        // An error that is thrown (e.g. by `use`) to trigger Suspense. If we\n        // detect this is caught by userspace, we'll log a warning in development.\n        var SuspenseException = new Error(\"Suspense Exception: This is not a real error! It's an implementation \" + \"detail of `use` to interrupt the current render. You must either \" + \"rethrow it immediately, or move the `use` call outside of the \" + \"`try/catch` block. Capturing without rethrowing will lead to \" + \"unexpected behavior.\\n\\n\" + \"To handle async errors, wrap your component in an error boundary, or \" + \"call the promise's `.catch` method and pass the result to `use`\");\n        function createThenableState() {\n            // The ThenableState is created the first time a component suspends. If it\n            // suspends again, we'll reuse the same state.\n            return [];\n        }\n        function noop$2() {}\n        function trackUsedThenable(thenableState, thenable, index) {\n            var previous = thenableState[index];\n            if (previous === undefined) {\n                thenableState.push(thenable);\n            } else {\n                if (previous !== thenable) {\n                    // Reuse the previous thenable, and drop the new one. We can assume\n                    // they represent the same value, because components are idempotent.\n                    // Avoid an unhandled rejection errors for the Promises that we'll\n                    // intentionally ignore.\n                    thenable.then(noop$2, noop$2);\n                    thenable = previous;\n                }\n            } // We use an expando to track the status and result of a thenable so that we\n            // can synchronously unwrap the value. Think of this as an extension of the\n            // Promise API, or a custom interface that is a superset of Thenable.\n            //\n            // If the thenable doesn't have a status, set it to \"pending\" and attach\n            // a listener that will update its status and result when it resolves.\n            switch(thenable.status){\n                case \"fulfilled\":\n                    {\n                        var fulfilledValue = thenable.value;\n                        return fulfilledValue;\n                    }\n                case \"rejected\":\n                    {\n                        var rejectedError = thenable.reason;\n                        throw rejectedError;\n                    }\n                default:\n                    {\n                        if (typeof thenable.status === \"string\") ;\n                        else {\n                            var pendingThenable = thenable;\n                            pendingThenable.status = \"pending\";\n                            pendingThenable.then(function(fulfilledValue) {\n                                if (thenable.status === \"pending\") {\n                                    var fulfilledThenable = thenable;\n                                    fulfilledThenable.status = \"fulfilled\";\n                                    fulfilledThenable.value = fulfilledValue;\n                                }\n                            }, function(error) {\n                                if (thenable.status === \"pending\") {\n                                    var rejectedThenable = thenable;\n                                    rejectedThenable.status = \"rejected\";\n                                    rejectedThenable.reason = error;\n                                }\n                            }); // Check one more time in case the thenable resolved synchronously\n                            switch(thenable.status){\n                                case \"fulfilled\":\n                                    {\n                                        var fulfilledThenable = thenable;\n                                        return fulfilledThenable.value;\n                                    }\n                                case \"rejected\":\n                                    {\n                                        var rejectedThenable = thenable;\n                                        throw rejectedThenable.reason;\n                                    }\n                            }\n                        } // Suspend.\n                        //\n                        // Throwing here is an implementation detail that allows us to unwind the\n                        // call stack. But we shouldn't allow it to leak into userspace. Throw an\n                        // opaque placeholder value instead of the actual thenable. If it doesn't\n                        // get captured by the work loop, log a warning, because that means\n                        // something in userspace must have caught it.\n                        suspendedThenable = thenable;\n                        throw SuspenseException;\n                    }\n            }\n        } // This is used to track the actual thenable that suspended so it can be\n        // passed to the rest of the Suspense implementation — which, for historical\n        // reasons, expects to receive a thenable.\n        var suspendedThenable = null;\n        function getSuspendedThenable() {\n            // This is called right after `use` suspends by throwing an exception. `use`\n            // throws an opaque value instead of the thenable itself so that it can't be\n            // caught in userspace. Then the work loop accesses the actual thenable using\n            // this function.\n            if (suspendedThenable === null) {\n                throw new Error(\"Expected a suspended thenable. This is a bug in React. Please file \" + \"an issue.\");\n            }\n            var thenable = suspendedThenable;\n            suspendedThenable = null;\n            return thenable;\n        }\n        /**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */ function is(x, y) {\n            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n            ;\n        }\n        var objectIs = typeof Object.is === \"function\" ? Object.is : is;\n        var currentlyRenderingComponent = null;\n        var currentlyRenderingTask = null;\n        var firstWorkInProgressHook = null;\n        var workInProgressHook = null; // Whether the work-in-progress hook is a re-rendered hook\n        var isReRender = false; // Whether an update was scheduled during the currently executing render pass.\n        var didScheduleRenderPhaseUpdate = false; // Counts the number of useId hooks in this component\n        var localIdCounter = 0; // Counts the number of use(thenable) calls in this component\n        var thenableIndexCounter = 0;\n        var thenableState = null; // Lazily created map of render-phase updates\n        var renderPhaseUpdates = null; // Counter to prevent infinite loops.\n        var numberOfReRenders = 0;\n        var RE_RENDER_LIMIT = 25;\n        var isInHookUserCodeInDev = false; // In DEV, this is the name of the currently executing primitive hook\n        var currentHookNameInDev;\n        function resolveCurrentlyRenderingComponent() {\n            if (currentlyRenderingComponent === null) {\n                throw new Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for\" + \" one of the following reasons:\\n\" + \"1. You might have mismatching versions of React and the renderer (such as React DOM)\\n\" + \"2. You might be breaking the Rules of Hooks\\n\" + \"3. You might have more than one copy of React in the same app\\n\" + \"See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.\");\n            }\n            {\n                if (isInHookUserCodeInDev) {\n                    error(\"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. \" + \"You can only call Hooks at the top level of your React function. \" + \"For more information, see \" + \"https://reactjs.org/link/rules-of-hooks\");\n                }\n            }\n            return currentlyRenderingComponent;\n        }\n        function areHookInputsEqual(nextDeps, prevDeps) {\n            if (prevDeps === null) {\n                {\n                    error(\"%s received a final argument during this render, but not during \" + \"the previous render. Even though the final argument is optional, \" + \"its type cannot change between renders.\", currentHookNameInDev);\n                }\n                return false;\n            }\n            {\n                // Don't bother comparing lengths in prod because these arrays should be\n                // passed inline.\n                if (nextDeps.length !== prevDeps.length) {\n                    error(\"The final argument passed to %s changed size between renders. The \" + \"order and size of this array must remain constant.\\n\\n\" + \"Previous: %s\\n\" + \"Incoming: %s\", currentHookNameInDev, \"[\" + nextDeps.join(\", \") + \"]\", \"[\" + prevDeps.join(\", \") + \"]\");\n                }\n            }\n            for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++){\n                // $FlowFixMe[incompatible-use] found when upgrading Flow\n                if (objectIs(nextDeps[i], prevDeps[i])) {\n                    continue;\n                }\n                return false;\n            }\n            return true;\n        }\n        function createHook() {\n            if (numberOfReRenders > 0) {\n                throw new Error(\"Rendered more hooks than during the previous render\");\n            }\n            return {\n                memoizedState: null,\n                queue: null,\n                next: null\n            };\n        }\n        function createWorkInProgressHook() {\n            if (workInProgressHook === null) {\n                // This is the first hook in the list\n                if (firstWorkInProgressHook === null) {\n                    isReRender = false;\n                    firstWorkInProgressHook = workInProgressHook = createHook();\n                } else {\n                    // There's already a work-in-progress. Reuse it.\n                    isReRender = true;\n                    workInProgressHook = firstWorkInProgressHook;\n                }\n            } else {\n                if (workInProgressHook.next === null) {\n                    isReRender = false; // Append to the end of the list\n                    workInProgressHook = workInProgressHook.next = createHook();\n                } else {\n                    // There's already a work-in-progress. Reuse it.\n                    isReRender = true;\n                    workInProgressHook = workInProgressHook.next;\n                }\n            }\n            return workInProgressHook;\n        }\n        function prepareToUseHooks(task, componentIdentity, prevThenableState) {\n            currentlyRenderingComponent = componentIdentity;\n            currentlyRenderingTask = task;\n            {\n                isInHookUserCodeInDev = false;\n            }\n            // didScheduleRenderPhaseUpdate = false;\n            // firstWorkInProgressHook = null;\n            // numberOfReRenders = 0;\n            // renderPhaseUpdates = null;\n            // workInProgressHook = null;\n            localIdCounter = 0;\n            thenableIndexCounter = 0;\n            thenableState = prevThenableState;\n        }\n        function finishHooks(Component, props, children, refOrContext) {\n            // This must be called after every function component to prevent hooks from\n            // being used in classes.\n            while(didScheduleRenderPhaseUpdate){\n                // Updates were scheduled during the render phase. They are stored in\n                // the `renderPhaseUpdates` map. Call the component again, reusing the\n                // work-in-progress hooks and applying the additional updates on top. Keep\n                // restarting until no more updates are scheduled.\n                didScheduleRenderPhaseUpdate = false;\n                localIdCounter = 0;\n                thenableIndexCounter = 0;\n                numberOfReRenders += 1; // Start over from the beginning of the list\n                workInProgressHook = null;\n                children = Component(props, refOrContext);\n            }\n            resetHooksState();\n            return children;\n        }\n        function getThenableStateAfterSuspending() {\n            var state = thenableState;\n            thenableState = null;\n            return state;\n        }\n        function checkDidRenderIdHook() {\n            // This should be called immediately after every finishHooks call.\n            // Conceptually, it's part of the return value of finishHooks; it's only a\n            // separate function to avoid using an array tuple.\n            var didRenderIdHook = localIdCounter !== 0;\n            return didRenderIdHook;\n        } // Reset the internal hooks state if an error occurs while rendering a component\n        function resetHooksState() {\n            {\n                isInHookUserCodeInDev = false;\n            }\n            currentlyRenderingComponent = null;\n            currentlyRenderingTask = null;\n            didScheduleRenderPhaseUpdate = false;\n            firstWorkInProgressHook = null;\n            numberOfReRenders = 0;\n            renderPhaseUpdates = null;\n            workInProgressHook = null;\n        }\n        function readContext(context) {\n            {\n                if (isInHookUserCodeInDev) {\n                    error(\"Context can only be read while React is rendering. \" + \"In classes, you can read it in the render method or getDerivedStateFromProps. \" + \"In function components, you can read it directly in the function body, but not \" + \"inside Hooks like useReducer() or useMemo().\");\n                }\n            }\n            return readContext$1(context);\n        }\n        function useContext(context) {\n            {\n                currentHookNameInDev = \"useContext\";\n            }\n            resolveCurrentlyRenderingComponent();\n            return readContext$1(context);\n        }\n        function basicStateReducer(state, action) {\n            // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types\n            return typeof action === \"function\" ? action(state) : action;\n        }\n        function useState(initialState) {\n            {\n                currentHookNameInDev = \"useState\";\n            }\n            return useReducer(basicStateReducer, initialState);\n        }\n        function useReducer(reducer, initialArg, init) {\n            {\n                if (reducer !== basicStateReducer) {\n                    currentHookNameInDev = \"useReducer\";\n                }\n            }\n            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n            workInProgressHook = createWorkInProgressHook();\n            if (isReRender) {\n                // This is a re-render. Apply the new render phase updates to the previous\n                // current hook.\n                var queue = workInProgressHook.queue;\n                var dispatch = queue.dispatch;\n                if (renderPhaseUpdates !== null) {\n                    // Render phase updates are stored in a map of queue -> linked list\n                    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n                    if (firstRenderPhaseUpdate !== undefined) {\n                        // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        renderPhaseUpdates.delete(queue); // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        var newState = workInProgressHook.memoizedState;\n                        var update = firstRenderPhaseUpdate;\n                        do {\n                            // Process this render phase update. We don't have to check the\n                            // priority because it will always be the same as the current\n                            // render's.\n                            var action = update.action;\n                            {\n                                isInHookUserCodeInDev = true;\n                            }\n                            newState = reducer(newState, action);\n                            {\n                                isInHookUserCodeInDev = false;\n                            }\n                            update = update.next;\n                        }while (update !== null); // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        workInProgressHook.memoizedState = newState;\n                        return [\n                            newState,\n                            dispatch\n                        ];\n                    }\n                } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                return [\n                    workInProgressHook.memoizedState,\n                    dispatch\n                ];\n            } else {\n                {\n                    isInHookUserCodeInDev = true;\n                }\n                var initialState;\n                if (reducer === basicStateReducer) {\n                    // Special case for `useState`.\n                    initialState = typeof initialArg === \"function\" ? initialArg() : initialArg;\n                } else {\n                    initialState = init !== undefined ? init(initialArg) : initialArg;\n                }\n                {\n                    isInHookUserCodeInDev = false;\n                }\n                workInProgressHook.memoizedState = initialState; // $FlowFixMe[incompatible-use] found when upgrading Flow\n                var _queue = workInProgressHook.queue = {\n                    last: null,\n                    dispatch: null\n                };\n                var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue); // $FlowFixMe[incompatible-use] found when upgrading Flow\n                return [\n                    workInProgressHook.memoizedState,\n                    _dispatch\n                ];\n            }\n        }\n        function useMemo(nextCreate, deps) {\n            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n            workInProgressHook = createWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            if (workInProgressHook !== null) {\n                var prevState = workInProgressHook.memoizedState;\n                if (prevState !== null) {\n                    if (nextDeps !== null) {\n                        var prevDeps = prevState[1];\n                        if (areHookInputsEqual(nextDeps, prevDeps)) {\n                            return prevState[0];\n                        }\n                    }\n                }\n            }\n            {\n                isInHookUserCodeInDev = true;\n            }\n            var nextValue = nextCreate();\n            {\n                isInHookUserCodeInDev = false;\n            }\n            workInProgressHook.memoizedState = [\n                nextValue,\n                nextDeps\n            ];\n            return nextValue;\n        }\n        function useRef(initialValue) {\n            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n            workInProgressHook = createWorkInProgressHook();\n            var previousRef = workInProgressHook.memoizedState;\n            if (previousRef === null) {\n                var ref = {\n                    current: initialValue\n                };\n                {\n                    Object.seal(ref);\n                }\n                workInProgressHook.memoizedState = ref;\n                return ref;\n            } else {\n                return previousRef;\n            }\n        }\n        function dispatchAction(componentIdentity, queue, action) {\n            if (numberOfReRenders >= RE_RENDER_LIMIT) {\n                throw new Error(\"Too many re-renders. React limits the number of renders to prevent \" + \"an infinite loop.\");\n            }\n            if (componentIdentity === currentlyRenderingComponent) {\n                // This is a render phase update. Stash it in a lazily-created map of\n                // queue -> linked list of updates. After this render pass, we'll restart\n                // and apply the stashed updates on top of the work-in-progress hook.\n                didScheduleRenderPhaseUpdate = true;\n                var update = {\n                    action: action,\n                    next: null\n                };\n                if (renderPhaseUpdates === null) {\n                    renderPhaseUpdates = new Map();\n                }\n                var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n                if (firstRenderPhaseUpdate === undefined) {\n                    // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    renderPhaseUpdates.set(queue, update);\n                } else {\n                    // Append the update to the end of the list.\n                    var lastRenderPhaseUpdate = firstRenderPhaseUpdate;\n                    while(lastRenderPhaseUpdate.next !== null){\n                        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n                    }\n                    lastRenderPhaseUpdate.next = update;\n                }\n            }\n        }\n        function useCallback(callback, deps) {\n            return useMemo(function() {\n                return callback;\n            }, deps);\n        }\n        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n            if (getServerSnapshot === undefined) {\n                throw new Error(\"Missing getServerSnapshot, which is required for \" + \"server-rendered content. Will revert to client rendering.\");\n            }\n            return getServerSnapshot();\n        }\n        function useDeferredValue(value) {\n            resolveCurrentlyRenderingComponent();\n            return value;\n        }\n        function unsupportedStartTransition() {\n            throw new Error(\"startTransition cannot be called during server rendering.\");\n        }\n        function useTransition() {\n            resolveCurrentlyRenderingComponent();\n            return [\n                false,\n                unsupportedStartTransition\n            ];\n        }\n        function useId() {\n            var task = currentlyRenderingTask;\n            var treeId = getTreeId(task.treeContext);\n            var responseState = currentResponseState;\n            if (responseState === null) {\n                throw new Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component.\");\n            }\n            var localId = localIdCounter++;\n            return makeId(responseState, treeId, localId);\n        }\n        function use(usable) {\n            if (usable !== null && typeof usable === \"object\") {\n                // $FlowFixMe[method-unbinding]\n                if (typeof usable.then === \"function\") {\n                    // This is a thenable.\n                    var thenable = usable;\n                    return unwrapThenable(thenable);\n                } else if (usable.$$typeof === REACT_CONTEXT_TYPE || usable.$$typeof === REACT_SERVER_CONTEXT_TYPE) {\n                    var context = usable;\n                    return readContext(context);\n                }\n            } // eslint-disable-next-line react-internal/safe-string-coercion\n            throw new Error(\"An unsupported type was passed to use(): \" + String(usable));\n        }\n        function unwrapThenable(thenable) {\n            var index = thenableIndexCounter;\n            thenableIndexCounter += 1;\n            if (thenableState === null) {\n                thenableState = createThenableState();\n            }\n            return trackUsedThenable(thenableState, thenable, index);\n        }\n        function unsupportedRefresh() {\n            throw new Error(\"Cache cannot be refreshed during server rendering.\");\n        }\n        function useCacheRefresh() {\n            return unsupportedRefresh;\n        }\n        function noop$1() {}\n        var HooksDispatcher = {\n            readContext: readContext,\n            use: use,\n            useContext: useContext,\n            useMemo: useMemo,\n            useReducer: useReducer,\n            useRef: useRef,\n            useState: useState,\n            useInsertionEffect: noop$1,\n            useLayoutEffect: noop$1,\n            useCallback: useCallback,\n            // useImperativeHandle is not run in the server environment\n            useImperativeHandle: noop$1,\n            // Effects are not run in the server environment.\n            useEffect: noop$1,\n            // Debugging effect\n            useDebugValue: noop$1,\n            useDeferredValue: useDeferredValue,\n            useTransition: useTransition,\n            useId: useId,\n            // Subscriptions are not setup in a server environment.\n            useSyncExternalStore: useSyncExternalStore\n        };\n        {\n            HooksDispatcher.useCacheRefresh = useCacheRefresh;\n        }\n        var currentResponseState = null;\n        function setCurrentResponseState(responseState) {\n            currentResponseState = responseState;\n        }\n        function getCacheSignal() {\n            throw new Error(\"Not implemented.\");\n        }\n        function getCacheForType(resourceType) {\n            throw new Error(\"Not implemented.\");\n        }\n        var DefaultCacheDispatcher = {\n            getCacheSignal: getCacheSignal,\n            getCacheForType: getCacheForType\n        };\n        function getStackByComponentStackNode(componentStack) {\n            try {\n                var info = \"\";\n                var node = componentStack;\n                do {\n                    switch(node.tag){\n                        case 0:\n                            info += describeBuiltInComponentFrame(node.type, null, null);\n                            break;\n                        case 1:\n                            info += describeFunctionComponentFrame(node.type, null, null);\n                            break;\n                        case 2:\n                            info += describeClassComponentFrame(node.type, null, null);\n                            break;\n                    } // $FlowFixMe[incompatible-type] we bail out when we get a null\n                    node = node.parent;\n                }while (node);\n                return info;\n            } catch (x) {\n                return \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var ReactCurrentCache = ReactSharedInternals.ReactCurrentCache;\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var PENDING = 0;\n        var COMPLETED = 1;\n        var FLUSHED = 2;\n        var ABORTED = 3;\n        var ERRORED = 4;\n        var OPEN = 0;\n        var CLOSING = 1;\n        var CLOSED = 2; // This is a default heuristic for how to split up the HTML content into progressive\n        // loading. Our goal is to be able to display additional new content about every 500ms.\n        // Faster than that is unnecessary and should be throttled on the client. It also\n        // adds unnecessary overhead to do more splits. We don't know if it's a higher or lower\n        // end device but higher end suffer less from the overhead than lower end does from\n        // not getting small enough pieces. We error on the side of low end.\n        // We base this on low end 3G speeds which is about 500kbits per second. We assume\n        // that there can be a reasonable drop off from max bandwidth which leaves you with\n        // as little as 80%. We can receive half of that each 500ms - at best. In practice,\n        // a little bandwidth is lost to processing and contention - e.g. CSS and images that\n        // are downloaded along with the main content. So we estimate about half of that to be\n        // the lower end throughput. In other words, we expect that you can at least show\n        // about 12.5kb of content per 500ms. Not counting starting latency for the first\n        // paint.\n        // 500 * 1024 / 8 * .8 * 0.5 / 2\n        var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;\n        function defaultErrorHandler(error) {\n            console[\"error\"](error); // Don't transform to our wrapper\n            return null;\n        }\n        function noop() {}\n        function createRequest(children, resources, responseState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError) {\n            prepareHostDispatcher();\n            var pingedTasks = [];\n            var abortSet = new Set();\n            var request = {\n                destination: null,\n                flushScheduled: false,\n                responseState: responseState,\n                progressiveChunkSize: progressiveChunkSize === undefined ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,\n                status: OPEN,\n                fatalError: null,\n                nextSegmentId: 0,\n                allPendingTasks: 0,\n                pendingRootTasks: 0,\n                resources: resources,\n                completedRootSegment: null,\n                abortableTasks: abortSet,\n                pingedTasks: pingedTasks,\n                clientRenderedBoundaries: [],\n                completedBoundaries: [],\n                partialBoundaries: [],\n                onError: onError === undefined ? defaultErrorHandler : onError,\n                onAllReady: onAllReady === undefined ? noop : onAllReady,\n                onShellReady: onShellReady === undefined ? noop : onShellReady,\n                onShellError: onShellError === undefined ? noop : onShellError,\n                onFatalError: onFatalError === undefined ? noop : onFatalError\n            }; // This segment represents the root fallback.\n            var rootSegment = createPendingSegment(request, 0, null, rootFormatContext, false, false); // There is no parent so conceptually, we're unblocked to flush this segment.\n            rootSegment.parentFlushed = true;\n            var rootTask = createTask(request, null, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);\n            pingedTasks.push(rootTask);\n            return request;\n        }\n        var currentRequest = null;\n        function resolveRequest() {\n            if (currentRequest) return currentRequest;\n            return null;\n        }\n        function pingTask(request, task) {\n            var pingedTasks = request.pingedTasks;\n            pingedTasks.push(task);\n            if (request.pingedTasks.length === 1) {\n                request.flushScheduled = request.destination !== null;\n                scheduleWork(function() {\n                    return performWork(request);\n                });\n            }\n        }\n        function createSuspenseBoundary(request, fallbackAbortableTasks) {\n            return {\n                id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,\n                rootSegmentID: -1,\n                parentFlushed: false,\n                pendingTasks: 0,\n                forceClientRender: false,\n                completedSegments: [],\n                byteSize: 0,\n                fallbackAbortableTasks: fallbackAbortableTasks,\n                errorDigest: null,\n                resources: createBoundaryResources()\n            };\n        }\n        function createTask(request, thenableState, node, blockedBoundary, blockedSegment, abortSet, legacyContext, context, treeContext) {\n            request.allPendingTasks++;\n            if (blockedBoundary === null) {\n                request.pendingRootTasks++;\n            } else {\n                blockedBoundary.pendingTasks++;\n            }\n            var task = {\n                node: node,\n                ping: function() {\n                    return pingTask(request, task);\n                },\n                blockedBoundary: blockedBoundary,\n                blockedSegment: blockedSegment,\n                abortSet: abortSet,\n                legacyContext: legacyContext,\n                context: context,\n                treeContext: treeContext,\n                thenableState: thenableState\n            };\n            {\n                task.componentStack = null;\n            }\n            abortSet.add(task);\n            return task;\n        }\n        function createPendingSegment(request, index, boundary, formatContext, lastPushedText, textEmbedded) {\n            return {\n                status: PENDING,\n                id: -1,\n                // lazily assigned later\n                index: index,\n                parentFlushed: false,\n                chunks: [],\n                children: [],\n                formatContext: formatContext,\n                boundary: boundary,\n                lastPushedText: lastPushedText,\n                textEmbedded: textEmbedded\n            };\n        } // DEV-only global reference to the currently executing task\n        var currentTaskInDEV = null;\n        function getCurrentStackInDEV() {\n            {\n                if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {\n                    return \"\";\n                }\n                return getStackByComponentStackNode(currentTaskInDEV.componentStack);\n            }\n        }\n        function pushBuiltInComponentStackInDEV(task, type) {\n            {\n                task.componentStack = {\n                    tag: 0,\n                    parent: task.componentStack,\n                    type: type\n                };\n            }\n        }\n        function pushFunctionComponentStackInDEV(task, type) {\n            {\n                task.componentStack = {\n                    tag: 1,\n                    parent: task.componentStack,\n                    type: type\n                };\n            }\n        }\n        function pushClassComponentStackInDEV(task, type) {\n            {\n                task.componentStack = {\n                    tag: 2,\n                    parent: task.componentStack,\n                    type: type\n                };\n            }\n        }\n        function popComponentStackInDEV(task) {\n            {\n                if (task.componentStack === null) {\n                    error(\"Unexpectedly popped too many stack frames. This is a bug in React.\");\n                } else {\n                    task.componentStack = task.componentStack.parent;\n                }\n            }\n        } // stash the component stack of an unwinding error until it is processed\n        var lastBoundaryErrorComponentStackDev = null;\n        function captureBoundaryErrorDetailsDev(boundary, error) {\n            {\n                var errorMessage;\n                if (typeof error === \"string\") {\n                    errorMessage = error;\n                } else if (error && typeof error.message === \"string\") {\n                    errorMessage = error.message;\n                } else {\n                    // eslint-disable-next-line react-internal/safe-string-coercion\n                    errorMessage = String(error);\n                }\n                var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();\n                lastBoundaryErrorComponentStackDev = null;\n                boundary.errorMessage = errorMessage;\n                boundary.errorComponentStack = errorComponentStack;\n            }\n        }\n        function logRecoverableError(request, error) {\n            // If this callback errors, we intentionally let that error bubble up to become a fatal error\n            // so that someone fixes the error reporting instead of hiding it.\n            var errorDigest = request.onError(error);\n            if (errorDigest != null && typeof errorDigest !== \"string\") {\n                // eslint-disable-next-line react-internal/prod-error-codes\n                throw new Error('onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"' + typeof errorDigest + '\" instead');\n            }\n            return errorDigest;\n        }\n        function fatalError(request, error) {\n            // This is called outside error handling code such as if the root errors outside\n            // a suspense boundary or if the root suspense boundary's fallback errors.\n            // It's also called if React itself or its host configs errors.\n            var onShellError = request.onShellError;\n            onShellError(error);\n            var onFatalError = request.onFatalError;\n            onFatalError(error);\n            if (request.destination !== null) {\n                request.status = CLOSED;\n                closeWithError(request.destination, error);\n            } else {\n                request.status = CLOSING;\n                request.fatalError = error;\n            }\n        }\n        function renderSuspenseBoundary(request, task, props) {\n            pushBuiltInComponentStackInDEV(task, \"Suspense\");\n            var parentBoundary = task.blockedBoundary;\n            var parentSegment = task.blockedSegment; // Each time we enter a suspense boundary, we split out into a new segment for\n            // the fallback so that we can later replace that segment with the content.\n            // This also lets us split out the main content even if it doesn't suspend,\n            // in case it ends up generating a large subtree of content.\n            var fallback = props.fallback;\n            var content = props.children;\n            var fallbackAbortSet = new Set();\n            var newBoundary = createSuspenseBoundary(request, fallbackAbortSet);\n            var insertionIndex = parentSegment.chunks.length; // The children of the boundary segment is actually the fallback.\n            var boundarySegment = createPendingSegment(request, insertionIndex, newBoundary, parentSegment.formatContext, false, false);\n            parentSegment.children.push(boundarySegment); // The parentSegment has a child Segment at this index so we reset the lastPushedText marker on the parent\n            parentSegment.lastPushedText = false; // This segment is the actual child content. We can start rendering that immediately.\n            var contentRootSegment = createPendingSegment(request, 0, null, parentSegment.formatContext, false, false); // We mark the root segment as having its parent flushed. It's not really flushed but there is\n            // no parent segment so there's nothing to wait on.\n            contentRootSegment.parentFlushed = true; // Currently this is running synchronously. We could instead schedule this to pingedTasks.\n            // I suspect that there might be some efficiency benefits from not creating the suspended task\n            // and instead just using the stack if possible.\n            // TODO: Call this directly instead of messing with saving and restoring contexts.\n            // We can reuse the current context and task to render the content immediately without\n            // context switching. We just need to temporarily switch which boundary and which segment\n            // we're writing to. If something suspends, it'll spawn new suspended task with that context.\n            task.blockedBoundary = newBoundary;\n            task.blockedSegment = contentRootSegment;\n            {\n                setCurrentlyRenderingBoundaryResourcesTarget(request.resources, newBoundary.resources);\n            }\n            try {\n                // We use the safe form because we don't handle suspending here. Only error handling.\n                renderNode(request, task, content);\n                pushSegmentFinale(contentRootSegment.chunks, request.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);\n                contentRootSegment.status = COMPLETED;\n                queueCompletedSegment(newBoundary, contentRootSegment);\n                if (newBoundary.pendingTasks === 0) {\n                    // This must have been the last segment we were waiting on. This boundary is now complete.\n                    // Therefore we won't need the fallback. We early return so that we don't have to create\n                    // the fallback.\n                    popComponentStackInDEV(task);\n                    return;\n                }\n            } catch (error) {\n                contentRootSegment.status = ERRORED;\n                newBoundary.forceClientRender = true;\n                newBoundary.errorDigest = logRecoverableError(request, error);\n                {\n                    captureBoundaryErrorDetailsDev(newBoundary, error);\n                }\n            // We don't need to schedule any task because we know the parent has written yet.\n            // We do need to fallthrough to create the fallback though.\n            } finally{\n                {\n                    setCurrentlyRenderingBoundaryResourcesTarget(request.resources, parentBoundary ? parentBoundary.resources : null);\n                }\n                task.blockedBoundary = parentBoundary;\n                task.blockedSegment = parentSegment;\n            } // We create suspended task for the fallback because we don't want to actually work\n            // on it yet in case we finish the main content, so we queue for later.\n            var suspendedFallbackTask = createTask(request, null, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);\n            {\n                suspendedFallbackTask.componentStack = task.componentStack;\n            }\n            // on preparing fallbacks if we don't have any more main content to task on.\n            request.pingedTasks.push(suspendedFallbackTask);\n            popComponentStackInDEV(task);\n        }\n        function renderHostElement(request, task, type, props) {\n            pushBuiltInComponentStackInDEV(task, type);\n            var segment = task.blockedSegment;\n            var children = pushStartInstance(segment.chunks, type, props, request.resources, request.responseState, segment.formatContext, segment.lastPushedText);\n            segment.lastPushedText = false;\n            var prevContext = segment.formatContext;\n            segment.formatContext = getChildFormatContext(prevContext, type, props); // We use the non-destructive form because if something suspends, we still\n            // need to pop back up and finish this subtree of HTML.\n            renderNode(request, task, children); // We expect that errors will fatal the whole task and that we don't need\n            // the correct context. Therefore this is not in a finally.\n            segment.formatContext = prevContext;\n            pushEndInstance(segment.chunks, type, props, request.responseState, prevContext);\n            segment.lastPushedText = false;\n            popComponentStackInDEV(task);\n        }\n        function shouldConstruct(Component) {\n            return Component.prototype && Component.prototype.isReactComponent;\n        }\n        function renderWithHooks(request, task, prevThenableState, Component, props, secondArg) {\n            var componentIdentity = {};\n            prepareToUseHooks(task, componentIdentity, prevThenableState);\n            var result = Component(props, secondArg);\n            return finishHooks(Component, props, result, secondArg);\n        }\n        function finishClassComponent(request, task, instance, Component, props) {\n            var nextChildren = instance.render();\n            {\n                if (instance.props !== props) {\n                    if (!didWarnAboutReassigningProps) {\n                        error(\"It looks like %s is reassigning its own `this.props` while rendering. \" + \"This is not supported and can lead to confusing bugs.\", getComponentNameFromType(Component) || \"a component\");\n                    }\n                    didWarnAboutReassigningProps = true;\n                }\n            }\n            {\n                var childContextTypes = Component.childContextTypes;\n                if (childContextTypes !== null && childContextTypes !== undefined) {\n                    var previousContext = task.legacyContext;\n                    var mergedContext = processChildContext(instance, Component, previousContext, childContextTypes);\n                    task.legacyContext = mergedContext;\n                    renderNodeDestructive(request, task, null, nextChildren);\n                    task.legacyContext = previousContext;\n                    return;\n                }\n            }\n            renderNodeDestructive(request, task, null, nextChildren);\n        }\n        function renderClassComponent(request, task, Component, props) {\n            pushClassComponentStackInDEV(task, Component);\n            var maskedContext = getMaskedContext(Component, task.legacyContext);\n            var instance = constructClassInstance(Component, props, maskedContext);\n            mountClassInstance(instance, Component, props, maskedContext);\n            finishClassComponent(request, task, instance, Component, props);\n            popComponentStackInDEV(task);\n        }\n        var didWarnAboutBadClass = {};\n        var didWarnAboutModulePatternComponent = {};\n        var didWarnAboutContextTypeOnFunctionComponent = {};\n        var didWarnAboutGetDerivedStateOnFunctionComponent = {};\n        var didWarnAboutReassigningProps = false;\n        var didWarnAboutDefaultPropsOnFunctionComponent = {};\n        var didWarnAboutGenerators = false;\n        var didWarnAboutMaps = false;\n        var hasWarnedAboutUsingContextAsConsumer = false; // This would typically be a function component but we still support module pattern\n        // components for some reason.\n        function renderIndeterminateComponent(request, task, prevThenableState, Component, props) {\n            var legacyContext;\n            {\n                legacyContext = getMaskedContext(Component, task.legacyContext);\n            }\n            pushFunctionComponentStackInDEV(task, Component);\n            {\n                if (Component.prototype && typeof Component.prototype.render === \"function\") {\n                    var componentName = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutBadClass[componentName]) {\n                        error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + \"This is likely to cause errors. Change %s to extend React.Component instead.\", componentName, componentName);\n                        didWarnAboutBadClass[componentName] = true;\n                    }\n                }\n            }\n            var value = renderWithHooks(request, task, prevThenableState, Component, props, legacyContext);\n            var hasId = checkDidRenderIdHook();\n            {\n                // Support for module components is deprecated and is removed behind a flag.\n                // Whether or not it would crash later, we want to show a good message in DEV first.\n                if (typeof value === \"object\" && value !== null && typeof value.render === \"function\" && value.$$typeof === undefined) {\n                    var _componentName = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutModulePatternComponent[_componentName]) {\n                        error(\"The <%s /> component appears to be a function component that returns a class instance. \" + \"Change %s to a class that extends React.Component instead. \" + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + \"cannot be called with `new` by React.\", _componentName, _componentName, _componentName);\n                        didWarnAboutModulePatternComponent[_componentName] = true;\n                    }\n                }\n            }\n            if (// Eventually we'll delete this branch altogether.\n            typeof value === \"object\" && value !== null && typeof value.render === \"function\" && value.$$typeof === undefined) {\n                {\n                    var _componentName2 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutModulePatternComponent[_componentName2]) {\n                        error(\"The <%s /> component appears to be a function component that returns a class instance. \" + \"Change %s to a class that extends React.Component instead. \" + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + \"cannot be called with `new` by React.\", _componentName2, _componentName2, _componentName2);\n                        didWarnAboutModulePatternComponent[_componentName2] = true;\n                    }\n                }\n                mountClassInstance(value, Component, props, legacyContext);\n                finishClassComponent(request, task, value, Component, props);\n            } else {\n                {\n                    validateFunctionComponentInDev(Component);\n                }\n                // the previous task every again, so we can use the destructive recursive form.\n                if (hasId) {\n                    // This component materialized an id. We treat this as its own level, with\n                    // a single \"child\" slot.\n                    var prevTreeContext = task.treeContext;\n                    var totalChildren = 1;\n                    var index = 0;\n                    task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);\n                    try {\n                        renderNodeDestructive(request, task, null, value);\n                    } finally{\n                        task.treeContext = prevTreeContext;\n                    }\n                } else {\n                    renderNodeDestructive(request, task, null, value);\n                }\n            }\n            popComponentStackInDEV(task);\n        }\n        function validateFunctionComponentInDev(Component) {\n            {\n                if (Component) {\n                    if (Component.childContextTypes) {\n                        error(\"%s(...): childContextTypes cannot be defined on a function component.\", Component.displayName || Component.name || \"Component\");\n                    }\n                }\n                if (Component.defaultProps !== undefined) {\n                    var componentName = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {\n                        error(\"%s: Support for defaultProps will be removed from function components \" + \"in a future major release. Use JavaScript default parameters instead.\", componentName);\n                        didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;\n                    }\n                }\n                if (typeof Component.getDerivedStateFromProps === \"function\") {\n                    var _componentName3 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {\n                        error(\"%s: Function components do not support getDerivedStateFromProps.\", _componentName3);\n                        didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;\n                    }\n                }\n                if (typeof Component.contextType === \"object\" && Component.contextType !== null) {\n                    var _componentName4 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {\n                        error(\"%s: Function components do not support contextType.\", _componentName4);\n                        didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;\n                    }\n                }\n            }\n        }\n        function resolveDefaultProps(Component, baseProps) {\n            if (Component && Component.defaultProps) {\n                // Resolve default props. Taken from ReactElement\n                var props = assign({}, baseProps);\n                var defaultProps = Component.defaultProps;\n                for(var propName in defaultProps){\n                    if (props[propName] === undefined) {\n                        props[propName] = defaultProps[propName];\n                    }\n                }\n                return props;\n            }\n            return baseProps;\n        }\n        function renderForwardRef(request, task, prevThenableState, type, props, ref) {\n            pushFunctionComponentStackInDEV(task, type.render);\n            var children = renderWithHooks(request, task, prevThenableState, type.render, props, ref);\n            var hasId = checkDidRenderIdHook();\n            if (hasId) {\n                // This component materialized an id. We treat this as its own level, with\n                // a single \"child\" slot.\n                var prevTreeContext = task.treeContext;\n                var totalChildren = 1;\n                var index = 0;\n                task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);\n                try {\n                    renderNodeDestructive(request, task, null, children);\n                } finally{\n                    task.treeContext = prevTreeContext;\n                }\n            } else {\n                renderNodeDestructive(request, task, null, children);\n            }\n            popComponentStackInDEV(task);\n        }\n        function renderMemo(request, task, prevThenableState, type, props, ref) {\n            var innerType = type.type;\n            var resolvedProps = resolveDefaultProps(innerType, props);\n            renderElement(request, task, prevThenableState, innerType, resolvedProps, ref);\n        }\n        function renderContextConsumer(request, task, context, props) {\n            // The logic below for Context differs depending on PROD or DEV mode. In\n            // DEV mode, we create a separate object for Context.Consumer that acts\n            // like a proxy to Context. This proxy object adds unnecessary code in PROD\n            // so we use the old behaviour (Context.Consumer references Context) to\n            // reduce size and overhead. The separate object references context via\n            // a property called \"_context\", which also gives us the ability to check\n            // in DEV mode if this property exists or not and warn if it does not.\n            {\n                if (context._context === undefined) {\n                    // This may be because it's a Context (rather than a Consumer).\n                    // Or it may be because it's older React where they're the same thing.\n                    // We only want to warn if we're sure it's a new React.\n                    if (context !== context.Consumer) {\n                        if (!hasWarnedAboutUsingContextAsConsumer) {\n                            hasWarnedAboutUsingContextAsConsumer = true;\n                            error(\"Rendering <Context> directly is not supported and will be removed in \" + \"a future major release. Did you mean to render <Context.Consumer> instead?\");\n                        }\n                    }\n                } else {\n                    context = context._context;\n                }\n            }\n            var render = props.children;\n            {\n                if (typeof render !== \"function\") {\n                    error(\"A context consumer was rendered with multiple children, or a child \" + \"that isn't a function. A context consumer expects a single child \" + \"that is a function. If you did pass a function, make sure there \" + \"is no trailing or leading whitespace around it.\");\n                }\n            }\n            var newValue = readContext$1(context);\n            var newChildren = render(newValue);\n            renderNodeDestructive(request, task, null, newChildren);\n        }\n        function renderContextProvider(request, task, type, props) {\n            var context = type._context;\n            var value = props.value;\n            var children = props.children;\n            var prevSnapshot;\n            {\n                prevSnapshot = task.context;\n            }\n            task.context = pushProvider(context, value);\n            renderNodeDestructive(request, task, null, children);\n            task.context = popProvider(context);\n            {\n                if (prevSnapshot !== task.context) {\n                    error(\"Popping the context provider did not return back to the original snapshot. This is a bug in React.\");\n                }\n            }\n        }\n        function renderLazyComponent(request, task, prevThenableState, lazyComponent, props, ref) {\n            pushBuiltInComponentStackInDEV(task, \"Lazy\");\n            var payload = lazyComponent._payload;\n            var init = lazyComponent._init;\n            var Component = init(payload);\n            var resolvedProps = resolveDefaultProps(Component, props);\n            renderElement(request, task, prevThenableState, Component, resolvedProps, ref);\n            popComponentStackInDEV(task);\n        }\n        function renderOffscreen(request, task, props) {\n            var mode = props.mode;\n            if (mode === \"hidden\") ;\n            else {\n                // A visible Offscreen boundary is treated exactly like a fragment: a\n                // pure indirection.\n                renderNodeDestructive(request, task, null, props.children);\n            }\n        }\n        function renderElement(request, task, prevThenableState, type, props, ref) {\n            if (typeof type === \"function\") {\n                if (shouldConstruct(type)) {\n                    renderClassComponent(request, task, type, props);\n                    return;\n                } else {\n                    renderIndeterminateComponent(request, task, prevThenableState, type, props);\n                    return;\n                }\n            }\n            if (typeof type === \"string\") {\n                renderHostElement(request, task, type, props);\n                return;\n            }\n            switch(type){\n                // LegacyHidden acts the same as a fragment. This only works because we\n                // currently assume that every instance of LegacyHidden is accompanied by a\n                // host component wrapper. In the hidden mode, the host component is given a\n                // `hidden` attribute, which ensures that the initial HTML is not visible.\n                // To support the use of LegacyHidden as a true fragment, without an extra\n                // DOM node, we would have to hide the initial HTML in some other way.\n                // TODO: Delete in LegacyHidden. It's an unstable API only used in the\n                // www build. As a migration step, we could add a special prop to Offscreen\n                // that simulates the old behavior (no hiding, no change to effects).\n                case REACT_LEGACY_HIDDEN_TYPE:\n                case REACT_DEBUG_TRACING_MODE_TYPE:\n                case REACT_STRICT_MODE_TYPE:\n                case REACT_PROFILER_TYPE:\n                case REACT_FRAGMENT_TYPE:\n                    {\n                        renderNodeDestructive(request, task, null, props.children);\n                        return;\n                    }\n                case REACT_OFFSCREEN_TYPE:\n                    {\n                        renderOffscreen(request, task, props);\n                        return;\n                    }\n                case REACT_SUSPENSE_LIST_TYPE:\n                    {\n                        pushBuiltInComponentStackInDEV(task, \"SuspenseList\"); // TODO: SuspenseList should control the boundaries.\n                        renderNodeDestructive(request, task, null, props.children);\n                        popComponentStackInDEV(task);\n                        return;\n                    }\n                case REACT_SCOPE_TYPE:\n                    {\n                        throw new Error(\"ReactDOMServer does not yet support scope components.\");\n                    }\n                case REACT_SUSPENSE_TYPE:\n                    {\n                        {\n                            renderSuspenseBoundary(request, task, props);\n                        }\n                        return;\n                    }\n            }\n            if (typeof type === \"object\" && type !== null) {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        {\n                            renderForwardRef(request, task, prevThenableState, type, props, ref);\n                            return;\n                        }\n                    case REACT_MEMO_TYPE:\n                        {\n                            renderMemo(request, task, prevThenableState, type, props, ref);\n                            return;\n                        }\n                    case REACT_PROVIDER_TYPE:\n                        {\n                            renderContextProvider(request, task, type, props);\n                            return;\n                        }\n                    case REACT_CONTEXT_TYPE:\n                        {\n                            renderContextConsumer(request, task, type, props);\n                            return;\n                        }\n                    case REACT_LAZY_TYPE:\n                        {\n                            renderLazyComponent(request, task, prevThenableState, type, props);\n                            return;\n                        }\n                }\n            }\n            var info = \"\";\n            {\n                if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                    info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and \" + \"named imports.\";\n                }\n            }\n            throw new Error(\"Element type is invalid: expected a string (for built-in \" + \"components) or a class/function (for composite components) \" + (\"but got: \" + (type == null ? type : typeof type) + \".\" + info));\n        } // $FlowFixMe[missing-local-annot]\n        function validateIterable(iterable, iteratorFn) {\n            {\n                // We don't support rendering Generators because it's a mutation.\n                // See https://github.com/facebook/react/issues/12995\n                if (typeof Symbol === \"function\" && iterable[Symbol.toStringTag] === \"Generator\") {\n                    if (!didWarnAboutGenerators) {\n                        error(\"Using Generators as children is unsupported and will likely yield \" + \"unexpected results because enumerating a generator mutates it. \" + \"You may convert it to an array with `Array.from()` or the \" + \"`[...spread]` operator before rendering. Keep in mind \" + \"you might need to polyfill these features for older browsers.\");\n                    }\n                    didWarnAboutGenerators = true;\n                } // Warn about using Maps as children\n                if (iterable.entries === iteratorFn) {\n                    if (!didWarnAboutMaps) {\n                        error(\"Using Maps as children is not supported. \" + \"Use an array of keyed ReactElements instead.\");\n                    }\n                    didWarnAboutMaps = true;\n                }\n            }\n        }\n        function renderNodeDestructive(request, task, // always null, except when called by retryTask.\n        prevThenableState, node) {\n            {\n                // In Dev we wrap renderNodeDestructiveImpl in a try / catch so we can capture\n                // a component stack at the right place in the tree. We don't do this in renderNode\n                // becuase it is not called at every layer of the tree and we may lose frames\n                try {\n                    return renderNodeDestructiveImpl(request, task, prevThenableState, node);\n                } catch (x) {\n                    if (typeof x === \"object\" && x !== null && typeof x.then === \"function\") ;\n                    else {\n                        // This is an error, stash the component stack if it is null.\n                        lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV();\n                    } // rethrow so normal suspense logic can handle thrown value accordingly\n                    throw x;\n                }\n            }\n        } // This function by it self renders a node and consumes the task by mutating it\n        // to update the current execution state.\n        function renderNodeDestructiveImpl(request, task, prevThenableState, node) {\n            // Stash the node we're working on. We'll pick up from this task in case\n            // something suspends.\n            task.node = node; // Handle object types\n            if (typeof node === \"object\" && node !== null) {\n                switch(node.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        {\n                            var element = node;\n                            var type = element.type;\n                            var props = element.props;\n                            var ref = element.ref;\n                            renderElement(request, task, prevThenableState, type, props, ref);\n                            return;\n                        }\n                    case REACT_PORTAL_TYPE:\n                        throw new Error(\"Portals are not currently supported by the server renderer. \" + \"Render them conditionally so that they only appear on the client render.\");\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyNode = node;\n                            var payload = lazyNode._payload;\n                            var init = lazyNode._init;\n                            var resolvedNode;\n                            {\n                                try {\n                                    resolvedNode = init(payload);\n                                } catch (x) {\n                                    if (typeof x === \"object\" && x !== null && typeof x.then === \"function\") {\n                                        // this Lazy initializer is suspending. push a temporary frame onto the stack so it can be\n                                        // popped off in spawnNewSuspendedTask. This aligns stack behavior between Lazy in element position\n                                        // vs Component position. We do not want the frame for Errors so we exclusively do this in\n                                        // the wakeable branch\n                                        pushBuiltInComponentStackInDEV(task, \"Lazy\");\n                                    }\n                                    throw x;\n                                }\n                            }\n                            renderNodeDestructive(request, task, null, resolvedNode);\n                            return;\n                        }\n                }\n                if (isArray(node)) {\n                    renderChildrenArray(request, task, node);\n                    return;\n                }\n                var iteratorFn = getIteratorFn(node);\n                if (iteratorFn) {\n                    {\n                        validateIterable(node, iteratorFn);\n                    }\n                    var iterator = iteratorFn.call(node);\n                    if (iterator) {\n                        // We need to know how many total children are in this set, so that we\n                        // can allocate enough id slots to acommodate them. So we must exhaust\n                        // the iterator before we start recursively rendering the children.\n                        // TODO: This is not great but I think it's inherent to the id\n                        // generation algorithm.\n                        var step = iterator.next(); // If there are not entries, we need to push an empty so we start by checking that.\n                        if (!step.done) {\n                            var children = [];\n                            do {\n                                children.push(step.value);\n                                step = iterator.next();\n                            }while (!step.done);\n                            renderChildrenArray(request, task, children);\n                            return;\n                        }\n                        return;\n                    }\n                } // Usables are a valid React node type. When React encounters a Usable in\n                // a child position, it unwraps it using the same algorithm as `use`. For\n                // example, for promises, React will throw an exception to unwind the\n                // stack, then replay the component once the promise resolves.\n                //\n                // A difference from `use` is that React will keep unwrapping the value\n                // until it reaches a non-Usable type.\n                //\n                // e.g. Usable<Usable<Usable<T>>> should resolve to T\n                var maybeUsable = node;\n                if (typeof maybeUsable.then === \"function\") {\n                    var thenable = maybeUsable;\n                    return renderNodeDestructiveImpl(request, task, null, unwrapThenable(thenable));\n                }\n                if (maybeUsable.$$typeof === REACT_CONTEXT_TYPE || maybeUsable.$$typeof === REACT_SERVER_CONTEXT_TYPE) {\n                    var context = maybeUsable;\n                    return renderNodeDestructiveImpl(request, task, null, readContext$1(context));\n                } // $FlowFixMe[method-unbinding]\n                var childString = Object.prototype.toString.call(node);\n                throw new Error(\"Objects are not valid as a React child (found: \" + (childString === \"[object Object]\" ? \"object with keys {\" + Object.keys(node).join(\", \") + \"}\" : childString) + \"). \" + \"If you meant to render a collection of children, use an array \" + \"instead.\");\n            }\n            if (typeof node === \"string\") {\n                var segment = task.blockedSegment;\n                segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, node, request.responseState, segment.lastPushedText);\n                return;\n            }\n            if (typeof node === \"number\") {\n                var _segment = task.blockedSegment;\n                _segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, \"\" + node, request.responseState, _segment.lastPushedText);\n                return;\n            }\n            {\n                if (typeof node === \"function\") {\n                    error(\"Functions are not valid as a React child. This may happen if \" + \"you return a Component instead of <Component /> from render. \" + \"Or maybe you meant to call this function rather than return it.\");\n                }\n            }\n        }\n        function renderChildrenArray(request, task, children) {\n            var totalChildren = children.length;\n            for(var i = 0; i < totalChildren; i++){\n                var prevTreeContext = task.treeContext;\n                task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i);\n                try {\n                    // We need to use the non-destructive form so that we can safely pop back\n                    // up and render the sibling if something suspends.\n                    renderNode(request, task, children[i]);\n                } finally{\n                    task.treeContext = prevTreeContext;\n                }\n            }\n        }\n        function spawnNewSuspendedTask(request, task, thenableState, x) {\n            // Something suspended, we'll need to create a new segment and resolve it later.\n            var segment = task.blockedSegment;\n            var insertionIndex = segment.chunks.length;\n            var newSegment = createPendingSegment(request, insertionIndex, null, segment.formatContext, segment.lastPushedText, true);\n            segment.children.push(newSegment); // Reset lastPushedText for current Segment since the new Segment \"consumed\" it\n            segment.lastPushedText = false;\n            var newTask = createTask(request, thenableState, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);\n            {\n                if (task.componentStack !== null) {\n                    // We pop one task off the stack because the node that suspended will be tried again,\n                    // which will add it back onto the stack.\n                    newTask.componentStack = task.componentStack.parent;\n                }\n            }\n            var ping = newTask.ping;\n            x.then(ping, ping);\n        } // This is a non-destructive form of rendering a node. If it suspends it spawns\n        // a new task and restores the context of this task to what it was before.\n        function renderNode(request, task, node) {\n            // Store how much we've pushed at this point so we can reset it in case something\n            // suspended partially through writing something.\n            var segment = task.blockedSegment;\n            var childrenLength = segment.children.length;\n            var chunkLength = segment.chunks.length; // Snapshot the current context in case something throws to interrupt the\n            // process.\n            var previousFormatContext = task.blockedSegment.formatContext;\n            var previousLegacyContext = task.legacyContext;\n            var previousContext = task.context;\n            var previousComponentStack = null;\n            {\n                previousComponentStack = task.componentStack;\n            }\n            try {\n                return renderNodeDestructive(request, task, null, node);\n            } catch (thrownValue) {\n                resetHooksState(); // Reset the write pointers to where we started.\n                segment.children.length = childrenLength;\n                segment.chunks.length = chunkLength;\n                var x = thrownValue === SuspenseException ? // reasons, the rest of the Suspense implementation expects the thrown\n                // value to be a thenable, because before `use` existed that was the\n                // (unstable) API for suspending. This implementation detail can change\n                // later, once we deprecate the old API in favor of `use`.\n                getSuspendedThenable() : thrownValue; // $FlowFixMe[method-unbinding]\n                if (typeof x === \"object\" && x !== null && typeof x.then === \"function\") {\n                    var wakeable = x;\n                    var thenableState = getThenableStateAfterSuspending();\n                    spawnNewSuspendedTask(request, task, thenableState, wakeable); // Restore the context. We assume that this will be restored by the inner\n                    // functions in case nothing throws so we don't use \"finally\" here.\n                    task.blockedSegment.formatContext = previousFormatContext;\n                    task.legacyContext = previousLegacyContext;\n                    task.context = previousContext; // Restore all active ReactContexts to what they were before.\n                    switchContext(previousContext);\n                    {\n                        task.componentStack = previousComponentStack;\n                    }\n                    return;\n                } else {\n                    // Restore the context. We assume that this will be restored by the inner\n                    // functions in case nothing throws so we don't use \"finally\" here.\n                    task.blockedSegment.formatContext = previousFormatContext;\n                    task.legacyContext = previousLegacyContext;\n                    task.context = previousContext; // Restore all active ReactContexts to what they were before.\n                    switchContext(previousContext);\n                    {\n                        task.componentStack = previousComponentStack;\n                    }\n                    // Let's terminate the rest of the tree and don't render any siblings.\n                    throw x;\n                }\n            }\n        }\n        function erroredTask(request, boundary, segment, error) {\n            // Report the error to a global handler.\n            var errorDigest = logRecoverableError(request, error);\n            if (boundary === null) {\n                fatalError(request, error);\n            } else {\n                boundary.pendingTasks--;\n                if (!boundary.forceClientRender) {\n                    boundary.forceClientRender = true;\n                    boundary.errorDigest = errorDigest;\n                    {\n                        captureBoundaryErrorDetailsDev(boundary, error);\n                    }\n                    // so we can flush it, if the parent already flushed.\n                    if (boundary.parentFlushed) {\n                        // We don't have a preference where in the queue this goes since it's likely\n                        // to error on the client anyway. However, intentionally client-rendered\n                        // boundaries should be flushed earlier so that they can start on the client.\n                        // We reuse the same queue for errors.\n                        request.clientRenderedBoundaries.push(boundary);\n                    }\n                }\n            }\n            request.allPendingTasks--;\n            if (request.allPendingTasks === 0) {\n                var onAllReady = request.onAllReady;\n                onAllReady();\n            }\n        }\n        function abortTaskSoft(task) {\n            // This aborts task without aborting the parent boundary that it blocks.\n            // It's used for when we didn't need this task to complete the tree.\n            // If task was needed, then it should use abortTask instead.\n            var request = this;\n            var boundary = task.blockedBoundary;\n            var segment = task.blockedSegment;\n            segment.status = ABORTED;\n            finishedTask(request, boundary, segment);\n        }\n        function abortTask(task, request, error) {\n            // This aborts the task and aborts the parent that it blocks, putting it into\n            // client rendered mode.\n            var boundary = task.blockedBoundary;\n            var segment = task.blockedSegment;\n            segment.status = ABORTED;\n            if (boundary === null) {\n                request.allPendingTasks--; // We didn't complete the root so we have nothing to show. We can close\n                // the request;\n                if (request.status !== CLOSING && request.status !== CLOSED) {\n                    logRecoverableError(request, error);\n                    fatalError(request, error);\n                }\n            } else {\n                boundary.pendingTasks--;\n                if (!boundary.forceClientRender) {\n                    boundary.forceClientRender = true;\n                    boundary.errorDigest = request.onError(error);\n                    {\n                        var errorPrefix = \"The server did not finish this Suspense boundary: \";\n                        var errorMessage;\n                        if (error && typeof error.message === \"string\") {\n                            errorMessage = errorPrefix + error.message;\n                        } else {\n                            // eslint-disable-next-line react-internal/safe-string-coercion\n                            errorMessage = errorPrefix + String(error);\n                        }\n                        var previousTaskInDev = currentTaskInDEV;\n                        currentTaskInDEV = task;\n                        try {\n                            captureBoundaryErrorDetailsDev(boundary, errorMessage);\n                        } finally{\n                            currentTaskInDEV = previousTaskInDev;\n                        }\n                    }\n                    if (boundary.parentFlushed) {\n                        request.clientRenderedBoundaries.push(boundary);\n                    }\n                } // If this boundary was still pending then we haven't already cancelled its fallbacks.\n                // We'll need to abort the fallbacks, which will also error that parent boundary.\n                boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {\n                    return abortTask(fallbackTask, request, error);\n                });\n                boundary.fallbackAbortableTasks.clear();\n                request.allPendingTasks--;\n                if (request.allPendingTasks === 0) {\n                    var onAllReady = request.onAllReady;\n                    onAllReady();\n                }\n            }\n        }\n        function queueCompletedSegment(boundary, segment) {\n            if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {\n                // This is an empty segment. There's nothing to write, so we can instead transfer the ID\n                // to the child. That way any existing references point to the child.\n                var childSegment = segment.children[0];\n                childSegment.id = segment.id;\n                childSegment.parentFlushed = true;\n                if (childSegment.status === COMPLETED) {\n                    queueCompletedSegment(boundary, childSegment);\n                }\n            } else {\n                var completedSegments = boundary.completedSegments;\n                completedSegments.push(segment);\n            }\n        }\n        function finishedTask(request, boundary, segment) {\n            if (boundary === null) {\n                if (segment.parentFlushed) {\n                    if (request.completedRootSegment !== null) {\n                        throw new Error(\"There can only be one root segment. This is a bug in React.\");\n                    }\n                    request.completedRootSegment = segment;\n                }\n                request.pendingRootTasks--;\n                if (request.pendingRootTasks === 0) {\n                    // We have completed the shell so the shell can't error anymore.\n                    request.onShellError = noop;\n                    var onShellReady = request.onShellReady;\n                    onShellReady();\n                }\n            } else {\n                boundary.pendingTasks--;\n                if (boundary.forceClientRender) ;\n                else if (boundary.pendingTasks === 0) {\n                    // This must have been the last segment we were waiting on. This boundary is now complete.\n                    if (segment.parentFlushed) {\n                        // Our parent segment already flushed, so we need to schedule this segment to be emitted.\n                        // If it is a segment that was aborted, we'll write other content instead so we don't need\n                        // to emit it.\n                        if (segment.status === COMPLETED) {\n                            queueCompletedSegment(boundary, segment);\n                        }\n                    }\n                    if (boundary.parentFlushed) {\n                        // The segment might be part of a segment that didn't flush yet, but if the boundary's\n                        // parent flushed, we need to schedule the boundary to be emitted.\n                        request.completedBoundaries.push(boundary);\n                    } // We can now cancel any pending task on the fallback since we won't need to show it anymore.\n                    // This needs to happen after we read the parentFlushed flags because aborting can finish\n                    // work which can trigger user code, which can start flushing, which can change those flags.\n                    boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request);\n                    boundary.fallbackAbortableTasks.clear();\n                } else {\n                    if (segment.parentFlushed) {\n                        // Our parent already flushed, so we need to schedule this segment to be emitted.\n                        // If it is a segment that was aborted, we'll write other content instead so we don't need\n                        // to emit it.\n                        if (segment.status === COMPLETED) {\n                            queueCompletedSegment(boundary, segment);\n                            var completedSegments = boundary.completedSegments;\n                            if (completedSegments.length === 1) {\n                                // This is the first time since we last flushed that we completed anything.\n                                // We can schedule this boundary to emit its partially completed segments early\n                                // in case the parent has already been flushed.\n                                if (boundary.parentFlushed) {\n                                    request.partialBoundaries.push(boundary);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            request.allPendingTasks--;\n            if (request.allPendingTasks === 0) {\n                // This needs to be called at the very end so that we can synchronously write the result\n                // in the callback if needed.\n                var onAllReady = request.onAllReady;\n                onAllReady();\n            }\n        }\n        function retryTask(request, task) {\n            {\n                var blockedBoundary = task.blockedBoundary;\n                setCurrentlyRenderingBoundaryResourcesTarget(request.resources, blockedBoundary ? blockedBoundary.resources : null);\n            }\n            var segment = task.blockedSegment;\n            if (segment.status !== PENDING) {\n                // We completed this by other means before we had a chance to retry it.\n                return;\n            } // We restore the context to what it was when we suspended.\n            // We don't restore it after we leave because it's likely that we'll end up\n            // needing a very similar context soon again.\n            switchContext(task.context);\n            var prevTaskInDEV = null;\n            {\n                prevTaskInDEV = currentTaskInDEV;\n                currentTaskInDEV = task;\n            }\n            var childrenLength = segment.children.length;\n            var chunkLength = segment.chunks.length;\n            try {\n                // We call the destructive form that mutates this task. That way if something\n                // suspends again, we can reuse the same task instead of spawning a new one.\n                // Reset the task's thenable state before continuing, so that if a later\n                // component suspends we can reuse the same task object. If the same\n                // component suspends again, the thenable state will be restored.\n                var prevThenableState = task.thenableState;\n                task.thenableState = null;\n                renderNodeDestructive(request, task, prevThenableState, task.node);\n                pushSegmentFinale(segment.chunks, request.responseState, segment.lastPushedText, segment.textEmbedded);\n                task.abortSet.delete(task);\n                segment.status = COMPLETED;\n                finishedTask(request, task.blockedBoundary, segment);\n            } catch (thrownValue) {\n                resetHooksState(); // Reset the write pointers to where we started.\n                segment.children.length = childrenLength;\n                segment.chunks.length = chunkLength;\n                var x = thrownValue === SuspenseException ? // reasons, the rest of the Suspense implementation expects the thrown\n                // value to be a thenable, because before `use` existed that was the\n                // (unstable) API for suspending. This implementation detail can change\n                // later, once we deprecate the old API in favor of `use`.\n                getSuspendedThenable() : thrownValue; // $FlowFixMe[method-unbinding]\n                if (typeof x === \"object\" && x !== null && typeof x.then === \"function\") {\n                    // Something suspended again, let's pick it back up later.\n                    var ping = task.ping;\n                    x.then(ping, ping);\n                    task.thenableState = getThenableStateAfterSuspending();\n                } else {\n                    task.abortSet.delete(task);\n                    segment.status = ERRORED;\n                    erroredTask(request, task.blockedBoundary, segment, x);\n                }\n            } finally{\n                {\n                    setCurrentlyRenderingBoundaryResourcesTarget(request.resources, null);\n                }\n                {\n                    currentTaskInDEV = prevTaskInDEV;\n                }\n            }\n        }\n        function performWork(request) {\n            if (request.status === CLOSED) {\n                return;\n            }\n            var prevContext = getActiveContext();\n            var prevDispatcher = ReactCurrentDispatcher.current;\n            ReactCurrentDispatcher.current = HooksDispatcher;\n            var prevCacheDispatcher;\n            {\n                prevCacheDispatcher = ReactCurrentCache.current;\n                ReactCurrentCache.current = DefaultCacheDispatcher;\n            }\n            var prevRequest = currentRequest;\n            currentRequest = request;\n            var prevGetCurrentStackImpl;\n            {\n                prevGetCurrentStackImpl = ReactDebugCurrentFrame.getCurrentStack;\n                ReactDebugCurrentFrame.getCurrentStack = getCurrentStackInDEV;\n            }\n            var prevResponseState = currentResponseState;\n            setCurrentResponseState(request.responseState);\n            try {\n                var pingedTasks = request.pingedTasks;\n                var i;\n                for(i = 0; i < pingedTasks.length; i++){\n                    var task = pingedTasks[i];\n                    retryTask(request, task);\n                }\n                pingedTasks.splice(0, i);\n                if (request.destination !== null) {\n                    flushCompletedQueues(request, request.destination);\n                }\n            } catch (error) {\n                logRecoverableError(request, error);\n                fatalError(request, error);\n            } finally{\n                setCurrentResponseState(prevResponseState);\n                ReactCurrentDispatcher.current = prevDispatcher;\n                {\n                    ReactCurrentCache.current = prevCacheDispatcher;\n                }\n                {\n                    ReactDebugCurrentFrame.getCurrentStack = prevGetCurrentStackImpl;\n                }\n                if (prevDispatcher === HooksDispatcher) {\n                    // This means that we were in a reentrant work loop. This could happen\n                    // in a renderer that supports synchronous work like renderToString,\n                    // when it's called from within another renderer.\n                    // Normally we don't bother switching the contexts to their root/default\n                    // values when leaving because we'll likely need the same or similar\n                    // context again. However, when we're inside a synchronous loop like this\n                    // we'll to restore the context to what it was before returning.\n                    switchContext(prevContext);\n                }\n                currentRequest = prevRequest;\n            }\n        }\n        function flushSubtree(request, destination, segment) {\n            segment.parentFlushed = true;\n            switch(segment.status){\n                case PENDING:\n                    {\n                        // We're emitting a placeholder for this segment to be filled in later.\n                        // Therefore we'll need to assign it an ID - to refer to it by.\n                        var segmentID = segment.id = request.nextSegmentId++; // When this segment finally completes it won't be embedded in text since it will flush separately\n                        segment.lastPushedText = false;\n                        segment.textEmbedded = false;\n                        return writePlaceholder(destination, request.responseState, segmentID);\n                    }\n                case COMPLETED:\n                    {\n                        segment.status = FLUSHED;\n                        var r = true;\n                        var chunks = segment.chunks;\n                        var chunkIdx = 0;\n                        var children = segment.children;\n                        for(var childIdx = 0; childIdx < children.length; childIdx++){\n                            var nextChild = children[childIdx]; // Write all the chunks up until the next child.\n                            for(; chunkIdx < nextChild.index; chunkIdx++){\n                                writeChunk(destination, chunks[chunkIdx]);\n                            }\n                            r = flushSegment(request, destination, nextChild);\n                        } // Finally just write all the remaining chunks\n                        for(; chunkIdx < chunks.length - 1; chunkIdx++){\n                            writeChunk(destination, chunks[chunkIdx]);\n                        }\n                        if (chunkIdx < chunks.length) {\n                            r = writeChunkAndReturn(destination, chunks[chunkIdx]);\n                        }\n                        return r;\n                    }\n                default:\n                    {\n                        throw new Error(\"Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.\");\n                    }\n            }\n        }\n        function flushSegment(request, destination, segment) {\n            var boundary = segment.boundary;\n            if (boundary === null) {\n                // Not a suspense boundary.\n                return flushSubtree(request, destination, segment);\n            }\n            boundary.parentFlushed = true; // This segment is a Suspense boundary. We need to decide whether to\n            // emit the content or the fallback now.\n            if (boundary.forceClientRender) {\n                // Emit a client rendered suspense boundary wrapper.\n                // We never queue the inner boundary so we'll never emit its content or partial segments.\n                writeStartClientRenderedSuspenseBoundary(destination, request.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack); // Flush the fallback.\n                flushSubtree(request, destination, segment);\n                return writeEndClientRenderedSuspenseBoundary(destination, request.responseState);\n            } else if (boundary.pendingTasks > 0) {\n                // This boundary is still loading. Emit a pending suspense boundary wrapper.\n                // Assign an ID to refer to the future content by.\n                boundary.rootSegmentID = request.nextSegmentId++;\n                if (boundary.completedSegments.length > 0) {\n                    // If this is at least partially complete, we can queue it to be partially emitted early.\n                    request.partialBoundaries.push(boundary);\n                } /// This is the first time we should have referenced this ID.\n                var id = boundary.id = assignSuspenseBoundaryID(request.responseState);\n                writeStartPendingSuspenseBoundary(destination, request.responseState, id); // Flush the fallback.\n                flushSubtree(request, destination, segment);\n                return writeEndPendingSuspenseBoundary(destination);\n            } else if (boundary.byteSize > request.progressiveChunkSize) {\n                // This boundary is large and will be emitted separately so that we can progressively show\n                // other content. We add it to the queue during the flush because we have to ensure that\n                // the parent flushes first so that there's something to inject it into.\n                // We also have to make sure that it's emitted into the queue in a deterministic slot.\n                // I.e. we can't insert it here when it completes.\n                // Assign an ID to refer to the future content by.\n                boundary.rootSegmentID = request.nextSegmentId++;\n                request.completedBoundaries.push(boundary); // Emit a pending rendered suspense boundary wrapper.\n                writeStartPendingSuspenseBoundary(destination, request.responseState, boundary.id); // Flush the fallback.\n                flushSubtree(request, destination, segment);\n                return writeEndPendingSuspenseBoundary(destination);\n            } else {\n                {\n                    hoistResources(request.resources, boundary.resources);\n                }\n                writeStartCompletedSuspenseBoundary(destination, request.responseState);\n                var completedSegments = boundary.completedSegments;\n                if (completedSegments.length !== 1) {\n                    throw new Error(\"A previously unvisited boundary must have exactly one root segment. This is a bug in React.\");\n                }\n                var contentSegment = completedSegments[0];\n                flushSegment(request, destination, contentSegment);\n                return writeEndCompletedSuspenseBoundary(destination, request.responseState);\n            }\n        }\n        function flushClientRenderedBoundary(request, destination, boundary) {\n            return writeClientRenderBoundaryInstruction(destination, request.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);\n        }\n        function flushSegmentContainer(request, destination, segment) {\n            writeStartSegment(destination, request.responseState, segment.formatContext, segment.id);\n            flushSegment(request, destination, segment);\n            return writeEndSegment(destination, segment.formatContext);\n        }\n        function flushCompletedBoundary(request, destination, boundary) {\n            {\n                setCurrentlyRenderingBoundaryResourcesTarget(request.resources, boundary.resources);\n            }\n            var completedSegments = boundary.completedSegments;\n            var i = 0;\n            for(; i < completedSegments.length; i++){\n                var segment = completedSegments[i];\n                flushPartiallyCompletedSegment(request, destination, boundary, segment);\n            }\n            completedSegments.length = 0;\n            {\n                writeResourcesForBoundary(destination, boundary.resources, request.responseState);\n            }\n            return writeCompletedBoundaryInstruction(destination, request.responseState, boundary.id, boundary.rootSegmentID, boundary.resources);\n        }\n        function flushPartialBoundary(request, destination, boundary) {\n            {\n                setCurrentlyRenderingBoundaryResourcesTarget(request.resources, boundary.resources);\n            }\n            var completedSegments = boundary.completedSegments;\n            var i = 0;\n            for(; i < completedSegments.length; i++){\n                var segment = completedSegments[i];\n                if (!flushPartiallyCompletedSegment(request, destination, boundary, segment)) {\n                    i++;\n                    completedSegments.splice(0, i); // Only write as much as the buffer wants. Something higher priority\n                    // might want to write later.\n                    return false;\n                }\n            }\n            completedSegments.splice(0, i);\n            {\n                // The way this is structured we only write resources for partial boundaries\n                // if there is no backpressure. Later before we complete the boundary we\n                // will write resources regardless of backpressure before we emit the\n                // completion instruction\n                return writeResourcesForBoundary(destination, boundary.resources, request.responseState);\n            }\n        }\n        function flushPartiallyCompletedSegment(request, destination, boundary, segment) {\n            if (segment.status === FLUSHED) {\n                // We've already flushed this inline.\n                return true;\n            }\n            var segmentID = segment.id;\n            if (segmentID === -1) {\n                // This segment wasn't previously referred to. This happens at the root of\n                // a boundary. We make kind of a leap here and assume this is the root.\n                var rootSegmentID = segment.id = boundary.rootSegmentID;\n                if (rootSegmentID === -1) {\n                    throw new Error(\"A root segment ID must have been assigned by now. This is a bug in React.\");\n                }\n                return flushSegmentContainer(request, destination, segment);\n            } else {\n                flushSegmentContainer(request, destination, segment);\n                return writeCompletedSegmentInstruction(destination, request.responseState, segmentID);\n            }\n        }\n        function flushCompletedQueues(request, destination) {\n            try {\n                // The structure of this is to go through each queue one by one and write\n                // until the sink tells us to stop. When we should stop, we still finish writing\n                // that item fully and then yield. At that point we remove the already completed\n                // items up until the point we completed them.\n                var i;\n                var completedRootSegment = request.completedRootSegment;\n                if (completedRootSegment !== null) {\n                    if (request.pendingRootTasks === 0) {\n                        if (enableFloat) {\n                            writePreamble(destination, request.resources, request.responseState, request.allPendingTasks === 0);\n                        }\n                        flushSegment(request, destination, completedRootSegment);\n                        request.completedRootSegment = null;\n                        writeCompletedRoot(destination, request.responseState);\n                    } else {\n                        // We haven't flushed the root yet so we don't need to check any other branches further down\n                        return;\n                    }\n                } else if (request.pendingRootTasks > 0) {\n                    // We have not yet flushed the root segment so we early return\n                    return;\n                }\n                if (enableFloat) {\n                    writeHoistables(destination, request.resources, request.responseState);\n                } // We emit client rendering instructions for already emitted boundaries first.\n                // This is so that we can signal to the client to start client rendering them as\n                // soon as possible.\n                var clientRenderedBoundaries = request.clientRenderedBoundaries;\n                for(i = 0; i < clientRenderedBoundaries.length; i++){\n                    var boundary = clientRenderedBoundaries[i];\n                    if (!flushClientRenderedBoundary(request, destination, boundary)) {\n                        request.destination = null;\n                        i++;\n                        clientRenderedBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                clientRenderedBoundaries.splice(0, i); // Next we emit any complete boundaries. It's better to favor boundaries\n                // that are completely done since we can actually show them, than it is to emit\n                // any individual segments from a partially complete boundary.\n                var completedBoundaries = request.completedBoundaries;\n                for(i = 0; i < completedBoundaries.length; i++){\n                    var _boundary = completedBoundaries[i];\n                    if (!flushCompletedBoundary(request, destination, _boundary)) {\n                        request.destination = null;\n                        i++;\n                        completedBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                completedBoundaries.splice(0, i); // Allow anything written so far to flush to the underlying sink before\n                // we continue with lower priorities.\n                completeWriting(destination);\n                beginWriting(destination); // TODO: Here we'll emit data used by hydration.\n                // Next we emit any segments of any boundaries that are partially complete\n                // but not deeply complete.\n                var partialBoundaries = request.partialBoundaries;\n                for(i = 0; i < partialBoundaries.length; i++){\n                    var _boundary2 = partialBoundaries[i];\n                    if (!flushPartialBoundary(request, destination, _boundary2)) {\n                        request.destination = null;\n                        i++;\n                        partialBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                partialBoundaries.splice(0, i); // Next we check the completed boundaries again. This may have had\n                // boundaries added to it in case they were too larged to be inlined.\n                // New ones might be added in this loop.\n                var largeBoundaries = request.completedBoundaries;\n                for(i = 0; i < largeBoundaries.length; i++){\n                    var _boundary3 = largeBoundaries[i];\n                    if (!flushCompletedBoundary(request, destination, _boundary3)) {\n                        request.destination = null;\n                        i++;\n                        largeBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                largeBoundaries.splice(0, i);\n            } finally{\n                if (request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0 // We don't need to check any partially completed segments because\n                ) {\n                    request.flushScheduled = false;\n                    {\n                        writePostamble(destination, request.responseState);\n                    }\n                    {\n                        if (request.abortableTasks.size !== 0) {\n                            error(\"There was still abortable task at the root when we closed. This is a bug in React.\");\n                        }\n                    }\n                    close(destination);\n                }\n            }\n        }\n        function startWork(request) {\n            request.flushScheduled = request.destination !== null;\n            {\n                scheduleWork(function() {\n                    return performWork(request);\n                });\n            }\n        }\n        function enqueueFlush(request) {\n            if (request.flushScheduled === false && // If there are pinged tasks we are going to flush anyway after work completes\n            request.pingedTasks.length === 0 && // If there is no destination there is nothing we can flush to. A flush will\n            // happen when we start flowing again\n            request.destination !== null) {\n                var destination = request.destination;\n                request.flushScheduled = true;\n                scheduleWork(function() {\n                    return flushCompletedQueues(request, destination);\n                });\n            }\n        }\n        function startFlowing(request, destination) {\n            if (request.status === CLOSING) {\n                request.status = CLOSED;\n                closeWithError(destination, request.fatalError);\n                return;\n            }\n            if (request.status === CLOSED) {\n                return;\n            }\n            if (request.destination !== null) {\n                // We're already flowing.\n                return;\n            }\n            request.destination = destination;\n            try {\n                flushCompletedQueues(request, destination);\n            } catch (error) {\n                logRecoverableError(request, error);\n                fatalError(request, error);\n            }\n        } // This is called to early terminate a request. It puts all pending boundaries in client rendered state.\n        function abort(request, reason) {\n            try {\n                var abortableTasks = request.abortableTasks;\n                if (abortableTasks.size > 0) {\n                    var error = reason === undefined ? new Error(\"The render was aborted by the server without a reason.\") : reason;\n                    abortableTasks.forEach(function(task) {\n                        return abortTask(task, request, error);\n                    });\n                    abortableTasks.clear();\n                }\n                if (request.destination !== null) {\n                    flushCompletedQueues(request, request.destination);\n                }\n            } catch (error) {\n                logRecoverableError(request, error);\n                fatalError(request, error);\n            }\n        }\n        function flushResources(request) {\n            enqueueFlush(request);\n        }\n        function getResources(request) {\n            return request.resources;\n        }\n        function onError$1() {}\n        function renderToStringImpl(children, options, generateStaticMarkup, abortReason, unstable_externalRuntimeSrc) {\n            var didFatal = false;\n            var fatalError = null;\n            var result = \"\";\n            var destination = {\n                // $FlowFixMe[missing-local-annot]\n                push: function(chunk) {\n                    if (chunk !== null) {\n                        result += chunk;\n                    }\n                    return true;\n                },\n                // $FlowFixMe[missing-local-annot]\n                destroy: function(error) {\n                    didFatal = true;\n                    fatalError = error;\n                }\n            };\n            var readyToStream = false;\n            function onShellReady() {\n                readyToStream = true;\n            }\n            var resources = createResources();\n            var request = createRequest(children, resources, createResponseState(resources, generateStaticMarkup, options ? options.identifierPrefix : undefined, unstable_externalRuntimeSrc), createRootFormatContext(), Infinity, onError$1, undefined, onShellReady, undefined, undefined);\n            startWork(request); // If anything suspended and is still pending, we'll abort it before writing.\n            // That way we write only client-rendered boundaries from the start.\n            abort(request, abortReason);\n            startFlowing(request, destination);\n            if (didFatal && fatalError !== abortReason) {\n                throw fatalError;\n            }\n            if (!readyToStream) {\n                // Note: This error message is the one we use on the client. It doesn't\n                // really make sense here. But this is the legacy server renderer, anyway.\n                // We're going to delete it soon.\n                throw new Error(\"A component suspended while responding to synchronous input. This \" + \"will cause the UI to be replaced with a loading indicator. To fix, \" + \"updates that suspend should be wrapped with startTransition.\");\n            }\n            return result;\n        }\n        var ReactMarkupReadableStream = /*#__PURE__*/ function(_Readable) {\n            _inheritsLoose(ReactMarkupReadableStream, _Readable);\n            function ReactMarkupReadableStream() {\n                var _this;\n                // Calls the stream.Readable(options) constructor. Consider exposing built-in\n                // features like highWaterMark in the future.\n                _this = _Readable.call(this, {}) || this;\n                _this.request = void 0;\n                _this.startedFlowing = void 0;\n                _this.request = null;\n                _this.startedFlowing = false;\n                return _this;\n            } // $FlowFixMe[missing-local-annot]\n            var _proto = ReactMarkupReadableStream.prototype;\n            _proto._destroy = function _destroy(err, callback) {\n                abort(this.request);\n                callback(err);\n            } // $FlowFixMe[missing-local-annot]\n            ;\n            _proto._read = function _read(size) {\n                if (this.startedFlowing) {\n                    startFlowing(this.request, this);\n                }\n            };\n            return ReactMarkupReadableStream;\n        }(stream.Readable);\n        function onError() {}\n        function renderToNodeStreamImpl(children, options, generateStaticMarkup) {\n            function onAllReady() {\n                // We wait until everything has loaded before starting to write.\n                // That way we only end up with fully resolved HTML even if we suspend.\n                destination.startedFlowing = true;\n                startFlowing(request, destination);\n            }\n            var destination = new ReactMarkupReadableStream();\n            var resources = createResources();\n            var request = createRequest(children, resources, createResponseState(resources, false, options ? options.identifierPrefix : undefined), createRootFormatContext(), Infinity, onError, onAllReady, undefined, undefined);\n            destination.request = request;\n            startWork(request);\n            return destination;\n        }\n        function renderToNodeStream(children, options) {\n            {\n                error(\"renderToNodeStream is deprecated. Use renderToPipeableStream instead.\");\n            }\n            return renderToNodeStreamImpl(children, options);\n        }\n        function renderToStaticNodeStream(children, options) {\n            return renderToNodeStreamImpl(children, options);\n        }\n        function renderToString(children, options) {\n            return renderToStringImpl(children, options, false, 'The server used \"renderToString\" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to \"renderToPipeableStream\" which supports Suspense on the server');\n        }\n        function renderToStaticMarkup(children, options) {\n            return renderToStringImpl(children, options, true, 'The server used \"renderToStaticMarkup\" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to \"renderToPipeableStream\" which supports Suspense on the server');\n        }\n        exports.renderToNodeStream = renderToNodeStream;\n        exports.renderToStaticMarkup = renderToStaticMarkup;\n        exports.renderToStaticNodeStream = renderToStaticNodeStream;\n        exports.renderToString = renderToString;\n        exports.version = ReactVersion;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLXNlcnZlci1sZWdhY3kubm9kZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUNIO1FBRUEsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUMsd0ZBQTBCO1FBQzlDLElBQUlDLFdBQVdELG1CQUFPQSxDQUFDO1FBQ3ZCLElBQUlFLFNBQVNGLG1CQUFPQSxDQUFDO1FBRXJCLElBQUlHLGVBQWU7UUFFbkIsSUFBSUMsdUJBQXVCTCxNQUFNTSxrREFBa0Q7UUFFbkYsK0NBQStDO1FBQy9DLEVBQUU7UUFDRiw4REFBOEQ7UUFDOUQscUNBQXFDO1FBRXJDLFNBQVNDLEtBQUtDLE1BQU07WUFDbEI7Z0JBQ0U7b0JBQ0UsSUFBSyxJQUFJQyxPQUFPQyxVQUFVQyxNQUFNLEVBQUVDLE9BQU8sSUFBSUMsTUFBTUosT0FBTyxJQUFJQSxPQUFPLElBQUksSUFBSUssT0FBTyxHQUFHQSxPQUFPTCxNQUFNSyxPQUFRO3dCQUMxR0YsSUFBSSxDQUFDRSxPQUFPLEVBQUUsR0FBR0osU0FBUyxDQUFDSSxLQUFLO29CQUNsQztvQkFFQUMsYUFBYSxRQUFRUCxRQUFRSTtnQkFDL0I7WUFDRjtRQUNGO1FBQ0EsU0FBU0ksTUFBTVIsTUFBTTtZQUNuQjtnQkFDRTtvQkFDRSxJQUFLLElBQUlTLFFBQVFQLFVBQVVDLE1BQU0sRUFBRUMsT0FBTyxJQUFJQyxNQUFNSSxRQUFRLElBQUlBLFFBQVEsSUFBSSxJQUFJQyxRQUFRLEdBQUdBLFFBQVFELE9BQU9DLFFBQVM7d0JBQ2pITixJQUFJLENBQUNNLFFBQVEsRUFBRSxHQUFHUixTQUFTLENBQUNRLE1BQU07b0JBQ3BDO29CQUVBSCxhQUFhLFNBQVNQLFFBQVFJO2dCQUNoQztZQUNGO1FBQ0Y7UUFFQSxTQUFTRyxhQUFhSSxLQUFLLEVBQUVY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QUFhO2FBQWE7WUFBRTtnQkFBQztnQkFBYTthQUFhO1lBQUU7Z0JBQUM7Z0JBQWU7YUFBZTtZQUFFO2dCQUFDO2dCQUFvQjthQUFvQjtZQUFFO2dCQUFDO2dCQUFxQjthQUFxQjtZQUFFO2dCQUFDO2dCQUFjO2FBQWM7WUFBRTtnQkFBQztnQkFBWTthQUFXO1lBQUU7Z0JBQUM7Z0JBQWlCO2FBQWlCO1lBQUU7Z0JBQUM7Z0JBQW1CO2FBQW1CO1lBQUU7Z0JBQUM7Z0JBQWtCO2FBQWtCO1lBQUU7Z0JBQUM7Z0JBQWE7YUFBYTtZQUFFO2dCQUFDO2dCQUFlO2FBQWU7WUFBRTtnQkFBQztnQkFBeUI7YUFBeUI7WUFBRTtnQkFBQztnQkFBMEI7YUFBMEI7WUFBRTtnQkFBQztnQkFBbUI7YUFBbUI7WUFBRTtnQkFBQztnQkFBb0I7YUFBb0I7WUFBRTtnQkFBQztnQkFBaUI7YUFBaUI7WUFBRTtnQkFBQztnQkFBa0I7YUFBa0I7WUFBRTtnQkFBQztnQkFBb0I7YUFBb0I7WUFBRTtnQkFBQztnQkFBaUI7YUFBaUI7WUFBRTtnQkFBQztnQkFBZTthQUFlO1lBQUU7Z0JBQUM7Z0JBQWM7YUFBYztZQUFFO2dCQUFDO2dCQUFrQjthQUFrQjtZQUFFO2dCQUFDO2dCQUFpQjthQUFpQjtZQUFFO2dCQUFDO2dCQUFtQjthQUFtQjtZQUFFO2dCQUFDO2dCQUFxQjthQUFxQjtZQUFFO2dCQUFDO2dCQUFzQjthQUFzQjtZQUFFO2dCQUFDO2dCQUFlO2FBQWU7WUFBRTtnQkFBQztnQkFBZ0I7YUFBZ0I7WUFBRTtnQkFBQztnQkFBYzthQUFlO1lBQUU7Z0JBQUM7Z0JBQWU7YUFBZTtZQUFFO2dCQUFDO2dCQUFZO2FBQVk7WUFBRTtnQkFBQztnQkFBZ0I7YUFBZ0I7WUFBRTtnQkFBQztnQkFBaUI7YUFBaUI7WUFBRTtnQkFBQztnQkFBZ0I7YUFBZ0I7WUFBRTtnQkFBQztnQkFBWTthQUFhO1lBQUU7Z0JBQUM7Z0JBQWU7YUFBZ0I7WUFBRTtnQkFBQztnQkFBZTthQUFnQjtZQUFFO2dCQUFDO2dCQUFlO2FBQWU7WUFBRTtnQkFBQztnQkFBZTthQUFlO1lBQUU7Z0JBQUM7Z0JBQWM7YUFBYztZQUFFO2dCQUFDO2dCQUFXO2FBQVc7U0FBQztRQUM5b0YsU0FBU0Msa0JBQW1CekIsSUFBSTtZQUM5QixPQUFPdUIsUUFBUUcsR0FBRyxDQUFDMUIsU0FBU0E7UUFDOUI7UUFFQSxJQUFJMkIsbUJBQW1CO1lBQ3JCQyxRQUFRO1lBQ1JDLFVBQVU7WUFDVkMsT0FBTztZQUNQQyxRQUFRO1lBQ1JDLE9BQU87WUFDUEMsT0FBTztZQUNQQyxRQUFRO1FBQ1Y7UUFDQSxTQUFTQywwQkFBMEJDLE9BQU8sRUFBRUMsS0FBSztZQUMvQztnQkFDRSxJQUFJLENBQUVWLENBQUFBLGdCQUFnQixDQUFDVSxNQUFNdEMsSUFBSSxDQUFDLElBQUlzQyxNQUFNQyxRQUFRLElBQUlELE1BQU1FLE9BQU8sSUFBSUYsTUFBTUcsUUFBUSxJQUFJSCxNQUFNSSxRQUFRLElBQUlKLE1BQU12RCxLQUFLLElBQUksSUFBRyxHQUFJO29CQUNqSXJDLE1BQU0sNERBQTRELGdFQUFnRSxnRUFBZ0U7Z0JBQ3BNO2dCQUVBLElBQUksQ0FBRTRGLENBQUFBLE1BQU1DLFFBQVEsSUFBSUQsTUFBTUcsUUFBUSxJQUFJSCxNQUFNSSxRQUFRLElBQUlKLE1BQU1LLE9BQU8sSUFBSSxJQUFHLEdBQUk7b0JBQ2xGakcsTUFBTSw4REFBOEQsZ0VBQWdFLGtFQUFrRTtnQkFDeE07WUFDRjtRQUNGO1FBRUEsSUFBSWtHLGlCQUFpQjtZQUNuQixnQkFBZ0I7WUFDaEIsUUFBUTtZQUNSLG9CQUFvQjtZQUNwQixnQkFBZ0I7WUFDaEIsaUJBQWlCO1lBQ2pCLFFBQVE7WUFDUixlQUFlO1lBQ2YsUUFBUTtZQUNSLGdCQUFnQjtZQUNoQixRQUFRO1lBQ1IscUJBQXFCO1lBQ3JCLGNBQWM7WUFDZCx3QkFBd0I7WUFDeEIsb0JBQW9CO1lBQ3BCLHFCQUFxQjtZQUNyQixnQkFBZ0I7WUFDaEIsaUJBQWlCO1lBQ2pCLGlCQUFpQjtZQUNqQixjQUFjO1lBQ2QsY0FBYztZQUNkLGtCQUFrQjtZQUNsQix3QkFBd0I7WUFDeEIsb0JBQW9CO1lBQ3BCLG9CQUFvQjtZQUNwQixnQkFBZ0I7WUFDaEIsaUJBQWlCO1lBQ2pCLGlCQUFpQjtZQUNqQixpQkFBaUI7WUFDakIsYUFBYTtZQUNiLGlCQUFpQjtZQUNqQixpQkFBaUI7WUFDakIsaUJBQWlCO1lBQ2pCLGtCQUFrQjtZQUNsQix5QkFBeUI7WUFDekIsZUFBZTtZQUNmLGFBQWE7WUFDYixhQUFhO1lBQ2IsaUJBQWlCO1lBQ2pCLDJCQUEyQjtZQUMzQixtQkFBbUI7WUFDbkIsZ0JBQWdCO1lBQ2hCLDBCQUEwQjtZQUMxQix5QkFBeUI7WUFDekIsaUJBQWlCO1lBQ2pCLGlCQUFpQjtZQUNqQixnQkFBZ0I7WUFDaEIsaUJBQWlCO1lBQ2pCLG9CQUFvQjtZQUNwQixxQkFBcUI7WUFDckIsZUFBZTtZQUNmLG1CQUFtQjtZQUNuQixhQUFhO1lBQ2IsaUJBQWlCO1lBQ2pCLGlCQUFpQjtZQUNqQixpQkFBaUI7WUFDakIsZ0JBQWdCO1lBQ2hCLGdCQUFnQjtRQUNsQjtRQUVBLElBQUlDLHFCQUFxQixDQUFDO1FBQzFCLElBQUlDLFVBQVUsSUFBSS9CLE9BQU8sY0FBY0Ysc0JBQXNCO1FBQzdELElBQUlrQyxlQUFlLElBQUloQyxPQUFPLGtCQUFrQkYsc0JBQXNCO1FBRXRFLFNBQVNtQyxtQkFBbUJYLE9BQU8sRUFBRXBDLElBQUk7WUFDdkM7Z0JBQ0UsSUFBSVUsZUFBZWpELElBQUksQ0FBQ21GLG9CQUFvQjVDLFNBQVM0QyxrQkFBa0IsQ0FBQzVDLEtBQUssRUFBRTtvQkFDN0UsT0FBTztnQkFDVDtnQkFFQSxJQUFJOEMsYUFBYTVCLElBQUksQ0FBQ2xCLE9BQU87b0JBQzNCLElBQUlnRCxXQUFXLFVBQVVoRCxLQUFLaUQsS0FBSyxDQUFDLEdBQUdDLFdBQVc7b0JBQ2xELElBQUlDLGNBQWNSLGVBQWVqQyxjQUFjLENBQUNzQyxZQUFZQSxXQUFXLE1BQU0scUVBQXFFO29CQUNsSiwwREFBMEQ7b0JBRTFELElBQUlHLGVBQWUsTUFBTTt3QkFDdkIxRyxNQUFNLGlHQUFpR3VEO3dCQUV2RzRDLGtCQUFrQixDQUFDNUMsS0FBSyxHQUFHO3dCQUMzQixPQUFPO29CQUNULEVBQUUsd0VBQXdFO29CQUcxRSxJQUFJQSxTQUFTbUQsYUFBYTt3QkFDeEIxRyxNQUFNLG1EQUFtRHVELE1BQU1tRDt3QkFFL0RQLGtCQUFrQixDQUFDNUMsS0FBSyxHQUFHO3dCQUMzQixPQUFPO29CQUNUO2dCQUNGO2dCQUVBLElBQUk2QyxRQUFRM0IsSUFBSSxDQUFDbEIsT0FBTztvQkFDdEIsSUFBSW9ELGlCQUFpQnBELEtBQUtrRCxXQUFXO29CQUNyQyxJQUFJRyxlQUFlVixlQUFlakMsY0FBYyxDQUFDMEMsa0JBQWtCQSxpQkFBaUIsTUFBTSxxRUFBcUU7b0JBQy9KLDBEQUEwRDtvQkFFMUQsSUFBSUMsZ0JBQWdCLE1BQU07d0JBQ3hCVCxrQkFBa0IsQ0FBQzVDLEtBQUssR0FBRzt3QkFDM0IsT0FBTztvQkFDVCxFQUFFLHdFQUF3RTtvQkFHMUUsSUFBSUEsU0FBU3FELGNBQWM7d0JBQ3pCNUcsTUFBTSxtREFBbUR1RCxNQUFNcUQ7d0JBRS9EVCxrQkFBa0IsQ0FBQzVDLEtBQUssR0FBRzt3QkFDM0IsT0FBTztvQkFDVDtnQkFDRjtZQUNGO1lBRUEsT0FBTztRQUNUO1FBRUEsU0FBU3NELHFCQUFxQnZELElBQUksRUFBRXNDLEtBQUs7WUFDdkM7Z0JBQ0UsSUFBSWtCLGVBQWUsRUFBRTtnQkFFckIsSUFBSyxJQUFJMUUsT0FBT3dELE1BQU87b0JBQ3JCLElBQUltQixVQUFVVCxtQkFBbUJoRCxNQUFNbEI7b0JBRXZDLElBQUksQ0FBQzJFLFNBQVM7d0JBQ1pELGFBQWFyRixJQUFJLENBQUNXO29CQUNwQjtnQkFDRjtnQkFFQSxJQUFJNEUsb0JBQW9CRixhQUFhckcsR0FBRyxDQUFDLFNBQVV3RyxJQUFJO29CQUNyRCxPQUFPLE1BQU1BLE9BQU87Z0JBQ3RCLEdBQUdDLElBQUksQ0FBQztnQkFFUixJQUFJSixhQUFhbkgsTUFBTSxLQUFLLEdBQUc7b0JBQzdCSyxNQUFNLHVDQUF1QyxnRUFBZ0VnSCxtQkFBbUIxRDtnQkFDbEksT0FBTyxJQUFJd0QsYUFBYW5ILE1BQU0sR0FBRyxHQUFHO29CQUNsQ0ssTUFBTSx3Q0FBd0MsZ0VBQWdFZ0gsbUJBQW1CMUQ7Z0JBQ25JO1lBQ0Y7UUFDRjtRQUVBLElBQUk2RCxtQkFBbUI7UUFDdkIsU0FBU0MscUJBQXFCOUQsSUFBSSxFQUFFc0MsS0FBSztZQUN2QztnQkFDRSxJQUFJdEMsU0FBUyxXQUFXQSxTQUFTLGNBQWNBLFNBQVMsVUFBVTtvQkFDaEU7Z0JBQ0Y7Z0JBRUEsSUFBSXNDLFNBQVMsUUFBUUEsTUFBTXZELEtBQUssS0FBSyxRQUFRLENBQUM4RSxrQkFBa0I7b0JBQzlEQSxtQkFBbUI7b0JBRW5CLElBQUk3RCxTQUFTLFlBQVlzQyxNQUFNeUIsUUFBUSxFQUFFO3dCQUN2Q3JILE1BQU0sOENBQThDLG9FQUFvRSxzRUFBc0VzRDtvQkFDaE0sT0FBTzt3QkFDTHRELE1BQU0sOENBQThDLDBFQUEwRSxnQ0FBZ0NzRDtvQkFDaEs7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsU0FBU2dFLGdCQUFnQjNCLE9BQU8sRUFBRUMsS0FBSztZQUNyQyxJQUFJRCxRQUFRNEIsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHO2dCQUMvQixPQUFPO1lBQ1Q7WUFFQSxPQUFRNUI7Z0JBQ04sOENBQThDO2dCQUM5Qyx1RUFBdUU7Z0JBQ3ZFLGlGQUFpRjtnQkFDakYsaUZBQWlGO2dCQUNqRixLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7b0JBQ0gsT0FBTztnQkFFVDtvQkFDRSxPQUFPO1lBQ1g7UUFDRjtRQUVBLCtFQUErRTtRQUMvRSxtRUFBbUU7UUFDbkUsWUFBWTtRQUNaLElBQUk2Qix3QkFBd0I7WUFDMUIsT0FBTztZQUNQQyxRQUFRO1lBQ1JDLGVBQWU7WUFDZixrQkFBa0I7WUFDbEJDLFdBQVc7WUFDWEMsUUFBUTtZQUNSQyxpQkFBaUI7WUFDakJDLEtBQUs7WUFDTEMsSUFBSTtZQUNKQyxPQUFPO1lBQ1BDLGdCQUFnQjtZQUNoQkMsY0FBYztZQUNkQyxhQUFhO1lBQ2JDLFdBQVc7WUFDWEMsVUFBVTtZQUNWQyxVQUFVO1lBQ1ZDLFNBQVM7WUFDVEMsYUFBYTtZQUNiQyxhQUFhO1lBQ2JDLFdBQVc7WUFDWEMsU0FBUztZQUNUMUMsU0FBUztZQUNUMkMsVUFBVTtZQUNWQyxNQUFNO1lBQ05DLE9BQU87WUFDUEMsU0FBUztZQUNUQyxXQUFXO1lBQ1hDLE1BQU07WUFDTkMsU0FBUztZQUNUckgsU0FBUztZQUNUc0gsaUJBQWlCO1lBQ2pCQyxhQUFhO1lBQ2JDLFVBQVU7WUFDVkMsY0FBYztZQUNkQyxRQUFRO1lBQ1JDLGFBQWE7WUFDYkMseUJBQXlCO1lBQ3pCQyxNQUFNO1lBQ05DLFVBQVU7WUFDVkMsU0FBUztZQUNUQyxnQkFBZ0I7WUFDaEJDLGNBQWM7WUFDZEMsT0FBTztZQUNQQyxLQUFLO1lBQ0xoRSxVQUFVO1lBQ1ZpRSx5QkFBeUI7WUFDekJDLHVCQUF1QjtZQUN2QkMsVUFBVTtZQUNWQyxXQUFXO1lBQ1hDLFNBQVM7WUFDVEMsY0FBYztZQUNkQyxlQUFlO1lBQ2ZDLEtBQUs7WUFDTEMsTUFBTTtZQUNOQyxZQUFZO1lBQ1pDLFlBQVk7WUFDWkMsYUFBYTtZQUNiQyxnQkFBZ0I7WUFDaEJDLFlBQVk7WUFDWkMsYUFBYTtZQUNiQyxTQUFTO1lBQ1RDLFFBQVE7WUFDUjNGLFFBQVE7WUFDUjRGLE1BQU07WUFDTkMsTUFBTTtZQUNOQyxVQUFVO1lBQ1ZDLFNBQVM7WUFDVEMsV0FBVztZQUNYLGNBQWM7WUFDZEMsTUFBTTtZQUNOQyxJQUFJO1lBQ0pDLFlBQVk7WUFDWkMsYUFBYTtZQUNiQyxXQUFXO1lBQ1hDLFdBQVc7WUFDWEMsV0FBVztZQUNYQyxJQUFJO1lBQ0pDLFFBQVE7WUFDUkMsVUFBVTtZQUNWQyxTQUFTO1lBQ1RDLFdBQVc7WUFDWEMsVUFBVTtZQUNWQyxXQUFXO1lBQ1hDLFNBQVM7WUFDVEMsTUFBTTtZQUNOQyxPQUFPO1lBQ1BDLE1BQU07WUFDTkMsTUFBTTtZQUNOQyxNQUFNO1lBQ05DLEtBQUs7WUFDTEMsVUFBVTtZQUNWQyxhQUFhO1lBQ2JDLGNBQWM7WUFDZEMsS0FBSztZQUNMQyxXQUFXO1lBQ1hDLE9BQU87WUFDUEMsWUFBWTtZQUNaQyxRQUFRO1lBQ1JDLEtBQUs7WUFDTEMsV0FBVztZQUNYaEcsVUFBVTtZQUNWaUcsT0FBTztZQUNQL0osTUFBTTtZQUNOZ0ssVUFBVTtZQUNWQyxPQUFPO1lBQ1BDLFlBQVk7WUFDWkMsTUFBTTtZQUNOQyxTQUFTO1lBQ1RDLFNBQVM7WUFDVEMsYUFBYTtZQUNiQyxhQUFhO1lBQ2JDLFFBQVE7WUFDUkMsU0FBUztZQUNUQyxTQUFTO1lBQ1RDLFlBQVk7WUFDWkMsVUFBVTtZQUNWQyxnQkFBZ0I7WUFDaEJDLEtBQUs7WUFDTEMsVUFBVTtZQUNWQyxVQUFVO1lBQ1ZDLE1BQU07WUFDTkMsTUFBTTtZQUNOQyxTQUFTO1lBQ1RDLFNBQVM7WUFDVEMsT0FBTztZQUNQQyxRQUFRO1lBQ1JDLFdBQVc7WUFDWEMsVUFBVTtZQUNWQyxVQUFVO1lBQ1ZDLE9BQU87WUFDUEMsTUFBTTtZQUNOQyxPQUFPO1lBQ1BDLE1BQU07WUFDTkMsWUFBWTtZQUNaQyxLQUFLO1lBQ0xDLFFBQVE7WUFDUkMsU0FBUztZQUNUQyxRQUFRO1lBQ1JDLE9BQU87WUFDUEMsTUFBTTtZQUNOQyxPQUFPO1lBQ1BDLFNBQVM7WUFDVEMsVUFBVTtZQUNWQyxRQUFRO1lBQ1JDLE9BQU87WUFDUDFNLE1BQU07WUFDTjJNLFFBQVE7WUFDUjVOLE9BQU87WUFDUDZOLE9BQU87WUFDUEMsT0FBTztZQUNQQyxNQUFNO1lBQ04sTUFBTTtZQUNOQyxPQUFPO1lBQ1BDLGNBQWM7WUFDZCxpQkFBaUI7WUFDakJDLFlBQVk7WUFDWkMsVUFBVTtZQUNWQyxtQkFBbUI7WUFDbkIsc0JBQXNCO1lBQ3RCQyxjQUFjO1lBQ2RDLFlBQVk7WUFDWkMsV0FBVztZQUNYQyxZQUFZO1lBQ1osZUFBZTtZQUNmQyxRQUFRO1lBQ1JDLGVBQWU7WUFDZkMsZUFBZTtZQUNmQyxhQUFhO1lBQ2JDLFNBQVM7WUFDVEMsZUFBZTtZQUNmQyxlQUFlO1lBQ2Ysa0JBQWtCO1lBQ2xCQyxhQUFhO1lBQ2JDLE1BQU07WUFDTkMsT0FBTztZQUNQQyxNQUFNO1lBQ05DLElBQUk7WUFDSkMsVUFBVTtZQUNWQyxXQUFXO1lBQ1gsY0FBYztZQUNkQyxNQUFNO1lBQ05DLFVBQVU7WUFDVixhQUFhO1lBQ2JDLGVBQWU7WUFDZkMsVUFBVTtZQUNWLGFBQWE7WUFDYkMsT0FBTztZQUNQQyxvQkFBb0I7WUFDcEIsdUJBQXVCO1lBQ3ZCQywyQkFBMkI7WUFDM0IsK0JBQStCO1lBQy9CQyxjQUFjO1lBQ2QsaUJBQWlCO1lBQ2pCQyxnQkFBZ0I7WUFDaEIsbUJBQW1CO1lBQ25CQyxtQkFBbUI7WUFDbkJDLGtCQUFrQjtZQUNsQkMsUUFBUTtZQUNSQyxJQUFJO1lBQ0pDLElBQUk7WUFDSkMsR0FBRztZQUNIQyxVQUFVO1lBQ1ZDLFlBQVk7WUFDWkMsU0FBUztZQUNUQyxpQkFBaUI7WUFDakJDLFdBQVc7WUFDWEMsU0FBUztZQUNUQyxTQUFTO1lBQ1RDLGtCQUFrQjtZQUNsQixxQkFBcUI7WUFDckJDLEtBQUs7WUFDTEMsSUFBSTtZQUNKQyxJQUFJO1lBQ0pDLFVBQVU7WUFDVkMsV0FBVztZQUNYQyxrQkFBa0I7WUFDbEIscUJBQXFCO1lBQ3JCQyxLQUFLO1lBQ0xDLFVBQVU7WUFDVkMsMkJBQTJCO1lBQzNCQyxNQUFNO1lBQ05DLGFBQWE7WUFDYixnQkFBZ0I7WUFDaEJDLFVBQVU7WUFDVixhQUFhO1lBQ2JDLFFBQVE7WUFDUkMsV0FBVztZQUNYQyxhQUFhO1lBQ2JDLGNBQWM7WUFDZCxpQkFBaUI7WUFDakJDLFlBQVk7WUFDWixlQUFlO1lBQ2ZDLFdBQVc7WUFDWEMsWUFBWTtZQUNaLGVBQWU7WUFDZkMsVUFBVTtZQUNWLGFBQWE7WUFDYkMsZ0JBQWdCO1lBQ2hCLG9CQUFvQjtZQUNwQkMsYUFBYTtZQUNiLGdCQUFnQjtZQUNoQkMsV0FBVztZQUNYLGNBQWM7WUFDZEMsYUFBYTtZQUNiLGdCQUFnQjtZQUNoQkMsWUFBWTtZQUNaLGVBQWU7WUFDZm5WLFFBQVE7WUFDUm9WLE1BQU07WUFDTkMsSUFBSTtZQUNKQyxJQUFJO1lBQ0pDLElBQUk7WUFDSkMsSUFBSTtZQUNKQyxXQUFXO1lBQ1gsY0FBYztZQUNkQyw0QkFBNEI7WUFDNUIsZ0NBQWdDO1lBQ2hDQywwQkFBMEI7WUFDMUIsOEJBQThCO1lBQzlCQyxVQUFVO1lBQ1ZDLG1CQUFtQjtZQUNuQkMsZUFBZTtZQUNmQyxTQUFTO1lBQ1RDLFdBQVc7WUFDWCxlQUFlO1lBQ2ZDLGNBQWM7WUFDZCxrQkFBa0I7WUFDbEJDLGFBQWE7WUFDYkMsZ0JBQWdCO1lBQ2hCLG1CQUFtQjtZQUNuQkMsS0FBSztZQUNMQyxJQUFJO1lBQ0pDLFFBQVE7WUFDUkMsV0FBVztZQUNYQyxJQUFJO1lBQ0pDLElBQUk7WUFDSkMsSUFBSTtZQUNKQyxJQUFJO1lBQ0pDLEdBQUc7WUFDSEMsY0FBYztZQUNkQyxrQkFBa0I7WUFDbEJDLFNBQVM7WUFDVEMsV0FBVztZQUNYQyxZQUFZO1lBQ1pDLFVBQVU7WUFDVkMsY0FBYztZQUNkQyxlQUFlO1lBQ2Ysa0JBQWtCO1lBQ2xCQyxlQUFlO1lBQ2Ysa0JBQWtCO1lBQ2xCQyxtQkFBbUI7WUFDbkJDLE9BQU87WUFDUEMsV0FBVztZQUNYLGNBQWM7WUFDZEMsY0FBYztZQUNkQyxXQUFXO1lBQ1gsY0FBYztZQUNkQyxhQUFhO1lBQ2IsZ0JBQWdCO1lBQ2hCQyxhQUFhO1lBQ2JDLGFBQWE7WUFDYkMsTUFBTTtZQUNOQyxrQkFBa0I7WUFDbEJDLFdBQVc7WUFDWEMsY0FBYztZQUNkQyxNQUFNO1lBQ05DLFlBQVk7WUFDWkMsUUFBUTtZQUNSQyxTQUFTO1lBQ1RDLFVBQVU7WUFDVkMsT0FBTztZQUNQQyxRQUFRO1lBQ1JDLGFBQWE7WUFDYkMsUUFBUTtZQUNSQyxVQUFVO1lBQ1ZDLGtCQUFrQjtZQUNsQixxQkFBcUI7WUFDckJDLG1CQUFtQjtZQUNuQixzQkFBc0I7WUFDdEJDLFlBQVk7WUFDWixlQUFlO1lBQ2ZDLFNBQVM7WUFDVCxZQUFZO1lBQ1pDLFlBQVk7WUFDWkMscUJBQXFCO1lBQ3JCQyxrQkFBa0I7WUFDbEJDLGNBQWM7WUFDZEMsZUFBZTtZQUNmLGtCQUFrQjtZQUNsQkMsUUFBUTtZQUNSQyxXQUFXO1lBQ1hDLFdBQVc7WUFDWEMsV0FBVztZQUNYQyxRQUFRO1lBQ1JDLGVBQWU7WUFDZkMscUJBQXFCO1lBQ3JCQyxnQkFBZ0I7WUFDaEJDLFVBQVU7WUFDVkMsR0FBRztZQUNIQyxRQUFRO1lBQ1JDLE1BQU07WUFDTkMsTUFBTTtZQUNOQyxpQkFBaUI7WUFDakIsb0JBQW9CO1lBQ3BCQyxhQUFhO1lBQ2JDLFdBQVc7WUFDWEMsb0JBQW9CO1lBQ3BCQyxrQkFBa0I7WUFDbEJDLFVBQVU7WUFDVkMsU0FBUztZQUNUQyxRQUFRO1lBQ1JDLFNBQVM7WUFDVEMsUUFBUTtZQUNSQyxJQUFJO1lBQ0pDLElBQUk7WUFDSkMsT0FBTztZQUNQQyxVQUFVO1lBQ1ZDLE1BQU07WUFDTkMsZ0JBQWdCO1lBQ2hCLG1CQUFtQjtZQUNuQkMsT0FBTztZQUNQQyxTQUFTO1lBQ1RDLGtCQUFrQjtZQUNsQkMsa0JBQWtCO1lBQ2xCQyxPQUFPO1lBQ1BDLGNBQWM7WUFDZEMsYUFBYTtZQUNiQyxjQUFjO1lBQ2RDLE9BQU87WUFDUEMsT0FBTztZQUNQQyxhQUFhO1lBQ2JDLFdBQVc7WUFDWCxjQUFjO1lBQ2RDLGFBQWE7WUFDYixnQkFBZ0I7WUFDaEJDLHVCQUF1QjtZQUN2QiwwQkFBMEI7WUFDMUJDLHdCQUF3QjtZQUN4QiwyQkFBMkI7WUFDM0JDLFFBQVE7WUFDUkMsUUFBUTtZQUNSQyxpQkFBaUI7WUFDakIsb0JBQW9CO1lBQ3BCQyxrQkFBa0I7WUFDbEIscUJBQXFCO1lBQ3JCQyxlQUFlO1lBQ2Ysa0JBQWtCO1lBQ2xCQyxnQkFBZ0I7WUFDaEIsbUJBQW1CO1lBQ25CQyxrQkFBa0I7WUFDbEIscUJBQXFCO1lBQ3JCQyxhQUFhO1lBQ2IsZ0JBQWdCO1lBQ2hCQyxlQUFlO1lBQ2Ysa0JBQWtCO1lBQ2xCQyxnQ0FBZ0M7WUFDaENDLDBCQUEwQjtZQUMxQkMsY0FBYztZQUNkQyxnQkFBZ0I7WUFDaEJDLGFBQWE7WUFDYkMsU0FBUztZQUNUQyxTQUFTO1lBQ1RDLFlBQVk7WUFDWixlQUFlO1lBQ2ZDLGdCQUFnQjtZQUNoQixtQkFBbUI7WUFDbkJDLFlBQVk7WUFDWkMsZUFBZTtZQUNmLGtCQUFrQjtZQUNsQkMsSUFBSTtZQUNKQyxXQUFXO1lBQ1hDLGlCQUFpQjtZQUNqQixvQkFBb0I7WUFDcEJDLFFBQVE7WUFDUkMsSUFBSTtZQUNKQyxJQUFJO1lBQ0pDLG1CQUFtQjtZQUNuQixzQkFBc0I7WUFDdEJDLG9CQUFvQjtZQUNwQix1QkFBdUI7WUFDdkJDLFNBQVM7WUFDVEMsYUFBYTtZQUNiLGdCQUFnQjtZQUNoQkMsY0FBYztZQUNkLGlCQUFpQjtZQUNqQkMsWUFBWTtZQUNaLGdCQUFnQjtZQUNoQkMsY0FBYztZQUNkQyxhQUFhO1lBQ2IsZ0JBQWdCO1lBQ2hCQyxRQUFRO1lBQ1JDLGNBQWM7WUFDZCxpQkFBaUI7WUFDakJDLFNBQVM7WUFDVEMsVUFBVTtZQUNWLGNBQWM7WUFDZEMsYUFBYTtZQUNiLGlCQUFpQjtZQUNqQkMsYUFBYTtZQUNiLGlCQUFpQjtZQUNqQkMsVUFBVTtZQUNWLGFBQWE7WUFDYkMsY0FBYztZQUNkLGlCQUFpQjtZQUNqQkMsU0FBUztZQUNUQyxZQUFZO1lBQ1pDLFlBQVk7WUFDWkMsZUFBZTtZQUNmLGtCQUFrQjtZQUNsQkMsT0FBTztZQUNQQyxRQUFRO1lBQ1JDLGFBQWE7WUFDYixnQkFBZ0I7WUFDaEJDLGFBQWE7WUFDYixnQkFBZ0I7WUFDaEJDLElBQUk7WUFDSkMsSUFBSTtZQUNKQyxHQUFHO1lBQ0hDLGtCQUFrQjtZQUNsQkMsU0FBUztZQUNULFlBQVk7WUFDWkMsY0FBYztZQUNkLGlCQUFpQjtZQUNqQkMsY0FBYztZQUNkLGlCQUFpQjtZQUNqQkMsV0FBVztZQUNYLGNBQWM7WUFDZEMsV0FBVztZQUNYLGNBQWM7WUFDZEMsV0FBVztZQUNYLGNBQWM7WUFDZEMsWUFBWTtZQUNaLGVBQWU7WUFDZkMsV0FBVztZQUNYLGNBQWM7WUFDZEMsU0FBUztZQUNULFlBQVk7WUFDWkMsU0FBUztZQUNULFlBQVk7WUFDWkMsT0FBTztZQUNQLGFBQWE7WUFDYkMsWUFBWTtZQUNaLGVBQWU7WUFDZkMsVUFBVTtZQUNWQyxJQUFJO1lBQ0pDLElBQUk7WUFDSkMsR0FBRztZQUNIQyxrQkFBa0I7WUFDbEJDLEdBQUc7WUFDSEMsWUFBWTtRQUNkO1FBRUEsSUFBSUMsbUJBQW1CLENBQUM7UUFDeEIsSUFBSUMsbUJBQW1CO1FBQ3ZCLElBQUlDLDJCQUEyQjtRQUMvQixJQUFJQyxRQUFRLElBQUloYyxPQUFPLGNBQWNGLHNCQUFzQjtRQUMzRCxJQUFJbWMsYUFBYSxJQUFJamMsT0FBTyxrQkFBa0JGLHNCQUFzQjtRQUVwRSxTQUFTb2MsaUJBQWlCNWEsT0FBTyxFQUFFcEMsSUFBSSxFQUFFbEIsS0FBSyxFQUFFbWUsYUFBYTtZQUMzRDtnQkFDRSxJQUFJdmMsZUFBZWpELElBQUksQ0FBQ2tmLGtCQUFrQjNjLFNBQVMyYyxnQkFBZ0IsQ0FBQzNjLEtBQUssRUFBRTtvQkFDekUsT0FBTztnQkFDVDtnQkFFQSxJQUFJb0QsaUJBQWlCcEQsS0FBS2tELFdBQVc7Z0JBRXJDLElBQUlFLG1CQUFtQixlQUFlQSxtQkFBbUIsY0FBYztvQkFDckUzRyxNQUFNLHdFQUF3RSw0RUFBNEU7b0JBRTFKa2dCLGdCQUFnQixDQUFDM2MsS0FBSyxHQUFHO29CQUN6QixPQUFPO2dCQUNUO2dCQUdBLElBQUlpZCxpQkFBaUIsTUFBTTtvQkFDekIsSUFBSUMsK0JBQStCRCxjQUFjQyw0QkFBNEIsRUFDekVDLDRCQUE0QkYsY0FBY0UseUJBQXlCO29CQUV2RSxJQUFJRCw2QkFBNkJ4YyxjQUFjLENBQUNWLE9BQU87d0JBQ3JELE9BQU87b0JBQ1Q7b0JBRUEsSUFBSW9kLG1CQUFtQkQsMEJBQTBCemMsY0FBYyxDQUFDMEMsa0JBQWtCK1oseUJBQXlCLENBQUMvWixlQUFlLEdBQUc7b0JBRTlILElBQUlnYSxvQkFBb0IsTUFBTTt3QkFDNUIzZ0IsTUFBTSwyREFBMkR1RCxNQUFNb2Q7d0JBRXZFVCxnQkFBZ0IsQ0FBQzNjLEtBQUssR0FBRzt3QkFDekIsT0FBTztvQkFDVDtvQkFFQSxJQUFJNGMsaUJBQWlCMWIsSUFBSSxDQUFDbEIsT0FBTzt3QkFDL0J2RCxNQUFNLDREQUE0RHVEO3dCQUVsRTJjLGdCQUFnQixDQUFDM2MsS0FBSyxHQUFHO3dCQUN6QixPQUFPO29CQUNUO2dCQUNGLE9BQU8sSUFBSTRjLGlCQUFpQjFiLElBQUksQ0FBQ2xCLE9BQU87b0JBQ3RDLDBFQUEwRTtvQkFDMUUsNEVBQTRFO29CQUM1RSxxRkFBcUY7b0JBQ3JGLElBQUk2Yyx5QkFBeUIzYixJQUFJLENBQUNsQixPQUFPO3dCQUN2Q3ZELE1BQU0sMENBQTBDLDRFQUE0RXVEO29CQUM5SDtvQkFFQTJjLGdCQUFnQixDQUFDM2MsS0FBSyxHQUFHO29CQUN6QixPQUFPO2dCQUNULEVBQUUsdURBQXVEO2dCQUd6RCxJQUFJOGMsTUFBTTViLElBQUksQ0FBQ2xCLFNBQVMrYyxXQUFXN2IsSUFBSSxDQUFDbEIsT0FBTztvQkFDN0MsT0FBTztnQkFDVDtnQkFFQSxJQUFJb0QsbUJBQW1CLGFBQWE7b0JBQ2xDM0csTUFBTSw2REFBNkQ7b0JBRW5Fa2dCLGdCQUFnQixDQUFDM2MsS0FBSyxHQUFHO29CQUN6QixPQUFPO2dCQUNUO2dCQUVBLElBQUlvRCxtQkFBbUIsUUFBUTtvQkFDN0IzRyxNQUFNLCtEQUErRDtvQkFFckVrZ0IsZ0JBQWdCLENBQUMzYyxLQUFLLEdBQUc7b0JBQ3pCLE9BQU87Z0JBQ1Q7Z0JBRUEsSUFBSW9ELG1CQUFtQixRQUFRdEUsVUFBVSxRQUFRQSxVQUFVdWUsYUFBYSxPQUFPdmUsVUFBVSxVQUFVO29CQUNqR3JDLE1BQU0sNEVBQTRFLDBCQUEwQixPQUFPcUM7b0JBRW5INmQsZ0JBQWdCLENBQUMzYyxLQUFLLEdBQUc7b0JBQ3pCLE9BQU87Z0JBQ1Q7Z0JBRUEsSUFBSSxPQUFPbEIsVUFBVSxZQUFZd2UsTUFBTXhlLFFBQVE7b0JBQzdDckMsTUFBTSxvRUFBb0UsMEJBQTBCdUQ7b0JBRXBHMmMsZ0JBQWdCLENBQUMzYyxLQUFLLEdBQUc7b0JBQ3pCLE9BQU87Z0JBQ1QsRUFBRSw2RUFBNkU7Z0JBRy9FLElBQUlpRSxzQkFBc0J2RCxjQUFjLENBQUMwQyxpQkFBaUI7b0JBQ3hELElBQUlDLGVBQWVZLHFCQUFxQixDQUFDYixlQUFlO29CQUV4RCxJQUFJQyxpQkFBaUJyRCxNQUFNO3dCQUN6QnZELE1BQU0saURBQWlEdUQsTUFBTXFEO3dCQUU3RHNaLGdCQUFnQixDQUFDM2MsS0FBSyxHQUFHO3dCQUN6QixPQUFPO29CQUNUO2dCQUNGLE9BQU8sSUFBSUEsU0FBU29ELGdCQUFnQjtvQkFDbEMsd0VBQXdFO29CQUN4RSw4Q0FBOEM7b0JBQzlDM0csTUFBTSxxRUFBcUUsNERBQTRELG9EQUFvRCxtRUFBbUUsNEJBQTRCdUQsTUFBTW9EO29CQUVoU3VaLGdCQUFnQixDQUFDM2MsS0FBSyxHQUFHO29CQUN6QixPQUFPO2dCQUNULEVBQUUsbURBQW1EO2dCQUNyRCxnQ0FBZ0M7Z0JBR2hDLE9BQVFBO29CQUNOLEtBQUs7b0JBQ0wsS0FBSztvQkFDTCxLQUFLO29CQUNMLEtBQUs7b0JBQ0wsS0FBSztvQkFDTCxLQUFLO29CQUVMLEtBQUs7b0JBQ0wsS0FBSzt3QkFDSDs0QkFDRSxPQUFPO3dCQUNUO2dCQUVKO2dCQUVBLE9BQVEsT0FBT2xCO29CQUNiLEtBQUs7d0JBQ0g7NEJBQ0UsT0FBUWtCO2dDQUNOLEtBQUs7Z0NBQ0wsS0FBSztnQ0FDTCxLQUFLO2dDQUNMLEtBQUs7Z0NBQ0wsS0FBSztnQ0FDTCxLQUFLO2dDQUNMLEtBQUs7Z0NBQ0wsS0FBSztnQ0FDTCxLQUFLO2dDQUNMLEtBQUs7Z0NBQ0wsS0FBSztnQ0FDTCxLQUFLO2dDQUNMLEtBQUs7Z0NBQ0wsS0FBSztnQ0FDTCxLQUFLO2dDQUNMLEtBQUs7Z0NBQ0wsS0FBSztnQ0FDTCxLQUFLO2dDQUNMLEtBQUs7Z0NBQ0wsS0FBSztnQ0FDTCxLQUFLO2dDQUNMLEtBQUs7Z0NBQ0wsS0FBSztnQ0FDTCxLQUFLO2dDQUNMLEtBQUs7Z0NBQ0wsS0FBSztnQ0FDTCxLQUFLO2dDQUNMLEtBQUs7Z0NBQ0wsS0FBSztnQ0FDTCxLQUFLO2dDQUNMLEtBQUs7Z0NBQ0wsS0FBSztnQ0FDTCxLQUFLO2dDQUNMLEtBQUs7Z0NBQ0wsS0FBSztnQ0FDTCxLQUFLO2dDQUNMLEtBQUs7b0NBQ0g7d0NBQ0UsK0NBQStDO3dDQUMvQyxPQUFPO29DQUNUO2dDQUVGO29DQUNFO3dDQUNFLElBQUkwVixTQUFTMVYsS0FBS2tELFdBQVcsR0FBR0QsS0FBSyxDQUFDLEdBQUc7d0NBRXpDLElBQUl5UyxXQUFXLFdBQVdBLFdBQVcsU0FBUzs0Q0FDNUMsT0FBTzt3Q0FDVDt3Q0FFQSxJQUFJNVcsT0FBTzs0Q0FDVHJDLE1BQU0sd0RBQXdELGdFQUFnRSxxQ0FBcUNxQyxPQUFPa0IsTUFBTUEsTUFBTWxCLE9BQU9rQjt3Q0FDL0wsT0FBTzs0Q0FDTHZELE1BQU0sd0RBQXdELGdFQUFnRSwwQ0FBMEMsd0VBQXdFLG9EQUFvRHFDLE9BQU9rQixNQUFNQSxNQUFNbEIsT0FBT2tCLE1BQU1BLE1BQU1BO3dDQUM1VTt3Q0FFQTJjLGdCQUFnQixDQUFDM2MsS0FBSyxHQUFHO3dDQUN6QixPQUFPO29DQUNUOzRCQUNKO3dCQUNGO29CQUVGLEtBQUs7b0JBQ0wsS0FBSzt3QkFDSCxzQkFBc0I7d0JBQ3RCLDRDQUE0Qzt3QkFDNUMyYyxnQkFBZ0IsQ0FBQzNjLEtBQUssR0FBRzt3QkFDekIsT0FBTztvQkFFVCxLQUFLO3dCQUNIOzRCQUNFLHNFQUFzRTs0QkFDdEUsSUFBSWxCLFVBQVUsV0FBV0EsVUFBVSxRQUFRO2dDQUN6QyxPQUFRa0I7b0NBQ04sS0FBSztvQ0FDTCxLQUFLO29DQUNMLEtBQUs7b0NBQ0wsS0FBSztvQ0FDTCxLQUFLO29DQUNMLEtBQUs7b0NBQ0wsS0FBSztvQ0FDTCxLQUFLO29DQUNMLEtBQUs7b0NBQ0wsS0FBSztvQ0FDTCxLQUFLO29DQUNMLEtBQUs7b0NBQ0wsS0FBSztvQ0FDTCxLQUFLO29DQUNMLEtBQUs7b0NBQ0wsS0FBSztvQ0FDTCxLQUFLO29DQUNMLEtBQUs7b0NBQ0wsS0FBSztvQ0FDTCxLQUFLO29DQUNMLEtBQUs7b0NBQ0wsS0FBSztvQ0FDTCxLQUFLO29DQUNMLEtBQUs7b0NBQ0wsS0FBSztvQ0FDTCxLQUFLO3dDQUNIOzRDQUNFO3dDQUNGO29DQUVGO3dDQUNFOzRDQUNFLE9BQU87d0NBQ1Q7Z0NBQ0o7Z0NBRUF2RCxNQUFNLDhEQUE4RCxRQUFRLHlCQUF5QnFDLE9BQU9rQixNQUFNbEIsVUFBVSxVQUFVLHFEQUFxRCxxRkFBcUZrQixNQUFNbEI7Z0NBRXRSNmQsZ0JBQWdCLENBQUMzYyxLQUFLLEdBQUc7Z0NBQ3pCLE9BQU87NEJBQ1Q7d0JBQ0Y7Z0JBQ0o7Z0JBRUEsT0FBTztZQUNUO1FBQ0Y7UUFFQSxTQUFTdWQsc0JBQXNCeGQsSUFBSSxFQUFFc0MsS0FBSyxFQUFFNGEsYUFBYTtZQUN2RDtnQkFDRSxJQUFJTyxlQUFlLEVBQUU7Z0JBRXJCLElBQUssSUFBSTNlLE9BQU93RCxNQUFPO29CQUNyQixJQUFJbUIsVUFBVXdaLGlCQUFpQmpkLE1BQU1sQixLQUFLd0QsS0FBSyxDQUFDeEQsSUFBSSxFQUFFb2U7b0JBRXRELElBQUksQ0FBQ3paLFNBQVM7d0JBQ1pnYSxhQUFhdGYsSUFBSSxDQUFDVztvQkFDcEI7Z0JBQ0Y7Z0JBRUEsSUFBSTRFLG9CQUFvQitaLGFBQWF0Z0IsR0FBRyxDQUFDLFNBQVV3RyxJQUFJO29CQUNyRCxPQUFPLE1BQU1BLE9BQU87Z0JBQ3RCLEdBQUdDLElBQUksQ0FBQztnQkFFUixJQUFJNlosYUFBYXBoQixNQUFNLEtBQUssR0FBRztvQkFDN0JLLE1BQU0sK0VBQStFLDZEQUE2RCxpRUFBaUVnSCxtQkFBbUIxRDtnQkFDeE8sT0FBTyxJQUFJeWQsYUFBYXBoQixNQUFNLEdBQUcsR0FBRztvQkFDbENLLE1BQU0sbUZBQW1GLCtEQUErRCxpRUFBaUVnSCxtQkFBbUIxRDtnQkFDOU87WUFDRjtRQUNGO1FBRUEsU0FBUzBkLG1CQUFtQjFkLElBQUksRUFBRXNDLEtBQUssRUFBRTRhLGFBQWE7WUFDcEQsSUFBSWxaLGdCQUFnQmhFLFNBQVMsT0FBT3NDLE1BQU1rRyxFQUFFLEtBQUssVUFBVTtnQkFDekQ7WUFDRjtZQUVBZ1Ysc0JBQXNCeGQsTUFBTXNDLE9BQU80YTtRQUNyQztRQUVBLHlFQUF5RTtRQUN6RSxJQUFJUyw4QkFBOEI7UUFDbEMsSUFBSUMsY0FBYztRQUNsQixJQUFJQyxnQkFBZ0IsU0FBUyw2Q0FBNkM7UUFFMUUsSUFBSUMsb0NBQW9DO1FBQ3hDLElBQUlDLG1CQUFtQixDQUFDO1FBQ3hCLElBQUlDLG9CQUFvQixDQUFDO1FBQ3pCLElBQUlDLG9CQUFvQjtRQUN4QixJQUFJQyx5QkFBeUI7UUFFN0IsU0FBU0MsU0FBU2hHLE1BQU07WUFDdEIsT0FBT0EsT0FBT2lHLE9BQU8sQ0FBQ1AsZUFBZSxTQUFVUSxDQUFDLEVBQUVDLFNBQVM7Z0JBQ3pELE9BQU9BLFVBQVVDLFdBQVc7WUFDOUI7UUFDRjtRQUVBLFNBQVNDLHdCQUF3QnZlLElBQUk7WUFDbkM7Z0JBQ0UsSUFBSThkLGlCQUFpQnBkLGNBQWMsQ0FBQ1YsU0FBUzhkLGdCQUFnQixDQUFDOWQsS0FBSyxFQUFFO29CQUNuRTtnQkFDRjtnQkFFQThkLGdCQUFnQixDQUFDOWQsS0FBSyxHQUFHO2dCQUV6QnZELE1BQU0sbURBQW1EdUQsTUFDekQsK0VBQStFO2dCQUMvRSxrQ0FBa0M7Z0JBQ2xDa2UsU0FBU2xlLEtBQUttZSxPQUFPLENBQUNSLGFBQWE7WUFDckM7UUFDRjtRQUVBLFNBQVNhLHlCQUF5QnhlLElBQUk7WUFDcEM7Z0JBQ0UsSUFBSThkLGlCQUFpQnBkLGNBQWMsQ0FBQ1YsU0FBUzhkLGdCQUFnQixDQUFDOWQsS0FBSyxFQUFFO29CQUNuRTtnQkFDRjtnQkFFQThkLGdCQUFnQixDQUFDOWQsS0FBSyxHQUFHO2dCQUV6QnZELE1BQU0sbUVBQW1FdUQsTUFBTUEsS0FBS3llLE1BQU0sQ0FBQyxHQUFHSCxXQUFXLEtBQUt0ZSxLQUFLaUQsS0FBSyxDQUFDO1lBQzNIO1FBQ0Y7UUFFQSxTQUFTeWIsNEJBQTRCMWUsSUFBSSxFQUFFbEIsS0FBSztZQUM5QztnQkFDRSxJQUFJaWYsa0JBQWtCcmQsY0FBYyxDQUFDNUIsVUFBVWlmLGlCQUFpQixDQUFDamYsTUFBTSxFQUFFO29CQUN2RTtnQkFDRjtnQkFFQWlmLGlCQUFpQixDQUFDamYsTUFBTSxHQUFHO2dCQUUzQnJDLE1BQU0sMERBQTBELHlCQUF5QnVELE1BQU1sQixNQUFNcWYsT0FBTyxDQUFDTixtQ0FBbUM7WUFDbEo7UUFDRjtRQUVBLFNBQVNjLG9CQUFvQjNlLElBQUksRUFBRWxCLEtBQUs7WUFDdEM7Z0JBQ0UsSUFBSWtmLG1CQUFtQjtvQkFDckI7Z0JBQ0Y7Z0JBRUFBLG9CQUFvQjtnQkFFcEJ2aEIsTUFBTSw4REFBOER1RDtZQUN0RTtRQUNGO1FBRUEsU0FBUzRlLHlCQUF5QjVlLElBQUksRUFBRWxCLEtBQUs7WUFDM0M7Z0JBQ0UsSUFBSW1mLHdCQUF3QjtvQkFDMUI7Z0JBQ0Y7Z0JBRUFBLHlCQUF5QjtnQkFFekJ4aEIsTUFBTSxtRUFBbUV1RDtZQUMzRTtRQUNGO1FBRUEsU0FBUzZlLGVBQWU3ZSxJQUFJLEVBQUVsQixLQUFLO1lBQ2pDO2dCQUNFLElBQUlrQixLQUFLZ0UsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHO29CQUMxQnVhLHdCQUF3QnZlO2dCQUMxQixPQUFPLElBQUkwZCw0QkFBNEJ4YyxJQUFJLENBQUNsQixPQUFPO29CQUNqRHdlLHlCQUF5QnhlO2dCQUMzQixPQUFPLElBQUk2ZCxrQ0FBa0MzYyxJQUFJLENBQUNwQyxRQUFRO29CQUN4RDRmLDRCQUE0QjFlLE1BQU1sQjtnQkFDcEM7Z0JBRUEsSUFBSSxPQUFPQSxVQUFVLFVBQVU7b0JBQzdCLElBQUl3ZSxNQUFNeGUsUUFBUTt3QkFDaEI2ZixvQkFBb0IzZTtvQkFDdEIsT0FBTyxJQUFJLENBQUM4ZSxTQUFTaGdCLFFBQVE7d0JBQzNCOGYseUJBQXlCNWU7b0JBQzNCO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBLDRDQUE0QztRQUM1QyxJQUFJK2Usa0JBQWtCO1FBQ3RCOzs7Ozs7Q0FNQyxHQUVELFNBQVNDLFdBQVc5RyxNQUFNO1lBQ3hCO2dCQUNFMVgsd0JBQXdCMFg7WUFDMUI7WUFFQSxJQUFJK0csTUFBTSxLQUFLL0c7WUFDZixJQUFJZ0gsUUFBUUgsZ0JBQWdCSSxJQUFJLENBQUNGO1lBRWpDLElBQUksQ0FBQ0MsT0FBTztnQkFDVixPQUFPRDtZQUNUO1lBRUEsSUFBSUc7WUFDSixJQUFJQyxPQUFPO1lBQ1gsSUFBSUM7WUFDSixJQUFJQyxZQUFZO1lBRWhCLElBQUtELFFBQVFKLE1BQU1JLEtBQUssRUFBRUEsUUFBUUwsSUFBSTdpQixNQUFNLEVBQUVrakIsUUFBUztnQkFDckQsT0FBUUwsSUFBSU8sVUFBVSxDQUFDRjtvQkFDckIsS0FBSzt3QkFDSCxJQUFJO3dCQUNKRixTQUFTO3dCQUNUO29CQUVGLEtBQUs7d0JBQ0gsSUFBSTt3QkFDSkEsU0FBUzt3QkFDVDtvQkFFRixLQUFLO3dCQUNILElBQUk7d0JBQ0pBLFNBQVMsVUFBVSwrQ0FBK0M7d0JBRWxFO29CQUVGLEtBQUs7d0JBQ0gsSUFBSTt3QkFDSkEsU0FBUzt3QkFDVDtvQkFFRixLQUFLO3dCQUNILElBQUk7d0JBQ0pBLFNBQVM7d0JBQ1Q7b0JBRUY7d0JBQ0U7Z0JBQ0o7Z0JBRUEsSUFBSUcsY0FBY0QsT0FBTztvQkFDdkJELFFBQVFKLElBQUloYyxLQUFLLENBQUNzYyxXQUFXRDtnQkFDL0I7Z0JBRUFDLFlBQVlELFFBQVE7Z0JBQ3BCRCxRQUFRRDtZQUNWO1lBRUEsT0FBT0csY0FBY0QsUUFBUUQsT0FBT0osSUFBSWhjLEtBQUssQ0FBQ3NjLFdBQVdELFNBQVNEO1FBQ3BFLEVBQUUsZ0RBQWdEO1FBRWxEOzs7OztDQUtDLEdBR0QsU0FBU0kscUJBQXFCQyxJQUFJO1lBQ2hDLElBQUksT0FBT0EsU0FBUyxhQUFhLE9BQU9BLFNBQVMsVUFBVTtnQkFDekQsc0VBQXNFO2dCQUN0RSx3RUFBd0U7Z0JBQ3hFLHVCQUF1QjtnQkFDdkIsT0FBTyxLQUFLQTtZQUNkO1lBRUEsT0FBT1YsV0FBV1U7UUFDcEI7UUFFQSxJQUFJQyxtQkFBbUI7UUFDdkIsSUFBSUMsWUFBWTtRQUNoQjs7Ozs7Ozs7Ozs7O0NBWUMsR0FFRCxTQUFTQyxtQkFBbUI3ZixJQUFJO1lBQzlCLE9BQU9BLEtBQUttZSxPQUFPLENBQUN3QixrQkFBa0IsT0FBT3pjLFdBQVcsR0FBR2liLE9BQU8sQ0FBQ3lCLFdBQVc7UUFDaEY7UUFFQSw2RUFBNkU7UUFDN0UsMkNBQTJDO1FBQzNDLHdDQUF3QztRQUN4QyxzREFBc0Q7UUFDdEQsa0VBQWtFO1FBQ2xFLHdDQUF3QztRQUN4QyxxREFBcUQ7UUFFckQsMEJBQTBCLEdBRTFCLElBQUlFLHVCQUF1QjtRQUMzQixJQUFJQyxVQUFVO1FBRWQsU0FBU0MsWUFBWUMsR0FBRztZQUN0Qiw2RUFBNkU7WUFDN0UsK0RBQStEO1lBQy9ELElBQUlDLGlCQUFpQixLQUFLRDtZQUUxQjtnQkFDRSxJQUFJLENBQUNGLFdBQVdELHFCQUFxQjVlLElBQUksQ0FBQ2dmLGlCQUFpQjtvQkFDekRILFVBQVU7b0JBRVZ0akIsTUFBTSxxRkFBcUYsb0ZBQW9GLCtEQUErRDBqQixLQUFLQyxTQUFTLENBQUNGO2dCQUMvUDtZQUNGO1lBRUEsT0FBT0Q7UUFDVDtRQUVBLElBQUlJLGNBQWMvakIsTUFBTWdrQixPQUFPLEVBQUUsd0NBQXdDO1FBRXpFLFNBQVNBLFFBQVFDLENBQUM7WUFDaEIsT0FBT0YsWUFBWUU7UUFDckI7UUFFQSx5RUFBeUU7UUFDekUsdURBQXVEO1FBQ3ZELElBQUlDLHVCQUF1QjtRQUMzQixJQUFJQyxtQkFBbUI7UUFDdkIsSUFBSUMsNkJBQTZCO1FBQ2pDLElBQUlDLGtCQUFrQjtRQUV0QixTQUFTQyw0Q0FBNENDLEtBQUs7WUFDeEQsT0FBT0EsVUFBVSxPQUFPLFdBQVdBLFVBQVV4RCxZQUFZLGdCQUFnQndELFVBQVUsS0FBSyxvQkFBb0IsMEJBQTJCLE9BQU9BLFFBQVE7UUFDeEo7UUFDQSxTQUFTQywwQ0FBMENELEtBQUs7WUFDdEQsT0FBT0EsVUFBVSxPQUFPLFdBQVdBLFVBQVV4RCxZQUFZLGdCQUFnQndELFVBQVUsS0FBSyxvQkFBb0IsT0FBT0EsVUFBVSxXQUFXVixLQUFLQyxTQUFTLENBQUNTLFNBQVMsMEJBQTJCLE9BQU9BLFFBQVE7UUFDNU07UUFFQSxTQUFTRSwrQkFBK0JDLFFBQVEsRUFBRUMsWUFBWTtZQUM1RDtnQkFDRSxJQUFJQyxZQUFZO2dCQUNoQixJQUFJQyxXQUFXN2tCLE1BQU0rVSxJQUFJLENBQUMsSUFBSWpRLElBQUlyQyxPQUFPcWlCLElBQUksQ0FBQ0gsY0FBY2prQixNQUFNLENBQUMrQixPQUFPcWlCLElBQUksQ0FBQ0o7Z0JBRS9FLElBQUssSUFBSUssSUFBSSxHQUFHQSxJQUFJRixTQUFTL2tCLE1BQU0sRUFBRWlsQixJQUFLO29CQUN4QyxJQUFJOWdCLFdBQVc0Z0IsUUFBUSxDQUFDRSxFQUFFO29CQUMxQixJQUFJQyxXQUFXTixRQUFRLENBQUN6Z0IsU0FBUztvQkFDakMsSUFBSWdoQixlQUFlTixZQUFZLENBQUMxZ0IsU0FBUztvQkFFekMsSUFBSStnQixhQUFhQyxnQkFBZ0IsQ0FBRUQsQ0FBQUEsWUFBWSxRQUFRQyxnQkFBZ0IsSUFBRyxHQUFJO3dCQUM1RSxJQUFJRCxZQUFZLE1BQU07NEJBQ3BCLElBQUlKLGNBQWMsTUFBTTtnQ0FDdEJBLFlBQVk7b0NBQ1ZNLFNBQVMsQ0FBQztvQ0FDVkMsT0FBTyxDQUFDO29DQUNSQyxXQUFXLENBQUM7Z0NBQ2Q7NEJBQ0Y7NEJBRUFSLFVBQVVNLE9BQU8sQ0FBQ2poQixTQUFTLEdBQUdnaEI7d0JBQ2hDLE9BQU8sSUFBSUEsZ0JBQWdCLE1BQU07NEJBQy9CLElBQUlMLGNBQWMsTUFBTTtnQ0FDdEJBLFlBQVk7b0NBQ1ZNLFNBQVMsQ0FBQztvQ0FDVkMsT0FBTyxDQUFDO29DQUNSQyxXQUFXLENBQUM7Z0NBQ2Q7NEJBQ0Y7NEJBRUFSLFVBQVVPLEtBQUssQ0FBQ2xoQixTQUFTLEdBQUcrZ0I7d0JBQzlCLE9BQU87NEJBQ0wsSUFBSUosY0FBYyxNQUFNO2dDQUN0QkEsWUFBWTtvQ0FDVk0sU0FBUyxDQUFDO29DQUNWQyxPQUFPLENBQUM7b0NBQ1JDLFdBQVcsQ0FBQztnQ0FDZDs0QkFDRjs0QkFFQVIsVUFBVVEsU0FBUyxDQUFDbmhCLFNBQVMsR0FBRztnQ0FDOUJvaEIsVUFBVUo7Z0NBQ1ZLLFFBQVFOOzRCQUNWO3dCQUNGO29CQUNGO2dCQUNGO2dCQUVBLE9BQU9KO1lBQ1Q7UUFDRjtRQUVBLFNBQVNXLGtDQUFrQ2IsUUFBUSxFQUFFQyxZQUFZO1lBQy9ELElBQUlhLE9BQU9mLCtCQUErQkMsVUFBVUM7WUFDcEQsSUFBSSxDQUFDYSxNQUFNLE9BQU87WUFDbEIsSUFBSUMsY0FBYztZQUVsQixJQUFLLElBQUl4aEIsWUFBWXVoQixLQUFLTixPQUFPLENBQUU7Z0JBQ2pDLElBQUlRLFlBQVlGLEtBQUtOLE9BQU8sQ0FBQ2poQixTQUFTO2dCQUV0QyxJQUFJQSxhQUFhLFNBQVM7b0JBQ3hCd2hCLGVBQWUsVUFBV3hoQixXQUFXLDBDQUEyQ3VnQiwwQ0FBMENrQjtnQkFDNUg7WUFDRjtZQUVBLElBQUssSUFBSUMsYUFBYUgsS0FBS0wsS0FBSyxDQUFFO2dCQUNoQyxJQUFJUyxhQUFhSixLQUFLTCxLQUFLLENBQUNRLFVBQVU7Z0JBQ3RDRixlQUFlLFVBQVdFLFlBQVksbUJBQW9CbkIsMENBQTBDb0IsY0FBYztZQUNwSDtZQUVBLElBQUssSUFBSUMsY0FBY0wsS0FBS0osU0FBUyxDQUFFO2dCQUNyQyxJQUFJVSxjQUFjTixLQUFLSixTQUFTLENBQUNTLFdBQVcsQ0FBQ1AsTUFBTTtnQkFDbkQsSUFBSVMsZ0JBQWdCUCxLQUFLSixTQUFTLENBQUNTLFdBQVcsQ0FBQ1IsUUFBUTtnQkFDdkRJLGVBQWUsVUFBV0ksYUFBYSxtQkFBb0JyQiwwQ0FBMENzQixlQUFlLHVCQUF1QnRCLDBDQUEwQ3VCO1lBQ3ZMO1lBRUEsT0FBT047UUFDVDtRQUNBLFNBQVNPLDRDQUE0Q3RCLFFBQVEsRUFBRUMsWUFBWTtZQUN6RSxJQUFJYSxPQUFPZiwrQkFBK0JDLFVBQVVDO1lBQ3BELElBQUksQ0FBQ2EsTUFBTSxPQUFPO1lBQ2xCLElBQUlDLGNBQWM7WUFFbEIsSUFBSyxJQUFJeGhCLFlBQVl1aEIsS0FBS0wsS0FBSyxDQUFFO2dCQUMvQixJQUFJTyxZQUFZRixLQUFLTCxLQUFLLENBQUNsaEIsU0FBUztnQkFFcEMsSUFBSUEsYUFBYSxnQkFBZ0JBLGFBQWEsaUJBQWlCQSxhQUFhLGFBQWE7b0JBQ3ZGd2hCLGVBQWUsVUFBV3hoQixXQUFXLG1CQUFvQnVnQiwwQ0FBMENrQixhQUFhO2dCQUNsSCxPQUFPO29CQUNMRCxlQUFlLFVBQVd4aEIsV0FBVyxtQkFBb0J1Z0IsMENBQTBDa0IsYUFBYTtnQkFDbEg7WUFDRjtZQUVBLElBQUssSUFBSU8sY0FBY1QsS0FBS0osU0FBUyxDQUFFO2dCQUNyQyxJQUFJVSxjQUFjTixLQUFLSixTQUFTLENBQUNhLFdBQVcsQ0FBQ1gsTUFBTTtnQkFDbkQsSUFBSVMsZ0JBQWdCUCxLQUFLSixTQUFTLENBQUNhLFdBQVcsQ0FBQ1osUUFBUTtnQkFFdkQsSUFBSVksZUFBZSxnQkFBZ0JGLGtCQUFrQixXQUFXO29CQUM5RE4sZUFBZSxVQUFXUSxhQUFhLG1CQUFvQnpCLDBDQUEwQ3NCLGVBQWU7Z0JBQ3RILE9BQU87b0JBQ0xMLGVBQWUsVUFBV1EsYUFBYSxtQkFBb0J6QiwwQ0FBMENzQixlQUFlLHFCQUFxQnRCLDBDQUEwQ3VCO2dCQUNyTDtZQUNGO1lBRUEsT0FBT047UUFDVDtRQUNBLFNBQVNTLDRDQUE0Q3hCLFFBQVEsRUFBRUMsWUFBWTtZQUN6RSxJQUFJYSxPQUFPZiwrQkFBK0JDLFVBQVVDO1lBQ3BELElBQUksQ0FBQ2EsTUFBTSxPQUFPO1lBQ2xCLElBQUlDLGNBQWM7WUFFbEIsSUFBSyxJQUFJeGhCLFlBQVl1aEIsS0FBS04sT0FBTyxDQUFFO2dCQUNqQyxJQUFJUSxZQUFZRixLQUFLTixPQUFPLENBQUNqaEIsU0FBUztnQkFFdEMsSUFBSUEsYUFBYSxnQkFBZ0J5aEIsY0FBYyxXQUFXO29CQUN4REQsZUFBZSxVQUFXeGhCLFdBQVcseUNBQTBDdWdCLDBDQUEwQ2tCO2dCQUMzSDtZQUNGO1lBRUEsSUFBSyxJQUFJUyxjQUFjWCxLQUFLTCxLQUFLLENBQUU7Z0JBQ2pDLElBQUlpQixjQUFjWixLQUFLTCxLQUFLLENBQUNnQixXQUFXO2dCQUV4QyxJQUFJQSxlQUFlLGdCQUFnQkEsZUFBZSxpQkFBaUJBLGVBQWUsYUFBYTtvQkFDN0ZWLGVBQWUsVUFBV1UsYUFBYSxxQkFBc0IzQiwwQ0FBMEM0QixlQUFlO2dCQUN4SDtZQUNGO1lBRUEsSUFBSyxJQUFJQyxjQUFjYixLQUFLSixTQUFTLENBQUU7Z0JBQ3JDLElBQUlVLGNBQWNOLEtBQUtKLFNBQVMsQ0FBQ2lCLFdBQVcsQ0FBQ2YsTUFBTTtnQkFDbkQsSUFBSVMsZ0JBQWdCUCxLQUFLSixTQUFTLENBQUNpQixXQUFXLENBQUNoQixRQUFRO2dCQUN2REksZUFBZSxVQUFXWSxhQUFhLHFCQUFzQjdCLDBDQUEwQ3NCLGVBQWUsbUJBQW1CdEIsMENBQTBDdUI7WUFDckw7WUFFQSxPQUFPTjtRQUNUO1FBQ0EsU0FBU2EsK0JBQStCNUIsUUFBUSxFQUFFQyxZQUFZO1lBQzVELElBQUlhLE9BQU9mLCtCQUErQkMsVUFBVUM7WUFDcEQsSUFBSSxDQUFDYSxNQUFNLE9BQU87WUFDbEIsSUFBSUMsY0FBYztZQUVsQixJQUFLLElBQUl4aEIsWUFBWXVoQixLQUFLTixPQUFPLENBQUU7Z0JBQ2pDLElBQUlRLFlBQVlGLEtBQUtOLE9BQU8sQ0FBQ2poQixTQUFTO2dCQUV0QyxJQUFJQSxhQUFhLGdCQUFnQnloQixjQUFjLFdBQVc7b0JBQ3hERCxlQUFlLFVBQVd4aEIsV0FBVyxvREFBcUR1Z0IsMENBQTBDa0I7Z0JBQ3RJO1lBQ0Y7WUFFQSxJQUFLLElBQUlhLGNBQWNmLEtBQUtMLEtBQUssQ0FBRTtnQkFDakMsSUFBSXFCLGNBQWNoQixLQUFLTCxLQUFLLENBQUNvQixXQUFXO2dCQUV4QyxJQUFJQSxlQUFlLGdCQUFnQkMsZ0JBQWdCLGFBQWFELGVBQWUsaUJBQWlCQSxlQUFlLGFBQWE7b0JBQzFIZCxlQUFlLFVBQVdjLGFBQWEscUJBQXNCL0IsMENBQTBDZ0MsZUFBZTtnQkFDeEg7WUFDRjtZQUVBLElBQUssSUFBSUMsY0FBY2pCLEtBQUtKLFNBQVMsQ0FBRTtnQkFDckMsSUFBSVUsY0FBY04sS0FBS0osU0FBUyxDQUFDcUIsV0FBVyxDQUFDbkIsTUFBTTtnQkFDbkQsSUFBSVMsZ0JBQWdCUCxLQUFLSixTQUFTLENBQUNxQixXQUFXLENBQUNwQixRQUFRO2dCQUN2REksZUFBZSxVQUFXZ0IsYUFBYSxxQkFBc0JqQywwQ0FBMENzQixlQUFlLDhCQUE4QnRCLDBDQUEwQ3VCO1lBQ2hNO1lBRUEsT0FBT047UUFDVDtRQUNBLElBQUlpQiw4QkFBOEI7WUFBQztZQUFNO1lBQWU7WUFBYTtTQUFRO1FBQzdFLFNBQVNDLCtCQUErQmpDLFFBQVEsRUFBRUMsWUFBWTtZQUM1RCxJQUFJYSxPQUFPZiwrQkFBK0JDLFVBQVVDO1lBQ3BELElBQUksQ0FBQ2EsTUFBTSxPQUFPO1lBQ2xCLElBQUlDLGNBQWM7WUFFbEIsSUFBSyxJQUFJeGhCLFlBQVl1aEIsS0FBS04sT0FBTyxDQUFFO2dCQUNqQyxJQUFJUSxZQUFZRixLQUFLTixPQUFPLENBQUNqaEIsU0FBUztnQkFFdEMsSUFBSXlpQiw0QkFBNEJFLFFBQVEsQ0FBQzNpQixXQUFXO29CQUNsRHdoQixlQUFlLFVBQVd4aEIsV0FBVyxvREFBcUR1Z0IsMENBQTBDa0I7Z0JBQ3RJO1lBQ0Y7WUFFQSxJQUFLLElBQUltQixjQUFjckIsS0FBS0wsS0FBSyxDQUFFO2dCQUNqQyxJQUFJMkIsY0FBY3RCLEtBQUtMLEtBQUssQ0FBQzBCLFdBQVc7Z0JBRXhDLElBQUlILDRCQUE0QkUsUUFBUSxDQUFDQyxhQUFhO29CQUNwRHBCLGVBQWUsVUFBV29CLGFBQWEscUJBQXNCckMsMENBQTBDc0MsZUFBZTtnQkFDeEg7WUFDRjtZQUVBLElBQUssSUFBSUMsY0FBY3ZCLEtBQUtKLFNBQVMsQ0FBRTtnQkFDckMsSUFBSVUsY0FBY04sS0FBS0osU0FBUyxDQUFDMkIsV0FBVyxDQUFDekIsTUFBTTtnQkFDbkQsSUFBSVMsZ0JBQWdCUCxLQUFLSixTQUFTLENBQUMyQixXQUFXLENBQUMxQixRQUFRO2dCQUV2RCxJQUFJcUIsNEJBQTRCRSxRQUFRLENBQUNHLGFBQWE7b0JBQ3BEdEIsZUFBZSxVQUFXc0IsYUFBYSxxQkFBc0J2QywwQ0FBMENzQixlQUFlLDhCQUE4QnRCLDBDQUEwQ3VCO2dCQUNoTTtZQUNGO1lBRUEsT0FBT047UUFDVDtRQUNBLFNBQVN1QixpREFBaUR0QyxRQUFRLEVBQUVDLFlBQVk7WUFDOUUsSUFBSWEsT0FBT2YsK0JBQStCQyxVQUFVQztZQUNwRCxJQUFJLENBQUNhLE1BQU0sT0FBTztZQUNsQixJQUFJQyxjQUFjO1lBRWxCLElBQUssSUFBSXhoQixZQUFZdWhCLEtBQUtOLE9BQU8sQ0FBRTtnQkFDakMsSUFBSVEsWUFBWUYsS0FBS04sT0FBTyxDQUFDamhCLFNBQVM7Z0JBRXRDLElBQUl5aUIsNEJBQTRCRSxRQUFRLENBQUMzaUIsV0FBVztvQkFDbER3aEIsZUFBZSxVQUFXeGhCLFdBQVcsb0RBQXFEdWdCLDBDQUEwQ2tCO2dCQUN0STtZQUNGO1lBRUEsSUFBSyxJQUFJdUIsZUFBZXpCLEtBQUtMLEtBQUssQ0FBRTtnQkFDbEMsSUFBSStCLGNBQWMxQixLQUFLTCxLQUFLLENBQUM4QixZQUFZO2dCQUV6QyxJQUFJUCw0QkFBNEJFLFFBQVEsQ0FBQ0ssY0FBYztvQkFDckR4QixlQUFlLFVBQVd3QixjQUFjLHFCQUFzQnpDLDBDQUEwQzBDLGVBQWU7Z0JBQ3pIO1lBQ0Y7WUFFQSxJQUFLLElBQUlDLGVBQWUzQixLQUFLSixTQUFTLENBQUU7Z0JBQ3RDLElBQUlVLGNBQWNOLEtBQUtKLFNBQVMsQ0FBQytCLFlBQVksQ0FBQzdCLE1BQU07Z0JBQ3BELElBQUlTLGdCQUFnQlAsS0FBS0osU0FBUyxDQUFDK0IsWUFBWSxDQUFDOUIsUUFBUTtnQkFFeEQsSUFBSXFCLDRCQUE0QkUsUUFBUSxDQUFDTyxjQUFjO29CQUNyRDFCLGVBQWUsVUFBVzBCLGNBQWMscUJBQXNCM0MsMENBQTBDc0IsZUFBZSw4QkFBOEJ0QiwwQ0FBMEN1QjtnQkFDak07WUFDRjtZQUVBLE9BQU9OO1FBQ1Q7UUFDQSxTQUFTMkIsOEJBQThCMUMsUUFBUSxFQUFFQyxZQUFZO1lBQzNELElBQUlhLE9BQU9mLCtCQUErQkMsVUFBVUM7WUFDcEQsSUFBSSxDQUFDYSxNQUFNLE9BQU87WUFDbEIsSUFBSUMsY0FBYztZQUVsQixJQUFLLElBQUl4aEIsWUFBWXVoQixLQUFLTixPQUFPLENBQUU7Z0JBQ2pDLElBQUlRLFlBQVlGLEtBQUtOLE9BQU8sQ0FBQ2poQixTQUFTO2dCQUN0Q3doQixlQUFlLFVBQVd4aEIsV0FBVywwQ0FBMkN1Z0IsMENBQTBDa0I7WUFDNUg7WUFFQSxJQUFLLElBQUkyQixlQUFlN0IsS0FBS0wsS0FBSyxDQUFFO2dCQUNsQyxJQUFJbUMsY0FBYzlCLEtBQUtMLEtBQUssQ0FBQ2tDLFlBQVk7Z0JBQ3pDNUIsZUFBZSxVQUFXNEIsY0FBYyxtQkFBb0I3QywwQ0FBMEM4QyxlQUFlO1lBQ3ZIO1lBRUEsSUFBSyxJQUFJQyxlQUFlL0IsS0FBS0osU0FBUyxDQUFFO2dCQUN0QyxJQUFJVSxjQUFjTixLQUFLSixTQUFTLENBQUNtQyxZQUFZLENBQUNqQyxNQUFNO2dCQUNwRCxJQUFJUyxnQkFBZ0JQLEtBQUtKLFNBQVMsQ0FBQ21DLFlBQVksQ0FBQ2xDLFFBQVE7Z0JBQ3hESSxlQUFlLFVBQVc4QixjQUFjLG1CQUFvQi9DLDBDQUEwQ3NCLGVBQWUsdUJBQXVCdEIsMENBQTBDdUI7WUFDeEw7WUFFQSxPQUFPTjtRQUNUO1FBQ0EsU0FBUytCLHdDQUF3QzlDLFFBQVEsRUFBRUMsWUFBWTtZQUNyRSxJQUFJYSxPQUFPZiwrQkFBK0JDLFVBQVVDO1lBQ3BELElBQUksQ0FBQ2EsTUFBTSxPQUFPO1lBQ2xCLElBQUlDLGNBQWM7WUFFbEIsSUFBSyxJQUFJeGhCLFlBQVl1aEIsS0FBS0wsS0FBSyxDQUFFO2dCQUMvQixJQUFJTyxZQUFZRixLQUFLTCxLQUFLLENBQUNsaEIsU0FBUztnQkFFcEMsSUFBSUEsYUFBYSxpQkFBaUJBLGFBQWEsYUFBYTtvQkFDMUR3aEIsZUFBZSxVQUFXeGhCLFdBQVcsbUJBQW9CdWdCLDBDQUEwQ2tCLGFBQWE7Z0JBQ2xILE9BQU87b0JBQ0xELGVBQWUsVUFBV3hoQixXQUFXLG1CQUFvQnVnQiwwQ0FBMENrQixhQUFhO2dCQUNsSDtZQUNGO1lBRUEsSUFBSyxJQUFJK0IsZUFBZWpDLEtBQUtKLFNBQVMsQ0FBRTtnQkFDdEMsSUFBSVUsY0FBY04sS0FBS0osU0FBUyxDQUFDcUMsWUFBWSxDQUFDbkMsTUFBTTtnQkFDcEQsSUFBSVMsZ0JBQWdCUCxLQUFLSixTQUFTLENBQUNxQyxZQUFZLENBQUNwQyxRQUFRO2dCQUN4REksZUFBZSxVQUFXZ0MsY0FBYyxtQkFBb0JqRCwwQ0FBMENzQixlQUFlLHFCQUFxQnRCLDBDQUEwQ3VCO1lBQ3RMO1lBRUEsT0FBT047UUFDVDtRQUNBLFNBQVNpQyx3Q0FBd0NoRCxRQUFRLEVBQUVDLFlBQVk7WUFDckUsSUFBSWEsT0FBT2YsK0JBQStCQyxVQUFVQztZQUNwRCxJQUFJLENBQUNhLE1BQU0sT0FBTztZQUNsQixJQUFJQyxjQUFjO1lBRWxCLElBQUssSUFBSXhoQixZQUFZdWhCLEtBQUtMLEtBQUssQ0FBRTtnQkFDL0IsSUFBSU8sWUFBWUYsS0FBS0wsS0FBSyxDQUFDbGhCLFNBQVM7Z0JBRXBDLElBQUlBLGFBQWEsaUJBQWlCQSxhQUFhLGFBQWE7b0JBQzFEd2hCLGVBQWUsVUFBV3hoQixXQUFXLHFCQUFzQnVnQiwwQ0FBMENrQixhQUFhO2dCQUNwSDtZQUNGO1lBRUEsSUFBSyxJQUFJaUMsZUFBZW5DLEtBQUtKLFNBQVMsQ0FBRTtnQkFDdEMsSUFBSVUsY0FBY04sS0FBS0osU0FBUyxDQUFDdUMsWUFBWSxDQUFDckMsTUFBTTtnQkFDcEQsSUFBSVMsZ0JBQWdCUCxLQUFLSixTQUFTLENBQUN1QyxZQUFZLENBQUN0QyxRQUFRO2dCQUN4REksZUFBZSxVQUFXa0MsY0FBYyxxQkFBc0JuRCwwQ0FBMENzQixlQUFlLG1CQUFtQnRCLDBDQUEwQ3VCO1lBQ3RMO1lBRUEsT0FBT047UUFDVDtRQUVBLElBQUltQywwQkFBMEJ2b0IsU0FBU0ksa0RBQWtEO1FBRXpGLElBQUlvb0IsNEJBQTRCRCx3QkFBd0JFLFVBQVU7UUFDbEUsSUFBSUMsMkJBQTJCO1lBQzdCQyxhQUFhQTtZQUNiQyxZQUFZQTtZQUNaOVosU0FBU0E7WUFDVCtaLFNBQVNBO1FBQ1g7UUFDQSxTQUFTQztZQUNQTiwwQkFBMEJPLE9BQU8sR0FBR0w7UUFDdEMsRUFBRSx3RUFBd0U7UUFDMUUsSUFBSU0sd0JBQXdCO1FBQzVCLElBQUlDLHNCQUFzQjtRQUMxQixJQUFJQyxjQUVGO1FBQ0YsSUFBSUMsOEJBRUY7UUFDRixJQUFJQywrQkFFRjtRQUNGLElBQUlDLDJCQUVGO1FBQ0YsSUFBSUMsNkJBRUY7UUFFRixJQUFJQyx1QkFBdUIzbUIseUJBQXlCO1FBQ3BELElBQUk0bUIsb0JBQW9CNW1CLHlCQUF5QjtRQUNqRCxJQUFJNm1CLGtCQUFrQjdtQix5QkFBeUI7UUFDL0MsSUFBSThtQixpQkFBaUI5bUIseUJBQXlCO1FBQzlDLElBQUkrbUIsaUJBQWlCL21CLHlCQUF5QjtRQUM5QyxJQUFJZ25CLGNBQWNobkIseUJBQXlCO1FBQzNDLElBQUlpbkIsa0JBQWtCam5CLHlCQUF5QjtRQUMvQyxJQUFJa25CLG9CQUFvQmxuQix5QkFBeUI7UUFDakQsSUFBSW1uQixpQkFBaUJubkIseUJBQXlCO1FBQzlDOzs7Ozs7Ozs7Q0FTQyxHQUVELFNBQVNvbkIsNkJBQTZCQyxVQUFVO1lBQzlDO2dCQUNFcGxCLHdCQUF3Qm9sQjtZQUMxQjtZQUVBLE9BQU8sQ0FBQyxLQUFLQSxVQUFTLEVBQUd6SCxPQUFPLENBQUMwSCxhQUFhQztRQUNoRDtRQUVBLElBQUlELGNBQWM7UUFFbEIsSUFBSUMsaUJBQWlCLFNBQVU1RyxLQUFLLEVBQUV4SixNQUFNLEVBQUVxUSxDQUFDLEVBQUVDLE1BQU07WUFDckQsT0FBTyxLQUFLdFEsU0FBVXFRLENBQUFBLE1BQU0sTUFBTSxZQUFZLFNBQVEsSUFBS0M7UUFDN0QsR0FBRyxvRkFBb0Y7UUFDdkYsaUZBQWlGO1FBQ2pGLDRGQUE0RjtRQUc1RixTQUFTQyxzQkFBc0JDLFNBQVMsRUFBRUMsZ0JBQWdCLEVBQUVsYyxLQUFLLEVBQUVtYyxzQkFBc0IsRUFBRUMsZ0JBQWdCLEVBQUVDLGdCQUFnQixFQUFFQyxxQkFBcUI7WUFDbEosSUFBSUMsV0FBV0wscUJBQXFCOUksWUFBWSxLQUFLOEk7WUFDckQsSUFBSU0sd0JBQXdCeGMsVUFBVW9ULFlBQVk4SCxvQkFBb0I1bUIseUJBQXlCLG9CQUFvQmtoQixxQkFBcUJ4VixTQUFTO1lBQ2pKLElBQUl5YyxrQkFBa0IsRUFBRTtZQUN4QixJQUFJQyx3QkFBd0I7WUFDNUIsSUFBSUMsa0JBQWtCakM7WUFFdEIsSUFBSXlCLDJCQUEyQi9JLFdBQVc7Z0JBQ3hDcUosZ0JBQWdCeG9CLElBQUksQ0FBQ3VvQix1QkFBdUJwb0IsY0FBY3NuQiw2QkFBNkJTLDBCQUEwQmhCO1lBQ25IO1lBRUE7Z0JBRUUsSUFBSW1CLDBCQUEwQmxKLFdBQVc7b0JBQ3ZDdUosa0JBQWtCaEM7b0JBRWxCLElBQUksT0FBTzJCLDBCQUEwQixVQUFVO3dCQUM3Q0ksd0JBQXdCOzRCQUN0QjVhLEtBQUt3YTs0QkFDTE0sUUFBUSxFQUFFO3dCQUNaO3dCQUNBQyxlQUFlSCxzQkFBc0JFLE1BQU0sRUFBRTs0QkFDM0M5YSxLQUFLd2E7NEJBQ0w5aEIsT0FBTzs0QkFDUDZELFdBQVcrVTs0QkFDWHBULE9BQU9BO3dCQUNUO29CQUNGLE9BQU87d0JBQ0wwYyx3QkFBd0I7NEJBQ3RCNWEsS0FBS3dhLHNCQUFzQnhhLEdBQUc7NEJBQzlCOGEsUUFBUSxFQUFFO3dCQUNaO3dCQUNBQyxlQUFlSCxzQkFBc0JFLE1BQU0sRUFBRTs0QkFDM0M5YSxLQUFLd2Esc0JBQXNCeGEsR0FBRzs0QkFDOUJ0SCxPQUFPOzRCQUNQNkQsV0FBV2llLHNCQUFzQmplLFNBQVM7NEJBQzFDMkIsT0FBT0E7d0JBQ1Q7b0JBQ0Y7Z0JBQ0Y7WUFDRjtZQUVBLElBQUlvYyxxQkFBcUJoSixXQUFXO2dCQUNsQyxJQUFLLElBQUlnRSxJQUFJLEdBQUdBLElBQUlnRixpQkFBaUJqcUIsTUFBTSxFQUFFaWxCLElBQUs7b0JBQ2hELElBQUkwRixlQUFlVixnQkFBZ0IsQ0FBQ2hGLEVBQUU7b0JBQ3RDLElBQUl0VixNQUFNLE9BQU9nYixpQkFBaUIsV0FBV0EsZUFBZUEsYUFBYWhiLEdBQUc7b0JBQzVFLElBQUl6RCxZQUFZLE9BQU95ZSxpQkFBaUIsV0FBVzFKLFlBQVkwSixhQUFhemUsU0FBUztvQkFDckYsSUFBSTBlLGNBQWMsT0FBT0QsaUJBQWlCLFlBQVlBLGFBQWFDLFdBQVcsSUFBSSxPQUFPM0osWUFBWTBKLGFBQWFDLFdBQVcsS0FBSyxvQkFBb0Isb0JBQW9CO29CQUMxS0MsdUJBQXVCZixXQUFXbmEsS0FBSzlCLE9BQU8zQixXQUFXMGU7b0JBQ3pETixnQkFBZ0J4b0IsSUFBSSxDQUFDbW5CLGdCQUFnQmhuQixjQUFjb2hCLHFCQUFxQjFUO29CQUV4RSxJQUFJOUIsT0FBTzt3QkFDVHljLGdCQUFnQnhvQixJQUFJLENBQUNxbkIsYUFBYWxuQixjQUFjb2hCLHFCQUFxQnhWO29CQUN2RTtvQkFFQSxJQUFJM0IsV0FBVzt3QkFDYm9lLGdCQUFnQnhvQixJQUFJLENBQUNzbkIsaUJBQWlCbm5CLGNBQWNvaEIscUJBQXFCblg7b0JBQzNFO29CQUVBLElBQUksT0FBTzBlLGdCQUFnQixVQUFVO3dCQUNuQ04sZ0JBQWdCeG9CLElBQUksQ0FBQ3VuQixtQkFBbUJwbkIsY0FBY29oQixxQkFBcUJ1SDtvQkFDN0U7b0JBRUFOLGdCQUFnQnhvQixJQUFJLENBQUN3bkI7Z0JBQ3ZCO1lBQ0Y7WUFFQSxJQUFJWSxxQkFBcUJqSixXQUFXO2dCQUNsQyxJQUFLLElBQUk2SixLQUFLLEdBQUdBLEtBQUtaLGlCQUFpQmxxQixNQUFNLEVBQUU4cUIsS0FBTTtvQkFDbkQsSUFBSUMsZ0JBQWdCYixnQkFBZ0IsQ0FBQ1ksR0FBRztvQkFFeEMsSUFBSUUsT0FBTyxPQUFPRCxrQkFBa0IsV0FBV0EsZ0JBQWdCQSxjQUFjcGIsR0FBRztvQkFFaEYsSUFBSXNiLGFBQWEsT0FBT0Ysa0JBQWtCLFdBQVc5SixZQUFZOEosY0FBYzdlLFNBQVM7b0JBRXhGLElBQUlnZixlQUFlLE9BQU9ILGtCQUFrQixZQUFZQSxjQUFjSCxXQUFXLElBQUksT0FBTzNKLFlBQVk4SixjQUFjSCxXQUFXLEtBQUssb0JBQW9CLG9CQUFvQjtvQkFFOUtPLHVCQUF1QnJCLFdBQVdrQixNQUFNbmQsT0FBT29kLFlBQVlDO29CQUMzRFosZ0JBQWdCeG9CLElBQUksQ0FBQ29uQixnQkFBZ0JqbkIsY0FBY29oQixxQkFBcUIySDtvQkFFeEUsSUFBSW5kLE9BQU87d0JBQ1R5YyxnQkFBZ0J4b0IsSUFBSSxDQUFDcW5CLGFBQWFsbkIsY0FBY29oQixxQkFBcUJ4VjtvQkFDdkU7b0JBRUEsSUFBSW9kLFlBQVk7d0JBQ2RYLGdCQUFnQnhvQixJQUFJLENBQUNzbkIsaUJBQWlCbm5CLGNBQWNvaEIscUJBQXFCNEg7b0JBQzNFO29CQUVBLElBQUksT0FBT0MsaUJBQWlCLFVBQVU7d0JBQ3BDWixnQkFBZ0J4b0IsSUFBSSxDQUFDdW5CLG1CQUFtQnBuQixjQUFjb2hCLHFCQUFxQjZIO29CQUM3RTtvQkFFQVosZ0JBQWdCeG9CLElBQUksQ0FBQ3duQjtnQkFDdkI7WUFDRjtZQUVBLE9BQU87Z0JBQ0xnQixpQkFBaUJBO2dCQUNqQmMsbUJBQW1CanBCLHlCQUF5QmlvQixXQUFXO2dCQUN2RGlCLGVBQWVscEIseUJBQXlCaW9CLFdBQVc7Z0JBQ25Ea0IsZ0JBQWdCbEIsV0FBVztnQkFDM0JBLFVBQVVBO2dCQUNWbUIsZ0JBQWdCO2dCQUNoQmYsaUJBQWlCQTtnQkFDakJ6QixtQkFBbUJzQjtnQkFDbkJtQixjQUFjL0M7Z0JBQ2Q4Qix1QkFBdUJBO2dCQUN2QmtCLFlBQVk7Z0JBQ1pDLFlBQVk7Z0JBQ1pDLFNBQVM7Z0JBQ1RDLGVBQWUsRUFBRTtnQkFDakJDLGtCQUFrQixFQUFFO2dCQUNwQkMsZUFBZSxFQUFFO2dCQUNqQkMsaUJBQWlCLEVBQUU7Z0JBQ25CQyxlQUFlO2dCQUNmbmUsT0FBT0E7WUFDVDtRQUNGLEVBQUUsbUdBQW1HO1FBQ3JHLG1GQUFtRjtRQUNuRiw0RkFBNEY7UUFFNUYsSUFBSW9lLGlCQUFpQixHQUFHLHNDQUFzQztRQUM5RCwrRkFBK0Y7UUFDL0Ysb0JBQW9CO1FBRXBCLElBQUlDLGlCQUFpQixHQUFHLGlEQUFpRDtRQUV6RSxJQUFJQyxZQUFZO1FBQ2hCLElBQUlDLFdBQVc7UUFDZixJQUFJQyxjQUFjO1FBQ2xCLElBQUlDLGtCQUFrQjtRQUN0QixJQUFJQyx1QkFBdUI7UUFDM0IsSUFBSUMsc0JBQXNCO1FBQzFCLElBQUlDLHFCQUFxQixHQUFHLG1HQUFtRztRQUMvSCxvQkFBb0I7UUFDcEIsK0VBQStFO1FBRS9FLFNBQVNDLG9CQUFvQkMsYUFBYSxFQUFFQyxhQUFhLEVBQUVDLGtCQUFrQjtZQUMzRSxPQUFPO2dCQUNMRixlQUFlQTtnQkFDZkMsZUFBZUE7Z0JBQ2ZDLG9CQUFvQkE7WUFDdEI7UUFDRjtRQUNBLFNBQVNDLHNCQUFzQkMsYUFBYSxFQUFFcHBCLElBQUksRUFBRXNDLEtBQUs7WUFDdkQsT0FBUXRDO2dCQUNOLEtBQUs7b0JBQ0gsT0FBTytvQixvQkFBb0JQLFdBQVcsTUFBTTtnQkFFOUMsS0FBSztvQkFDSCxPQUFPTyxvQkFBb0JQLFdBQVdsbUIsTUFBTXZELEtBQUssSUFBSSxPQUFPdUQsTUFBTXZELEtBQUssR0FBR3VELE1BQU0rbUIsWUFBWSxFQUFFRCxjQUFjRixrQkFBa0I7Z0JBRWhJLEtBQUs7b0JBQ0gsT0FBT0gsb0JBQW9CTixVQUFVLE1BQU1XLGNBQWNGLGtCQUFrQjtnQkFFN0UsS0FBSztvQkFDSCxPQUFPSCxvQkFBb0JMLGFBQWEsTUFBTVUsY0FBY0Ysa0JBQWtCO2dCQUVoRixLQUFLO29CQUNILE9BQU9ILG9CQUFvQlAsV0FBVyxNQUFNWSxjQUFjRixrQkFBa0I7Z0JBQzlFLHlGQUF5RjtnQkFDekYsaUZBQWlGO2dCQUVqRixLQUFLO29CQUNILE9BQU9ILG9CQUFvQkosaUJBQWlCLE1BQU1TLGNBQWNGLGtCQUFrQjtnQkFFcEYsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7b0JBQ0gsT0FBT0gsb0JBQW9CSCxzQkFBc0IsTUFBTVEsY0FBY0Ysa0JBQWtCO2dCQUV6RixLQUFLO29CQUNILE9BQU9ILG9CQUFvQkQsb0JBQW9CLE1BQU1NLGNBQWNGLGtCQUFrQjtnQkFFdkYsS0FBSztvQkFDSCxPQUFPSCxvQkFBb0JGLHFCQUFxQixNQUFNTyxjQUFjRixrQkFBa0I7WUFDMUY7WUFFQSxJQUFJRSxjQUFjSixhQUFhLElBQUlMLGlCQUFpQjtnQkFDbEQsMkZBQTJGO2dCQUMzRiw0QkFBNEI7Z0JBQzVCLE9BQU9JLG9CQUFvQlAsV0FBVyxNQUFNWSxjQUFjRixrQkFBa0I7WUFDOUU7WUFFQSxJQUFJRSxjQUFjSixhQUFhLEtBQUtWLGdCQUFnQjtnQkFDbEQsSUFBSXRvQixTQUFTLFFBQVE7b0JBQ25CLG9EQUFvRDtvQkFDcEQsT0FBTytvQixvQkFBb0JSLGdCQUFnQixNQUFNO2dCQUNuRCxPQUFPO29CQUNMLHdEQUF3RDtvQkFDeEQsT0FBT1Esb0JBQW9CUCxXQUFXLE1BQU07Z0JBQzlDO1lBQ0YsT0FBTyxJQUFJWSxjQUFjSixhQUFhLEtBQUtULGdCQUFnQjtnQkFDekQsb0VBQW9FO2dCQUNwRSxPQUFPUSxvQkFBb0JQLFdBQVcsTUFBTTtZQUM5QztZQUVBLE9BQU9ZO1FBQ1Q7UUFDQSxJQUFJRSxxQ0FBcUM7UUFDekMsU0FBU0MseUJBQXlCQyxhQUFhO1lBQzdDLElBQUlDLGNBQWNELGNBQWM1QixjQUFjO1lBQzlDLE9BQU9wcEIseUJBQXlCZ3JCLGNBQWM3QixjQUFjLEdBQUc4QixZQUFZQyxRQUFRLENBQUM7UUFDdEY7UUFDQSxTQUFTQyxPQUFPSCxhQUFhLEVBQUVJLE1BQU0sRUFBRUMsT0FBTztZQUM1QyxJQUFJcEQsV0FBVytDLGNBQWMvQyxRQUFRO1lBQ3JDLElBQUl2ZSxLQUFLLE1BQU11ZSxXQUFXLE1BQU1tRCxRQUFRLHdFQUF3RTtZQUNoSCxzRUFBc0U7WUFDdEUsd0JBQXdCO1lBRXhCLElBQUlDLFVBQVUsR0FBRztnQkFDZjNoQixNQUFNLE1BQU0yaEIsUUFBUUgsUUFBUSxDQUFDO1lBQy9CO1lBRUEsT0FBT3hoQixLQUFLO1FBQ2Q7UUFFQSxTQUFTNGhCLG1CQUFtQm5LLElBQUk7WUFDOUIsT0FBT0QscUJBQXFCQztRQUM5QjtRQUVBLElBQUlvSyxnQkFBZ0J2ckIseUJBQXlCO1FBQzdDLFNBQVN3ckIsbUJBQW1CdmQsTUFBTSxFQUFFa1QsSUFBSSxFQUFFNkosYUFBYSxFQUFFUyxZQUFZO1lBQ25FLElBQUl0SyxTQUFTLElBQUk7Z0JBQ2Ysd0ZBQXdGO2dCQUN4RixPQUFPc0s7WUFDVDtZQUVBLElBQUlBLGNBQWM7Z0JBQ2hCeGQsT0FBT3RPLElBQUksQ0FBQzRyQjtZQUNkO1lBRUF0ZCxPQUFPdE8sSUFBSSxDQUFDRyxjQUFjd3JCLG1CQUFtQm5LO1lBQzdDLE9BQU87UUFDVCxFQUFFLDBGQUEwRjtRQUM1Rix1RUFBdUU7UUFFdkUsU0FBU3VLLG9CQUFvQnpkLE1BQU0sRUFBRStjLGFBQWEsRUFBRVcsY0FBYyxFQUFFRixZQUFZO1lBQzlFLElBQUlFLGtCQUFrQkYsY0FBYztnQkFDbEN4ZCxPQUFPdE8sSUFBSSxDQUFDNHJCO1lBQ2Q7UUFDRjtRQUNBLElBQUlLLGlCQUFpQixJQUFJM29CO1FBRXpCLFNBQVM0b0IsaUJBQWlCQyxTQUFTO1lBQ2pDLElBQUlyc0IsUUFBUW1zQixlQUFlem9CLEdBQUcsQ0FBQzJvQjtZQUUvQixJQUFJcnNCLFVBQVVxZixXQUFXO2dCQUN2QixPQUFPcmY7WUFDVDtZQUVBLElBQUkwWSxTQUFTblkseUJBQXlCa2hCLHFCQUFxQkksbUJBQW1Cd0s7WUFDOUVGLGVBQWVHLEdBQUcsQ0FBQ0QsV0FBVzNUO1lBQzlCLE9BQU9BO1FBQ1Q7UUFFQSxJQUFJNlQsc0JBQXNCaHNCLHlCQUF5QjtRQUNuRCxJQUFJaXNCLGNBQWNqc0IseUJBQXlCO1FBQzNDLElBQUlrc0IsaUJBQWlCbHNCLHlCQUF5QjtRQUU5QyxTQUFTbXNCLG1CQUFtQmxlLE1BQU0sRUFBRUgsS0FBSztZQUN2QyxJQUFJLE9BQU9BLFVBQVUsVUFBVTtnQkFDN0IsTUFBTSxJQUFJc2UsTUFBTSx5RUFBeUUsMkVBQTJFO1lBQ3RLO1lBRUEsSUFBSUMsVUFBVTtZQUVkLElBQUssSUFBSVAsYUFBYWhlLE1BQU87Z0JBQzNCLElBQUksQ0FBQzNMLGVBQWVqRCxJQUFJLENBQUM0TyxPQUFPZ2UsWUFBWTtvQkFDMUM7Z0JBQ0YsRUFBRSxxRUFBcUU7Z0JBQ3ZFLG9EQUFvRDtnQkFDcEQsaUVBQWlFO2dCQUNqRSxxRUFBcUU7Z0JBQ3JFLHNFQUFzRTtnQkFDdEUsa0VBQWtFO2dCQUNsRSwwQ0FBMEM7Z0JBRzFDLElBQUlRLGFBQWF4ZSxLQUFLLENBQUNnZSxVQUFVO2dCQUVqQyxJQUFJUSxjQUFjLFFBQVEsT0FBT0EsZUFBZSxhQUFhQSxlQUFlLElBQUk7b0JBRTlFO2dCQUNGO2dCQUVBLElBQUlDLFlBQVksS0FBSztnQkFDckIsSUFBSUMsYUFBYSxLQUFLO2dCQUN0QixJQUFJQyxtQkFBbUJYLFVBQVVybUIsT0FBTyxDQUFDLFVBQVU7Z0JBRW5ELElBQUlnbkIsa0JBQWtCO29CQUNwQkYsWUFBWXpzQixjQUFjb2hCLHFCQUFxQjRLO29CQUUvQzt3QkFDRS9wQiwrQkFBK0J1cUIsWUFBWVI7b0JBQzdDO29CQUVBVSxhQUFhMXNCLGNBQWNvaEIscUJBQXFCLENBQUMsS0FBS29MLFVBQVMsRUFBR0ksSUFBSTtnQkFDeEUsT0FBTztvQkFDTDt3QkFDRXBNLGVBQWV3TCxXQUFXUTtvQkFDNUI7b0JBRUFDLFlBQVlWLGlCQUFpQkM7b0JBRTdCLElBQUksT0FBT1EsZUFBZSxVQUFVO3dCQUNsQyxJQUFJQSxlQUFlLEtBQUssQ0FBQ3hwQixpQkFBaUJncEIsWUFBWTs0QkFDcERVLGFBQWExc0IsY0FBY3dzQixhQUFhLE9BQU8scURBQXFEO3dCQUN0RyxPQUFPOzRCQUNMRSxhQUFhMXNCLGNBQWMsS0FBS3dzQjt3QkFDbEM7b0JBQ0YsT0FBTzt3QkFDTDs0QkFDRXZxQiwrQkFBK0J1cUIsWUFBWVI7d0JBQzdDO3dCQUVBVSxhQUFhMXNCLGNBQWNvaEIscUJBQXFCLENBQUMsS0FBS29MLFVBQVMsRUFBR0ksSUFBSTtvQkFDeEU7Z0JBQ0Y7Z0JBRUEsSUFBSUwsU0FBUztvQkFDWEEsVUFBVSxPQUFPLHdEQUF3RDtvQkFFekVwZSxPQUFPdE8sSUFBSSxDQUFDcXNCLHFCQUFxQk8sV0FBV04sYUFBYU87Z0JBQzNELE9BQU87b0JBQ0x2ZSxPQUFPdE8sSUFBSSxDQUFDdXNCLGdCQUFnQkssV0FBV04sYUFBYU87Z0JBQ3REO1lBQ0Y7WUFFQSxJQUFJLENBQUNILFNBQVM7Z0JBQ1pwZSxPQUFPdE8sSUFBSSxDQUFDZ3RCO1lBQ2Q7UUFDRjtRQUVBLElBQUlDLHFCQUFxQjVzQix5QkFBeUI7UUFDbEQsSUFBSTZzQixrQkFBa0I3c0IseUJBQXlCO1FBQy9DLElBQUkyc0IsZUFBZTNzQix5QkFBeUI7UUFDNUMsSUFBSThzQix1QkFBdUI5c0IseUJBQXlCO1FBRXBELFNBQVMrc0IscUJBQXFCOWUsTUFBTSxFQUFFeE0sSUFBSSxFQUFFbEIsS0FBSztZQUUvQyxJQUFJQSxTQUFTLE9BQU9BLFVBQVUsY0FBYyxPQUFPQSxVQUFVLFVBQVU7Z0JBQ3JFME4sT0FBT3RPLElBQUksQ0FBQ2l0QixvQkFBb0I5c0IsY0FBYzJCLE9BQU9xckI7WUFDdkQ7UUFDRjtRQUVBLFNBQVNFLG9CQUFvQi9lLE1BQU0sRUFBRXhNLElBQUksRUFBRWxCLEtBQUs7WUFFOUMsSUFBSSxPQUFPQSxVQUFVLGNBQWMsT0FBT0EsVUFBVSxZQUFZLE9BQU9BLFVBQVUsV0FBVztnQkFDMUYwTixPQUFPdE8sSUFBSSxDQUFDaXRCLG9CQUFvQjlzQixjQUFjMkIsT0FBT29yQixpQkFBaUIvc0IsY0FBY29oQixxQkFBcUIzZ0IsU0FBU29zQjtZQUNwSDtRQUNGO1FBQ0Esb0RBQW9EO1FBR3BEM3NCLHlCQUF5QmtoQixxQkFDekI7UUFDQSxJQUFJK0wsd0JBQXdCanRCLHlCQUF5QjtRQUVyRCxTQUFTa3RCLHdCQUF3QjNzQixLQUFLLEVBQUVELEdBQUc7WUFDekMsSUFBSTJOLFNBQVMsSUFBSTtZQUNqQkEsT0FBT3RPLElBQUksQ0FBQ3N0QjtZQUVaLElBQUksT0FBTzFzQixVQUFVLFVBQVU7Z0JBQzdCLE1BQU0sSUFBSTZyQixNQUFNLGtFQUFrRTtZQUNwRjtZQUVBWSxvQkFBb0IvZSxRQUFRLFFBQVEzTjtZQUNwQzBzQixvQkFBb0IvZSxRQUFRLFNBQVMxTjtZQUNyQzBOLE9BQU90TyxJQUFJLENBQUN3dEI7UUFDZDtRQUVBLFNBQVNDLHlCQUF5Qm5mLE1BQU0sRUFBRW9mLFFBQVE7WUFDaEQsSUFBSUEsYUFBYSxNQUFNO2dCQUNyQixrREFBa0Q7Z0JBQ2xEQSxTQUFTQyxPQUFPLENBQUNKLHlCQUF5QmpmO1lBQzVDO1FBQ0Y7UUFFQSxTQUFTc2Ysd0JBQXdCdGYsTUFBTSxFQUFFK2MsYUFBYSxFQUFFd0MsVUFBVSxFQUFFQyxXQUFXLEVBQUVDLFVBQVUsRUFBRUMsVUFBVSxFQUFFbHNCLElBQUk7WUFDM0csSUFBSTRyQixXQUFXO1lBRWYsSUFBSTVyQixRQUFRLE1BQU07Z0JBQ2hCbXNCLGNBQWMzZixRQUFRLFFBQVF4TTtZQUNoQztZQUVBLElBQUkrckIsY0FBYyxNQUFNO2dCQUN0QkksY0FBYzNmLFFBQVEsY0FBY3VmO1lBQ3RDO1lBRUEsSUFBSUMsZUFBZSxNQUFNO2dCQUN2QkcsY0FBYzNmLFFBQVEsZUFBZXdmO1lBQ3ZDO1lBRUEsSUFBSUMsY0FBYyxNQUFNO2dCQUN0QkUsY0FBYzNmLFFBQVEsY0FBY3lmO1lBQ3RDO1lBRUEsSUFBSUMsY0FBYyxNQUFNO2dCQUN0QkMsY0FBYzNmLFFBQVEsY0FBYzBmO1lBQ3RDO1lBRUEsT0FBT047UUFDVDtRQUVBLFNBQVNPLGNBQWMzZixNQUFNLEVBQUV4TSxJQUFJLEVBQUVsQixLQUFLO1lBRXhDLE9BQVFrQjtnQkFDTixnRkFBZ0Y7Z0JBQ2hGLHVGQUF1RjtnQkFDdkYsMENBQTBDO2dCQUMxQyxLQUFLO29CQUNIO3dCQUNFdXJCLG9CQUFvQi9lLFFBQVEsU0FBUzFOO3dCQUNyQztvQkFDRjtnQkFFRixLQUFLO29CQUNIO3dCQUNFeXNCLG9CQUFvQi9lLFFBQVEsWUFBWTFOO3dCQUN4QztvQkFDRjtnQkFFRixLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7b0JBQ0g7d0JBQ0V5c0Isb0JBQW9CL2UsUUFBUXhNLE1BQU1sQjt3QkFDbEM7b0JBQ0Y7Z0JBRUYsS0FBSztvQkFDSDt3QkFDRTRyQixtQkFBbUJsZSxRQUFRMU47d0JBQzNCO29CQUNGO2dCQUVGLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxzRUFBc0U7Z0JBRXRFLEtBQUs7Z0JBQ0wsS0FBSztvQkFDSDt3QkFDRSx5REFBeUQ7d0JBQ3pELElBQUlBLFNBQVMsUUFBUSxPQUFPQSxVQUFVLGNBQWMsT0FBT0EsVUFBVSxZQUFZLE9BQU9BLFVBQVUsV0FBVzs0QkFDM0c7d0JBQ0Y7d0JBRUE7NEJBQ0VzQiw2QkFBNkJ0QixPQUFPa0I7d0JBQ3RDO3dCQUVBLElBQUlvc0IsaUJBQWlCcE0sWUFBWSxLQUFLbGhCO3dCQUN0QzBOLE9BQU90TyxJQUFJLENBQUNpdEIsb0JBQW9COXNCLGNBQWMyQixPQUFPb3JCLGlCQUFpQi9zQixjQUFjb2hCLHFCQUFxQjJNLGtCQUFrQmxCO3dCQUMzSDtvQkFDRjtnQkFFRixLQUFLO2dCQUNMLEtBQUs7Z0JBRUwsS0FBSztnQkFFTCxLQUFLO2dCQUNMLEtBQUs7b0JBQ0gsc0RBQXNEO29CQUN0RDtnQkFFRixLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztvQkFDSDt3QkFDRUkscUJBQXFCOWUsUUFBUXhNLEtBQUtrRCxXQUFXLElBQUlwRTt3QkFDakQ7b0JBQ0Y7Z0JBRUYsS0FBSztvQkFDSDt3QkFDRSxJQUFJLE9BQU9BLFVBQVUsY0FBYyxPQUFPQSxVQUFVLFlBQVksT0FBT0EsVUFBVSxXQUFXOzRCQUMxRjt3QkFDRjt3QkFFQTs0QkFDRXNCLDZCQUE2QnRCLE9BQU9rQjt3QkFDdEM7d0JBRUEsSUFBSXFzQixrQkFBa0JyTSxZQUFZLEtBQUtsaEI7d0JBRXZDME4sT0FBT3RPLElBQUksQ0FBQ2l0QixvQkFBb0I5c0IsY0FBYyxlQUFlK3NCLGlCQUFpQi9zQixjQUFjb2hCLHFCQUFxQjRNLG1CQUFtQm5CO3dCQUNwSTtvQkFDRjtnQkFFRixLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7b0JBQ0g7d0JBQ0Usb0JBQW9CO3dCQUNwQixvRUFBb0U7d0JBQ3BFLHlFQUF5RTt3QkFDekUsaUVBQWlFO3dCQUNqRSxJQUFJLE9BQU9wc0IsVUFBVSxjQUFjLE9BQU9BLFVBQVUsVUFBVTs0QkFDNUQwTixPQUFPdE8sSUFBSSxDQUFDaXRCLG9CQUFvQjlzQixjQUFjMkIsT0FBT29yQixpQkFBaUIvc0IsY0FBY29oQixxQkFBcUIzZ0IsU0FBU29zQjt3QkFDcEg7d0JBRUE7b0JBQ0Y7Z0JBRUYsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztvQkFDSDt3QkFDRSxVQUFVO3dCQUNWLElBQUlwc0IsU0FBUyxPQUFPQSxVQUFVLGNBQWMsT0FBT0EsVUFBVSxVQUFVOzRCQUNyRTBOLE9BQU90TyxJQUFJLENBQUNpdEIsb0JBQW9COXNCLGNBQWMyQixPQUFPcXJCO3dCQUN2RDt3QkFFQTtvQkFDRjtnQkFFRixLQUFLO2dCQUNMLEtBQUs7b0JBQ0g7d0JBQ0UscUJBQXFCO3dCQUNyQixJQUFJdnNCLFVBQVUsTUFBTTs0QkFDbEIwTixPQUFPdE8sSUFBSSxDQUFDaXRCLG9CQUFvQjlzQixjQUFjMkIsT0FBT3FyQjt3QkFDdkQsT0FBTyxJQUFJdnNCLFVBQVU7NkJBQWMsSUFBSSxPQUFPQSxVQUFVLGNBQWMsT0FBT0EsVUFBVSxVQUFVOzRCQUMvRjBOLE9BQU90TyxJQUFJLENBQUNpdEIsb0JBQW9COXNCLGNBQWMyQixPQUFPb3JCLGlCQUFpQi9zQixjQUFjb2hCLHFCQUFxQjNnQixTQUFTb3NCO3dCQUNwSDt3QkFFQTtvQkFDRjtnQkFFRixLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO29CQUNIO3dCQUNFLDJEQUEyRDt3QkFDM0QsSUFBSSxPQUFPcHNCLFVBQVUsY0FBYyxPQUFPQSxVQUFVLFlBQVksQ0FBQ3dlLE1BQU14ZSxVQUFVQSxTQUFTLEdBQUc7NEJBQzNGME4sT0FBT3RPLElBQUksQ0FBQ2l0QixvQkFBb0I5c0IsY0FBYzJCLE9BQU9vckIsaUJBQWlCL3NCLGNBQWNvaEIscUJBQXFCM2dCLFNBQVNvc0I7d0JBQ3BIO3dCQUVBO29CQUNGO2dCQUVGLEtBQUs7Z0JBQ0wsS0FBSztvQkFDSDt3QkFDRSxrREFBa0Q7d0JBQ2xELElBQUksT0FBT3BzQixVQUFVLGNBQWMsT0FBT0EsVUFBVSxZQUFZLENBQUN3ZSxNQUFNeGUsUUFBUTs0QkFDN0UwTixPQUFPdE8sSUFBSSxDQUFDaXRCLG9CQUFvQjlzQixjQUFjMkIsT0FBT29yQixpQkFBaUIvc0IsY0FBY29oQixxQkFBcUIzZ0IsU0FBU29zQjt3QkFDcEg7d0JBRUE7b0JBQ0Y7Z0JBRUYsS0FBSztvQkFDSEssb0JBQW9CL2UsUUFBUSxpQkFBaUIxTjtvQkFDN0M7Z0JBRUYsS0FBSztvQkFDSHlzQixvQkFBb0IvZSxRQUFRLGlCQUFpQjFOO29CQUM3QztnQkFFRixLQUFLO29CQUNIeXNCLG9CQUFvQi9lLFFBQVEsY0FBYzFOO29CQUMxQztnQkFFRixLQUFLO29CQUNIeXNCLG9CQUFvQi9lLFFBQVEsY0FBYzFOO29CQUMxQztnQkFFRixLQUFLO29CQUNIeXNCLG9CQUFvQi9lLFFBQVEsZUFBZTFOO29CQUMzQztnQkFFRixLQUFLO29CQUNIeXNCLG9CQUFvQi9lLFFBQVEsY0FBYzFOO29CQUMxQztnQkFFRixLQUFLO29CQUNIeXNCLG9CQUFvQi9lLFFBQVEsWUFBWTFOO29CQUN4QztnQkFFRixLQUFLO29CQUNIeXNCLG9CQUFvQi9lLFFBQVEsWUFBWTFOO29CQUN4QztnQkFFRixLQUFLO29CQUNIeXNCLG9CQUFvQi9lLFFBQVEsYUFBYTFOO29CQUN6QztnQkFFRjtvQkFDRSxJQUNBLGtFQUFrRTtvQkFDbEVrQixLQUFLNUQsTUFBTSxHQUFHLEtBQU00RCxDQUFBQSxJQUFJLENBQUMsRUFBRSxLQUFLLE9BQU9BLElBQUksQ0FBQyxFQUFFLEtBQUssR0FBRSxLQUFPQSxDQUFBQSxJQUFJLENBQUMsRUFBRSxLQUFLLE9BQU9BLElBQUksQ0FBQyxFQUFFLEtBQUssR0FBRSxHQUFJO3dCQUMvRjtvQkFDRjtvQkFFQSxJQUFJSyxnQkFBZ0JvQixrQkFBa0J6QjtvQkFFdEMsSUFBSWlCLG9CQUFvQlosZ0JBQWdCO3dCQUN0Qyx3QkFBd0I7d0JBQ3hCLE9BQVEsT0FBT3ZCOzRCQUNiLEtBQUs7NEJBQ0wsS0FBSztnQ0FDSCxzQkFBc0I7Z0NBQ3RCOzRCQUVGLEtBQUs7Z0NBQ0g7b0NBQ0UsSUFBSTRXLFNBQVNyVixjQUFjNkMsV0FBVyxHQUFHRCxLQUFLLENBQUMsR0FBRztvQ0FFbEQsSUFBSXlTLFdBQVcsV0FBV0EsV0FBVyxTQUFTO3dDQUM1QztvQ0FDRjtnQ0FDRjt3QkFDSjt3QkFFQWxKLE9BQU90TyxJQUFJLENBQUNpdEIsb0JBQW9COXNCLGNBQWNnQyxnQkFBZ0IrcUIsaUJBQWlCL3NCLGNBQWNvaEIscUJBQXFCM2dCLFNBQVNvc0I7b0JBQzdIO1lBRUo7UUFDRjtRQUVBLElBQUlvQixnQkFBZ0IvdEIseUJBQXlCO1FBQzdDLElBQUltdEIsMkJBQTJCbnRCLHlCQUF5QjtRQUV4RCxTQUFTZ3VCLGNBQWMvZixNQUFNLEVBQUVnZ0IsU0FBUyxFQUFFbm5CLFFBQVE7WUFDaEQsSUFBSW1uQixhQUFhLE1BQU07Z0JBQ3JCLElBQUlubkIsWUFBWSxNQUFNO29CQUNwQixNQUFNLElBQUlzbEIsTUFBTTtnQkFDbEI7Z0JBRUEsSUFBSSxPQUFPNkIsY0FBYyxZQUFZLENBQUUsYUFBWUEsU0FBUSxHQUFJO29CQUM3RCxNQUFNLElBQUk3QixNQUFNLDBFQUEwRSxzRUFBc0U7Z0JBQ2xLO2dCQUVBLElBQUl0TCxPQUFPbU4sVUFBVUMsTUFBTTtnQkFFM0IsSUFBSXBOLFNBQVMsUUFBUUEsU0FBU2hDLFdBQVc7b0JBQ3ZDO3dCQUNFN2Msd0JBQXdCNmU7b0JBQzFCO29CQUVBN1MsT0FBT3RPLElBQUksQ0FBQ0csY0FBYyxLQUFLZ2hCO2dCQUNqQztZQUNGO1FBQ0YsRUFBRSx1RUFBdUU7UUFDekUscUVBQXFFO1FBR3JFLElBQUlxTiwyQkFBMkI7UUFDL0IsSUFBSUMsd0JBQXdCO1FBQzVCLElBQUlDLDRCQUE0QjtRQUNoQyxJQUFJQyw4QkFBOEI7UUFDbEMsSUFBSUMsK0JBQStCO1FBQ25DLElBQUlDLGdDQUFnQztRQUNwQyxJQUFJQyw2QkFBNkI7UUFDakMsSUFBSUMsd0JBQXdCO1FBRTVCLFNBQVNDLGdCQUFnQjdxQixLQUFLLEVBQUU5QixRQUFRO1lBQ3RDO2dCQUNFLElBQUl6QixRQUFRdUQsS0FBSyxDQUFDOUIsU0FBUztnQkFFM0IsSUFBSXpCLFNBQVMsTUFBTTtvQkFDakIsSUFBSXF1QixRQUFRN00sUUFBUXhoQjtvQkFFcEIsSUFBSXVELE1BQU15QixRQUFRLElBQUksQ0FBQ3FwQixPQUFPO3dCQUM1QjF3QixNQUFNLDREQUE0RCx1QkFBdUI4RDtvQkFDM0YsT0FBTyxJQUFJLENBQUM4QixNQUFNeUIsUUFBUSxJQUFJcXBCLE9BQU87d0JBQ25DMXdCLE1BQU0seURBQXlELGlDQUFpQzhEO29CQUNsRztnQkFDRjtZQUNGO1FBQ0Y7UUFFQSxTQUFTNnNCLGdCQUFnQjVnQixNQUFNLEVBQUVuSyxLQUFLO1lBQ3BDO2dCQUNFRiwwQkFBMEIsVUFBVUU7Z0JBQ3BDNnFCLGdCQUFnQjdxQixPQUFPO2dCQUN2QjZxQixnQkFBZ0I3cUIsT0FBTztnQkFFdkIsSUFBSUEsTUFBTXZELEtBQUssS0FBS3VlLGFBQWFoYixNQUFNK21CLFlBQVksS0FBSy9MLGFBQWEsQ0FBQ3VQLDJCQUEyQjtvQkFDL0Zud0IsTUFBTSwrREFBK0QsdUVBQXVFLHFFQUFxRSx1REFBdUQ7b0JBRXhRbXdCLDRCQUE0QjtnQkFDOUI7WUFDRjtZQUVBcGdCLE9BQU90TyxJQUFJLENBQUNtdkIsaUJBQWlCO1lBQzdCLElBQUlob0IsV0FBVztZQUNmLElBQUltbkIsWUFBWTtZQUVoQixJQUFLLElBQUljLFdBQVdqckIsTUFBTztnQkFDekIsSUFBSTNCLGVBQWVqRCxJQUFJLENBQUM0RSxPQUFPaXJCLFVBQVU7b0JBQ3ZDLElBQUl0TCxZQUFZM2YsS0FBSyxDQUFDaXJCLFFBQVE7b0JBRTlCLElBQUl0TCxhQUFhLE1BQU07d0JBQ3JCO29CQUNGO29CQUVBLE9BQVFzTDt3QkFDTixLQUFLOzRCQUNIam9CLFdBQVcyYzs0QkFDWDt3QkFFRixLQUFLOzRCQUNILG9GQUFvRjs0QkFDcEYsMEJBQTBCOzRCQUMxQndLLFlBQVl4Szs0QkFDWjt3QkFFRixLQUFLO3dCQUNMLEtBQUs7NEJBRUg7d0JBRUY7NEJBQ0VtSyxjQUFjM2YsUUFBUThnQixTQUFTdEw7NEJBQy9CO29CQUNKO2dCQUNGO1lBQ0Y7WUFFQXhWLE9BQU90TyxJQUFJLENBQUNvdUI7WUFDWkMsY0FBYy9mLFFBQVFnZ0IsV0FBV25uQjtZQUNqQyxPQUFPQTtRQUNUO1FBRUEsU0FBU2tvQixzQkFBc0Jsb0IsUUFBUTtZQUNyQyxJQUFJL0csVUFBVSxJQUFJLCtEQUErRDtZQUNqRiw2QkFBNkI7WUFFN0I3QyxNQUFNK3hCLFFBQVEsQ0FBQzNCLE9BQU8sQ0FBQ3htQixVQUFVLFNBQVVvb0IsS0FBSztnQkFDOUMsSUFBSUEsU0FBUyxNQUFNO29CQUNqQjtnQkFDRjtnQkFFQW52QixXQUFXbXZCO2dCQUVYO29CQUNFLElBQUksQ0FBQ1gsZ0NBQWdDLE9BQU9XLFVBQVUsWUFBWSxPQUFPQSxVQUFVLFVBQVU7d0JBQzNGWCwrQkFBK0I7d0JBRS9CcndCLE1BQU0sd0RBQXdEO29CQUNoRTtnQkFDRjtZQUNGO1lBQ0EsT0FBTzZCO1FBQ1Q7UUFFQSxJQUFJb3ZCLDBCQUEwQm52Qix5QkFBeUI7UUFFdkQsU0FBU292QixnQkFBZ0JuaEIsTUFBTSxFQUFFbkssS0FBSyxFQUFFdXJCLGFBQWE7WUFDbkQsSUFBSTVFLGdCQUFnQjRFLGNBQWM1RSxhQUFhO1lBQy9DeGMsT0FBT3RPLElBQUksQ0FBQ212QixpQkFBaUI7WUFDN0IsSUFBSWhvQixXQUFXO1lBQ2YsSUFBSXZHLFFBQVE7WUFDWixJQUFJMk0sV0FBVztZQUNmLElBQUkrZ0IsWUFBWTtZQUVoQixJQUFLLElBQUljLFdBQVdqckIsTUFBTztnQkFDekIsSUFBSTNCLGVBQWVqRCxJQUFJLENBQUM0RSxPQUFPaXJCLFVBQVU7b0JBQ3ZDLElBQUl0TCxZQUFZM2YsS0FBSyxDQUFDaXJCLFFBQVE7b0JBRTlCLElBQUl0TCxhQUFhLE1BQU07d0JBQ3JCO29CQUNGO29CQUVBLE9BQVFzTDt3QkFDTixLQUFLOzRCQUNIam9CLFdBQVcyYzs0QkFDWDt3QkFFRixLQUFLOzRCQUNILFNBQVM7NEJBQ1R2VyxXQUFXdVc7NEJBRVg7Z0NBQ0UsbURBQW1EO2dDQUNuRCxJQUFJLENBQUNnTCw0QkFBNEI7b0NBQy9CdndCLE1BQU0sb0VBQW9FO29DQUUxRXV3Qiw2QkFBNkI7Z0NBQy9COzRCQUNGOzRCQUVBO3dCQUVGLEtBQUs7NEJBQ0hSLFlBQVl4Szs0QkFDWjt3QkFFRixLQUFLOzRCQUNIbGpCLFFBQVFrakI7d0JBQ1Ysc0VBQXNFO3dCQUV0RTs0QkFDRW1LLGNBQWMzZixRQUFROGdCLFNBQVN0TDs0QkFDL0I7b0JBQ0o7Z0JBQ0Y7WUFDRjtZQUVBLElBQUlnSCxpQkFBaUIsTUFBTTtnQkFDekIsSUFBSTZFO2dCQUVKLElBQUkvdUIsVUFBVSxNQUFNO29CQUNsQjt3QkFDRXNCLDZCQUE2QnRCLE9BQU87b0JBQ3RDO29CQUVBK3VCLGNBQWMsS0FBSy91QjtnQkFDckIsT0FBTztvQkFDTDt3QkFDRSxJQUFJMHRCLGNBQWMsTUFBTTs0QkFDdEIsSUFBSSxDQUFDTywrQkFBK0I7Z0NBQ2xDQSxnQ0FBZ0M7Z0NBRWhDdHdCLE1BQU0sd0VBQXdFOzRCQUNoRjt3QkFDRjtvQkFDRjtvQkFFQW94QixjQUFjTixzQkFBc0Jsb0I7Z0JBQ3RDO2dCQUVBLElBQUlpYixRQUFRMEksZ0JBQWdCO29CQUMxQixXQUFXO29CQUNYLElBQUssSUFBSTNILElBQUksR0FBR0EsSUFBSTJILGNBQWM1c0IsTUFBTSxFQUFFaWxCLElBQUs7d0JBQzdDOzRCQUNFamhCLDZCQUE2QjRvQixhQUFhLENBQUMzSCxFQUFFLEVBQUU7d0JBQ2pEO3dCQUVBLElBQUl5TSxJQUFJLEtBQUs5RSxhQUFhLENBQUMzSCxFQUFFO3dCQUU3QixJQUFJeU0sTUFBTUQsYUFBYTs0QkFDckJyaEIsT0FBT3RPLElBQUksQ0FBQ3d2Qjs0QkFDWjt3QkFDRjtvQkFDRjtnQkFDRixPQUFPO29CQUNMO3dCQUNFdHRCLDZCQUE2QjRvQixlQUFlO29CQUM5QztvQkFFQSxJQUFJLEtBQUtBLGtCQUFrQjZFLGFBQWE7d0JBQ3RDcmhCLE9BQU90TyxJQUFJLENBQUN3dkI7b0JBQ2Q7Z0JBQ0Y7WUFDRixPQUFPLElBQUlqaUIsVUFBVTtnQkFDbkJlLE9BQU90TyxJQUFJLENBQUN3dkI7WUFDZDtZQUVBbGhCLE9BQU90TyxJQUFJLENBQUNvdUI7WUFDWkMsY0FBYy9mLFFBQVFnZ0IsV0FBV25uQjtZQUNqQyxPQUFPQTtRQUNUO1FBRUEsU0FBUzBvQixjQUFjdmhCLE1BQU0sRUFBRW5LLEtBQUssRUFBRWtuQixhQUFhO1lBQ2pEL2MsT0FBT3RPLElBQUksQ0FBQ212QixpQkFBaUI7WUFDN0IsSUFBSWhvQixXQUFXO1lBQ2YsSUFBSW1uQixZQUFZO1lBQ2hCLElBQUlULGFBQWE7WUFDakIsSUFBSUMsY0FBYztZQUNsQixJQUFJQyxhQUFhO1lBQ2pCLElBQUlDLGFBQWE7WUFFakIsSUFBSyxJQUFJb0IsV0FBV2pyQixNQUFPO2dCQUN6QixJQUFJM0IsZUFBZWpELElBQUksQ0FBQzRFLE9BQU9pckIsVUFBVTtvQkFDdkMsSUFBSXRMLFlBQVkzZixLQUFLLENBQUNpckIsUUFBUTtvQkFFOUIsSUFBSXRMLGFBQWEsTUFBTTt3QkFDckI7b0JBQ0Y7b0JBRUEsT0FBUXNMO3dCQUNOLEtBQUs7NEJBQ0hqb0IsV0FBVzJjOzRCQUNYO3dCQUVGLEtBQUs7NEJBQ0h3SyxZQUFZeEs7NEJBQ1o7d0JBRUYsS0FBSzs0QkFDSCtKLGFBQWEvSjs0QkFDYjt3QkFFRixLQUFLOzRCQUNIZ0ssY0FBY2hLOzRCQUNkO3dCQUVGLEtBQUs7NEJBQ0hpSyxhQUFhaks7NEJBQ2I7d0JBRUYsS0FBSzs0QkFDSGtLLGFBQWFsSzs0QkFDYjt3QkFFRjs0QkFDRW1LLGNBQWMzZixRQUFROGdCLFNBQVN0TDs0QkFDL0I7b0JBQ0o7Z0JBQ0Y7WUFDRjtZQUVBLElBQUkrSixjQUFjLE1BQU07Z0JBQ3RCSSxjQUFjM2YsUUFBUSxVQUFVdWY7WUFDbEM7WUFFQSxJQUFJQyxlQUFlLE1BQU07Z0JBQ3ZCRyxjQUFjM2YsUUFBUSxXQUFXd2Y7WUFDbkM7WUFFQSxJQUFJQyxjQUFjLE1BQU07Z0JBQ3RCRSxjQUFjM2YsUUFBUSxVQUFVeWY7WUFDbEM7WUFFQSxJQUFJQyxjQUFjLE1BQU07Z0JBQ3RCQyxjQUFjM2YsUUFBUSxVQUFVMGY7WUFDbEM7WUFFQTFmLE9BQU90TyxJQUFJLENBQUNvdUI7WUFFWkMsY0FBYy9mLFFBQVFnZ0IsV0FBV25uQjtZQUVqQyxJQUFJLE9BQU9BLGFBQWEsVUFBVTtnQkFDaEMsc0VBQXNFO2dCQUN0RSw2RUFBNkU7Z0JBQzdFbUgsT0FBT3RPLElBQUksQ0FBQ0csY0FBY3dyQixtQkFBbUJ4a0I7Z0JBQzdDLE9BQU87WUFDVDtZQUVBLE9BQU9BO1FBQ1Q7UUFFQSxTQUFTMm9CLFVBQVV4aEIsTUFBTSxFQUFFbkssS0FBSyxFQUFFa25CLGFBQWE7WUFDN0M7Z0JBQ0VwbkIsMEJBQTBCLFNBQVNFO1lBQ3JDO1lBRUFtSyxPQUFPdE8sSUFBSSxDQUFDbXZCLGlCQUFpQjtZQUM3QixJQUFJcnRCLE9BQU87WUFDWCxJQUFJK3JCLGFBQWE7WUFDakIsSUFBSUMsY0FBYztZQUNsQixJQUFJQyxhQUFhO1lBQ2pCLElBQUlDLGFBQWE7WUFDakIsSUFBSXB0QixRQUFRO1lBQ1osSUFBSXNxQixlQUFlO1lBQ25CLElBQUkxbUIsVUFBVTtZQUNkLElBQUl1ckIsaUJBQWlCO1lBRXJCLElBQUssSUFBSVgsV0FBV2pyQixNQUFPO2dCQUN6QixJQUFJM0IsZUFBZWpELElBQUksQ0FBQzRFLE9BQU9pckIsVUFBVTtvQkFDdkMsSUFBSXRMLFlBQVkzZixLQUFLLENBQUNpckIsUUFBUTtvQkFFOUIsSUFBSXRMLGFBQWEsTUFBTTt3QkFDckI7b0JBQ0Y7b0JBRUEsT0FBUXNMO3dCQUNOLEtBQUs7d0JBQ0wsS0FBSzs0QkFDSCxNQUFNLElBQUkzQyxNQUFNLFVBQVUsaUVBQWlFO3dCQUU3RixLQUFLOzRCQUNIM3FCLE9BQU9naUI7NEJBQ1A7d0JBRUYsS0FBSzs0QkFDSCtKLGFBQWEvSjs0QkFDYjt3QkFFRixLQUFLOzRCQUNIZ0ssY0FBY2hLOzRCQUNkO3dCQUVGLEtBQUs7NEJBQ0hpSyxhQUFhaks7NEJBQ2I7d0JBRUYsS0FBSzs0QkFDSGtLLGFBQWFsSzs0QkFDYjt3QkFFRixLQUFLOzRCQUNIaU0saUJBQWlCak07NEJBQ2pCO3dCQUVGLEtBQUs7NEJBQ0hvSCxlQUFlcEg7NEJBQ2Y7d0JBRUYsS0FBSzs0QkFDSHRmLFVBQVVzZjs0QkFDVjt3QkFFRixLQUFLOzRCQUNIbGpCLFFBQVFrakI7NEJBQ1I7d0JBRUY7NEJBQ0VtSyxjQUFjM2YsUUFBUThnQixTQUFTdEw7NEJBQy9CO29CQUNKO2dCQUNGO1lBQ0Y7WUFFQTtnQkFDRSxJQUFJK0osZUFBZSxRQUFRMXBCLE1BQU10QyxJQUFJLEtBQUssV0FBV3NDLE1BQU10QyxJQUFJLEtBQUssWUFBWSxDQUFDa3RCLHVCQUF1QjtvQkFDdEdBLHdCQUF3QjtvQkFFeEJ4d0IsTUFBTTtnQkFDUjtZQUNGO1lBRUEsSUFBSW12QixXQUFXRSx3QkFBd0J0ZixRQUFRK2MsZUFBZXdDLFlBQVlDLGFBQWFDLFlBQVlDLFlBQVlsc0I7WUFFL0c7Z0JBQ0UsSUFBSTBDLFlBQVksUUFBUXVyQixtQkFBbUIsUUFBUSxDQUFDdEIsdUJBQXVCO29CQUN6RWx3QixNQUFNLGlGQUFpRiw4REFBOEQsMkVBQTJFLG9FQUFvRSx1REFBdUQsa0RBQWtELGVBQWU0RixNQUFNdEMsSUFBSTtvQkFFdGE0c0Isd0JBQXdCO2dCQUMxQjtnQkFFQSxJQUFJN3RCLFVBQVUsUUFBUXNxQixpQkFBaUIsUUFBUSxDQUFDc0QsMEJBQTBCO29CQUN4RWp3QixNQUFNLDZFQUE2RSw4REFBOEQsdUVBQXVFLG9FQUFvRSx1REFBdUQsa0RBQWtELGVBQWU0RixNQUFNdEMsSUFBSTtvQkFFOVoyc0IsMkJBQTJCO2dCQUM3QjtZQUNGO1lBRUEsSUFBSWhxQixZQUFZLE1BQU07Z0JBQ3BCNG9CLHFCQUFxQjllLFFBQVEsV0FBVzlKO1lBQzFDLE9BQU8sSUFBSXVyQixtQkFBbUIsTUFBTTtnQkFDbEMzQyxxQkFBcUI5ZSxRQUFRLFdBQVd5aEI7WUFDMUM7WUFFQSxJQUFJbnZCLFVBQVUsTUFBTTtnQkFDbEJxdEIsY0FBYzNmLFFBQVEsU0FBUzFOO1lBQ2pDLE9BQU8sSUFBSXNxQixpQkFBaUIsTUFBTTtnQkFDaEMrQyxjQUFjM2YsUUFBUSxTQUFTNGM7WUFDakM7WUFFQTVjLE9BQU90TyxJQUFJLENBQUN3dEIsMkJBQTJCLDhEQUE4RDtZQUVyR0MseUJBQXlCbmYsUUFBUW9mO1lBQ2pDLE9BQU87UUFDVDtRQUVBLFNBQVNzQyxnQkFBZ0IxaEIsTUFBTSxFQUFFbkssS0FBSyxFQUFFa25CLGFBQWE7WUFDbkQvYyxPQUFPdE8sSUFBSSxDQUFDbXZCLGlCQUFpQjtZQUM3QixJQUFJaG9CLFdBQVc7WUFDZixJQUFJbW5CLFlBQVk7WUFDaEIsSUFBSXhzQixPQUFPO1lBQ1gsSUFBSStyQixhQUFhO1lBQ2pCLElBQUlDLGNBQWM7WUFDbEIsSUFBSUMsYUFBYTtZQUNqQixJQUFJQyxhQUFhO1lBRWpCLElBQUssSUFBSW9CLFdBQVdqckIsTUFBTztnQkFDekIsSUFBSTNCLGVBQWVqRCxJQUFJLENBQUM0RSxPQUFPaXJCLFVBQVU7b0JBQ3ZDLElBQUl0TCxZQUFZM2YsS0FBSyxDQUFDaXJCLFFBQVE7b0JBRTlCLElBQUl0TCxhQUFhLE1BQU07d0JBQ3JCO29CQUNGO29CQUVBLE9BQVFzTDt3QkFDTixLQUFLOzRCQUNIam9CLFdBQVcyYzs0QkFDWDt3QkFFRixLQUFLOzRCQUNId0ssWUFBWXhLOzRCQUNaO3dCQUVGLEtBQUs7NEJBQ0hoaUIsT0FBT2dpQjs0QkFDUDt3QkFFRixLQUFLOzRCQUNIK0osYUFBYS9KOzRCQUNiO3dCQUVGLEtBQUs7NEJBQ0hnSyxjQUFjaEs7NEJBQ2Q7d0JBRUYsS0FBSzs0QkFDSGlLLGFBQWFqSzs0QkFDYjt3QkFFRixLQUFLOzRCQUNIa0ssYUFBYWxLOzRCQUNiO3dCQUVGOzRCQUNFbUssY0FBYzNmLFFBQVE4Z0IsU0FBU3RMOzRCQUMvQjtvQkFDSjtnQkFDRjtZQUNGO1lBRUE7Z0JBQ0UsSUFBSStKLGVBQWUsUUFBUTFwQixNQUFNdEMsSUFBSSxJQUFJLFFBQVFzQyxNQUFNdEMsSUFBSSxLQUFLLFlBQVksQ0FBQ2t0Qix1QkFBdUI7b0JBQ2xHQSx3QkFBd0I7b0JBRXhCeHdCLE1BQU07Z0JBQ1I7WUFDRjtZQUVBLElBQUltdkIsV0FBV0Usd0JBQXdCdGYsUUFBUStjLGVBQWV3QyxZQUFZQyxhQUFhQyxZQUFZQyxZQUFZbHNCO1lBQy9Hd00sT0FBT3RPLElBQUksQ0FBQ291QixnQkFBZ0IsMEZBQTBGO1lBRXRIWCx5QkFBeUJuZixRQUFRb2Y7WUFDakNXLGNBQWMvZixRQUFRZ2dCLFdBQVdubkI7WUFFakMsSUFBSSxPQUFPQSxhQUFhLFVBQVU7Z0JBQ2hDLHNFQUFzRTtnQkFDdEUsNkVBQTZFO2dCQUM3RW1ILE9BQU90TyxJQUFJLENBQUNHLGNBQWN3ckIsbUJBQW1CeGtCO2dCQUM3QyxPQUFPO1lBQ1Q7WUFFQSxPQUFPQTtRQUNUO1FBRUEsU0FBUzhvQixrQkFBa0IzaEIsTUFBTSxFQUFFbkssS0FBSztZQUN0QztnQkFDRUYsMEJBQTBCLFlBQVlFO2dCQUV0QyxJQUFJQSxNQUFNdkQsS0FBSyxLQUFLdWUsYUFBYWhiLE1BQU0rbUIsWUFBWSxLQUFLL0wsYUFBYSxDQUFDd1AsNkJBQTZCO29CQUNqR3B3QixNQUFNLGlFQUFpRSx1RUFBdUUsdUVBQXVFLCtDQUErQztvQkFFcFFvd0IsOEJBQThCO2dCQUNoQztZQUNGO1lBRUFyZ0IsT0FBT3RPLElBQUksQ0FBQ212QixpQkFBaUI7WUFDN0IsSUFBSXZ1QixRQUFRO1lBQ1osSUFBSXNxQixlQUFlO1lBQ25CLElBQUkvakIsV0FBVztZQUVmLElBQUssSUFBSWlvQixXQUFXanJCLE1BQU87Z0JBQ3pCLElBQUkzQixlQUFlakQsSUFBSSxDQUFDNEUsT0FBT2lyQixVQUFVO29CQUN2QyxJQUFJdEwsWUFBWTNmLEtBQUssQ0FBQ2lyQixRQUFRO29CQUU5QixJQUFJdEwsYUFBYSxNQUFNO3dCQUNyQjtvQkFDRjtvQkFFQSxPQUFRc0w7d0JBQ04sS0FBSzs0QkFDSGpvQixXQUFXMmM7NEJBQ1g7d0JBRUYsS0FBSzs0QkFDSGxqQixRQUFRa2pCOzRCQUNSO3dCQUVGLEtBQUs7NEJBQ0hvSCxlQUFlcEg7NEJBQ2Y7d0JBRUYsS0FBSzs0QkFDSCxNQUFNLElBQUkySSxNQUFNO3dCQUVsQjs0QkFDRXdCLGNBQWMzZixRQUFROGdCLFNBQVN0TDs0QkFDL0I7b0JBQ0o7Z0JBQ0Y7WUFDRjtZQUVBLElBQUlsakIsVUFBVSxRQUFRc3FCLGlCQUFpQixNQUFNO2dCQUMzQ3RxQixRQUFRc3FCO1lBQ1Y7WUFFQTVjLE9BQU90TyxJQUFJLENBQUNvdUIsZ0JBQWdCLHVFQUF1RTtZQUVuRyxJQUFJam5CLFlBQVksTUFBTTtnQkFDcEI7b0JBQ0U1SSxNQUFNLGdFQUFnRTtnQkFDeEU7Z0JBRUEsSUFBSXFDLFNBQVMsTUFBTTtvQkFDakIsTUFBTSxJQUFJNnJCLE1BQU07Z0JBQ2xCO2dCQUVBLElBQUlySyxRQUFRamIsV0FBVztvQkFDckIsSUFBSUEsU0FBU2pKLE1BQU0sR0FBRyxHQUFHO3dCQUN2QixNQUFNLElBQUl1dUIsTUFBTTtvQkFDbEIsRUFBRSxvRUFBb0U7b0JBQ3RFLHVFQUF1RTtvQkFHdkU7d0JBQ0VucUIsd0JBQXdCNkUsUUFBUSxDQUFDLEVBQUU7b0JBQ3JDO29CQUVBdkcsUUFBUSxLQUFLdUcsUUFBUSxDQUFDLEVBQUU7Z0JBQzFCO2dCQUVBO29CQUNFN0Usd0JBQXdCNkU7Z0JBQzFCO2dCQUVBdkcsUUFBUSxLQUFLdUc7WUFDZjtZQUVBLElBQUksT0FBT3ZHLFVBQVUsWUFBWUEsS0FBSyxDQUFDLEVBQUUsS0FBSyxNQUFNO2dCQUNsRCx3RUFBd0U7Z0JBQ3hFLHFFQUFxRTtnQkFDckUsc0VBQXNFO2dCQUN0RSwwRUFBMEU7Z0JBQzFFLHNEQUFzRDtnQkFDdEQsMEVBQTBFO2dCQUMxRSxxRUFBcUU7Z0JBQ3JFLHlEQUF5RDtnQkFDekQsMERBQTBEO2dCQUMxRCxxRUFBcUU7Z0JBQ3JFME4sT0FBT3RPLElBQUksQ0FBQ2t3QjtZQUNkLEVBQUUsK0RBQStEO1lBQ2pFLGdFQUFnRTtZQUNoRSw0RUFBNEU7WUFHNUUsSUFBSXR2QixVQUFVLE1BQU07Z0JBQ2xCO29CQUNFc0IsNkJBQTZCdEIsT0FBTztnQkFDdEM7Z0JBRUEwTixPQUFPdE8sSUFBSSxDQUFDRyxjQUFjd3JCLG1CQUFtQixLQUFLL3FCO1lBQ3BEO1lBRUEsT0FBTztRQUNUO1FBRUEsU0FBU3V2QixTQUFTN2hCLE1BQU0sRUFBRW5LLEtBQUssRUFBRWtuQixhQUFhLEVBQUVTLFlBQVksRUFBRWpCLGFBQWEsRUFBRUUsa0JBQWtCO1lBQzdGO2dCQUNFLElBQUlGLGtCQUFrQlAsWUFBWVMsc0JBQXNCNW1CLE1BQU1pc0IsUUFBUSxJQUFJLE1BQU07b0JBQzlFLE9BQU9DLGdCQUFnQi9oQixRQUFRbkssT0FBTztnQkFDeEMsT0FBTztvQkFDTCxJQUFJMm5CLGNBQWM7d0JBQ2hCLGlHQUFpRzt3QkFDakcsc0VBQXNFO3dCQUN0RXhkLE9BQU90TyxJQUFJLENBQUM0ckI7b0JBQ2Q7b0JBRUEsSUFBSSxPQUFPem5CLE1BQU1tc0IsT0FBTyxLQUFLLFVBQVU7d0JBQ3JDLE9BQU9ELGdCQUFnQmhGLGNBQWN2QixhQUFhLEVBQUUzbEIsT0FBTztvQkFDN0QsT0FBTyxJQUFJQSxNQUFNckMsSUFBSSxLQUFLLFlBQVk7d0JBQ3BDLHVFQUF1RTt3QkFDdkUsT0FBT3V1QixnQkFBZ0JoRixjQUFjdEIsZ0JBQWdCLEVBQUU1bEIsT0FBTztvQkFDaEUsT0FBTzt3QkFDTCxPQUFPa3NCLGdCQUFnQmhGLGNBQWNwQixlQUFlLEVBQUU5bEIsT0FBTztvQkFDL0Q7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsU0FBU29zQixTQUFTamlCLE1BQU0sRUFBRW5LLEtBQUssRUFBRWtuQixhQUFhLEVBQUVyRCxTQUFTLEVBQUU4RCxZQUFZLEVBQUVqQixhQUFhLEVBQUVFLGtCQUFrQjtZQUN4RztnQkFDRSxJQUFJbmUsTUFBTXpJLE1BQU15SSxHQUFHO2dCQUNuQixJQUFJbEQsT0FBT3ZGLE1BQU11RixJQUFJO2dCQUNyQixJQUFJOG1CLGFBQWFyc0IsTUFBTXFzQixVQUFVO2dCQUVqQyxJQUFJM0Ysa0JBQWtCUCxZQUFZUyxzQkFBc0I1bUIsTUFBTWlzQixRQUFRLElBQUksUUFBUSxPQUFPeGpCLFFBQVEsWUFBWSxPQUFPbEQsU0FBUyxZQUFZQSxTQUFTLElBQUk7b0JBQ3BKO3dCQUNFLElBQUlrRCxRQUFRLGdCQUFnQixPQUFPekksTUFBTXFzQixVQUFVLEtBQUssVUFBVTs0QkFDaEUsSUFBSSxPQUFPOW1CLFNBQVMsWUFBWSxDQUFDQSxNQUFNO2dDQUNyQ25MLE1BQU0sbVdBQW1XbWtCLDRDQUE0Q2haOzRCQUN2Wjt3QkFDRjtvQkFDRjtvQkFFQSttQixhQUFhbmlCLFFBQVFuSztvQkFDckIsT0FBTztnQkFDVDtnQkFFQSxJQUFJQSxNQUFNeUksR0FBRyxLQUFLLGNBQWM7b0JBQzlCLHNGQUFzRjtvQkFDdEYsSUFBSWpNLE1BQU0rdkIsZUFBZSxTQUFTaG5CO29CQUVsQyxJQUFJLE9BQU84bUIsZUFBZSxZQUFZcnNCLE1BQU1JLFFBQVEsSUFBSSxRQUFRSixNQUFNd3NCLE1BQU0sSUFBSXhzQixNQUFNeXNCLE9BQU8sRUFBRTt3QkFDN0Ysa0dBQWtHO3dCQUNsRywrRkFBK0Y7d0JBQy9GLFNBQVM7d0JBQ1Q7NEJBQ0UsSUFBSSxPQUFPSixlQUFlLFVBQVU7Z0NBQ2xDLElBQUlyc0IsTUFBTUksUUFBUSxJQUFJLE1BQU07b0NBQzFCaEcsTUFBTTtnQ0FDUixPQUFPLElBQUk0RixNQUFNd3NCLE1BQU0sSUFBSXhzQixNQUFNeXNCLE9BQU8sRUFBRTtvQ0FDeEMsSUFBSUMsa0JBQWtCMXNCLE1BQU13c0IsTUFBTSxJQUFJeHNCLE1BQU15c0IsT0FBTyxHQUFHLGlDQUFpQ3pzQixNQUFNd3NCLE1BQU0sR0FBRyxrQkFBa0I7b0NBRXhIcHlCLE1BQU0sbWJBQW1ic3lCLGlCQUFpQkE7Z0NBQzVjOzRCQUNGO3dCQUNGO3dCQUVBLE9BQU9KLGFBQWFuaUIsUUFBUW5LO29CQUM5QixPQUFPO3dCQUNMLDRFQUE0RTt3QkFDNUUsSUFBSW1VLFdBQVcwUCxVQUFVOEksU0FBUyxDQUFDdHRCLEdBQUcsQ0FBQzdDO3dCQUV2Qzs0QkFDRSxJQUFJb3dCLGNBQWNDLGlCQUFpQjFZOzRCQUVuQyxJQUFJeVksYUFBYTtnQ0FDZixPQUFRQSxZQUFZRSxZQUFZO29DQUM5QixLQUFLO3dDQUNIOzRDQUNFLElBQUlDLHdCQUF3QnZOLGtDQUM1QnhmLE9BQU80c0IsWUFBWUksZUFBZTs0Q0FFbEMsSUFBSUQsdUJBQXVCO2dEQUN6QjN5QixNQUFNLHFIQUFxSCxzSEFBc0gsZ0hBQWdILHNGQUFzRm1MLE1BQU13bkI7NENBQy9iOzRDQUVBO3dDQUNGO29DQUVGLEtBQUs7d0NBQ0g7NENBQ0UsSUFBSUUseUJBQXlCaE4sNENBQzdCamdCLE9BQU80c0IsWUFBWU0saUJBQWlCOzRDQUVwQyxJQUFJRCx3QkFBd0I7Z0RBQzFCN3lCLE1BQU0sd0dBQXdHLHNJQUFzSSwySEFBMkgsa0hBQWtILG9IQUFvSCx5SEFBeUgsd0JBQXdCaXlCLFlBQVk5bUIsTUFBTUEsTUFBTTBuQjs0Q0FDaHdCOzRDQUVBO3dDQUNGO2dDQUNKOzRCQUNGO3dCQUNGO3dCQUVBLElBQUksQ0FBQzlZLFVBQVU7NEJBQ2IsSUFBSWdaLGdCQUFnQkMsNEJBQTRCcHRCOzRCQUNoRCxJQUFJcXRCLGtCQUFrQnhKLFVBQVV5SixXQUFXLENBQUNqdUIsR0FBRyxDQUFDN0M7NEJBQ2hELElBQUkrd0IsUUFBUUM7NEJBRVosSUFBSUgsaUJBQWlCO2dDQUNuQiw2RUFBNkU7Z0NBQzdFLHFEQUFxRDtnQ0FDckRBLGdCQUFnQkUsS0FBSyxJQUFJRTtnQ0FDekJDLG9DQUFvQ1AsZUFBZUUsZ0JBQWdCcnRCLEtBQUs7Z0NBRXhFLElBQUlxdEIsZ0JBQWdCRSxLQUFLLEdBQUdJLFNBQVM7b0NBQ25DSixRQUFRSztnQ0FDVjs0QkFDRjs0QkFFQXpaLFdBQVc7Z0NBQ1R6VyxNQUFNO2dDQUNOOG1CLFFBQVEsRUFBRTtnQ0FDVitJLE9BQU9BO2dDQUNQdnRCLE9BQU9tdEI7NEJBQ1Q7NEJBQ0F0SixVQUFVOEksU0FBUyxDQUFDMUUsR0FBRyxDQUFDenJCLEtBQUsyWDs0QkFFN0I7Z0NBQ0UwWiwwQkFBMEIxWixVQUFVblU7NEJBQ3RDOzRCQUVBLElBQUk4dEIsZ0JBQWdCakssVUFBVWtLLFdBQVcsQ0FBQzF1QixHQUFHLENBQUNndEI7NEJBRTlDLElBQUksQ0FBQ3lCLGVBQWU7Z0NBQ2xCQSxnQkFBZ0IsSUFBSS91QjtnQ0FDcEI4a0IsVUFBVWtLLFdBQVcsQ0FBQzlGLEdBQUcsQ0FBQ29FLFlBQVl5QjtnQ0FDdEMsSUFBSUUscUJBQXFCO29DQUN2QnR3QixNQUFNO29DQUNOOG1CLFFBQVEsRUFBRTtvQ0FDVitJLE9BQU9DO29DQUNQeHRCLE9BQU87d0NBQ0xxc0IsWUFBWUE7d0NBQ1o0QixPQUFPLEVBQUU7b0NBQ1g7Z0NBQ0Y7Z0NBQ0FILGNBQWNJLEdBQUcsQ0FBQ0Y7Z0NBRWxCO29DQUNFLElBQUluSyxVQUFVc0ssZ0JBQWdCLENBQUNsdkIsR0FBRyxDQUFDb3RCLGFBQWE7d0NBQzlDanlCLE1BQU0scUlBQXFJaXlCO29DQUM3STtnQ0FDRjtnQ0FFQXhJLFVBQVVzSyxnQkFBZ0IsQ0FBQ2xHLEdBQUcsQ0FBQ29FLFlBQVkyQjs0QkFDN0M7NEJBRUFGLGNBQWNJLEdBQUcsQ0FBQy9aO3dCQUNwQjt3QkFFQSxJQUFJMFAsVUFBVXVLLGlCQUFpQixFQUFFOzRCQUMvQnZLLFVBQVV1SyxpQkFBaUIsQ0FBQ0YsR0FBRyxDQUFDL1o7d0JBQ2xDO3dCQUVBLElBQUl3VCxjQUFjOzRCQUNoQixpR0FBaUc7NEJBQ2pHLHNFQUFzRTs0QkFDdEV4ZCxPQUFPdE8sSUFBSSxDQUFDNHJCO3dCQUNkO3dCQUVBLE9BQU87b0JBQ1Q7Z0JBQ0YsT0FBTyxJQUFJem5CLE1BQU13c0IsTUFBTSxJQUFJeHNCLE1BQU15c0IsT0FBTyxFQUFFO29CQUN4QywyRUFBMkU7b0JBQzNFLE9BQU9ILGFBQWFuaUIsUUFBUW5LO2dCQUM5QixPQUFPO29CQUNMLGtFQUFrRTtvQkFDbEUscUVBQXFFO29CQUNyRSw0RUFBNEU7b0JBQzVFLElBQUkybkIsY0FBYzt3QkFDaEIsaUdBQWlHO3dCQUNqRyxzRUFBc0U7d0JBQ3RFeGQsT0FBT3RPLElBQUksQ0FBQzRyQjtvQkFDZDtvQkFFQSxPQUFRem5CLE1BQU15SSxHQUFHO3dCQUNmLEtBQUs7d0JBQ0wsS0FBSzs0QkFDSCxPQUFPNmpCLGFBQWFwRixjQUFjdEIsZ0JBQWdCLEVBQUU1bEI7d0JBRXRELEtBQUs7NEJBQ0gsT0FBT3NzQixhQUFhcEYsY0FBY3JCLGFBQWEsRUFBRTdsQjt3QkFFbkQ7NEJBQ0UsT0FBT3NzQixhQUFhcEYsY0FBY3BCLGVBQWUsRUFBRTlsQjtvQkFDdkQ7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsU0FBU3NzQixhQUFhbmlCLE1BQU0sRUFBRW5LLEtBQUs7WUFDakNtSyxPQUFPdE8sSUFBSSxDQUFDbXZCLGlCQUFpQjtZQUU3QixJQUFLLElBQUlDLFdBQVdqckIsTUFBTztnQkFDekIsSUFBSTNCLGVBQWVqRCxJQUFJLENBQUM0RSxPQUFPaXJCLFVBQVU7b0JBQ3ZDLElBQUl0TCxZQUFZM2YsS0FBSyxDQUFDaXJCLFFBQVE7b0JBRTlCLElBQUl0TCxhQUFhLE1BQU07d0JBQ3JCO29CQUNGO29CQUVBLE9BQVFzTDt3QkFDTixLQUFLO3dCQUNMLEtBQUs7NEJBQ0gsTUFBTSxJQUFJM0MsTUFBTSxTQUFTLGlFQUFpRTt3QkFFNUY7NEJBQ0V3QixjQUFjM2YsUUFBUThnQixTQUFTdEw7NEJBQy9CO29CQUNKO2dCQUNGO1lBQ0Y7WUFFQXhWLE9BQU90TyxJQUFJLENBQUN3dEI7WUFDWixPQUFPO1FBQ1Q7UUFFQSxTQUFTZ0YsVUFBVWxrQixNQUFNLEVBQUVuSyxLQUFLLEVBQUU2akIsU0FBUyxFQUFFOEQsWUFBWSxFQUFFakIsYUFBYSxFQUFFRSxrQkFBa0I7WUFDMUY7Z0JBQ0UsSUFBSXZvQixlQUFlakQsSUFBSSxDQUFDNEUsT0FBTyxhQUFhO29CQUMxQyxJQUFJZ0QsV0FBV2hELE1BQU1nRCxRQUFRO29CQUM3QixJQUFJb29CLFFBQVFueEIsTUFBTWdrQixPQUFPLENBQUNqYixZQUFZQSxTQUFTakosTUFBTSxHQUFHLElBQUlpSixRQUFRLENBQUMsRUFBRSxHQUFHLE9BQU9BO29CQUVqRixJQUFJLE9BQU9vb0IsVUFBVSxjQUFjLE9BQU9BLFVBQVUsWUFBWW54QixNQUFNZ2tCLE9BQU8sQ0FBQ21OLFFBQVE7d0JBQ3BGLElBQUlrRCxZQUFZLE9BQU9sRCxVQUFVLGFBQWEsZUFBZSxPQUFPQSxVQUFVLFdBQVcsYUFBYTt3QkFFdEdoeEIsTUFBTSw0SEFBNEgsc0VBQXNFazBCO29CQUMxTTtnQkFDRjtZQUNGO1lBRUE7Z0JBQ0UsSUFBSWpDLGFBQWFyc0IsTUFBTXFzQixVQUFVO2dCQUNqQyxJQUFJOW1CLE9BQU92RixNQUFNdUYsSUFBSTtnQkFFckIsSUFBSW1oQixrQkFBa0JQLFlBQVlTLHNCQUFzQjVtQixNQUFNaXNCLFFBQVEsSUFBSSxRQUFRLE9BQU9JLGVBQWUsWUFBWSxPQUFPOW1CLFNBQVMsWUFBWUEsU0FBUyxJQUFJO29CQUMzSixnRUFBZ0U7b0JBQ2hFLE9BQU9ncEIsY0FBY3BrQixRQUFRbks7Z0JBQy9CO2dCQUVBO29CQUNFLElBQUl1RixLQUFLc2IsUUFBUSxDQUFDLE1BQU07d0JBQ3RCem1CLE1BQU0sOFNBQThTbUw7b0JBQ3RUO2dCQUNGO2dCQUVBLElBQUkvSSxNQUFNK3ZCLGVBQWUsU0FBU2huQjtnQkFDbEMsSUFBSTRPLFdBQVcwUCxVQUFVOEksU0FBUyxDQUFDdHRCLEdBQUcsQ0FBQzdDO2dCQUV2QyxJQUFJLENBQUMyWCxVQUFVO29CQUNiQSxXQUFXMFAsVUFBVXNLLGdCQUFnQixDQUFDOXVCLEdBQUcsQ0FBQ2d0QjtvQkFFMUMsSUFBSSxDQUFDbFksVUFBVTt3QkFDYkEsV0FBVzs0QkFDVHpXLE1BQU07NEJBQ044bUIsUUFBUSxFQUFFOzRCQUNWK0ksT0FBT0M7NEJBQ1B4dEIsT0FBTztnQ0FDTHFzQixZQUFZQTtnQ0FDWjRCLE9BQU87b0NBQUMxb0I7aUNBQUs7NEJBQ2Y7d0JBQ0Y7d0JBQ0FzZSxVQUFVc0ssZ0JBQWdCLENBQUNsRyxHQUFHLENBQUNvRSxZQUFZbFk7d0JBQzNDLElBQUkyWixnQkFBZ0IsSUFBSS91Qjt3QkFDeEIrdUIsY0FBY0ksR0FBRyxDQUFDL1o7d0JBRWxCOzRCQUNFLElBQUkwUCxVQUFVa0ssV0FBVyxDQUFDOXVCLEdBQUcsQ0FBQ290QixhQUFhO2dDQUN6Q2p5QixNQUFNLDJIQUEySGl5Qjs0QkFDbkk7d0JBQ0Y7d0JBRUF4SSxVQUFVa0ssV0FBVyxDQUFDOUYsR0FBRyxDQUFDb0UsWUFBWXlCO29CQUN4QyxPQUFPO3dCQUNMM1osU0FBU25VLEtBQUssQ0FBQ2l1QixLQUFLLENBQUNweUIsSUFBSSxDQUFDMEo7b0JBQzVCO29CQUVBc2UsVUFBVThJLFNBQVMsQ0FBQzFFLEdBQUcsQ0FBQ3pyQixLQUFLMlg7b0JBRTdCLElBQUkwUCxVQUFVdUssaUJBQWlCLEVBQUU7d0JBQy9CdkssVUFBVXVLLGlCQUFpQixDQUFDRixHQUFHLENBQUMvWjtvQkFDbEM7b0JBRUFxYSxrQkFBa0JyYSxTQUFTcVEsTUFBTSxFQUFFeGtCO2dCQUNyQztnQkFFQSxJQUFJMm5CLGNBQWM7b0JBQ2hCLGlHQUFpRztvQkFDakcsc0VBQXNFO29CQUN0RXhkLE9BQU90TyxJQUFJLENBQUM0ckI7Z0JBQ2Q7WUFDRjtRQUNGO1FBRUEsU0FBUzhHLGNBQWNwa0IsTUFBTSxFQUFFbkssS0FBSztZQUNsQ21LLE9BQU90TyxJQUFJLENBQUNtdkIsaUJBQWlCO1lBQzdCLElBQUlob0IsV0FBVztZQUNmLElBQUltbkIsWUFBWTtZQUVoQixJQUFLLElBQUljLFdBQVdqckIsTUFBTztnQkFDekIsSUFBSTNCLGVBQWVqRCxJQUFJLENBQUM0RSxPQUFPaXJCLFVBQVU7b0JBQ3ZDLElBQUl0TCxZQUFZM2YsS0FBSyxDQUFDaXJCLFFBQVE7b0JBRTlCLElBQUl0TCxhQUFhLE1BQU07d0JBQ3JCO29CQUNGO29CQUVBLE9BQVFzTDt3QkFDTixLQUFLOzRCQUNIam9CLFdBQVcyYzs0QkFDWDt3QkFFRixLQUFLOzRCQUNId0ssWUFBWXhLOzRCQUNaO3dCQUVGOzRCQUNFbUssY0FBYzNmLFFBQVE4Z0IsU0FBU3RMOzRCQUMvQjtvQkFDSjtnQkFDRjtZQUNGO1lBRUF4VixPQUFPdE8sSUFBSSxDQUFDb3VCO1lBQ1osSUFBSW1CLFFBQVFueEIsTUFBTWdrQixPQUFPLENBQUNqYixZQUFZQSxTQUFTakosTUFBTSxHQUFHLElBQUlpSixRQUFRLENBQUMsRUFBRSxHQUFHLE9BQU9BO1lBRWpGLElBQUksT0FBT29vQixVQUFVLGNBQWMsT0FBT0EsVUFBVSxZQUFZQSxVQUFVLFFBQVFBLFVBQVVwUSxXQUFXO2dCQUNyRywrREFBK0Q7Z0JBQy9EN1EsT0FBT3RPLElBQUksQ0FBQ0csY0FBY29oQixxQkFBcUIsS0FBS2dPO1lBQ3REO1lBRUFsQixjQUFjL2YsUUFBUWdnQixXQUFXbm5CO1lBQ2pDbUgsT0FBT3RPLElBQUksQ0FBQzR5QixTQUFTenlCLGNBQWMsVUFBVTB5QjtZQUM3QyxPQUFPO1FBQ1Q7UUFFQSxTQUFTRixrQkFBa0Jya0IsTUFBTSxFQUFFbkssS0FBSztZQUN0QyxJQUFJZ0QsV0FBVztZQUNmLElBQUltbkIsWUFBWTtZQUVoQixJQUFLLElBQUljLFdBQVdqckIsTUFBTztnQkFDekIsSUFBSTNCLGVBQWVqRCxJQUFJLENBQUM0RSxPQUFPaXJCLFVBQVU7b0JBQ3ZDLElBQUl0TCxZQUFZM2YsS0FBSyxDQUFDaXJCLFFBQVE7b0JBRTlCLElBQUl0TCxhQUFhLE1BQU07d0JBQ3JCO29CQUNGO29CQUVBLE9BQVFzTDt3QkFDTixLQUFLOzRCQUNIam9CLFdBQVcyYzs0QkFDWDt3QkFFRixLQUFLOzRCQUNId0ssWUFBWXhLOzRCQUNaO29CQUNKO2dCQUNGO1lBQ0Y7WUFFQSxJQUFJeUwsUUFBUW54QixNQUFNZ2tCLE9BQU8sQ0FBQ2piLFlBQVlBLFNBQVNqSixNQUFNLEdBQUcsSUFBSWlKLFFBQVEsQ0FBQyxFQUFFLEdBQUcsT0FBT0E7WUFFakYsSUFBSSxPQUFPb29CLFVBQVUsY0FBYyxPQUFPQSxVQUFVLFlBQVlBLFVBQVUsUUFBUUEsVUFBVXBRLFdBQVc7Z0JBQ3JHLCtEQUErRDtnQkFDL0Q3USxPQUFPdE8sSUFBSSxDQUFDRyxjQUFjb2hCLHFCQUFxQixLQUFLZ087WUFDdEQ7WUFFQWxCLGNBQWMvZixRQUFRZ2dCLFdBQVdubkI7WUFDakM7UUFDRjtRQUVBLFNBQVMyckIsbUJBQW1CcHBCLElBQUksRUFBRXFwQixXQUFXLEVBQUVDLFVBQVU7WUFDdkQsSUFBSUMsYUFBYTtZQUVqQixJQUFJLE9BQU9GLGdCQUFnQixZQUFZQSxnQkFBZ0IsSUFBSTtnQkFDekRFLGNBQWMsTUFBTUYsY0FBYztnQkFFbEMsSUFBSSxPQUFPQyxlQUFlLFVBQVU7b0JBQ2xDQyxjQUFjLE1BQU1ELGFBQWE7Z0JBQ25DO1lBQ0YsT0FBTztnQkFDTEMsY0FBYyxTQUFTdnBCO1lBQ3pCO1lBRUEsT0FBT2duQixlQUFlLFNBQVN1QztRQUNqQztRQUVBLFNBQVNDLFFBQVE1a0IsTUFBTSxFQUFFbkssS0FBSyxFQUFFNmpCLFNBQVM7WUFDdkMsSUFBSW5hLE1BQU0xSixNQUFNMEosR0FBRyxFQUNmc2xCLFNBQVNodkIsTUFBTWd2QixNQUFNO1lBRXpCLElBQUlodkIsTUFBTWl2QixPQUFPLEtBQUssVUFBVyxRQUFPdmxCLFFBQVEsWUFBWSxPQUFPc2xCLFdBQVcsUUFBTyxLQUFNaHZCLE1BQU1rdkIsYUFBYSxLQUFLLFNBQVMsNkVBQTZFO1lBQ3pNLENBQUUsUUFBT3hsQixRQUFRLFlBQVlBLEdBQUcsQ0FBQyxFQUFFLEtBQUssT0FBUUEsQ0FBQUEsR0FBRyxDQUFDLEVBQUUsS0FBSyxPQUFPQSxHQUFHLENBQUMsRUFBRSxLQUFLLEdBQUUsS0FBT0EsQ0FBQUEsR0FBRyxDQUFDLEVBQUUsS0FBSyxPQUFPQSxHQUFHLENBQUMsRUFBRSxLQUFLLEdBQUUsS0FBT0EsQ0FBQUEsR0FBRyxDQUFDLEVBQUUsS0FBSyxPQUFPQSxHQUFHLENBQUMsRUFBRSxLQUFLLEdBQUUsS0FBT0EsQ0FBQUEsR0FBRyxDQUFDLEVBQUUsS0FBSyxPQUFPQSxHQUFHLENBQUMsRUFBRSxLQUFLLEdBQUUsQ0FBQyxLQUFNLENBQUUsUUFBT3NsQixXQUFXLFlBQVlBLE1BQU0sQ0FBQyxFQUFFLEtBQUssT0FBUUEsQ0FBQUEsTUFBTSxDQUFDLEVBQUUsS0FBSyxPQUFPQSxNQUFNLENBQUMsRUFBRSxLQUFLLEdBQUUsS0FBT0EsQ0FBQUEsTUFBTSxDQUFDLEVBQUUsS0FBSyxPQUFPQSxNQUFNLENBQUMsRUFBRSxLQUFLLEdBQUUsS0FBT0EsQ0FBQUEsTUFBTSxDQUFDLEVBQUUsS0FBSyxPQUFPQSxNQUFNLENBQUMsRUFBRSxLQUFLLEdBQUUsS0FBT0EsQ0FBQUEsTUFBTSxDQUFDLEVBQUUsS0FBSyxPQUFPQSxNQUFNLENBQUMsRUFBRSxLQUFLLEdBQUUsQ0FBQyxHQUFJO2dCQUMxYSxnR0FBZ0c7Z0JBQ2hHLGFBQWE7Z0JBQ2IsSUFBSXpsQixRQUFRdkosTUFBTXVKLEtBQUs7Z0JBQ3ZCLElBQUkvTSxNQUFNbXlCLG1CQUFtQmpsQixLQUFLc2xCLFFBQVF6bEI7Z0JBQzFDLElBQUk0SyxXQUFXMFAsVUFBVXlKLFdBQVcsQ0FBQ2p1QixHQUFHLENBQUM3QztnQkFFekMsSUFBSSxDQUFDMlgsVUFBVTtvQkFDYkEsV0FBVzt3QkFDVHpXLE1BQU07d0JBQ044bUIsUUFBUSxFQUFFO3dCQUNWK0ksT0FBT0M7d0JBQ1B4dEIsT0FBTzs0QkFDTHlJLEtBQUs7NEJBQ0x0RyxJQUFJOzRCQUNKLCtFQUErRTs0QkFDL0Usd0ZBQXdGOzRCQUN4Riw2RkFBNkY7NEJBQzdGLHlGQUF5Rjs0QkFDekZvRCxNQUFNeXBCLFNBQVNoVSxZQUFZdFI7NEJBQzNCa2xCLGFBQWFJOzRCQUNiSCxZQUFZdGxCOzRCQUNab2IsYUFBYTNrQixNQUFNMmtCLFdBQVc7NEJBQzlCMWUsV0FBV2pHLE1BQU1pRyxTQUFTOzRCQUMxQnZJLE1BQU1zQyxNQUFNdEMsSUFBSTs0QkFDaEJ3eEIsZUFBZWx2QixNQUFNa3ZCLGFBQWE7NEJBQ2xDQyxnQkFBZ0JudkIsTUFBTW12QixjQUFjO3dCQUN0QztvQkFDRjtvQkFDQXRMLFVBQVV5SixXQUFXLENBQUNyRixHQUFHLENBQUN6ckIsS0FBSzJYO29CQUUvQjt3QkFDRTBaLDBCQUEwQjFaLFVBQVVuVTtvQkFDdEM7b0JBRUFzc0IsYUFBYW5ZLFNBQVNxUSxNQUFNLEVBQUVyUSxTQUFTblUsS0FBSztnQkFDOUM7Z0JBRUEsSUFBSUEsTUFBTWt2QixhQUFhLEtBQUssVUFBVXJMLFVBQVV1TCxpQkFBaUIsQ0FBQzlsQixJQUFJLEdBQUcsSUFBSTtvQkFDM0V1YSxVQUFVdUwsaUJBQWlCLENBQUNsQixHQUFHLENBQUMvWjtnQkFDbEMsT0FBTztvQkFDTDBQLFVBQVV3TCxZQUFZLENBQUNuQixHQUFHLENBQUMvWjtnQkFDN0I7WUFDRjtZQUVBLE9BQU8rWCxnQkFBZ0IvaEIsUUFBUW5LLE9BQU87UUFDeEM7UUFFQSxTQUFTa3NCLGdCQUFnQi9oQixNQUFNLEVBQUVuSyxLQUFLLEVBQUVzdkIsR0FBRztZQUN6Q25sQixPQUFPdE8sSUFBSSxDQUFDbXZCLGlCQUFpQnNFO1lBRTdCLElBQUssSUFBSXJFLFdBQVdqckIsTUFBTztnQkFDekIsSUFBSTNCLGVBQWVqRCxJQUFJLENBQUM0RSxPQUFPaXJCLFVBQVU7b0JBQ3ZDLElBQUl0TCxZQUFZM2YsS0FBSyxDQUFDaXJCLFFBQVE7b0JBRTlCLElBQUl0TCxhQUFhLE1BQU07d0JBQ3JCO29CQUNGO29CQUVBLE9BQVFzTDt3QkFDTixLQUFLO3dCQUNMLEtBQUs7NEJBQ0gsTUFBTSxJQUFJM0MsTUFBTWdILE1BQU0saUVBQWlFO3dCQUV6Rjs0QkFDRXhGLGNBQWMzZixRQUFROGdCLFNBQVN0TDs0QkFDL0I7b0JBQ0o7Z0JBQ0Y7WUFDRjtZQUVBeFYsT0FBT3RPLElBQUksQ0FBQ3d0QjtZQUNaLE9BQU87UUFDVDtRQUVBLFNBQVNrRyxrQkFBa0JwbEIsTUFBTSxFQUFFbkssS0FBSztZQUN0Q21LLE9BQU90TyxJQUFJLENBQUNtdkIsaUJBQWlCO1lBRTdCLElBQUssSUFBSUMsV0FBV2pyQixNQUFPO2dCQUN6QixJQUFJM0IsZUFBZWpELElBQUksQ0FBQzRFLE9BQU9pckIsVUFBVTtvQkFDdkMsSUFBSXRMLFlBQVkzZixLQUFLLENBQUNpckIsUUFBUTtvQkFFOUIsSUFBSXRMLGFBQWEsTUFBTTt3QkFDckI7b0JBQ0Y7b0JBRUEsT0FBUXNMO3dCQUNOLEtBQUs7d0JBQ0wsS0FBSzs0QkFDSCxNQUFNLElBQUkzQyxNQUFNO3dCQUVsQjs0QkFDRXdCLGNBQWMzZixRQUFROGdCLFNBQVN0TDs0QkFDL0I7b0JBQ0o7Z0JBQ0Y7WUFDRjtZQUVBeFYsT0FBT3RPLElBQUksQ0FBQ291QjtZQUNaLE9BQU87UUFDVDtRQUVBLFNBQVN1RixVQUFVcmxCLE1BQU0sRUFBRW5LLEtBQUssRUFBRWtuQixhQUFhLEVBQUVSLGFBQWEsRUFBRUUsa0JBQWtCO1lBQ2hGO2dCQUNFLElBQUl2b0IsZUFBZWpELElBQUksQ0FBQzRFLE9BQU8sYUFBYTtvQkFDMUMsSUFBSWdELFdBQVdoRCxNQUFNZ0QsUUFBUTtvQkFDN0IsSUFBSW9vQixRQUFRbnhCLE1BQU1na0IsT0FBTyxDQUFDamIsWUFBWUEsU0FBU2pKLE1BQU0sR0FBRyxJQUFJaUosUUFBUSxDQUFDLEVBQUUsR0FBRyxPQUFPQTtvQkFFakYsSUFBSS9JLE1BQU1na0IsT0FBTyxDQUFDamIsYUFBYUEsU0FBU2pKLE1BQU0sR0FBRyxHQUFHO3dCQUNsREssTUFBTSxrS0FBa0ssZ0tBQWdLLDZJQUE2SSxnS0FBZ0sseUdBQXlHNEksU0FBU2pKLE1BQU07b0JBQy91QixPQUFPLElBQUksT0FBT3F4QixVQUFVLGNBQWMsT0FBT0EsVUFBVSxVQUFVO3dCQUNuRSxJQUFJa0QsWUFBWSxPQUFPbEQsVUFBVSxhQUFhLGVBQWU7d0JBRTdEaHhCLE1BQU0saUlBQWlJLGdJQUFnSSxtQ0FBbUNrMEI7b0JBQzVTLE9BQU8sSUFBSWxELFNBQVNBLE1BQU1oRSxRQUFRLEtBQUssRUFBQyxHQUFFQSxRQUFRLEVBQUU7d0JBQ2xELElBQUlnRSxNQUFNcUUsUUFBUSxJQUFJLE1BQU07NEJBQzFCcjFCLE1BQU0sOEpBQThKLDhKQUE4SixrS0FBa0s7d0JBQ3RlLE9BQU87NEJBQ0xBLE1BQU0sbUtBQW1LLG1LQUFtSywyS0FBMks7d0JBQ3pmO29CQUNGO2dCQUNGO1lBQ0Y7WUFFQTtnQkFDRSxJQUFJc3NCLGtCQUFrQlAsWUFBWSxDQUFDUyxzQkFBc0I1bUIsTUFBTWlzQixRQUFRLElBQUksTUFBTTtvQkFDL0V5RCxjQUFjeEksY0FBY3BCLGVBQWUsRUFBRTlsQjtvQkFDN0MsT0FBTztnQkFDVCxPQUFPO29CQUNMLE9BQU8wdkIsY0FBY3ZsQixRQUFRbks7Z0JBQy9CO1lBQ0Y7UUFDRjtRQUVBLFNBQVMwdkIsY0FBY3ZsQixNQUFNLEVBQUVuSyxLQUFLO1lBQ2xDbUssT0FBT3RPLElBQUksQ0FBQ212QixpQkFBaUI7WUFDN0IsSUFBSWhvQixXQUFXO1lBQ2YsSUFBSW1uQixZQUFZO1lBRWhCLElBQUssSUFBSWMsV0FBV2pyQixNQUFPO2dCQUN6QixJQUFJM0IsZUFBZWpELElBQUksQ0FBQzRFLE9BQU9pckIsVUFBVTtvQkFDdkMsSUFBSXRMLFlBQVkzZixLQUFLLENBQUNpckIsUUFBUTtvQkFFOUIsSUFBSXRMLGFBQWEsTUFBTTt3QkFDckI7b0JBQ0Y7b0JBRUEsT0FBUXNMO3dCQUNOLEtBQUs7NEJBQ0hqb0IsV0FBVzJjOzRCQUNYO3dCQUVGLEtBQUs7NEJBQ0h3SyxZQUFZeEs7NEJBQ1o7d0JBRUY7NEJBQ0VtSyxjQUFjM2YsUUFBUThnQixTQUFTdEw7NEJBQy9CO29CQUNKO2dCQUNGO1lBQ0Y7WUFFQXhWLE9BQU90TyxJQUFJLENBQUNvdUI7WUFDWixJQUFJbUIsUUFBUW54QixNQUFNZ2tCLE9BQU8sQ0FBQ2piLFlBQVlBLFNBQVNqSixNQUFNLEdBQUcsSUFBSWlKLFFBQVEsQ0FBQyxFQUFFLEdBQUcsT0FBT0E7WUFFakYsSUFBSSxPQUFPb29CLFVBQVUsY0FBYyxPQUFPQSxVQUFVLFlBQVlBLFVBQVUsUUFBUUEsVUFBVXBRLFdBQVc7Z0JBQ3JHLCtEQUErRDtnQkFDL0Q3USxPQUFPdE8sSUFBSSxDQUFDRyxjQUFjb2hCLHFCQUFxQixLQUFLZ087WUFDdEQ7WUFFQWxCLGNBQWMvZixRQUFRZ2dCLFdBQVdubkI7WUFDakNtSCxPQUFPdE8sSUFBSSxDQUFDNHlCLFNBQVN6eUIsY0FBYyxVQUFVMHlCO1lBQzdDLE9BQU87UUFDVDtRQUVBLFNBQVNpQixjQUFjeGxCLE1BQU0sRUFBRW5LLEtBQUssRUFBRWtuQixhQUFhLEVBQUVSLGFBQWE7WUFDaEU7Z0JBQ0UsSUFBSUEsZ0JBQWdCUixhQUFhZ0IsY0FBY3pCLFVBQVUsS0FBSyxNQUFNO29CQUNsRSxzRUFBc0U7b0JBQ3RFeUIsY0FBY3pCLFVBQVUsR0FBRyxFQUFFO29CQUM3QixPQUFPbUssd0JBQXdCMUksY0FBY3pCLFVBQVUsRUFBRXpsQixPQUFPO2dCQUNsRSxPQUFPO29CQUNMLDZFQUE2RTtvQkFDN0UsOERBQThEO29CQUM5RCxPQUFPNHZCLHdCQUF3QnpsQixRQUFRbkssT0FBTztnQkFDaEQ7WUFDRjtRQUNGO1FBRUEsU0FBUzZ2QixjQUFjMWxCLE1BQU0sRUFBRW5LLEtBQUssRUFBRWtuQixhQUFhLEVBQUVSLGFBQWE7WUFDaEU7Z0JBQ0UsSUFBSUEsa0JBQWtCVixrQkFBa0JrQixjQUFjMUIsVUFBVSxLQUFLLE1BQU07b0JBQ3pFLGlGQUFpRjtvQkFDakYwQixjQUFjMUIsVUFBVSxHQUFHO3dCQUFDc0s7cUJBQVE7b0JBQ3BDLE9BQU9GLHdCQUF3QjFJLGNBQWMxQixVQUFVLEVBQUV4bEIsT0FBTztnQkFDbEUsT0FBTztvQkFDTCw2RUFBNkU7b0JBQzdFLDhEQUE4RDtvQkFDOUQsT0FBTzR2Qix3QkFBd0J6bEIsUUFBUW5LLE9BQU87Z0JBQ2hEO1lBQ0Y7UUFDRjtRQUVBLFNBQVMrdkIsV0FBVzVsQixNQUFNLEVBQUVuSyxLQUFLLEVBQUU2akIsU0FBUyxFQUFFOEQsWUFBWSxFQUFFakIsYUFBYSxFQUFFRSxrQkFBa0I7WUFDM0Y7Z0JBQ0UsSUFBSW9KLFlBQVlod0IsTUFBTW9DLEtBQUs7Z0JBRTNCLElBQUksT0FBT3BDLE1BQU0wSixHQUFHLEtBQUssWUFBWSxDQUFDMUosTUFBTTBKLEdBQUcsSUFBSSxDQUFFc21CLENBQUFBLGFBQWEsT0FBT0EsY0FBYyxjQUFjLE9BQU9BLGNBQWMsUUFBTyxLQUFNaHdCLE1BQU13c0IsTUFBTSxJQUFJeHNCLE1BQU15c0IsT0FBTyxJQUFJL0Ysa0JBQWtCUCxZQUFZUyxzQkFBc0I1bUIsTUFBTWlzQixRQUFRLElBQUksTUFBTTtvQkFDbFAsNkVBQTZFO29CQUM3RSxPQUFPeEgsZUFBZXRhLFFBQVFuSztnQkFDaEM7Z0JBRUEsSUFBSTBKLE1BQU0xSixNQUFNMEosR0FBRztnQkFDbkIsSUFBSWxOLE1BQU0rdkIsZUFBZSxVQUFVN2lCLE1BQU0sa0RBQWtEO2dCQUUzRixJQUFJeUssV0FBVzBQLFVBQVVvTSxVQUFVLENBQUM1d0IsR0FBRyxDQUFDN0M7Z0JBRXhDO29CQUNFLElBQUlvd0IsY0FBY0MsaUJBQWlCMVk7b0JBRW5DLElBQUl5WSxhQUFhO3dCQUNmLE9BQVFBLFlBQVlFLFlBQVk7NEJBQzlCLEtBQUs7Z0NBQ0g7b0NBQ0UsSUFBSUMsd0JBQXdCMUwsOEJBQzVCcmhCLE9BQU80c0IsWUFBWUksZUFBZTtvQ0FFbEMsSUFBSUQsdUJBQXVCO3dDQUN6QjN5QixNQUFNLHlGQUF5RixzSUFBc0ksZ0hBQWdILGtGQUFrRnNQLEtBQUtxakI7b0NBQzlhO29DQUVBO2dDQUNGOzRCQUVGLEtBQUs7Z0NBQ0g7b0NBQ0UsSUFBSW1ELDBCQUEwQnpPLHdDQUM5QnpoQixPQUFPNHNCLFlBQVlNLGlCQUFpQjtvQ0FFcEMsSUFBSWdELHlCQUF5Qjt3Q0FDM0I5MUIsTUFBTSxxRkFBcUYsdUlBQXVJLHNIQUFzSCw4R0FBOEcsb0hBQW9ILHlIQUF5SCwwQkFBMEJzUCxLQUFLQSxLQUFLd21CO29DQUN6dEI7b0NBRUE7Z0NBQ0Y7d0JBQ0o7b0JBQ0Y7Z0JBQ0Y7Z0JBRUEsSUFBSSxDQUFDL2IsVUFBVTtvQkFDYkEsV0FBVzt3QkFDVHpXLE1BQU07d0JBQ044bUIsUUFBUSxFQUFFO3dCQUNWK0ksT0FBT0M7d0JBQ1B4dEIsT0FBTztvQkFDVDtvQkFDQTZqQixVQUFVb00sVUFBVSxDQUFDaEksR0FBRyxDQUFDenJCLEtBQUsyWDtvQkFFOUI7d0JBQ0UwWiwwQkFBMEIxWixVQUFVblU7b0JBQ3RDO29CQUdBNmpCLFVBQVVzTSxPQUFPLENBQUNqQyxHQUFHLENBQUMvWjtvQkFDdEIsSUFBSWljLGNBQWNwd0I7b0JBQ2xCLElBQUlxdEIsa0JBQWtCeEosVUFBVXlKLFdBQVcsQ0FBQ2p1QixHQUFHLENBQUM3QztvQkFFaEQsSUFBSTZ3QixpQkFBaUI7d0JBQ25CLDZFQUE2RTt3QkFDN0UscURBQXFEO3dCQUNyREEsZ0JBQWdCRSxLQUFLLElBQUlFO3dCQUN6QjJDLGNBQWMveUIsT0FBTyxDQUFDLEdBQUcyQzt3QkFDekJxd0IsZ0NBQWdDRCxhQUFhL0MsZ0JBQWdCcnRCLEtBQUs7b0JBQ3BFLEVBQUUsMkJBQTJCO29CQUc3QnlrQixlQUFldFEsU0FBU3FRLE1BQU0sRUFBRTRMO2dCQUNsQztnQkFFQSxJQUFJekksY0FBYztvQkFDaEIsbUdBQW1HO29CQUNuRyxzRUFBc0U7b0JBQ3RFeGQsT0FBT3RPLElBQUksQ0FBQzRyQjtnQkFDZDtnQkFFQSxPQUFPO1lBQ1Q7UUFDRjtRQUVBLFNBQVNoRCxlQUFldGEsTUFBTSxFQUFFbkssS0FBSztZQUNuQ21LLE9BQU90TyxJQUFJLENBQUNtdkIsaUJBQWlCO1lBQzdCLElBQUlob0IsV0FBVztZQUNmLElBQUltbkIsWUFBWTtZQUVoQixJQUFLLElBQUljLFdBQVdqckIsTUFBTztnQkFDekIsSUFBSTNCLGVBQWVqRCxJQUFJLENBQUM0RSxPQUFPaXJCLFVBQVU7b0JBQ3ZDLElBQUl0TCxZQUFZM2YsS0FBSyxDQUFDaXJCLFFBQVE7b0JBRTlCLElBQUl0TCxhQUFhLE1BQU07d0JBQ3JCO29CQUNGO29CQUVBLE9BQVFzTDt3QkFDTixLQUFLOzRCQUNIam9CLFdBQVcyYzs0QkFDWDt3QkFFRixLQUFLOzRCQUNId0ssWUFBWXhLOzRCQUNaO3dCQUVGOzRCQUNFbUssY0FBYzNmLFFBQVE4Z0IsU0FBU3RMOzRCQUMvQjtvQkFDSjtnQkFDRjtZQUNGO1lBRUF4VixPQUFPdE8sSUFBSSxDQUFDb3VCO1lBRVo7Z0JBQ0UsSUFBSWpuQixZQUFZLFFBQVEsT0FBT0EsYUFBYSxVQUFVO29CQUNwRCxJQUFJc3RCLHVCQUF1QixPQUFPdHRCLGFBQWEsV0FBVywwQkFBMEIvSSxNQUFNZ2tCLE9BQU8sQ0FBQ2piLFlBQVksMEJBQTBCO29CQUV4STVJLE1BQU0sc0dBQXNHLGtGQUFrRmsyQjtnQkFDaE07WUFDRjtZQUVBcEcsY0FBYy9mLFFBQVFnZ0IsV0FBV25uQjtZQUVqQyxJQUFJLE9BQU9BLGFBQWEsVUFBVTtnQkFDaENtSCxPQUFPdE8sSUFBSSxDQUFDRyxjQUFjd3JCLG1CQUFtQnhrQjtZQUMvQztZQUVBbUgsT0FBT3RPLElBQUksQ0FBQzR5QixTQUFTenlCLGNBQWMsV0FBVzB5QjtZQUM5QyxPQUFPO1FBQ1Q7UUFFQSxTQUFTa0Isd0JBQXdCemxCLE1BQU0sRUFBRW5LLEtBQUssRUFBRXN2QixHQUFHO1lBQ2pEbmxCLE9BQU90TyxJQUFJLENBQUNtdkIsaUJBQWlCc0U7WUFDN0IsSUFBSXRzQixXQUFXO1lBQ2YsSUFBSW1uQixZQUFZO1lBRWhCLElBQUssSUFBSWMsV0FBV2pyQixNQUFPO2dCQUN6QixJQUFJM0IsZUFBZWpELElBQUksQ0FBQzRFLE9BQU9pckIsVUFBVTtvQkFDdkMsSUFBSXRMLFlBQVkzZixLQUFLLENBQUNpckIsUUFBUTtvQkFFOUIsSUFBSXRMLGFBQWEsTUFBTTt3QkFDckI7b0JBQ0Y7b0JBRUEsT0FBUXNMO3dCQUNOLEtBQUs7NEJBQ0hqb0IsV0FBVzJjOzRCQUNYO3dCQUVGLEtBQUs7NEJBQ0h3SyxZQUFZeEs7NEJBQ1o7d0JBRUY7NEJBQ0VtSyxjQUFjM2YsUUFBUThnQixTQUFTdEw7NEJBQy9CO29CQUNKO2dCQUNGO1lBQ0Y7WUFFQXhWLE9BQU90TyxJQUFJLENBQUNvdUI7WUFDWkMsY0FBYy9mLFFBQVFnZ0IsV0FBV25uQjtZQUVqQyxJQUFJLE9BQU9BLGFBQWEsVUFBVTtnQkFDaEMsc0VBQXNFO2dCQUN0RSw2RUFBNkU7Z0JBQzdFbUgsT0FBT3RPLElBQUksQ0FBQ0csY0FBY3dyQixtQkFBbUJ4a0I7Z0JBQzdDLE9BQU87WUFDVDtZQUVBLE9BQU9BO1FBQ1Q7UUFFQSxTQUFTdXRCLHVCQUF1QnBtQixNQUFNLEVBQUVuSyxLQUFLLEVBQUVzdkIsR0FBRztZQUNoRG5sQixPQUFPdE8sSUFBSSxDQUFDbXZCLGlCQUFpQnNFO1lBQzdCLElBQUl0c0IsV0FBVztZQUNmLElBQUltbkIsWUFBWTtZQUVoQixJQUFLLElBQUljLFdBQVdqckIsTUFBTztnQkFDekIsSUFBSTNCLGVBQWVqRCxJQUFJLENBQUM0RSxPQUFPaXJCLFVBQVU7b0JBQ3ZDLElBQUl0TCxZQUFZM2YsS0FBSyxDQUFDaXJCLFFBQVE7b0JBRTlCLElBQUl0TCxhQUFhLE1BQU07d0JBQ3JCO29CQUNGO29CQUVBLE9BQVFzTDt3QkFDTixLQUFLOzRCQUNIam9CLFdBQVcyYzs0QkFDWDt3QkFFRixLQUFLOzRCQUNId0ssWUFBWXhLOzRCQUNaO3dCQUVGLEtBQUs7NEJBQ0gwSSxtQkFBbUJsZSxRQUFRd1Y7NEJBQzNCO3dCQUVGLEtBQUs7d0JBQ0wsS0FBSzs0QkFFSDt3QkFFRjs0QkFDRSxJQUFJL2dCLG9CQUFvQnFzQixZQUFZLE9BQU90TCxjQUFjLGNBQWMsT0FBT0EsY0FBYyxVQUFVO2dDQUNwR3hWLE9BQU90TyxJQUFJLENBQUNpdEIsb0JBQW9COXNCLGNBQWNpdkIsVUFBVWxDLGlCQUFpQi9zQixjQUFjb2hCLHFCQUFxQnVDLGFBQWFrSjs0QkFDM0g7NEJBRUE7b0JBQ0o7Z0JBQ0Y7WUFDRjtZQUVBMWUsT0FBT3RPLElBQUksQ0FBQ291QjtZQUNaQyxjQUFjL2YsUUFBUWdnQixXQUFXbm5CO1lBQ2pDLE9BQU9BO1FBQ1Q7UUFFQSxJQUFJK29CLGlCQUFpQjd2Qix5QkFBeUI7UUFFOUMsU0FBU3MwQiw2QkFBNkJybUIsTUFBTSxFQUFFbkssS0FBSyxFQUFFc3ZCLEdBQUc7WUFDdERubEIsT0FBT3RPLElBQUksQ0FBQ212QixpQkFBaUJzRTtZQUM3QixJQUFJdHNCLFdBQVc7WUFDZixJQUFJbW5CLFlBQVk7WUFFaEIsSUFBSyxJQUFJYyxXQUFXanJCLE1BQU87Z0JBQ3pCLElBQUkzQixlQUFlakQsSUFBSSxDQUFDNEUsT0FBT2lyQixVQUFVO29CQUN2QyxJQUFJdEwsWUFBWTNmLEtBQUssQ0FBQ2lyQixRQUFRO29CQUU5QixJQUFJdEwsYUFBYSxNQUFNO3dCQUNyQjtvQkFDRjtvQkFFQSxPQUFRc0w7d0JBQ04sS0FBSzs0QkFDSGpvQixXQUFXMmM7NEJBQ1g7d0JBRUYsS0FBSzs0QkFDSHdLLFlBQVl4Szs0QkFDWjt3QkFFRjs0QkFDRW1LLGNBQWMzZixRQUFROGdCLFNBQVN0TDs0QkFDL0I7b0JBQ0o7Z0JBQ0Y7WUFDRjtZQUVBeFYsT0FBT3RPLElBQUksQ0FBQ291QixnQkFBZ0Isd0VBQXdFO1lBQ3BHLHFFQUFxRTtZQUNyRSxzRUFBc0U7WUFDdEUsMEVBQTBFO1lBQzFFLHNEQUFzRDtZQUN0RCwwRUFBMEU7WUFDMUUscUVBQXFFO1lBQ3JFLHlEQUF5RDtZQUN6RCwwREFBMEQ7WUFDMUQscUVBQXFFO1lBQ3JFLG9FQUFvRTtZQUNwRSxzQ0FBc0M7WUFFdEMsSUFBSUUsYUFBYSxNQUFNO2dCQUNyQixJQUFJbm5CLFlBQVksTUFBTTtvQkFDcEIsTUFBTSxJQUFJc2xCLE1BQU07Z0JBQ2xCO2dCQUVBLElBQUksT0FBTzZCLGNBQWMsWUFBWSxDQUFFLGFBQVlBLFNBQVEsR0FBSTtvQkFDN0QsTUFBTSxJQUFJN0IsTUFBTSwwRUFBMEUsc0VBQXNFO2dCQUNsSztnQkFFQSxJQUFJdEwsT0FBT21OLFVBQVVDLE1BQU07Z0JBRTNCLElBQUlwTixTQUFTLFFBQVFBLFNBQVNoQyxXQUFXO29CQUN2QyxJQUFJLE9BQU9nQyxTQUFTLFlBQVlBLEtBQUtqakIsTUFBTSxHQUFHLEtBQUtpakIsSUFBSSxDQUFDLEVBQUUsS0FBSyxNQUFNO3dCQUNuRTdTLE9BQU90TyxJQUFJLENBQUNrd0IsZ0JBQWdCL3ZCLGNBQWNnaEI7b0JBQzVDLE9BQU87d0JBQ0w7NEJBQ0U3ZSx3QkFBd0I2ZTt3QkFDMUI7d0JBRUE3UyxPQUFPdE8sSUFBSSxDQUFDRyxjQUFjLEtBQUtnaEI7b0JBQ2pDO2dCQUNGO1lBQ0Y7WUFFQSxJQUFJLE9BQU9oYSxhQUFhLFlBQVlBLFFBQVEsQ0FBQyxFQUFFLEtBQUssTUFBTTtnQkFDeERtSCxPQUFPdE8sSUFBSSxDQUFDa3dCO1lBQ2Q7WUFFQSxPQUFPL29CO1FBQ1QsRUFBRSwrRUFBK0U7UUFDakYsbURBQW1EO1FBQ25ELHdDQUF3QztRQUd4QyxJQUFJeXRCLGtCQUFrQiwrQkFBK0Isb0JBQW9CO1FBRXpFLElBQUlDLG9CQUFvQixJQUFJdnhCO1FBRTVCLFNBQVM2ckIsaUJBQWlCc0UsR0FBRztZQUMzQixJQUFJcUIsZ0JBQWdCRCxrQkFBa0JyeEIsR0FBRyxDQUFDaXdCO1lBRTFDLElBQUlxQixrQkFBa0IzVixXQUFXO2dCQUMvQixJQUFJLENBQUN5VixnQkFBZ0I1eEIsSUFBSSxDQUFDeXdCLE1BQU07b0JBQzlCLE1BQU0sSUFBSWhILE1BQU0sa0JBQWtCZ0g7Z0JBQ3BDO2dCQUVBcUIsZ0JBQWdCejBCLHlCQUF5QixNQUFNb3pCO2dCQUMvQ29CLGtCQUFrQnpJLEdBQUcsQ0FBQ3FILEtBQUtxQjtZQUM3QjtZQUVBLE9BQU9BO1FBQ1Q7UUFFQSxJQUFJYixVQUFVNXpCLHlCQUF5QjtRQUN2QyxTQUFTMDBCLGtCQUFrQnptQixNQUFNLEVBQUV6TSxJQUFJLEVBQUVzQyxLQUFLLEVBQUU2akIsU0FBUyxFQUFFcUQsYUFBYSxFQUFFcUUsYUFBYSxFQUFFNUQsWUFBWTtZQUNuRztnQkFDRTFtQixxQkFBcUJ2RCxNQUFNc0M7Z0JBQzNCd0IscUJBQXFCOUQsTUFBTXNDO2dCQUMzQm9iLG1CQUFtQjFkLE1BQU1zQyxPQUFPO2dCQUVoQyxJQUFJLENBQUNBLE1BQU02d0IsOEJBQThCLElBQUk3d0IsTUFBTTh3QixlQUFlLElBQUk5d0IsTUFBTWdELFFBQVEsSUFBSSxNQUFNO29CQUM1RjVJLE1BQU0seUVBQXlFLG9FQUFvRSxrRUFBa0U7Z0JBQ3ZOO2dCQUVBLElBQUlteEIsY0FBYzdFLGFBQWEsS0FBS1AsWUFBWW9GLGNBQWM3RSxhQUFhLEtBQUtOLGFBQWE7b0JBQzNGLElBQUkxb0IsS0FBS2lFLE9BQU8sQ0FBQyxTQUFTLENBQUMsS0FBS2pFLEtBQUttRCxXQUFXLE9BQU9uRCxNQUFNO3dCQUMzRHRELE1BQU0sdUNBQXVDLDBDQUEwQyxtQ0FBbUNzRDtvQkFDNUg7Z0JBQ0Y7WUFDRjtZQUVBLE9BQVFBO2dCQUNOLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztvQkFFSDtnQkFDRixlQUFlO2dCQUVmLEtBQUs7b0JBQ0gsT0FBT3F0QixnQkFBZ0I1Z0IsUUFBUW5LO2dCQUVqQyxLQUFLO29CQUNILE9BQU9zckIsZ0JBQWdCbmhCLFFBQVFuSyxPQUFPdXJCO2dCQUV4QyxLQUFLO29CQUNILE9BQU9PLGtCQUFrQjNoQixRQUFRbks7Z0JBRW5DLEtBQUs7b0JBQ0gsT0FBTzJyQixVQUFVeGhCLFFBQVFuSyxPQUFPa25CO2dCQUVsQyxLQUFLO29CQUNILE9BQU8yRSxnQkFBZ0IxaEIsUUFBUW5LLE9BQU9rbkI7Z0JBRXhDLEtBQUs7b0JBQ0gsT0FBT3dFLGNBQWN2aEIsUUFBUW5LO2dCQUUvQixLQUFLO29CQUNILE9BQU91dkIsa0JBQWtCcGxCLFFBQVFuSztnQkFFbkMsS0FBSztvQkFDSCxPQUFPd3ZCLFVBQVVybEIsUUFBUW5LLE9BQU9rbkIsZUFBZXFFLGNBQWM3RSxhQUFhLEVBQUU2RSxjQUFjM0Usa0JBQWtCO2dCQUU5RyxLQUFLO29CQUNILE9BQU93RixTQUFTamlCLFFBQVFuSyxPQUFPa25CLGVBQWVyRCxXQUFXOEQsY0FBYzRELGNBQWM3RSxhQUFhLEVBQUU2RSxjQUFjM0Usa0JBQWtCO2dCQUV0SSxLQUFLO29CQUNILE9BQU9tSixXQUFXNWxCLFFBQVFuSyxPQUFPNmpCLFdBQVc4RCxjQUFjNEQsY0FBYzdFLGFBQWEsRUFBRTZFLGNBQWMzRSxrQkFBa0I7Z0JBRXpILEtBQUs7b0JBQ0gsT0FBT3lILFVBQVVsa0IsUUFBUW5LLE9BQU82akIsV0FBVzhELGNBQWM0RCxjQUFjN0UsYUFBYSxFQUFFNkUsY0FBYzNFLGtCQUFrQjtnQkFFeEgsS0FBSztvQkFDSCxPQUFPb0YsU0FBUzdoQixRQUFRbkssT0FBT2tuQixlQUFlUyxjQUFjNEQsY0FBYzdFLGFBQWEsRUFBRTZFLGNBQWMzRSxrQkFBa0I7Z0JBQzNILHNCQUFzQjtnQkFFdEIsS0FBSztnQkFDTCxLQUFLO29CQUNIO3dCQUNFLE9BQU80Siw2QkFBNkJybUIsUUFBUW5LLE9BQU90QztvQkFDckQ7Z0JBRUYsS0FBSztvQkFDSDt3QkFDRSxPQUFPcXhCLFFBQVE1a0IsUUFBUW5LLE9BQU82akI7b0JBQ2hDO2dCQUNGLHFCQUFxQjtnQkFFckIsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO29CQUNIO3dCQUNFLE9BQU9xSSxnQkFBZ0IvaEIsUUFBUW5LLE9BQU90QztvQkFDeEM7Z0JBQ0YsOEVBQThFO2dCQUM5RSxpRkFBaUY7Z0JBRWpGLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztvQkFDSDt3QkFDRTtvQkFDRjtnQkFDRixzQkFBc0I7Z0JBRXRCLEtBQUs7b0JBQ0gsT0FBT2l5QixjQUFjeGxCLFFBQVFuSyxPQUFPa25CLGVBQWVxRSxjQUFjN0UsYUFBYTtnQkFFaEYsS0FBSztvQkFDSDt3QkFDRSxPQUFPbUosY0FBYzFsQixRQUFRbkssT0FBT2tuQixlQUFlcUUsY0FBYzdFLGFBQWE7b0JBQ2hGO2dCQUVGO29CQUNFO3dCQUNFLElBQUlocEIsS0FBS2lFLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRzs0QkFDNUIsaUJBQWlCOzRCQUNqQixPQUFPNHVCLHVCQUF1QnBtQixRQUFRbkssT0FBT3RDO3dCQUMvQztvQkFDRjtZQUNKLEVBQUUsa0JBQWtCO1lBR3BCLE9BQU9reUIsd0JBQXdCemxCLFFBQVFuSyxPQUFPdEM7UUFDaEQ7UUFDQSxJQUFJK3dCLFVBQVV2eUIseUJBQXlCO1FBQ3ZDLElBQUl3eUIsVUFBVXh5Qix5QkFBeUI7UUFDdkMsU0FBUzYwQixnQkFBZ0I1bUIsTUFBTSxFQUFFek0sSUFBSSxFQUFFc0MsS0FBSyxFQUFFa25CLGFBQWEsRUFBRXFFLGFBQWE7WUFDeEUsT0FBUTd0QjtnQkFDTiwwRUFBMEU7Z0JBQzFFLDBFQUEwRTtnQkFDMUUsc0RBQXNEO2dCQUN0RCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxxQkFBcUI7Z0JBQ3JCLGlGQUFpRjtnQkFDakYsOEVBQThFO2dCQUU5RSxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztvQkFDSDt3QkFDRSx1QkFBdUI7d0JBQ3ZCO29CQUNGO2dCQUNGLHFCQUFxQjtnQkFDckIsb0VBQW9FO2dCQUNwRSx1RUFBdUU7Z0JBQ3ZFLG1FQUFtRTtnQkFDbkUsOEJBQThCO2dCQUU5QixLQUFLO29CQUNIO3dCQUNFLElBQUk2dEIsY0FBYzdFLGFBQWEsSUFBSVQsZ0JBQWdCOzRCQUNqRGlCLGNBQWN4QixPQUFPLEdBQUc7NEJBQ3hCO3dCQUNGO3dCQUVBO29CQUNGO2dCQUVGLEtBQUs7b0JBQ0gsSUFBSTZGLGNBQWM3RSxhQUFhLEtBQUtWLGdCQUFnQjt3QkFDbEQ7b0JBQ0Y7b0JBRUE7WUFDSjtZQUVBN2IsT0FBT3RPLElBQUksQ0FBQzR5QixTQUFTenlCLGNBQWMwQixPQUFPZ3hCO1FBQzVDO1FBRUEsU0FBU3NDLGVBQWV2MUIsV0FBVyxFQUFFeXJCLGFBQWE7WUFDaEQsSUFBSTdDLGtCQUFrQjZDLGNBQWM3QyxlQUFlO1lBQ25ELElBQUlyRixJQUFJO1lBRVIsTUFBT0EsSUFBSXFGLGdCQUFnQnRxQixNQUFNLEdBQUcsR0FBR2lsQixJQUFLO2dCQUMxQ3RqQixXQUFXRCxhQUFhNG9CLGVBQWUsQ0FBQ3JGLEVBQUU7WUFDNUM7WUFFQSxJQUFJQSxJQUFJcUYsZ0JBQWdCdHFCLE1BQU0sRUFBRTtnQkFDOUIsSUFBSWszQixZQUFZNU0sZUFBZSxDQUFDckYsRUFBRTtnQkFDbENxRixnQkFBZ0J0cUIsTUFBTSxHQUFHO2dCQUN6QixPQUFPNkIsb0JBQW9CSCxhQUFhdzFCO1lBQzFDO1lBRUEsT0FBTztRQUNUO1FBRUEsU0FBU0MsbUJBQW1CejFCLFdBQVcsRUFBRXlyQixhQUFhO1lBQ3BELE9BQU84SixlQUFldjFCLGFBQWF5ckI7UUFDckMsRUFBRSxtQkFBbUI7UUFDckIsK0ZBQStGO1FBQy9GLGdHQUFnRztRQUNoRyxnRkFBZ0Y7UUFFaEYsSUFBSWlLLGVBQWVqMUIseUJBQXlCO1FBQzVDLElBQUlrMUIsZUFBZWwxQix5QkFBeUI7UUFDNUMsU0FBU20xQixpQkFBaUI1MUIsV0FBVyxFQUFFeXJCLGFBQWEsRUFBRXRoQixFQUFFO1lBQ3REbEssV0FBV0QsYUFBYTAxQjtZQUN4QnoxQixXQUFXRCxhQUFheXJCLGNBQWMvQixpQkFBaUI7WUFDdkQsSUFBSW1NLGNBQWN0MUIsY0FBYzRKLEdBQUd3aEIsUUFBUSxDQUFDO1lBQzVDMXJCLFdBQVdELGFBQWE2MUI7WUFDeEIsT0FBTzExQixvQkFBb0JILGFBQWEyMUI7UUFDMUMsRUFBRSwrQ0FBK0M7UUFFakQsSUFBSUcsaUNBQWlDcjFCLHlCQUF5QjtRQUM5RCxJQUFJczFCLGdDQUFnQ3QxQix5QkFBeUI7UUFDN0QsSUFBSXUxQixnQ0FBZ0N2MUIseUJBQXlCO1FBQzdELElBQUl3MUIsc0NBQXNDeDFCLHlCQUF5QjtRQUNuRSxJQUFJeTFCLHNCQUFzQnoxQix5QkFBeUI7UUFDbkQsSUFBSTAxQix1Q0FBdUMxMUIseUJBQXlCO1FBQ3BFLElBQUkyMUIsc0RBQXNEMzFCLHlCQUF5QjtRQUNuRixJQUFJNDFCLHdDQUF3QzUxQix5QkFBeUI7UUFDckUsSUFBSTYxQix3Q0FBd0M3MUIseUJBQXlCO1FBQ3JFLElBQUk4MUIsd0NBQXdDOTFCLHlCQUF5QjtRQUNyRSxJQUFJKzFCLHVDQUF1Qy8xQix5QkFBeUI7UUFDcEUsU0FBU2cyQixzQ0FBc0N6MkIsV0FBVyxFQUFFeXJCLGFBQWE7WUFDdkUsT0FBT3RyQixvQkFBb0JILGFBQWE4MUI7UUFDMUM7UUFDQSxTQUFTWSxrQ0FBa0MxMkIsV0FBVyxFQUFFeXJCLGFBQWEsRUFBRXRoQixFQUFFO1lBQ3ZFbEssV0FBV0QsYUFBYSsxQjtZQUV4QixJQUFJNXJCLE9BQU8sTUFBTTtnQkFDZixNQUFNLElBQUkwaUIsTUFBTTtZQUNsQjtZQUVBNXNCLFdBQVdELGFBQWFtSztZQUN4QixPQUFPaEssb0JBQW9CSCxhQUFhZzJCO1FBQzFDO1FBQ0EsU0FBU1csMkNBQTJDMzJCLFdBQVcsRUFBRXlyQixhQUFhLEVBQUVtTCxXQUFXLEVBQUVDLGFBQWEsRUFBRUMsbUJBQW1CO1lBQzdILElBQUlsZTtZQUNKQSxTQUFTelksb0JBQW9CSCxhQUFhaTJCO1lBQzFDaDJCLFdBQVdELGFBQWFtMkI7WUFFeEIsSUFBSVMsYUFBYTtnQkFDZjMyQixXQUFXRCxhQUFhcTJCO2dCQUN4QnAyQixXQUFXRCxhQUFhTyxjQUFjb2hCLHFCQUFxQmlWO2dCQUMzRDMyQixXQUFXRCxhQUFhbzJCO1lBQzFCO1lBRUE7Z0JBQ0UsSUFBSVMsZUFBZTtvQkFDakI1MkIsV0FBV0QsYUFBYXMyQjtvQkFDeEJyMkIsV0FBV0QsYUFBYU8sY0FBY29oQixxQkFBcUJrVjtvQkFDM0Q1MkIsV0FBV0QsYUFBYW8yQjtnQkFDMUI7Z0JBRUEsSUFBSVUscUJBQXFCO29CQUN2QjcyQixXQUFXRCxhQUFhdTJCO29CQUN4QnQyQixXQUFXRCxhQUFhTyxjQUFjb2hCLHFCQUFxQm1WO29CQUMzRDcyQixXQUFXRCxhQUFhbzJCO2dCQUMxQjtZQUNGO1lBRUF4ZCxTQUFTelksb0JBQW9CSCxhQUFhdzJCO1lBQzFDLE9BQU81ZDtRQUNUO1FBQ0EsU0FBU21lLG9DQUFvQy8yQixXQUFXLEVBQUV5ckIsYUFBYTtZQUNyRSxPQUFPdHJCLG9CQUFvQkgsYUFBYWsyQjtRQUMxQztRQUNBLFNBQVNjLGdDQUFnQ2gzQixXQUFXLEVBQUV5ckIsYUFBYTtZQUNqRSxPQUFPdHJCLG9CQUFvQkgsYUFBYWsyQjtRQUMxQztRQUNBLFNBQVNlLHlDQUF5Q2ozQixXQUFXLEVBQUV5ckIsYUFBYTtZQUMxRSxPQUFPdHJCLG9CQUFvQkgsYUFBYWsyQjtRQUMxQztRQUNBLElBQUlnQixtQkFBbUJ6MkIseUJBQXlCO1FBQ2hELElBQUkwMkIsb0JBQW9CMTJCLHlCQUF5QjtRQUNqRCxJQUFJMjJCLGlCQUFpQjMyQix5QkFBeUI7UUFDOUMsSUFBSTQyQixrQkFBa0I1MkIseUJBQXlCO1FBQy9DLElBQUk2MkIsbUJBQW1CNzJCLHlCQUF5QjtRQUNoRCxJQUFJODJCLGdCQUFnQjkyQix5QkFBeUI7UUFDN0MsSUFBSSsyQixxQkFBcUIvMkIseUJBQXlCO1FBQ2xELElBQUlnM0Isc0JBQXNCaDNCLHlCQUF5QjtRQUNuRCxJQUFJaTNCLG1CQUFtQmozQix5QkFBeUI7UUFDaEQsSUFBSWszQixvQkFBb0JsM0IseUJBQXlCO1FBQ2pELElBQUltM0IscUJBQXFCbjNCLHlCQUF5QjtRQUNsRCxJQUFJbzNCLGtCQUFrQnAzQix5QkFBeUI7UUFDL0MsSUFBSXEzQix3QkFBd0JyM0IseUJBQXlCO1FBQ3JELElBQUlzM0IseUJBQXlCdDNCLHlCQUF5QjtRQUN0RCxJQUFJdTNCLHNCQUFzQnYzQix5QkFBeUI7UUFDbkQsSUFBSXczQix1QkFBdUJ4M0IseUJBQXlCO1FBQ3BELElBQUl5M0Isd0JBQXdCejNCLHlCQUF5QjtRQUNyRCxJQUFJMDNCLHFCQUFxQjEzQix5QkFBeUI7UUFDbEQsSUFBSTIzQix1QkFBdUIzM0IseUJBQXlCO1FBQ3BELElBQUk0M0Isd0JBQXdCNTNCLHlCQUF5QjtRQUNyRCxJQUFJNjNCLHFCQUFxQjczQix5QkFBeUI7UUFDbEQsU0FBUzgzQixrQkFBa0J2NEIsV0FBVyxFQUFFeXJCLGFBQWEsRUFBRXFFLGFBQWEsRUFBRTNsQixFQUFFO1lBQ3RFLE9BQVEybEIsY0FBYzdFLGFBQWE7Z0JBQ2pDLEtBQUtWO2dCQUNMLEtBQUtDO2dCQUNMLEtBQUtDO29CQUNIO3dCQUNFeHFCLFdBQVdELGFBQWFrM0I7d0JBQ3hCajNCLFdBQVdELGFBQWF5ckIsY0FBYzlCLGFBQWE7d0JBQ25EMXBCLFdBQVdELGFBQWFPLGNBQWM0SixHQUFHd2hCLFFBQVEsQ0FBQzt3QkFDbEQsT0FBT3hyQixvQkFBb0JILGFBQWFtM0I7b0JBQzFDO2dCQUVGLEtBQUt6TTtvQkFDSDt3QkFDRXpxQixXQUFXRCxhQUFhcTNCO3dCQUN4QnAzQixXQUFXRCxhQUFheXJCLGNBQWM5QixhQUFhO3dCQUNuRDFwQixXQUFXRCxhQUFhTyxjQUFjNEosR0FBR3doQixRQUFRLENBQUM7d0JBQ2xELE9BQU94ckIsb0JBQW9CSCxhQUFhczNCO29CQUMxQztnQkFFRixLQUFLM007b0JBQ0g7d0JBQ0UxcUIsV0FBV0QsYUFBYXczQjt3QkFDeEJ2M0IsV0FBV0QsYUFBYXlyQixjQUFjOUIsYUFBYTt3QkFDbkQxcEIsV0FBV0QsYUFBYU8sY0FBYzRKLEdBQUd3aEIsUUFBUSxDQUFDO3dCQUNsRCxPQUFPeHJCLG9CQUFvQkgsYUFBYXkzQjtvQkFDMUM7Z0JBRUYsS0FBSzdNO29CQUNIO3dCQUNFM3FCLFdBQVdELGFBQWEyM0I7d0JBQ3hCMTNCLFdBQVdELGFBQWF5ckIsY0FBYzlCLGFBQWE7d0JBQ25EMXBCLFdBQVdELGFBQWFPLGNBQWM0SixHQUFHd2hCLFFBQVEsQ0FBQzt3QkFDbEQsT0FBT3hyQixvQkFBb0JILGFBQWE0M0I7b0JBQzFDO2dCQUNGLDRFQUE0RTtnQkFDNUUseUVBQXlFO2dCQUN6RSw4RUFBOEU7Z0JBQzlFLGlGQUFpRjtnQkFFakYsS0FBSy9NO29CQUNIO3dCQUNFNXFCLFdBQVdELGFBQWE4M0I7d0JBQ3hCNzNCLFdBQVdELGFBQWF5ckIsY0FBYzlCLGFBQWE7d0JBQ25EMXBCLFdBQVdELGFBQWFPLGNBQWM0SixHQUFHd2hCLFFBQVEsQ0FBQzt3QkFDbEQsT0FBT3hyQixvQkFBb0JILGFBQWErM0I7b0JBQzFDO2dCQUVGLEtBQUtqTjtvQkFDSDt3QkFDRTdxQixXQUFXRCxhQUFhaTRCO3dCQUN4Qmg0QixXQUFXRCxhQUFheXJCLGNBQWM5QixhQUFhO3dCQUNuRDFwQixXQUFXRCxhQUFhTyxjQUFjNEosR0FBR3doQixRQUFRLENBQUM7d0JBQ2xELE9BQU94ckIsb0JBQW9CSCxhQUFhazRCO29CQUMxQztnQkFFRixLQUFLbk47b0JBQ0g7d0JBQ0U5cUIsV0FBV0QsYUFBYW80Qjt3QkFDeEJuNEIsV0FBV0QsYUFBYXlyQixjQUFjOUIsYUFBYTt3QkFDbkQxcEIsV0FBV0QsYUFBYU8sY0FBYzRKLEdBQUd3aEIsUUFBUSxDQUFDO3dCQUNsRCxPQUFPeHJCLG9CQUFvQkgsYUFBYXE0QjtvQkFDMUM7Z0JBRUY7b0JBQ0U7d0JBQ0UsTUFBTSxJQUFJeEwsTUFBTTtvQkFDbEI7WUFDSjtRQUNGO1FBQ0EsU0FBUzJMLGdCQUFnQng0QixXQUFXLEVBQUU4dkIsYUFBYTtZQUNqRCxPQUFRQSxjQUFjN0UsYUFBYTtnQkFDakMsS0FBS1Y7Z0JBQ0wsS0FBS0M7Z0JBQ0wsS0FBS0M7b0JBQ0g7d0JBQ0UsT0FBT3RxQixvQkFBb0JILGFBQWFvM0I7b0JBQzFDO2dCQUVGLEtBQUsxTTtvQkFDSDt3QkFDRSxPQUFPdnFCLG9CQUFvQkgsYUFBYXUzQjtvQkFDMUM7Z0JBRUYsS0FBSzVNO29CQUNIO3dCQUNFLE9BQU94cUIsb0JBQW9CSCxhQUFhMDNCO29CQUMxQztnQkFFRixLQUFLOU07b0JBQ0g7d0JBQ0UsT0FBT3pxQixvQkFBb0JILGFBQWE2M0I7b0JBQzFDO2dCQUVGLEtBQUtoTjtvQkFDSDt3QkFDRSxPQUFPMXFCLG9CQUFvQkgsYUFBYWc0QjtvQkFDMUM7Z0JBRUYsS0FBS2xOO29CQUNIO3dCQUNFLE9BQU8zcUIsb0JBQW9CSCxhQUFhbTRCO29CQUMxQztnQkFFRixLQUFLcE47b0JBQ0g7d0JBQ0UsT0FBTzVxQixvQkFBb0JILGFBQWFzNEI7b0JBQzFDO2dCQUVGO29CQUNFO3dCQUNFLE1BQU0sSUFBSXpMLE1BQU07b0JBQ2xCO1lBQ0o7UUFDRjtRQUNBLElBQUk0TCw2QkFBNkJoNEIseUJBQXlCb2lCLGtCQUFrQjtRQUM1RSxJQUFJNlYsZ0NBQWdDajRCLHlCQUF5QjtRQUM3RCxJQUFJazRCLHlCQUF5Qmw0Qix5QkFBeUI7UUFDdEQsSUFBSW00QiwyQkFBMkJuNEIseUJBQXlCO1FBQ3hELElBQUlvNEIsdUJBQXVCcDRCLHlCQUF5QjtRQUNwRCxJQUFJcTRCLHVCQUF1QnI0Qix5QkFBeUI7UUFDcEQsSUFBSXM0Qix5QkFBeUIzUjtRQUM3QixTQUFTNFIsaUNBQWlDaDVCLFdBQVcsRUFBRXlyQixhQUFhLEVBQUV3TixnQkFBZ0I7WUFDcEYsSUFBSUMsZUFBZXpOLGNBQWMzQyxlQUFlLEtBQUtqQztZQUVyRCxJQUFJcVMsY0FBYztnQkFDaEJqNUIsV0FBV0QsYUFBYXlyQixjQUFjcEUsaUJBQWlCO2dCQUV2RCxJQUFJLENBQUNvRSxjQUFjM0IsWUFBWSxHQUFHOUMsMkJBQTBCLE1BQU9ELGFBQWE7b0JBQzlFLCtFQUErRTtvQkFDL0UwRSxjQUFjM0IsWUFBWSxJQUFJOUM7b0JBQzlCL21CLFdBQVdELGFBQWF5NEI7Z0JBQzFCLE9BQU87b0JBQ0wsaURBQWlEO29CQUNqRHg0QixXQUFXRCxhQUFhMDRCO2dCQUMxQjtZQUNGLE9BQU87Z0JBQ0x6NEIsV0FBV0QsYUFBYTY0QjtZQUMxQixFQUFFLHNEQUFzRDtZQUd4RDU0QixXQUFXRCxhQUFheXJCLGNBQWM5QixhQUFhO1lBQ25ELElBQUlrTSxjQUFjdDFCLGNBQWMwNEIsaUJBQWlCdE4sUUFBUSxDQUFDO1lBQzFEMXJCLFdBQVdELGFBQWE2MUI7WUFFeEIsSUFBSXFELGNBQWM7Z0JBQ2hCajVCLFdBQVdELGFBQWEyNEI7WUFDMUIsT0FBTztnQkFDTDE0QixXQUFXRCxhQUFhODRCO1lBQzFCO1lBRUE3NEIsV0FBV0QsYUFBYXlyQixjQUFjL0IsaUJBQWlCO1lBQ3ZEenBCLFdBQVdELGFBQWE2MUI7WUFFeEIsSUFBSXFELGNBQWM7Z0JBQ2hCLE9BQU8vNEIsb0JBQW9CSCxhQUFhNDRCO1lBQzFDLE9BQU87Z0JBQ0wsT0FBT3o0QixvQkFBb0JILGFBQWErNEI7WUFDMUM7UUFDRjtRQUNBLElBQUlJLDhCQUE4QjE0Qix5QkFBeUJraUIsbUJBQW1CO1FBQzlFLElBQUl5VyxpQ0FBaUMzNEIseUJBQXlCO1FBQzlELElBQUk0NEIsNENBQTRDNTRCLHlCQUF5QmtpQixtQkFBbUJDLDZCQUE2QjtRQUN6SCxJQUFJMFcsK0NBQStDNzRCLHlCQUF5Qm1pQiw2QkFBNkI7UUFDekcsSUFBSTJXLDJDQUEyQzk0Qix5QkFBeUI7UUFDeEUsSUFBSSs0QiwwQkFBMEIvNEIseUJBQXlCO1FBQ3ZELElBQUlnNUIsMkJBQTJCaDVCLHlCQUF5QjtRQUN4RCxJQUFJaTVCLDJCQUEyQmo1Qix5QkFBeUI7UUFDeEQsSUFBSWs1Qiw0QkFBNEJsNUIseUJBQXlCO1FBQ3pELElBQUltNUIsd0JBQXdCbjVCLHlCQUF5QjtRQUNyRCxJQUFJbzVCLGtDQUFrQ3A1Qix5QkFBeUI7UUFDL0QsSUFBSXE1Qix3QkFBd0JyNUIseUJBQXlCO1FBQ3JELElBQUlzNUIseUJBQXlCdDVCLHlCQUF5QjtRQUN0RCxJQUFJdTVCLDBCQUEwQjVTO1FBQzlCLFNBQVM2UyxrQ0FBa0NqNkIsV0FBVyxFQUFFeXJCLGFBQWEsRUFBRXlPLFVBQVUsRUFBRWpCLGdCQUFnQixFQUFFdEcsaUJBQWlCO1lBQ3BILElBQUl3SDtZQUVKO2dCQUNFQSx5QkFBeUIxTyxjQUFjbkIsYUFBYSxFQUFFLGtFQUFrRTtnQkFDeEgsdUVBQXVFO2dCQUN2RSx1RUFBdUU7Z0JBQ3ZFLDBDQUEwQztnQkFFMUNtQixjQUFjbkIsYUFBYSxHQUFHO1lBQ2hDO1lBRUEsSUFBSTRPLGVBQWV6TixjQUFjM0MsZUFBZSxLQUFLakM7WUFFckQsSUFBSXFTLGNBQWM7Z0JBQ2hCajVCLFdBQVdELGFBQWF5ckIsY0FBY3BFLGlCQUFpQjtnQkFFdkQsSUFBSThTLHdCQUF3QjtvQkFDMUIsSUFBSSxDQUFDMU8sY0FBYzNCLFlBQVksR0FBRzdDLDRCQUEyQixNQUFPRixhQUFhO3dCQUMvRTBFLGNBQWMzQixZQUFZLElBQUkzQyw2QkFBNkJGO3dCQUMzRGhuQixXQUFXRCxhQUFhVSxzQkFBc0IyNEI7b0JBQ2hELE9BQU8sSUFBSSxDQUFDNU4sY0FBYzNCLFlBQVksR0FBRzNDLDBCQUF5QixNQUFPSixhQUFhO3dCQUNwRjBFLGNBQWMzQixZQUFZLElBQUkzQzt3QkFDOUJsbkIsV0FBV0QsYUFBYXM1QjtvQkFDMUIsT0FBTzt3QkFDTHI1QixXQUFXRCxhQUFhdTVCO29CQUMxQjtnQkFDRixPQUFPO29CQUNMLElBQUksQ0FBQzlOLGNBQWMzQixZQUFZLEdBQUc3Qyw0QkFBMkIsTUFBT0YsYUFBYTt3QkFDL0UwRSxjQUFjM0IsWUFBWSxJQUFJN0M7d0JBQzlCaG5CLFdBQVdELGFBQWFtNUI7b0JBQzFCLE9BQU87d0JBQ0xsNUIsV0FBV0QsYUFBYW81QjtvQkFDMUI7Z0JBQ0Y7WUFDRixPQUFPO2dCQUNMLElBQUllLHdCQUF3QjtvQkFDMUJsNkIsV0FBV0QsYUFBYTY1QjtnQkFDMUIsT0FBTztvQkFDTDU1QixXQUFXRCxhQUFhNDVCO2dCQUMxQjtZQUNGO1lBRUEsSUFBSU0sZUFBZSxNQUFNO2dCQUN2QixNQUFNLElBQUlyTixNQUFNO1lBQ2xCLEVBQUUsZ0VBQWdFO1lBR2xFLElBQUl1TixxQkFBcUI3NUIsY0FBYzA0QixpQkFBaUJ0TixRQUFRLENBQUM7WUFDakUxckIsV0FBV0QsYUFBYWs2QjtZQUV4QixJQUFJaEIsY0FBYztnQkFDaEJqNUIsV0FBV0QsYUFBYXc1QjtZQUMxQixPQUFPO2dCQUNMdjVCLFdBQVdELGFBQWE4NUI7WUFDMUI7WUFFQTc1QixXQUFXRCxhQUFheXJCLGNBQWM5QixhQUFhO1lBQ25EMXBCLFdBQVdELGFBQWFvNkI7WUFFeEIsSUFBSUQsd0JBQXdCO2dCQUMxQix3REFBd0Q7Z0JBQ3hELHFFQUFxRTtnQkFDckUsNkNBQTZDO2dCQUM3QyxrRUFBa0U7Z0JBQ2xFLHFDQUFxQztnQkFDckMsSUFBSWpCLGNBQWM7b0JBQ2hCajVCLFdBQVdELGFBQWF5NUIsMkJBQTJCLDZDQUE2QztvQkFFaEdZLG1DQUFtQ3I2QixhQUFhMnlCO2dCQUNsRCxPQUFPO29CQUNMMXlCLFdBQVdELGFBQWErNUI7b0JBQ3hCTyxxQ0FBcUN0NkIsYUFBYTJ5QjtnQkFDcEQ7WUFDRixPQUFPO2dCQUNMLElBQUl1RyxjQUFjO29CQUNoQmo1QixXQUFXRCxhQUFhMDVCO2dCQUMxQjtZQUNGO1lBRUEsSUFBSWE7WUFFSixJQUFJckIsY0FBYztnQkFDaEJxQixZQUFZcDZCLG9CQUFvQkgsYUFBYTI1QjtZQUMvQyxPQUFPO2dCQUNMWSxZQUFZcDZCLG9CQUFvQkgsYUFBYWc2QjtZQUMvQztZQUVBLE9BQU96RSxlQUFldjFCLGFBQWF5ckIsa0JBQWtCOE87UUFDdkQ7UUFDQSxJQUFJQywwQkFBMEIvNUIseUJBQXlCaWlCLHVCQUF1QjtRQUM5RSxJQUFJK1gsNkJBQTZCaDZCLHlCQUF5QjtRQUMxRCxJQUFJaTZCLHVCQUF1Qmo2Qix5QkFBeUI7UUFDcEQsSUFBSWs2Qix5Q0FBeUNsNkIseUJBQXlCO1FBQ3RFLElBQUltNkIsd0JBQXdCbjZCLHlCQUF5QjtRQUNyRCxJQUFJbzZCLG9CQUFvQnA2Qix5QkFBeUI7UUFDakQsSUFBSXE2QixvQkFBb0JyNkIseUJBQXlCO1FBQ2pELElBQUlzNkIsb0JBQW9CdDZCLHlCQUF5QjtRQUNqRCxJQUFJdTZCLG9CQUFvQnY2Qix5QkFBeUI7UUFDakQsSUFBSXc2QixzQkFBc0I3VDtRQUMxQixTQUFTOFQscUNBQXFDbDdCLFdBQVcsRUFBRXlyQixhQUFhLEVBQUV5TyxVQUFVLEVBQUV0RCxXQUFXLEVBQUV1RSxZQUFZLEVBQUVyRSxtQkFBbUI7WUFDbEksSUFBSW9DLGVBQWV6TixjQUFjM0MsZUFBZSxLQUFLakM7WUFFckQsSUFBSXFTLGNBQWM7Z0JBQ2hCajVCLFdBQVdELGFBQWF5ckIsY0FBY3BFLGlCQUFpQjtnQkFFdkQsSUFBSSxDQUFDb0UsY0FBYzNCLFlBQVksR0FBRzVDLHdCQUF1QixNQUFPSCxhQUFhO29CQUMzRSwrRUFBK0U7b0JBQy9FMEUsY0FBYzNCLFlBQVksSUFBSTVDO29CQUM5QmpuQixXQUFXRCxhQUFhdzZCO2dCQUMxQixPQUFPO29CQUNMLGlEQUFpRDtvQkFDakR2NkIsV0FBV0QsYUFBYXk2QjtnQkFDMUI7WUFDRixPQUFPO2dCQUNMLG1DQUFtQztnQkFDbkN4NkIsV0FBV0QsYUFBYTY2QjtZQUMxQjtZQUVBLElBQUlYLGVBQWUsTUFBTTtnQkFDdkIsTUFBTSxJQUFJck4sTUFBTTtZQUNsQjtZQUVBNXNCLFdBQVdELGFBQWFrNkI7WUFFeEIsSUFBSWhCLGNBQWM7Z0JBQ2hCLDZFQUE2RTtnQkFDN0UsNkJBQTZCO2dCQUM3Qmo1QixXQUFXRCxhQUFhMDZCO1lBQzFCO1lBRUEsSUFBSTlELGVBQWV1RSxnQkFBZ0JyRSxxQkFBcUI7Z0JBQ3RELElBQUlvQyxjQUFjO29CQUNoQixnQkFBZ0I7b0JBQ2hCajVCLFdBQVdELGFBQWEyNkI7b0JBQ3hCMTZCLFdBQVdELGFBQWFPLGNBQWM2NkIscUNBQXFDeEUsZUFBZTtnQkFDNUYsT0FBTztvQkFDTCwwQkFBMEI7b0JBQzFCMzJCLFdBQVdELGFBQWE4NkI7b0JBQ3hCNzZCLFdBQVdELGFBQWFPLGNBQWNvaEIscUJBQXFCaVYsZUFBZTtnQkFDNUU7WUFDRjtZQUVBLElBQUl1RSxnQkFBZ0JyRSxxQkFBcUI7Z0JBQ3ZDLElBQUlvQyxjQUFjO29CQUNoQixnQkFBZ0I7b0JBQ2hCajVCLFdBQVdELGFBQWEyNkI7b0JBQ3hCMTZCLFdBQVdELGFBQWFPLGNBQWM2NkIscUNBQXFDRCxnQkFBZ0I7Z0JBQzdGLE9BQU87b0JBQ0wseUJBQXlCO29CQUN6Qmw3QixXQUFXRCxhQUFhKzZCO29CQUN4Qjk2QixXQUFXRCxhQUFhTyxjQUFjb2hCLHFCQUFxQndaLGdCQUFnQjtnQkFDN0U7WUFDRjtZQUVBLElBQUlyRSxxQkFBcUI7Z0JBQ3ZCLGdCQUFnQjtnQkFDaEIsSUFBSW9DLGNBQWM7b0JBQ2hCajVCLFdBQVdELGFBQWEyNkI7b0JBQ3hCMTZCLFdBQVdELGFBQWFPLGNBQWM2NkIscUNBQXFDdEU7Z0JBQzdFLE9BQU87b0JBQ0wsMEJBQTBCO29CQUMxQjcyQixXQUFXRCxhQUFhZzdCO29CQUN4Qi82QixXQUFXRCxhQUFhTyxjQUFjb2hCLHFCQUFxQm1WO2dCQUM3RDtZQUNGO1lBRUEsSUFBSW9DLGNBQWM7Z0JBQ2hCLGFBQWE7Z0JBQ2IsT0FBTy80QixvQkFBb0JILGFBQWE0NkI7WUFDMUMsT0FBTztnQkFDTCxnQkFBZ0I7Z0JBQ2hCLE9BQU96NkIsb0JBQW9CSCxhQUFhaTdCO1lBQzFDO1FBQ0Y7UUFDQSxJQUFJSSx3Q0FBd0M7UUFFNUMsU0FBU0QscUNBQXFDRSxLQUFLO1lBQ2pELElBQUlDLFVBQVVsWixLQUFLQyxTQUFTLENBQUNnWjtZQUM3QixPQUFPQyxRQUFRbGIsT0FBTyxDQUFDZ2IsdUNBQXVDLFNBQVVqYSxLQUFLO2dCQUMzRSxPQUFRQTtvQkFDTixvREFBb0Q7b0JBQ3BELEtBQUs7d0JBQ0gsT0FBTztvQkFFVCxLQUFLO3dCQUNILE9BQU87b0JBRVQsS0FBSzt3QkFDSCxPQUFPO29CQUVUO3dCQUNFOzRCQUNFLDJEQUEyRDs0QkFDM0QsTUFBTSxJQUFJeUwsTUFBTTt3QkFDbEI7Z0JBQ0o7WUFDRjtRQUNGO1FBRUEsSUFBSTJPLDZCQUE2QjtRQUVqQyxTQUFTQyxvQ0FBb0NILEtBQUs7WUFDaEQsSUFBSUMsVUFBVWxaLEtBQUtDLFNBQVMsQ0FBQ2daO1lBQzdCLE9BQU9DLFFBQVFsYixPQUFPLENBQUNtYiw0QkFBNEIsU0FBVXBhLEtBQUs7Z0JBQ2hFLE9BQVFBO29CQUNOLG9EQUFvRDtvQkFDcEQsS0FBSzt3QkFDSCxPQUFPO29CQUVULEtBQUs7d0JBQ0gsT0FBTztvQkFFVCxLQUFLO3dCQUNILE9BQU87b0JBRVQsS0FBSzt3QkFDSCxPQUFPO29CQUVULEtBQUs7d0JBQ0gsT0FBTztvQkFFVDt3QkFDRTs0QkFDRSwyREFBMkQ7NEJBQzNELE1BQU0sSUFBSXlMLE1BQU07d0JBQ2xCO2dCQUNKO1lBQ0Y7UUFDRjtRQUVBLElBQUk2Tyw0QkFBNEJqN0IseUJBQXlCO1FBQ3pELElBQUlrN0IsNEJBQTRCbDdCLHlCQUF5QjtRQUN6RCxJQUFJbTdCLDRCQUE0Qm43Qix5QkFBeUI7UUFDekQsSUFBSW83Qiw0QkFBNEJwN0IseUJBQXlCLGFBQWEsbUZBQW1GO1FBQ3pKLHVEQUF1RDtRQUV2RCxJQUFJcTdCLDZDQUE2QyxPQUFPLDBFQUEwRTtRQUVsSSxJQUFJQyx5QkFBeUI7UUFFN0IsU0FBU0MsOEJBQThCdGpCLFFBQVE7WUFDN0MsSUFBSUEsU0FBU3pXLElBQUksS0FBSyxnQkFBZ0IsQ0FBQ3lXLFNBQVNvWixLQUFLLEdBQUdtSyxpQkFBZ0IsTUFBT2xLLFNBQVM7Z0JBQ3RGK0osNkNBQTZDO1lBQy9DLE9BQU8sSUFBSXBqQixTQUFTelcsSUFBSSxLQUFLLFNBQVM7Z0JBQ3BDLElBQUk4bUIsU0FBU3JRLFNBQVNxUSxNQUFNO2dCQUM1QixJQUFJeUosUUFBUTlaLFNBQVNuVSxLQUFLLENBQUNpdUIsS0FBSztnQkFDaEMsSUFBSWpQLElBQUk7Z0JBRVIsSUFBSXdGLE9BQU96cUIsTUFBTSxFQUFFO29CQUNqQjJCLFdBQVcsSUFBSSxFQUFFeTdCO29CQUNqQno3QixXQUFXLElBQUksRUFBRU0sY0FBY29oQixxQkFBcUJqSixTQUFTblUsS0FBSyxDQUFDcXNCLFVBQVU7b0JBRTdFLElBQUk0QixNQUFNbDBCLE1BQU0sRUFBRTt3QkFDaEIyQixXQUFXLElBQUksRUFBRTA3Qjt3QkFFakIsTUFBT3BZLElBQUlpUCxNQUFNbDBCLE1BQU0sR0FBRyxHQUFHaWxCLElBQUs7NEJBQ2hDdGpCLFdBQVcsSUFBSSxFQUFFTSxjQUFjb2hCLHFCQUFxQjZRLEtBQUssQ0FBQ2pQLEVBQUU7NEJBQzVEdGpCLFdBQVcsSUFBSSxFQUFFaThCO3dCQUNuQjt3QkFFQWo4QixXQUFXLElBQUksRUFBRU0sY0FBY29oQixxQkFBcUI2USxLQUFLLENBQUNqUCxFQUFFO29CQUM5RDtvQkFFQXRqQixXQUFXLElBQUksRUFBRTI3QjtvQkFFakIsSUFBS3JZLElBQUksR0FBR0EsSUFBSXdGLE9BQU96cUIsTUFBTSxFQUFFaWxCLElBQUs7d0JBQ2xDdGpCLFdBQVcsSUFBSSxFQUFFOG9CLE1BQU0sQ0FBQ3hGLEVBQUU7b0JBQzVCO29CQUVBd1kseUJBQXlCNTdCLG9CQUFvQixJQUFJLEVBQUUwN0IsNEJBQTRCLHlFQUF5RTtvQkFDeEosaUJBQWlCO29CQUVqQkMsNkNBQTZDLE1BQU0sOEVBQThFO29CQUNqSSxpRkFBaUY7b0JBQ2pGLFlBQVk7b0JBRVovUyxPQUFPenFCLE1BQU0sR0FBRztvQkFDaEJrMEIsTUFBTWwwQixNQUFNLEdBQUc7Z0JBQ2pCO1lBQ0Y7UUFDRjtRQUVBLFNBQVM2OUIsMEJBQTBCbjhCLFdBQVcsRUFBRTJ5QixpQkFBaUIsRUFBRWxILGFBQWE7WUFDOUUsOEVBQThFO1lBQzlFcVEsNkNBQTZDO1lBQzdDQyx5QkFBeUIsTUFBTSwrQkFBK0I7WUFFOURwSixrQkFBa0I1RSxPQUFPLENBQUNpTywrQkFBK0JoOEI7WUFFekQsSUFBSTg3Qiw0Q0FBNEM7Z0JBQzlDclEsY0FBY25CLGFBQWEsR0FBRztZQUNoQztZQUVBLE9BQU95UjtRQUNUO1FBRUEsU0FBU0ssd0JBQXdCMWpCLFFBQVE7WUFDdkMsSUFBSSxDQUFDQSxTQUFTb1osS0FBSyxHQUFJSSxDQUFBQSxVQUFVRixPQUFNLENBQUMsTUFBT0QsU0FBUztnQkFDdEQsSUFBSWhKLFNBQVNyUSxTQUFTcVEsTUFBTTtnQkFFNUIsSUFBSyxJQUFJeEYsSUFBSSxHQUFHQSxJQUFJd0YsT0FBT3pxQixNQUFNLEVBQUVpbEIsSUFBSztvQkFDdEN0akIsV0FBVyxJQUFJLEVBQUU4b0IsTUFBTSxDQUFDeEYsRUFBRTtnQkFDNUI7Z0JBRUE3SyxTQUFTb1osS0FBSyxJQUFJbUs7WUFDcEI7UUFDRjtRQUVBLFNBQVNJLGtCQUFrQjNqQixRQUFRO1lBQ2pDLElBQUksQ0FBQ0EsU0FBU29aLEtBQUssR0FBSUksQ0FBQUEsVUFBVUYsT0FBTSxDQUFDLE1BQU9ELFNBQVM7Z0JBQ3RELElBQUloSixTQUFTclEsU0FBU3FRLE1BQU07Z0JBRTVCLElBQUssSUFBSXhGLElBQUksR0FBR0EsSUFBSXdGLE9BQU96cUIsTUFBTSxFQUFFaWxCLElBQUs7b0JBQ3RDdGpCLFdBQVcsSUFBSSxFQUFFOG9CLE1BQU0sQ0FBQ3hGLEVBQUU7Z0JBQzVCO2dCQUVBN0ssU0FBU29aLEtBQUssSUFBSXdLO1lBQ3BCO1FBQ0YsRUFBRSx3R0FBd0c7UUFDMUcsb0dBQW9HO1FBR3BHLElBQUlDLDZCQUE2QixNQUFNLDZHQUE2RztRQUNwSiw2R0FBNkc7UUFDN0csc0NBQXNDO1FBRXRDLElBQUlDLHFCQUFxQjtRQUV6QixTQUFTQyxxQkFBcUIvakIsUUFBUSxFQUFFM1gsR0FBRyxFQUFFeXJCLEdBQUc7WUFDOUMsSUFBSXpELFNBQVNyUSxTQUFTcVEsTUFBTTtZQUU1QixJQUFJclEsU0FBU29aLEtBQUssR0FBR0ksU0FBUztnQkFDNUIsK0RBQStEO2dCQUMvRCw2REFBNkQ7Z0JBQzdELG9DQUFvQztnQkFDcEMxRixJQUFJa1EsTUFBTSxDQUFDaGtCO1lBQ2IsT0FBTztnQkFDTCw4Q0FBOEM7Z0JBQzlDLElBQUlBLFNBQVN6VyxJQUFJLEtBQUssU0FBUztvQkFDN0JzNkIsNkJBQTZCN2pCO29CQUM3QjtnQkFDRixFQUFFLDRDQUE0QztnQkFDOUMsd0VBQXdFO2dCQUN4RSx5RUFBeUU7Z0JBQ3pFLGdFQUFnRTtnQkFHaEVtWSxhQUFhOUgsUUFBUXJRLFNBQVNuVSxLQUFLO2dCQUVuQyxJQUFLLElBQUlnZixJQUFJLEdBQUdBLElBQUl3RixPQUFPenFCLE1BQU0sRUFBRWlsQixJQUFLO29CQUN0Q3RqQixXQUFXLElBQUksRUFBRThvQixNQUFNLENBQUN4RixFQUFFO2dCQUM1QjtnQkFFQTdLLFNBQVNvWixLQUFLLElBQUltSztnQkFDbEJPLHFCQUFxQjtZQUN2QjtRQUNGO1FBRUEsSUFBSUcsd0JBQXdCbDhCLHlCQUF5QjtRQUNyRCxJQUFJbThCLHdCQUF3Qm44Qix5QkFBeUI7UUFDckQsSUFBSXk3QixpQkFBaUJ6N0IseUJBQXlCO1FBQzlDLElBQUlvOEIsd0JBQXdCcDhCLHlCQUF5QjtRQUNyRCxJQUFJcThCLHdCQUF3QnI4Qix5QkFBeUI7UUFFckQsU0FBU3M4Qix5QkFBeUJ2USxHQUFHLEVBQUVvRSxVQUFVO1lBQy9DNEwscUJBQXFCO1lBQ3JCaFEsSUFBSXVCLE9BQU8sQ0FBQzBPLHNCQUFzQixJQUFJO1lBQ3RDalEsSUFBSXdRLEtBQUs7WUFDVCxJQUFJalUsU0FBU3dULDJCQUEyQnhULE1BQU07WUFDOUMsSUFBSXlKLFFBQVErSiwyQkFBMkJoNEIsS0FBSyxDQUFDaXVCLEtBQUs7WUFFbEQsSUFBSWdLLHVCQUF1QixTQUFTelQsT0FBT3pxQixNQUFNLEVBQUU7Z0JBQ2pEMkIsV0FBVyxJQUFJLEVBQUUwOEI7Z0JBQ2pCMThCLFdBQVcsSUFBSSxFQUFFTSxjQUFjb2hCLHFCQUFxQmlQO2dCQUNwRCxJQUFJck4sSUFBSTtnQkFFUixJQUFJaVAsTUFBTWwwQixNQUFNLEVBQUU7b0JBQ2hCMkIsV0FBVyxJQUFJLEVBQUUyOEI7b0JBRWpCLE1BQU9yWixJQUFJaVAsTUFBTWwwQixNQUFNLEdBQUcsR0FBR2lsQixJQUFLO3dCQUNoQ3RqQixXQUFXLElBQUksRUFBRU0sY0FBY29oQixxQkFBcUI2USxLQUFLLENBQUNqUCxFQUFFO3dCQUM1RHRqQixXQUFXLElBQUksRUFBRWk4QjtvQkFDbkI7b0JBRUFqOEIsV0FBVyxJQUFJLEVBQUVNLGNBQWNvaEIscUJBQXFCNlEsS0FBSyxDQUFDalAsRUFBRTtnQkFDOUQ7Z0JBRUF0akIsV0FBVyxJQUFJLEVBQUU0OEI7Z0JBRWpCLElBQUt0WixJQUFJLEdBQUdBLElBQUl3RixPQUFPenFCLE1BQU0sRUFBRWlsQixJQUFLO29CQUNsQ3RqQixXQUFXLElBQUksRUFBRThvQixNQUFNLENBQUN4RixFQUFFO2dCQUM1QjtnQkFFQXRqQixXQUFXLElBQUksRUFBRTY4Qix3QkFBd0IsOEVBQThFO2dCQUN2SCxpRkFBaUY7Z0JBQ2pGLFlBQVk7Z0JBRVovVCxPQUFPenFCLE1BQU0sR0FBRztnQkFDaEJrMEIsTUFBTWwwQixNQUFNLEdBQUc7WUFDakI7UUFDRjtRQUVBLFNBQVMyK0IsaUJBQWlCdmtCLFFBQVE7WUFDaEMsSUFBSUEsU0FBU29aLEtBQUssR0FBR0ssZ0JBQWdCO2dCQUNuQyxrREFBa0Q7Z0JBQ2xEO1lBQ0Y7WUFFQSxJQUFJelosU0FBU3pXLElBQUksS0FBSyxTQUFTO2dCQUM3QiwyQ0FBMkM7Z0JBQzNDO1lBQ0Y7WUFFQSxJQUFJOG1CLFNBQVNyUSxTQUFTcVEsTUFBTTtZQUM1QixJQUFJbVUsZUFBZUMsNkJBQTZCemtCLFNBQVNuVSxLQUFLLENBQUN1RixJQUFJLEVBQUU0TyxTQUFTblUsS0FBSztZQUNuRnNzQixhQUFhOUgsUUFBUW1VO1lBRXJCLElBQUssSUFBSTNaLElBQUksR0FBR0EsSUFBSXdGLE9BQU96cUIsTUFBTSxFQUFFaWxCLElBQUs7Z0JBQ3RDdGpCLFdBQVcsSUFBSSxFQUFFOG9CLE1BQU0sQ0FBQ3hGLEVBQUU7WUFDNUI7WUFFQTdLLFNBQVNvWixLQUFLLElBQUlLO1lBQ2xCcEosT0FBT3pxQixNQUFNLEdBQUc7UUFDbEI7UUFFQSxTQUFTOCtCLGtCQUFrQjVRLEdBQUcsRUFBRW9FLFVBQVU7WUFDeENwRSxJQUFJdUIsT0FBTyxDQUFDa1Asa0JBQWtCLElBQUk7WUFDbEN6USxJQUFJd1EsS0FBSztRQUNYLEVBQUUsNEVBQTRFO1FBQzlFLCtFQUErRTtRQUMvRSxpRkFBaUY7UUFDakYsZ0NBQWdDO1FBR2hDLFNBQVNLLGNBQWNyOUIsV0FBVyxFQUFFb29CLFNBQVMsRUFBRXFELGFBQWEsRUFBRTZSLG9CQUFvQjtZQUNoRiw2REFBNkQ7WUFDN0QsSUFBSSxDQUFDQSx3QkFBd0I3UixjQUFjNUMscUJBQXFCLEVBQUU7Z0JBQ2hFLDJEQUEyRDtnQkFDM0QsNERBQTREO2dCQUM1RCx5REFBeUQ7Z0JBQ3pELCtEQUErRDtnQkFDL0Qsa0RBQWtEO2dCQUNsRCxJQUFJMFUsd0JBQXdCOVIsY0FBYzVDLHFCQUFxQixFQUMzRDVhLE1BQU1zdkIsc0JBQXNCdHZCLEdBQUcsRUFDL0I4YSxTQUFTd1Usc0JBQXNCeFUsTUFBTTtnQkFDekN5VSxzQkFBc0JwVixXQUFXbmEsS0FBSzhhO1lBQ3hDO1lBRUEsSUFBSWdCLGFBQWEwQixjQUFjMUIsVUFBVTtZQUN6QyxJQUFJQyxhQUFheUIsY0FBY3pCLFVBQVU7WUFDekMsSUFBSXpHLElBQUksR0FBRyxpREFBaUQ7WUFFNUQsSUFBSXdHLFlBQVk7Z0JBQ2Qsb0RBQW9EO2dCQUNwRCxJQUFLeEcsSUFBSSxHQUFHQSxJQUFJd0csV0FBV3pyQixNQUFNLEVBQUVpbEIsSUFBSztvQkFDdEN0akIsV0FBV0QsYUFBYStwQixVQUFVLENBQUN4RyxFQUFFO2dCQUN2QztnQkFFQSxJQUFJeUcsWUFBWTtvQkFDZCxJQUFLekcsSUFBSSxHQUFHQSxJQUFJeUcsV0FBVzFyQixNQUFNLEVBQUVpbEIsSUFBSzt3QkFDdEN0akIsV0FBV0QsYUFBYWdxQixVQUFVLENBQUN6RyxFQUFFO29CQUN2QztnQkFDRixPQUFPO29CQUNMLHVFQUF1RTtvQkFDdkV0akIsV0FBV0QsYUFBYXV2QixpQkFBaUI7b0JBQ3pDdHZCLFdBQVdELGFBQWF3dUI7Z0JBQzFCO1lBQ0YsT0FBTyxJQUFJeEUsWUFBWTtnQkFDckIsbURBQW1EO2dCQUNuRCxJQUFLekcsSUFBSSxHQUFHQSxJQUFJeUcsV0FBVzFyQixNQUFNLEVBQUVpbEIsSUFBSztvQkFDdEN0akIsV0FBV0QsYUFBYWdxQixVQUFVLENBQUN6RyxFQUFFO2dCQUN2QztZQUNGLEVBQUUsZ0NBQWdDO1lBR2xDLElBQUkyRyxnQkFBZ0J1QixjQUFjdkIsYUFBYTtZQUUvQyxJQUFLM0csSUFBSSxHQUFHQSxJQUFJMkcsY0FBYzVyQixNQUFNLEVBQUVpbEIsSUFBSztnQkFDekN0akIsV0FBV0QsYUFBYWtxQixhQUFhLENBQUMzRyxFQUFFO1lBQzFDO1lBRUEyRyxjQUFjNXJCLE1BQU0sR0FBRyxHQUFHLDRCQUE0QjtZQUV0RDhwQixVQUFVcVYsV0FBVyxDQUFDMVAsT0FBTyxDQUFDcU8seUJBQXlCcDhCO1lBQ3ZEb29CLFVBQVVxVixXQUFXLENBQUNULEtBQUs7WUFDM0IsSUFBSTdTLG1CQUFtQnNCLGNBQWN0QixnQkFBZ0I7WUFFckQsSUFBSzVHLElBQUksR0FBR0EsSUFBSTRHLGlCQUFpQjdyQixNQUFNLEVBQUVpbEIsSUFBSztnQkFDNUN0akIsV0FBV0QsYUFBYW1xQixnQkFBZ0IsQ0FBQzVHLEVBQUU7WUFDN0M7WUFFQTRHLGlCQUFpQjdyQixNQUFNLEdBQUc7WUFDMUI4cEIsVUFBVXNWLFlBQVksQ0FBQzNQLE9BQU8sQ0FBQ3FPLHlCQUF5QnA4QjtZQUN4RG9vQixVQUFVc1YsWUFBWSxDQUFDVixLQUFLO1lBQzVCNVUsVUFBVXVMLGlCQUFpQixDQUFDNUYsT0FBTyxDQUFDcU8seUJBQXlCcDhCO1lBQzdEb29CLFVBQVV1TCxpQkFBaUIsQ0FBQ3FKLEtBQUssSUFBSSw0Q0FBNEM7WUFFakY1VSxVQUFVa0ssV0FBVyxDQUFDdkUsT0FBTyxDQUFDZ1AsMEJBQTBCLzhCO1lBQ3hEb29CLFVBQVVHLGdCQUFnQixDQUFDd0YsT0FBTyxDQUFDcU8seUJBQXlCcDhCO1lBQzVEb29CLFVBQVVzTSxPQUFPLENBQUMzRyxPQUFPLENBQUNxTyx5QkFBeUJwOEI7WUFDbkRvb0IsVUFBVXNNLE9BQU8sQ0FBQ3NJLEtBQUs7WUFDdkI1VSxVQUFVd0wsWUFBWSxDQUFDN0YsT0FBTyxDQUFDcU8seUJBQXlCcDhCO1lBQ3hEb29CLFVBQVV3TCxZQUFZLENBQUNvSixLQUFLLElBQUksZ0NBQWdDO1lBRWhFLElBQUk1UyxnQkFBZ0JxQixjQUFjckIsYUFBYTtZQUUvQyxJQUFLN0csSUFBSSxHQUFHQSxJQUFJNkcsY0FBYzlyQixNQUFNLEVBQUVpbEIsSUFBSztnQkFDekN0akIsV0FBV0QsYUFBYW9xQixhQUFhLENBQUM3RyxFQUFFO1lBQzFDO1lBRUE2RyxjQUFjOXJCLE1BQU0sR0FBRyxHQUFHLGtDQUFrQztZQUU1RCxJQUFJK3JCLGtCQUFrQm9CLGNBQWNwQixlQUFlO1lBRW5ELElBQUs5RyxJQUFJLEdBQUdBLElBQUk4RyxnQkFBZ0IvckIsTUFBTSxFQUFFaWxCLElBQUs7Z0JBQzNDdGpCLFdBQVdELGFBQWFxcUIsZUFBZSxDQUFDOUcsRUFBRTtZQUM1QztZQUVBOEcsZ0JBQWdCL3JCLE1BQU0sR0FBRyxHQUFHLGtDQUFrQztZQUU5RCxJQUFJeXJCLGNBQWNDLGVBQWUsTUFBTTtnQkFDckMseUVBQXlFO2dCQUN6RSw2RUFBNkU7Z0JBQzdFLDBFQUEwRTtnQkFDMUUsNEVBQTRFO2dCQUM1RSxlQUFlO2dCQUNmL3BCLFdBQVdELGFBQWFnekI7Z0JBQ3hCL3lCLFdBQVdELGFBQWFPLGNBQWM7Z0JBQ3RDTixXQUFXRCxhQUFhaXpCO1lBQzFCO1FBQ0YsRUFBRSw0RUFBNEU7UUFDOUUsK0VBQStFO1FBQy9FLGlGQUFpRjtRQUNqRixnQ0FBZ0M7UUFFaEMsU0FBUzBLLGdCQUFnQjM5QixXQUFXLEVBQUVvb0IsU0FBUyxFQUFFcUQsYUFBYTtZQUM1RCxJQUFJbEksSUFBSSxHQUFHLGdDQUFnQztZQUMzQyxnRkFBZ0Y7WUFDaEYsbUNBQW1DO1lBRW5DNkUsVUFBVXFWLFdBQVcsQ0FBQzFQLE9BQU8sQ0FBQ3NPLG1CQUFtQnI4QjtZQUNqRG9vQixVQUFVcVYsV0FBVyxDQUFDVCxLQUFLO1lBQzNCLElBQUk3UyxtQkFBbUJzQixjQUFjdEIsZ0JBQWdCO1lBRXJELElBQUs1RyxJQUFJLEdBQUdBLElBQUk0RyxpQkFBaUI3ckIsTUFBTSxFQUFFaWxCLElBQUs7Z0JBQzVDdGpCLFdBQVdELGFBQWFtcUIsZ0JBQWdCLENBQUM1RyxFQUFFO1lBQzdDO1lBRUE0RyxpQkFBaUI3ckIsTUFBTSxHQUFHO1lBQzFCOHBCLFVBQVVzVixZQUFZLENBQUMzUCxPQUFPLENBQUNzTyxtQkFBbUJyOEI7WUFDbERvb0IsVUFBVXNWLFlBQVksQ0FBQ1YsS0FBSztZQUM1QjVVLFVBQVV1TCxpQkFBaUIsQ0FBQzVGLE9BQU8sQ0FBQ3FPLHlCQUF5QnA4QjtZQUM3RG9vQixVQUFVdUwsaUJBQWlCLENBQUNxSixLQUFLLElBQUkscUZBQXFGO1lBQzFILHlEQUF5RDtZQUV6RDVVLFVBQVVrSyxXQUFXLENBQUN2RSxPQUFPLENBQUNxUCxtQkFBbUJwOUIsY0FBYyxnR0FBZ0c7WUFDL0osNENBQTRDO1lBRTVDb29CLFVBQVVzTSxPQUFPLENBQUMzRyxPQUFPLENBQUNzTyxtQkFBbUJyOEI7WUFDN0Nvb0IsVUFBVXNNLE9BQU8sQ0FBQ3NJLEtBQUs7WUFDdkI1VSxVQUFVd0wsWUFBWSxDQUFDN0YsT0FBTyxDQUFDc08sbUJBQW1CcjhCO1lBQ2xEb29CLFVBQVV3TCxZQUFZLENBQUNvSixLQUFLLElBQUksZ0NBQWdDO1lBRWhFLElBQUk1UyxnQkFBZ0JxQixjQUFjckIsYUFBYTtZQUUvQyxJQUFLN0csSUFBSSxHQUFHQSxJQUFJNkcsY0FBYzlyQixNQUFNLEVBQUVpbEIsSUFBSztnQkFDekN0akIsV0FBV0QsYUFBYW9xQixhQUFhLENBQUM3RyxFQUFFO1lBQzFDO1lBRUE2RyxjQUFjOXJCLE1BQU0sR0FBRyxHQUFHLGtDQUFrQztZQUU1RCxJQUFJK3JCLGtCQUFrQm9CLGNBQWNwQixlQUFlO1lBRW5ELElBQUs5RyxJQUFJLEdBQUdBLElBQUk4RyxnQkFBZ0IvckIsTUFBTSxFQUFFaWxCLElBQUs7Z0JBQzNDdGpCLFdBQVdELGFBQWFxcUIsZUFBZSxDQUFDOUcsRUFBRTtZQUM1QztZQUVBOEcsZ0JBQWdCL3JCLE1BQU0sR0FBRztRQUMzQjtRQUNBLFNBQVNzL0IsZUFBZTU5QixXQUFXLEVBQUV5ckIsYUFBYTtZQUNoRCxJQUFJQSxjQUFjeEIsT0FBTyxFQUFFO2dCQUN6QmhxQixXQUFXRCxhQUFhZ3pCO2dCQUN4Qi95QixXQUFXRCxhQUFhTyxjQUFjO2dCQUN0Q04sV0FBV0QsYUFBYWl6QjtZQUMxQjtZQUVBLElBQUl4SCxjQUFjMUIsVUFBVSxFQUFFO2dCQUM1QjlwQixXQUFXRCxhQUFhZ3pCO2dCQUN4Qi95QixXQUFXRCxhQUFhTyxjQUFjO2dCQUN0Q04sV0FBV0QsYUFBYWl6QjtZQUMxQjtRQUNGO1FBQ0EsSUFBSTRLLHdCQUF3QnA5Qix5QkFBeUI7UUFDckQsSUFBSXE5Qiw2QkFBNkJyOUIseUJBQXlCO1FBQzFELElBQUlzOUIsb0JBQW9CdDlCLHlCQUF5QjtRQUNqRCxJQUFJdTlCLG9CQUFvQnY5Qix5QkFBeUIsTUFBTSwyRUFBMkU7UUFDbEksT0FBTztRQUNQLGtEQUFrRDtRQUVsRCxTQUFTNDVCLG1DQUFtQ3I2QixXQUFXLEVBQUUyeUIsaUJBQWlCO1lBQ3hFMXlCLFdBQVdELGFBQWE2OUI7WUFDeEIsSUFBSUksMEJBQTBCSjtZQUM5QmxMLGtCQUFrQjVFLE9BQU8sQ0FBQyxTQUFVclYsUUFBUTtnQkFDMUMsSUFBSUEsU0FBU3pXLElBQUksS0FBSztxQkFBZ0IsSUFBSXlXLFNBQVNvWixLQUFLLEdBQUdtSztxQkFBMEIsSUFBSXZqQixTQUFTb1osS0FBSyxHQUFHSSxTQUFTO29CQUNqSCw0RUFBNEU7b0JBQzVFLHVFQUF1RTtvQkFDdkUsdUNBQXVDO29CQUN2Q2p5QixXQUFXRCxhQUFhaStCO29CQUN4QkMseUNBQXlDbCtCLGFBQWEwWSxTQUFTblUsS0FBSyxDQUFDdUYsSUFBSTtvQkFDekU3SixXQUFXRCxhQUFhZytCO29CQUN4QkMsMEJBQTBCSDtnQkFDNUIsT0FBTyxJQUFJcGxCLFNBQVN6VyxJQUFJLEtBQUssY0FBYztvQkFDekMsaUVBQWlFO29CQUNqRWhDLFdBQVdELGFBQWFpK0I7b0JBQ3hCRSxpQ0FBaUNuK0IsYUFBYTBZLFNBQVNuVSxLQUFLLENBQUN1RixJQUFJLEVBQUU0TyxTQUFTblUsS0FBSyxDQUFDLGtCQUFrQixFQUFFbVUsU0FBU25VLEtBQUs7b0JBQ3BIdEUsV0FBV0QsYUFBYWcrQjtvQkFDeEJDLDBCQUEwQkg7b0JBQzFCcGxCLFNBQVNvWixLQUFLLElBQUl3SztnQkFDcEI7WUFDRjtZQUNBcjhCLFdBQVdELGFBQWFnK0I7UUFDMUI7UUFDQSxvQkFBb0IsR0FHcEIsU0FBU0UseUNBQXlDbCtCLFdBQVcsRUFBRThKLElBQUk7WUFDakUsK0VBQStFO1lBQy9FLCtEQUErRDtZQUMvRDtnQkFDRXhILDZCQUE2QndILE1BQU07WUFDckM7WUFFQSxJQUFJczBCLGNBQWMsS0FBS3QwQjtZQUN2QjdKLFdBQVdELGFBQWFPLGNBQWNrN0Isb0NBQW9DMkM7UUFDNUU7UUFFQSxTQUFTRCxpQ0FBaUNuK0IsV0FBVyxFQUFFOEosSUFBSSxFQUFFOG1CLFVBQVUsRUFBRXJzQixLQUFLO1lBQzVFLCtEQUErRDtZQUMvRCxJQUFJNjVCLGNBQWNsYyxZQUFZLEtBQUtwWTtZQUNuQzdKLFdBQVdELGFBQWFPLGNBQWNrN0Isb0NBQW9DMkM7WUFFMUU7Z0JBQ0U5N0IsNkJBQTZCc3VCLFlBQVk7WUFDM0M7WUFFQSxJQUFJeU4sb0JBQW9CLEtBQUt6TjtZQUM3QjN3QixXQUFXRCxhQUFhKzlCO1lBQ3hCOTlCLFdBQVdELGFBQWFPLGNBQWNrN0Isb0NBQW9DNEM7WUFFMUUsSUFBSyxJQUFJN08sV0FBV2pyQixNQUFPO2dCQUN6QixJQUFJM0IsZUFBZWpELElBQUksQ0FBQzRFLE9BQU9pckIsVUFBVTtvQkFDdkMsSUFBSXRMLFlBQVkzZixLQUFLLENBQUNpckIsUUFBUTtvQkFFOUIsSUFBSXRMLGFBQWEsTUFBTTt3QkFDckI7b0JBQ0Y7b0JBRUEsT0FBUXNMO3dCQUNOLEtBQUs7d0JBQ0wsS0FBSzt3QkFDTCxLQUFLO3dCQUNMLEtBQUs7NEJBQ0g7Z0NBQ0U7NEJBQ0Y7d0JBRUYsS0FBSzt3QkFDTCxLQUFLOzRCQUNILE1BQU0sSUFBSTNDLE1BQU0sU0FBUyxpRUFBaUU7d0JBRTVGOzRCQUNFeVIsZ0NBQWdDdCtCLGFBQWF3dkIsU0FBU3RMOzRCQUN0RDtvQkFDSjtnQkFDRjtZQUNGO1lBRUEsT0FBTztRQUNUO1FBRUEsU0FBU29hLGdDQUFnQ3QrQixXQUFXLEVBQUVrQyxJQUFJLEVBQUVsQixLQUFLO1lBRS9ELElBQUl1QixnQkFBZ0JMLEtBQUtrRCxXQUFXO1lBQ3BDLElBQUltNUI7WUFFSixPQUFRLE9BQU92OUI7Z0JBQ2IsS0FBSztnQkFDTCxLQUFLO29CQUNIO1lBQ0o7WUFFQSxPQUFRa0I7Z0JBQ04saUJBQWlCO2dCQUNqQixLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7b0JBQ0gsVUFBVTtvQkFDVjtnQkFDRixvQkFBb0I7Z0JBRXBCLEtBQUs7b0JBQ0g7d0JBQ0VLLGdCQUFnQjt3QkFFaEI7NEJBQ0VELDZCQUE2QnRCLE9BQU91Qjt3QkFDdEM7d0JBRUFnOEIsaUJBQWlCLEtBQUt2OUI7d0JBQ3RCO29CQUNGO2dCQUNGLFdBQVc7Z0JBRVgsS0FBSztvQkFDSDt3QkFDRSxJQUFJQSxVQUFVLE9BQU87NEJBQ25CO3dCQUNGO3dCQUVBdTlCLGlCQUFpQjt3QkFDakI7b0JBQ0Y7Z0JBQ0YsZ0JBQWdCO2dCQUVoQixLQUFLO2dCQUNMLEtBQUs7b0JBQ0g7d0JBQ0V2OUIsUUFBUWtoQixZQUFZbGhCO3dCQUVwQjs0QkFDRXNCLDZCQUE2QnRCLE9BQU91Qjt3QkFDdEM7d0JBRUFnOEIsaUJBQWlCLEtBQUt2OUI7d0JBQ3RCO29CQUNGO2dCQUVGO29CQUNFO3dCQUNFLElBQ0EsK0NBQStDO3dCQUMvQ2tCLEtBQUs1RCxNQUFNLEdBQUcsS0FBTTRELENBQUFBLElBQUksQ0FBQyxFQUFFLEtBQUssT0FBT0EsSUFBSSxDQUFDLEVBQUUsS0FBSyxHQUFFLEtBQU9BLENBQUFBLElBQUksQ0FBQyxFQUFFLEtBQUssT0FBT0EsSUFBSSxDQUFDLEVBQUUsS0FBSyxHQUFFLEdBQUk7NEJBQy9GO3dCQUNGO3dCQUVBLElBQUksQ0FBQ2lCLG9CQUFvQmpCLE9BQU87NEJBQzlCO3dCQUNGO3dCQUVBOzRCQUNFSSw2QkFBNkJ0QixPQUFPdUI7d0JBQ3RDO3dCQUVBZzhCLGlCQUFpQixLQUFLdjlCO29CQUN4QjtZQUNKO1lBRUFmLFdBQVdELGFBQWErOUI7WUFDeEI5OUIsV0FBV0QsYUFBYU8sY0FBY2s3QixvQ0FBb0NsNUI7WUFDMUV0QyxXQUFXRCxhQUFhKzlCO1lBQ3hCOTlCLFdBQVdELGFBQWFPLGNBQWNrN0Isb0NBQW9DOEM7UUFDNUUsRUFBRSw0RUFBNEU7UUFDOUUscUVBQXFFO1FBQ3JFLE9BQU87UUFDUCwwRUFBMEU7UUFHMUUsU0FBU2pFLHFDQUFxQ3Q2QixXQUFXLEVBQUUyeUIsaUJBQWlCO1lBQzFFMXlCLFdBQVdELGFBQWE2OUI7WUFDeEIsSUFBSUksMEJBQTBCSjtZQUM5QmxMLGtCQUFrQjVFLE9BQU8sQ0FBQyxTQUFVclYsUUFBUTtnQkFDMUMsSUFBSUEsU0FBU3pXLElBQUksS0FBSztxQkFBZ0IsSUFBSXlXLFNBQVNvWixLQUFLLEdBQUdtSztxQkFBMEIsSUFBSXZqQixTQUFTb1osS0FBSyxHQUFHSSxTQUFTO29CQUNqSCw0RUFBNEU7b0JBQzVFLHVFQUF1RTtvQkFDdkUsdUNBQXVDO29CQUN2Q2p5QixXQUFXRCxhQUFhaStCO29CQUN4Qk8sMkNBQTJDeCtCLGFBQWEwWSxTQUFTblUsS0FBSyxDQUFDdUYsSUFBSTtvQkFDM0U3SixXQUFXRCxhQUFhZytCO29CQUN4QkMsMEJBQTBCSDtnQkFDNUIsT0FBTyxJQUFJcGxCLFNBQVN6VyxJQUFJLEtBQUssY0FBYztvQkFDekMsaUVBQWlFO29CQUNqRWhDLFdBQVdELGFBQWFpK0I7b0JBQ3hCUSxtQ0FBbUN6K0IsYUFBYTBZLFNBQVNuVSxLQUFLLENBQUN1RixJQUFJLEVBQUU0TyxTQUFTblUsS0FBSyxDQUFDLGtCQUFrQixFQUFFbVUsU0FBU25VLEtBQUs7b0JBQ3RIdEUsV0FBV0QsYUFBYWcrQjtvQkFDeEJDLDBCQUEwQkg7b0JBQzFCcGxCLFNBQVNvWixLQUFLLElBQUl3SztnQkFDcEI7WUFDRjtZQUNBcjhCLFdBQVdELGFBQWFnK0I7UUFDMUI7UUFDQSxvQkFBb0IsR0FHcEIsU0FBU1EsMkNBQTJDeCtCLFdBQVcsRUFBRThKLElBQUk7WUFDbkUsK0VBQStFO1lBQy9FLCtEQUErRDtZQUMvRDtnQkFDRXhILDZCQUE2QndILE1BQU07WUFDckM7WUFFQSxJQUFJczBCLGNBQWMsS0FBS3QwQjtZQUN2QjdKLFdBQVdELGFBQWFPLGNBQWNvaEIscUJBQXFCVSxLQUFLQyxTQUFTLENBQUM4YjtRQUM1RTtRQUVBLFNBQVNLLG1DQUFtQ3orQixXQUFXLEVBQUU4SixJQUFJLEVBQUU4bUIsVUFBVSxFQUFFcnNCLEtBQUs7WUFDOUUsK0RBQStEO1lBQy9ELElBQUk2NUIsY0FBY2xjLFlBQVksS0FBS3BZO1lBQ25DN0osV0FBV0QsYUFBYU8sY0FBY29oQixxQkFBcUJVLEtBQUtDLFNBQVMsQ0FBQzhiO1lBRTFFO2dCQUNFOTdCLDZCQUE2QnN1QixZQUFZO1lBQzNDO1lBRUEsSUFBSXlOLG9CQUFvQixLQUFLek47WUFDN0Izd0IsV0FBV0QsYUFBYSs5QjtZQUN4Qjk5QixXQUFXRCxhQUFhTyxjQUFjb2hCLHFCQUFxQlUsS0FBS0MsU0FBUyxDQUFDK2I7WUFFMUUsSUFBSyxJQUFJN08sV0FBV2pyQixNQUFPO2dCQUN6QixJQUFJM0IsZUFBZWpELElBQUksQ0FBQzRFLE9BQU9pckIsVUFBVTtvQkFDdkMsSUFBSXRMLFlBQVkzZixLQUFLLENBQUNpckIsUUFBUTtvQkFFOUIsSUFBSXRMLGFBQWEsTUFBTTt3QkFDckI7b0JBQ0Y7b0JBRUEsT0FBUXNMO3dCQUNOLEtBQUs7d0JBQ0wsS0FBSzt3QkFDTCxLQUFLO3dCQUNMLEtBQUs7NEJBQ0g7Z0NBQ0U7NEJBQ0Y7d0JBRUYsS0FBSzt3QkFDTCxLQUFLOzRCQUNILE1BQU0sSUFBSTNDLE1BQU0sU0FBUyxpRUFBaUU7d0JBRTVGOzRCQUNFNlIsa0NBQWtDMStCLGFBQWF3dkIsU0FBU3RMOzRCQUN4RDtvQkFDSjtnQkFDRjtZQUNGO1lBRUEsT0FBTztRQUNUO1FBRUEsU0FBU3dhLGtDQUFrQzErQixXQUFXLEVBQUVrQyxJQUFJLEVBQUVsQixLQUFLO1lBRWpFLElBQUl1QixnQkFBZ0JMLEtBQUtrRCxXQUFXO1lBQ3BDLElBQUltNUI7WUFFSixPQUFRLE9BQU92OUI7Z0JBQ2IsS0FBSztnQkFDTCxLQUFLO29CQUNIO1lBQ0o7WUFFQSxPQUFRa0I7Z0JBQ04saUJBQWlCO2dCQUNqQixLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7b0JBQ0gsVUFBVTtvQkFDVjtnQkFDRixvQkFBb0I7Z0JBRXBCLEtBQUs7b0JBQ0g7d0JBQ0VLLGdCQUFnQjt3QkFFaEI7NEJBQ0VELDZCQUE2QnRCLE9BQU91Qjt3QkFDdEM7d0JBRUFnOEIsaUJBQWlCLEtBQUt2OUI7d0JBQ3RCO29CQUNGO2dCQUNGLFdBQVc7Z0JBRVgsS0FBSztvQkFDSDt3QkFDRSxJQUFJQSxVQUFVLE9BQU87NEJBQ25CO3dCQUNGO3dCQUVBdTlCLGlCQUFpQjt3QkFDakI7b0JBQ0Y7Z0JBQ0YsZ0JBQWdCO2dCQUVoQixLQUFLO2dCQUNMLEtBQUs7b0JBQ0g7d0JBQ0V2OUIsUUFBUWtoQixZQUFZbGhCO3dCQUVwQjs0QkFDRXNCLDZCQUE2QnRCLE9BQU91Qjt3QkFDdEM7d0JBRUFnOEIsaUJBQWlCLEtBQUt2OUI7d0JBQ3RCO29CQUNGO2dCQUVGO29CQUNFO3dCQUNFLElBQ0EsK0NBQStDO3dCQUMvQ2tCLEtBQUs1RCxNQUFNLEdBQUcsS0FBTTRELENBQUFBLElBQUksQ0FBQyxFQUFFLEtBQUssT0FBT0EsSUFBSSxDQUFDLEVBQUUsS0FBSyxHQUFFLEtBQU9BLENBQUFBLElBQUksQ0FBQyxFQUFFLEtBQUssT0FBT0EsSUFBSSxDQUFDLEVBQUUsS0FBSyxHQUFFLEdBQUk7NEJBQy9GO3dCQUNGO3dCQUVBLElBQUksQ0FBQ2lCLG9CQUFvQmpCLE9BQU87NEJBQzlCO3dCQUNGO3dCQUVBOzRCQUNFSSw2QkFBNkJ0QixPQUFPdUI7d0JBQ3RDO3dCQUVBZzhCLGlCQUFpQixLQUFLdjlCO29CQUN4QjtZQUNKO1lBRUFmLFdBQVdELGFBQWErOUI7WUFDeEI5OUIsV0FBV0QsYUFBYU8sY0FBY29oQixxQkFBcUJVLEtBQUtDLFNBQVMsQ0FBQy9mO1lBQzFFdEMsV0FBV0QsYUFBYSs5QjtZQUN4Qjk5QixXQUFXRCxhQUFhTyxjQUFjb2hCLHFCQUFxQlUsS0FBS0MsU0FBUyxDQUFDaWM7UUFDNUU7UUFDQTs7Q0FFQyxHQUdELElBQUl4TSxVQUVGLEdBQUcsMEVBQTBFO1FBRS9FLElBQUlrSyxvQkFFRjtRQUNGLElBQUlLLGNBRUY7UUFDRixJQUFJcEssVUFFRixHQUFHLHFFQUFxRTtRQUMxRSw4RUFBOEU7UUFFOUUsSUFBSUYsVUFFRixHQUFHLCtEQUErRDtRQUNwRSwyRUFBMkU7UUFFM0UsSUFBSUcsaUJBRUYsR0FBRyxrQkFBa0I7UUFDdkIsNENBQTRDO1FBQzVDLCtFQUErRTtRQUMvRSwyRkFBMkY7UUFDM0Ysa0ZBQWtGO1FBQ2xGLGtEQUFrRDtRQUVsRCxTQUFTd007WUFDUCxPQUFPO2dCQUNMLGFBQWE7Z0JBQ2I5TSxhQUFhLElBQUludUI7Z0JBQ2pCazdCLGdCQUFnQixJQUFJbDdCO2dCQUNwQnd0QixXQUFXLElBQUl4dEI7Z0JBQ2Y4d0IsWUFBWSxJQUFJOXdCO2dCQUNoQixtQkFBbUI7Z0JBQ25CKzVCLGFBQWEsSUFBSW42QjtnQkFDakJvNkIsY0FBYyxJQUFJcDZCO2dCQUNsQnF3QixtQkFBbUIsSUFBSXJ3QjtnQkFDdkIsZ0NBQWdDO2dCQUNoQ2d2QixhQUFhLElBQUk1dUI7Z0JBQ2pCZ3ZCLGtCQUFrQixJQUFJaHZCO2dCQUN0QjZrQixrQkFBa0IsSUFBSWpsQjtnQkFDdEJveEIsU0FBUyxJQUFJcHhCO2dCQUNic3dCLGNBQWMsSUFBSXR3QjtnQkFDbEIsd0RBQXdEO2dCQUN4RHF2QixtQkFBbUI7WUFDckI7UUFDRjtRQUNBLFNBQVNrTTtZQUNQLE9BQU8sSUFBSXY3QjtRQUNiO1FBQ0EsU0FBU3c3Qiw2Q0FBNkMxVyxTQUFTLEVBQUV1SyxpQkFBaUI7WUFDaEZ2SyxVQUFVdUssaUJBQWlCLEdBQUdBO1FBQ2hDO1FBRUEsU0FBUzdCLGVBQWVwcUIsRUFBRSxFQUFFb0QsSUFBSTtZQUM5QixPQUFPLE1BQU1wRCxLQUFLLE1BQU1vRDtRQUMxQjtRQUVBLFNBQVMwYyxZQUFZMWMsSUFBSSxFQUFFaTFCLE9BQU87WUFFaEMsSUFBSUMsVUFBVUM7WUFFZCxJQUFJLENBQUNELFNBQVM7Z0JBQ1osdUdBQXVHO2dCQUN2Ryx3R0FBd0c7Z0JBQ3hHLHlHQUF5RztnQkFDekcseUdBQXlHO2dCQUN6RyxzREFBc0Q7Z0JBQ3REO1lBQ0Y7WUFFQSxJQUFJNVcsWUFBWThXLGFBQWFGO1lBRTdCO2dCQUNFLElBQUksT0FBT2wxQixTQUFTLFlBQVksQ0FBQ0EsTUFBTTtvQkFDckNuTCxNQUFNLHFIQUFxSG1rQiw0Q0FBNENoWjtnQkFDekssT0FBTyxJQUFJaTFCLFdBQVcsTUFBTTtvQkFDMUIsSUFBSSxPQUFPQSxZQUFZLFlBQVlBLFFBQVFuOEIsY0FBYyxDQUFDLGdCQUFnQjt3QkFDeEVqRSxNQUFNLG9kQUFvZHFrQiwwQ0FBMEMrYjtvQkFDdGdCLE9BQU87d0JBQ0xwZ0MsTUFBTSx5UUFBeVFxa0IsMENBQTBDK2I7b0JBQzNUO2dCQUNGO1lBQ0Y7WUFFQSxJQUFJLE9BQU9qMUIsU0FBUyxZQUFZQSxNQUFNO2dCQUNwQyxJQUFJL0ksTUFBTSt2QixlQUFlLGVBQWVobkI7Z0JBQ3hDLElBQUk0TyxXQUFXMFAsVUFBVXdXLGNBQWMsQ0FBQ2g3QixHQUFHLENBQUM3QztnQkFFNUMsSUFBSSxDQUFDMlgsVUFBVTtvQkFDYkEsV0FBVzt3QkFDVHpXLE1BQU07d0JBQ044bUIsUUFBUSxFQUFFO3dCQUNWK0ksT0FBT0M7d0JBQ1B4dEIsT0FBTztvQkFDVDtvQkFDQTZqQixVQUFVd1csY0FBYyxDQUFDcFMsR0FBRyxDQUFDenJCLEtBQUsyWDtvQkFDbENtWSxhQUFhblksU0FBU3FRLE1BQU0sRUFBRTt3QkFDNUJqZixNQUFNQTt3QkFDTmtELEtBQUs7b0JBQ1A7Z0JBQ0Y7Z0JBRUFvYixVQUFVcVYsV0FBVyxDQUFDaEwsR0FBRyxDQUFDL1o7Z0JBQzFCeW1CLGVBQWVIO1lBQ2pCO1FBQ0Y7UUFDQSxTQUFTdlksV0FBVzNjLElBQUksRUFBRWkxQixPQUFPO1lBRS9CLElBQUlDLFVBQVVDO1lBRWQsSUFBSSxDQUFDRCxTQUFTO2dCQUNaLHVHQUF1RztnQkFDdkcsd0dBQXdHO2dCQUN4Ryx5R0FBeUc7Z0JBQ3pHLHlHQUF5RztnQkFDekcsc0RBQXNEO2dCQUN0RDtZQUNGO1lBRUEsSUFBSTVXLFlBQVk4VyxhQUFhRjtZQUU3QjtnQkFDRSxJQUFJLE9BQU9sMUIsU0FBUyxZQUFZLENBQUNBLE1BQU07b0JBQ3JDbkwsTUFBTSxvSEFBb0hta0IsNENBQTRDaFo7Z0JBQ3hLLE9BQU8sSUFBSWkxQixXQUFXLFFBQVEsT0FBT0EsWUFBWSxVQUFVO29CQUN6RHBnQyxNQUFNLCtMQUErTHFrQiwwQ0FBMEMrYjtnQkFDalAsT0FBTyxJQUFJQSxXQUFXLFFBQVEsT0FBT0EsUUFBUTdWLFdBQVcsS0FBSyxVQUFVO29CQUNyRXZxQixNQUFNLHFMQUFxTG1rQiw0Q0FBNENpYyxRQUFRN1YsV0FBVztnQkFDNVA7WUFDRjtZQUVBLElBQUksT0FBT3BmLFNBQVMsWUFBWUEsTUFBTTtnQkFDcEMsSUFBSW9mLGNBQWM2VixXQUFXLFFBQVEsT0FBT0EsUUFBUTdWLFdBQVcsS0FBSyxXQUFXLE9BQU82VixRQUFRN1YsV0FBVyxLQUFLLG9CQUFvQixvQkFBb0I7Z0JBQ3RKLElBQUlub0IsTUFBTSxrQkFBbUJtb0IsQ0FBQUEsZ0JBQWdCLE9BQU8sU0FBU0EsV0FBVSxJQUFLLE1BQU1wZjtnQkFDbEYsSUFBSTRPLFdBQVcwUCxVQUFVd1csY0FBYyxDQUFDaDdCLEdBQUcsQ0FBQzdDO2dCQUU1QyxJQUFJLENBQUMyWCxVQUFVO29CQUNiQSxXQUFXO3dCQUNUelcsTUFBTTt3QkFDTjhtQixRQUFRLEVBQUU7d0JBQ1YrSSxPQUFPQzt3QkFDUHh0QixPQUFPO29CQUNUO29CQUNBNmpCLFVBQVV3VyxjQUFjLENBQUNwUyxHQUFHLENBQUN6ckIsS0FBSzJYO29CQUNsQ21ZLGFBQWFuWSxTQUFTcVEsTUFBTSxFQUFFO3dCQUM1Qi9iLEtBQUs7d0JBQ0xsRCxNQUFNQTt3QkFDTm9mLGFBQWFBO29CQUNmO2dCQUNGO2dCQUVBZCxVQUFVcVYsV0FBVyxDQUFDaEwsR0FBRyxDQUFDL1o7Z0JBQzFCeW1CLGVBQWVIO1lBQ2pCO1FBQ0Y7UUFDQSxTQUFTcnlCLFFBQVE3QyxJQUFJLEVBQUVpMUIsT0FBTztZQUU1QixJQUFJQyxVQUFVQztZQUVkLElBQUksQ0FBQ0QsU0FBUztnQkFDWix1R0FBdUc7Z0JBQ3ZHLHdHQUF3RztnQkFDeEcseUdBQXlHO2dCQUN6Ryx5R0FBeUc7Z0JBQ3pHLHNEQUFzRDtnQkFDdEQ7WUFDRjtZQUVBLElBQUk1VyxZQUFZOFcsYUFBYUY7WUFFN0I7Z0JBQ0UsSUFBSUksY0FBYztnQkFFbEIsSUFBSSxPQUFPdDFCLFNBQVMsWUFBWSxDQUFDQSxNQUFNO29CQUNyQ3MxQixlQUFlLDBDQUEwQ3RjLDRDQUE0Q2haLFFBQVE7Z0JBQy9HO2dCQUVBLElBQUlpMUIsV0FBVyxRQUFRLE9BQU9BLFlBQVksVUFBVTtvQkFDbERLLGVBQWUsNkNBQTZDdGMsNENBQTRDaWMsV0FBVztnQkFDckgsT0FBTyxJQUFJLE9BQU9BLFFBQVFyNEIsRUFBRSxLQUFLLFlBQVksQ0FBQ3E0QixRQUFRcjRCLEVBQUUsRUFBRTtvQkFDeEQwNEIsZUFBZSxzQ0FBc0N0Yyw0Q0FBNENpYyxRQUFRcjRCLEVBQUUsSUFBSTtnQkFDakg7Z0JBRUEsSUFBSTA0QixhQUFhO29CQUNmemdDLE1BQU0sNEtBQTRLeWdDO2dCQUNwTDtZQUNGO1lBRUEsSUFBSSxPQUFPdDFCLFNBQVMsWUFBWUEsUUFBUSxPQUFPaTFCLFlBQVksWUFBWUEsWUFBWSxRQUFRLE9BQU9BLFFBQVFyNEIsRUFBRSxLQUFLLFlBQVlxNEIsUUFBUXI0QixFQUFFLEVBQUU7Z0JBQ3ZJLElBQUlBLEtBQUtxNEIsUUFBUXI0QixFQUFFO2dCQUNuQixJQUFJM0Y7Z0JBRUosSUFBSTJGLE9BQU8sU0FBUztvQkFDbEIsOEZBQThGO29CQUM5RiwyRkFBMkY7b0JBQzNGLGlGQUFpRjtvQkFDakYsSUFBSXlzQixjQUFjNEwsUUFBUTVMLFdBQVcsRUFDakNDLGFBQWEyTCxRQUFRM0wsVUFBVTtvQkFDbkNyeUIsTUFBTW15QixtQkFBbUJwcEIsTUFBTXFwQixhQUFhQztnQkFDOUMsT0FBTztvQkFDTHJ5QixNQUFNK3ZCLGVBQWVwcUIsSUFBSW9EO2dCQUMzQjtnQkFFQSxJQUFJNE8sV0FBVzBQLFVBQVV5SixXQUFXLENBQUNqdUIsR0FBRyxDQUFDN0M7Z0JBRXpDO29CQUNFLElBQUlvd0IsY0FBY0MsaUJBQWlCMVk7b0JBRW5DLElBQUl5WSxhQUFhO3dCQUNmLE9BQVFBLFlBQVlFLFlBQVk7NEJBQzlCLEtBQUs7Z0NBQ0g7b0NBQ0UsSUFBSUMsd0JBQXdCbk0sK0JBQStCNFosU0FBUzVOLFlBQVlrTyxpQkFBaUI7b0NBRWpHLElBQUkvTix1QkFBdUI7d0NBQ3pCM3lCLE1BQU0sdUhBQXVILDRLQUE0SyxnSkFBZ0ptTCxNQUFNcEQsSUFBSTRxQjtvQ0FDcmM7b0NBRUE7Z0NBQ0Y7NEJBRUYsS0FBSztnQ0FDSDtvQ0FDRSxJQUFJZ08sMEJBQTBCOVosaURBQWlEdVosU0FBUzVOLFlBQVlvTyxjQUFjO29DQUVsSCxJQUFJRCx5QkFBeUI7d0NBQzNCLElBQUlFLHFCQUFxQjk0QixPQUFPLFVBQVUsa0NBQWtDQSxPQUFPLFdBQVcsbUJBQW1CO3dDQUVqSCxJQUFJODRCLG9CQUFvQjs0Q0FDdEI3Z0MsTUFBTSw2SEFBNkgsc0lBQXNJLCtJQUErSSwySEFBMkgsdUlBQXVJLGdIQUFnSCwrQ0FBK0NtTCxNQUFNMDFCLG9CQUFvQkEsb0JBQW9CRjt3Q0FDejJCO29DQUNGO29DQUVBO2dDQUNGO3dCQUNKO29CQUNGO2dCQUNGO2dCQUVBLElBQUksQ0FBQzVtQixVQUFVO29CQUNiQSxXQUFXO3dCQUNUelcsTUFBTTt3QkFDTjhtQixRQUFRLEVBQUU7d0JBQ1YrSSxPQUFPQzt3QkFDUHh0QixPQUFPazdCLCtCQUErQjMxQixNQUFNcEQsSUFBSXE0QjtvQkFDbEQ7b0JBQ0EzVyxVQUFVeUosV0FBVyxDQUFDckYsR0FBRyxDQUFDenJCLEtBQUsyWDtvQkFFL0I7d0JBQ0VnbkIsNEJBQTRCaG5CLFVBQVUsV0FBVzVPLE1BQU1pMUIsU0FBU3JtQixTQUFTblUsS0FBSztvQkFDaEY7b0JBRUFzc0IsYUFBYW5ZLFNBQVNxUSxNQUFNLEVBQUVyUSxTQUFTblUsS0FBSztnQkFDOUM7Z0JBRUEsSUFBSW1DLE9BQU8sUUFBUTtvQkFDakIwaEIsVUFBVXNWLFlBQVksQ0FBQ2pMLEdBQUcsQ0FBQy9aO2dCQUM3QixPQUFPLElBQUloUyxPQUFPLFdBQVdxNEIsUUFBUXRMLGFBQWEsS0FBSyxRQUFRO29CQUM3RHJMLFVBQVV1TCxpQkFBaUIsQ0FBQ2xCLEdBQUcsQ0FBQy9aO2dCQUNsQyxPQUFPO29CQUNMMFAsVUFBVXdMLFlBQVksQ0FBQ25CLEdBQUcsQ0FBQy9aO2dCQUM3QjtnQkFFQXltQixlQUFlSDtZQUNqQjtRQUNGO1FBRUEsU0FBU3RZLFFBQVE1YyxJQUFJLEVBQUVpMUIsT0FBTztZQUU1QixJQUFJQyxVQUFVQztZQUVkLElBQUksQ0FBQ0QsU0FBUztnQkFDWix1R0FBdUc7Z0JBQ3ZHLHdHQUF3RztnQkFDeEcseUdBQXlHO2dCQUN6Ryx5R0FBeUc7Z0JBQ3pHLHNEQUFzRDtnQkFDdEQ7WUFDRjtZQUVBLElBQUk1VyxZQUFZOFcsYUFBYUY7WUFFN0I7Z0JBQ0UsSUFBSSxPQUFPbDFCLFNBQVMsWUFBWSxDQUFDQSxNQUFNO29CQUNyQ25MLE1BQU0saUhBQWlIbWtCLDRDQUE0Q2haO2dCQUNySyxPQUFPLElBQUlpMUIsV0FBVyxRQUFRLE9BQU9BLFlBQVksVUFBVTtvQkFDekRwZ0MsTUFBTSx1TEFBdUxxa0IsMENBQTBDK2I7Z0JBQ3pPLE9BQU8sSUFBSUEsUUFBUXI0QixFQUFFLEtBQUssV0FBV3E0QixRQUFRcjRCLEVBQUUsS0FBSyxVQUFVO29CQUM1RC9ILE1BQU0sK09BQStPcWtCLDBDQUEwQytiLFFBQVFyNEIsRUFBRTtnQkFDM1M7WUFDRjtZQUVBLElBQUksT0FBT29ELFNBQVMsWUFBWUEsUUFBUSxPQUFPaTFCLFlBQVksWUFBWUEsWUFBWSxNQUFNO2dCQUN2RixJQUFJcjRCLEtBQUtxNEIsUUFBUXI0QixFQUFFO2dCQUVuQixPQUFRQTtvQkFDTixLQUFLO3dCQUNIOzRCQUNFLElBQUkzRixNQUFNK3ZCLGVBQWVwcUIsSUFBSW9EOzRCQUM3QixJQUFJNE8sV0FBVzBQLFVBQVU4SSxTQUFTLENBQUN0dEIsR0FBRyxDQUFDN0M7NEJBQ3ZDLElBQUk2dkIsYUFBYW1PLFFBQVFuTyxVQUFVLElBQUk7NEJBRXZDO2dDQUNFLElBQUlPLGNBQWNDLGlCQUFpQjFZO2dDQUVuQyxJQUFJeVksYUFBYTtvQ0FDZixJQUFJTyxnQkFBZ0JpTyxrQ0FBa0M3MUIsTUFBTThtQixZQUFZbU87b0NBRXhFLElBQUlhLGtCQUFrQmgrQixPQUFPLENBQUMsR0FBRzh2QixlQUFlN3dCLGdCQUFnQjt3Q0FDOUQrdkIsWUFBWW1PLFFBQVFuTyxVQUFVO29DQUNoQyxHQUFHLG1CQUFtQjtvQ0FFdEIsT0FBUU8sWUFBWUUsWUFBWTt3Q0FDOUIsS0FBSzs0Q0FDSDtnREFDRSxJQUFJQyx3QkFBd0I1TSw0Q0FDNUJrYixpQkFBaUJ6TyxZQUFZSSxlQUFlO2dEQUU1QyxJQUFJRCx1QkFBdUI7b0RBQ3pCM3lCLE1BQU0sK0tBQStLLCtLQUErSyxrSUFBa0kscUhBQXFILHNJQUFzSSw0Q0FBNENtTCxNQUFNcW5CLFlBQVlJLGVBQWUsQ0FBQ1gsVUFBVSxFQUFFOW1CLE1BQU13bkI7Z0RBQ24wQjtnREFFQTs0Q0FDRjt3Q0FFRixLQUFLOzRDQUNIO2dEQUNFLElBQUl1TywwQkFBMEIvYSwrQkFDOUI4YSxpQkFBaUJ6TyxZQUFZTSxpQkFBaUI7Z0RBRTlDLElBQUlvTyx5QkFBeUI7b0RBQzNCbGhDLE1BQU0sNElBQTRJLDhLQUE4SyxvSkFBb0ptTCxNQUFNQSxNQUFNKzFCO2dEQUNsZTtnREFFQTs0Q0FDRjtvQ0FDSjtnQ0FDRjs0QkFDRjs0QkFFQSxJQUFJLENBQUNubkIsVUFBVTtnQ0FDYixJQUFJb1osUUFBUUM7Z0NBQ1osSUFBSUgsa0JBQWtCeEosVUFBVXlKLFdBQVcsQ0FBQ2p1QixHQUFHLENBQUM3QztnQ0FFaEQsSUFBSTZ3QixtQkFBbUJBLGdCQUFnQkUsS0FBSyxHQUFHSSxTQUFTO29DQUN0REosUUFBUUs7Z0NBQ1Y7Z0NBRUF6WixXQUFXO29DQUNUelcsTUFBTTtvQ0FDTjhtQixRQUFRLEVBQUU7b0NBQ1YrSSxPQUFPQTtvQ0FDUHZ0QixPQUFPbzdCLGtDQUFrQzcxQixNQUFNOG1CLFlBQVltTztnQ0FDN0Q7Z0NBQ0EzVyxVQUFVOEksU0FBUyxDQUFDMUUsR0FBRyxDQUFDenJCLEtBQUsyWDtnQ0FFN0I7b0NBQ0VnbkIsNEJBQTRCaG5CLFVBQVUsV0FBVzVPLE1BQU1pMUIsU0FBU245QixPQUFPLENBQUMsR0FBRzhXLFNBQVNuVSxLQUFLLEVBQUUxRCxnQkFBZ0I7d0NBQ3pHK3ZCLFlBQVlBO29DQUNkLEdBQUcsbUJBQW1CclI7Z0NBQ3hCO2dDQUVBLElBQUk4UyxnQkFBZ0JqSyxVQUFVa0ssV0FBVyxDQUFDMXVCLEdBQUcsQ0FBQ2d0QjtnQ0FFOUMsSUFBSSxDQUFDeUIsZUFBZTtvQ0FDbEJBLGdCQUFnQixJQUFJL3VCO29DQUNwQjhrQixVQUFVa0ssV0FBVyxDQUFDOUYsR0FBRyxDQUFDb0UsWUFBWXlCO29DQUN0QyxJQUFJRSxxQkFBcUI7d0NBQ3ZCdHdCLE1BQU07d0NBQ044bUIsUUFBUSxFQUFFO3dDQUNWK0ksT0FBT0M7d0NBQ1B4dEIsT0FBTzs0Q0FDTHFzQixZQUFZQTs0Q0FDWjRCLE9BQU8sRUFBRTt3Q0FDWDtvQ0FDRjtvQ0FDQUgsY0FBY0ksR0FBRyxDQUFDRjtvQ0FFbEI7d0NBQ0UsSUFBSW5LLFVBQVVzSyxnQkFBZ0IsQ0FBQ2x2QixHQUFHLENBQUNvdEIsYUFBYTs0Q0FDOUNqeUIsTUFBTSxxSUFBcUlpeUI7d0NBQzdJO29DQUNGO29DQUVBeEksVUFBVXNLLGdCQUFnQixDQUFDbEcsR0FBRyxDQUFDb0UsWUFBWTJCO2dDQUM3QztnQ0FFQUYsY0FBY0ksR0FBRyxDQUFDL1o7Z0NBQ2xCeW1CLGVBQWVIOzRCQUNqQjs0QkFFQTt3QkFDRjtvQkFFRixLQUFLO3dCQUNIOzRCQUNFLElBQUkvd0IsTUFBTW5FOzRCQUVWLElBQUlyTCxPQUFPcXlCLGVBQWVwcUIsSUFBSXVIOzRCQUU5QixJQUFJNnhCLFlBQVkxWCxVQUFVb00sVUFBVSxDQUFDNXdCLEdBQUcsQ0FBQ25GOzRCQUV6QztnQ0FDRSxJQUFJc2hDLGVBQWUzTyxpQkFBaUIwTztnQ0FFcEMsSUFBSUMsY0FBYztvQ0FDaEIsSUFBSUMsbUJBQW1CQyw4QkFBOEJoeUIsS0FBSzh3QjtvQ0FFMUQsT0FBUWdCLGFBQWExTyxZQUFZO3dDQUMvQixLQUFLOzRDQUNIO2dEQUNFLElBQUk2TywwQkFBMEJoYSx3Q0FDOUI4WixrQkFBa0JELGFBQWF4TyxlQUFlO2dEQUU5QyxJQUFJMk8seUJBQXlCO29EQUMzQnZoQyxNQUFNLDRKQUE0SiwyS0FBMkssNktBQTZLLGdJQUFnSSw4SkFBOEptTCxNQUFNQSxNQUFNbzJCO2dEQUN0eUI7Z0RBRUE7NENBQ0Y7d0NBRUYsS0FBSzs0Q0FDSDtnREFDRSxJQUFJQywwQkFBMEJyYiwrQkFDOUJrYixrQkFBa0JELGFBQWF0TyxpQkFBaUI7Z0RBRWhELElBQUkwTyx5QkFBeUI7b0RBQzNCeGhDLE1BQU0sNklBQTZJLDBLQUEwSyxvSkFBb0ptTCxNQUFNQSxNQUFNcTJCO2dEQUMvZDtnREFFQTs0Q0FDRjtvQ0FDSjtnQ0FDRjs0QkFDRjs0QkFFQSxJQUFJLENBQUNMLFdBQVc7Z0NBQ2RBLFlBQVk7b0NBQ1Y3OUIsTUFBTTtvQ0FDTjhtQixRQUFRLEVBQUU7b0NBQ1YrSSxPQUFPQztvQ0FDUHh0QixPQUFPO2dDQUNUO2dDQUNBNmpCLFVBQVVvTSxVQUFVLENBQUNoSSxHQUFHLENBQUMvdEIsTUFBTXFoQztnQ0FFL0IsSUFBSU0saUJBQWlCSCw4QkFBOEJoeUIsS0FBSzh3QjtnQ0FFeEQ7b0NBQ0VXLDRCQUE0QkksV0FBVyxXQUFXaDJCLE1BQU1pMUIsU0FBU3FCO2dDQUNuRTtnQ0FFQWhZLFVBQVVzTSxPQUFPLENBQUNqQyxHQUFHLENBQUNxTjtnQ0FDdEI5VyxlQUFlOFcsVUFBVS9XLE1BQU0sRUFBRXFYO2dDQUNqQ2pCLGVBQWVIOzRCQUNqQjs0QkFFQTt3QkFDRjtnQkFDSjtZQUNGO1FBQ0YsRUFBRSw0RUFBNEU7UUFDOUUsZ0ZBQWdGO1FBQ2hGLCtFQUErRTtRQUMvRSxtQ0FBbUM7UUFHbkMsU0FBUzdWLHVCQUF1QmYsU0FBUyxFQUFFbmEsR0FBRyxFQUFFOUIsS0FBSyxFQUFFM0IsU0FBUyxFQUFFMGUsV0FBVztZQUMzRSxJQUFJbm9CLE1BQU0rdkIsZUFBZSxVQUFVN2lCO1lBRW5DO2dCQUNFLElBQUltYSxVQUFVeUosV0FBVyxDQUFDcnVCLEdBQUcsQ0FBQ3pDLE1BQU07b0JBQ2xDLDhHQUE4RztvQkFDOUcsK0dBQStHO29CQUMvRyxrRkFBa0Y7b0JBQ2xGcEMsTUFBTSxnSUFBZ0lzUDtnQkFDeEk7WUFDRjtZQUVBLElBQUkxSixRQUFRO2dCQUNWeUksS0FBSztnQkFDTGxELE1BQU1tRTtnQkFDTnZILElBQUk7Z0JBQ0orc0IsZUFBZTtnQkFDZnRuQixPQUFPQTtnQkFDUDNCLFdBQVdBO2dCQUNYMGUsYUFBYUE7WUFDZjtZQUNBLElBQUl4USxXQUFXO2dCQUNielcsTUFBTTtnQkFDTjhtQixRQUFRLEVBQUU7Z0JBQ1YrSSxPQUFPQztnQkFDUHh0QixPQUFPQTtZQUNUO1lBQ0E2akIsVUFBVXlKLFdBQVcsQ0FBQ3JGLEdBQUcsQ0FBQ3pyQixLQUFLMlg7WUFDL0IwUCxVQUFVRyxnQkFBZ0IsQ0FBQ2tLLEdBQUcsQ0FBQy9aO1lBQy9CbVksYUFBYW5ZLFNBQVNxUSxNQUFNLEVBQUV4a0I7UUFDaEMsRUFBRSw0RUFBNEU7UUFDOUUsZ0ZBQWdGO1FBQ2hGLCtFQUErRTtRQUMvRSxtQ0FBbUM7UUFHbkMsU0FBU2tsQix1QkFBdUJyQixTQUFTLEVBQUVuYSxHQUFHLEVBQUU5QixLQUFLLEVBQUUzQixTQUFTLEVBQUUwZSxXQUFXO1lBQzNFLElBQUlub0IsTUFBTSt2QixlQUFlLFVBQVU3aUI7WUFFbkM7Z0JBQ0UsSUFBSW1hLFVBQVV5SixXQUFXLENBQUNydUIsR0FBRyxDQUFDekMsTUFBTTtvQkFDbEMsOEdBQThHO29CQUM5RywrR0FBK0c7b0JBQy9HLGtGQUFrRjtvQkFDbEZwQyxNQUFNLGdJQUFnSXNQO2dCQUN4STtZQUNGO1lBRUEsSUFBSTFKLFFBQVE7Z0JBQ1Z5SSxLQUFLO2dCQUNMbEQsTUFBTW1FO2dCQUNOd2xCLGVBQWU7Z0JBQ2Z0bkIsT0FBT0E7Z0JBQ1AzQixXQUFXQTtnQkFDWDBlLGFBQWFBO1lBQ2Y7WUFDQSxJQUFJeFEsV0FBVztnQkFDYnpXLE1BQU07Z0JBQ044bUIsUUFBUSxFQUFFO2dCQUNWK0ksT0FBT0M7Z0JBQ1B4dEIsT0FBT0E7WUFDVDtZQUNBNmpCLFVBQVV5SixXQUFXLENBQUNyRixHQUFHLENBQUN6ckIsS0FBSzJYO1lBQy9CMFAsVUFBVUcsZ0JBQWdCLENBQUNrSyxHQUFHLENBQUMvWjtZQUMvQm1ZLGFBQWFuWSxTQUFTcVEsTUFBTSxFQUFFeGtCO1lBQzlCO1FBQ0Y7UUFFQSxTQUFTaTVCLHNCQUFzQnBWLFNBQVMsRUFBRW5hLEdBQUcsRUFBRThhLE1BQU07WUFDbkQsSUFBSWhvQixNQUFNK3ZCLGVBQWUsVUFBVTdpQjtZQUNuQyxJQUFJeUssV0FBVzBQLFVBQVVvTSxVQUFVLENBQUM1d0IsR0FBRyxDQUFDN0M7WUFFeEMsSUFBSSxDQUFDMlgsVUFBVTtnQkFDYkEsV0FBVztvQkFDVHpXLE1BQU07b0JBQ044bUIsUUFBUUE7b0JBQ1IrSSxPQUFPQztvQkFDUHh0QixPQUFPO2dCQUNUO2dCQUNBNmpCLFVBQVVvTSxVQUFVLENBQUNoSSxHQUFHLENBQUN6ckIsS0FBSzJYO2dCQUM5QjBQLFVBQVVzTSxPQUFPLENBQUNqQyxHQUFHLENBQUMvWjtZQUN4QjtZQUVBO1FBQ0Y7UUFFQSxTQUFTK21CLCtCQUErQjMxQixJQUFJLEVBQUVwRCxFQUFFLEVBQUVxNEIsT0FBTztZQUN2RCxPQUFPO2dCQUNML3hCLEtBQUs7Z0JBQ0x0RyxJQUFJQTtnQkFDSiwrRUFBK0U7Z0JBQy9FLHdGQUF3RjtnQkFDeEYsNkZBQTZGO2dCQUM3Rix5RkFBeUY7Z0JBQ3pGb0QsTUFBTXBELE9BQU8sV0FBV3E0QixRQUFRNUwsV0FBVyxHQUFHNVQsWUFBWXpWO2dCQUMxRG9mLGFBQWF4aUIsT0FBTyxTQUFTLEtBQUtxNEIsUUFBUTdWLFdBQVc7Z0JBQ3JEMWUsV0FBV3UwQixRQUFRdjBCLFNBQVM7Z0JBQzVCdkksTUFBTTg4QixRQUFROThCLElBQUk7Z0JBQ2xCa0ssT0FBTzR5QixRQUFRNXlCLEtBQUs7Z0JBQ3BCc25CLGVBQWVzTCxRQUFRdEwsYUFBYTtnQkFDcENOLGFBQWE0TCxRQUFRNUwsV0FBVztnQkFDaENDLFlBQVkyTCxRQUFRM0wsVUFBVTtnQkFDOUJNLGdCQUFnQnFMLFFBQVFyTCxjQUFjO1lBQ3hDO1FBQ0Y7UUFFQSxTQUFTeUosNkJBQTZCcnpCLElBQUksRUFBRXZGLEtBQUs7WUFDL0MsT0FBTztnQkFDTHlJLEtBQUs7Z0JBQ0x0RyxJQUFJO2dCQUNKb0QsTUFBTUE7Z0JBQ05vZixhQUFhM2tCLE1BQU0ya0IsV0FBVztnQkFDOUJ1SyxlQUFlbHZCLE1BQU1rdkIsYUFBYTtnQkFDbENqcEIsV0FBV2pHLE1BQU1pRyxTQUFTO2dCQUMxQm9CLE9BQU9ySCxNQUFNcUgsS0FBSztnQkFDbEJ5MEIsVUFBVTk3QixNQUFNODdCLFFBQVE7Z0JBQ3hCM00sZ0JBQWdCbnZCLE1BQU1tdkIsY0FBYztZQUN0QztRQUNGO1FBRUEsU0FBU2lNLGtDQUFrQzcxQixJQUFJLEVBQUU4bUIsVUFBVSxFQUFFbU8sT0FBTztZQUNsRSxPQUFPO2dCQUNML3hCLEtBQUs7Z0JBQ0xsRCxNQUFNQTtnQkFDTixtQkFBbUI4bUI7Z0JBQ25CMUgsYUFBYTZWLFFBQVE3VixXQUFXO2dCQUNoQzFlLFdBQVd1MEIsUUFBUXYwQixTQUFTO2dCQUM1QmlwQixlQUFlc0wsUUFBUXRMLGFBQWE7WUFDdEM7UUFDRjtRQUVBLFNBQVM5Qiw0QkFBNEIyTyxRQUFRO1lBQzNDLE9BQU8xK0IsT0FBTyxDQUFDLEdBQUcwK0IsVUFBVTtnQkFDMUIsbUJBQW1CQSxTQUFTMVAsVUFBVTtnQkFDdENBLFlBQVk7WUFDZDtRQUNGO1FBRUEsU0FBU3FCLG9DQUFvQ1AsYUFBYSxFQUFFd0wsWUFBWTtZQUN0RSxJQUFJeEwsY0FBY3hJLFdBQVcsSUFBSSxNQUFNd0ksY0FBY3hJLFdBQVcsR0FBR2dVLGFBQWFoVSxXQUFXO1lBQzNGLElBQUl3SSxjQUFjbG5CLFNBQVMsSUFBSSxNQUFNa25CLGNBQWNsbkIsU0FBUyxHQUFHMHlCLGFBQWExeUIsU0FBUztRQUN2RjtRQUVBLFNBQVN5MUIsOEJBQThCaHlCLEdBQUcsRUFBRTh3QixPQUFPO1lBQ2pELE9BQU87Z0JBQ0w5d0IsS0FBS0E7Z0JBQ0x0SCxPQUFPO2dCQUNQdWlCLGFBQWE2VixRQUFRN1YsV0FBVztnQkFDaEMxZSxXQUFXdTBCLFFBQVF2MEIsU0FBUztnQkFDNUIyQixPQUFPNHlCLFFBQVE1eUIsS0FBSztnQkFDcEJzbkIsZUFBZXNMLFFBQVF0TCxhQUFhO1lBQ3RDO1FBQ0Y7UUFFQSxTQUFTbUIsZ0NBQWdDbEQsYUFBYSxFQUFFd0wsWUFBWTtZQUNsRSxJQUFJeEwsY0FBY3hJLFdBQVcsSUFBSSxNQUFNd0ksY0FBY3hJLFdBQVcsR0FBR2dVLGFBQWFoVSxXQUFXO1lBQzNGLElBQUl3SSxjQUFjbG5CLFNBQVMsSUFBSSxNQUFNa25CLGNBQWNsbkIsU0FBUyxHQUFHMHlCLGFBQWExeUIsU0FBUztRQUN2RjtRQUVBLFNBQVMrMUIsbUJBQW1CN25CLFFBQVE7WUFDbEMsSUFBSSxDQUFDK1osR0FBRyxDQUFDL1o7UUFDWDtRQUVBLFNBQVM4bkIsZUFBZXBZLFNBQVMsRUFBRXFZLE1BQU07WUFDdkMsSUFBSUMsMkJBQTJCdFksVUFBVXVLLGlCQUFpQjtZQUUxRCxJQUFJK04sMEJBQTBCO2dCQUM1QkQsT0FBTzFTLE9BQU8sQ0FBQ3dTLG9CQUFvQkc7WUFDckM7UUFDRjtRQUVBLFNBQVN0TywwQkFBMEIxWixRQUFRLEVBQUVpb0IsYUFBYTtZQUN4RDtnQkFDRSxJQUFJeFAsY0FBY3pZO2dCQUVsQixJQUFJLE9BQU95WSxZQUFZRSxZQUFZLEtBQUssVUFBVTtvQkFDaEQxeUIsTUFBTTtnQkFDUjtnQkFFQXd5QixZQUFZRSxZQUFZLEdBQUc7Z0JBQzNCRixZQUFZSSxlQUFlLEdBQUdvUDtZQUNoQztRQUNGO1FBRUEsU0FBU2pCLDRCQUE0QmhuQixRQUFRLEVBQUVrb0IsVUFBVSxFQUFFQyxZQUFZLEVBQUVDLGVBQWUsRUFBRWxCLGVBQWU7WUFDdkc7Z0JBQ0UsSUFBSXpPLGNBQWN6WTtnQkFFbEIsSUFBSSxPQUFPeVksWUFBWUUsWUFBWSxLQUFLLFVBQVU7b0JBQ2hEMXlCLE1BQU07Z0JBQ1I7Z0JBRUF3eUIsWUFBWUUsWUFBWSxHQUFHdVA7Z0JBQzNCelAsWUFBWTRQLGNBQWMsR0FBR0Y7Z0JBQzdCMVAsWUFBWWtPLGlCQUFpQixHQUFHeUI7Z0JBQ2hDM1AsWUFBWU0saUJBQWlCLEdBQUdtTztZQUNsQztRQUNGO1FBRUEsU0FBU3hPLGlCQUFpQjFZLFFBQVE7WUFDaEM7Z0JBQ0UsSUFBSUEsVUFBVTtvQkFDWixJQUFJLE9BQU9BLFNBQVMyWSxZQUFZLEtBQUssVUFBVTt3QkFDN0MsT0FBTzNZO29CQUNUO29CQUVBL1osTUFBTTtnQkFDUjtnQkFFQSxPQUFPO1lBQ1Q7UUFDRjtRQUVBLFNBQVNxaUMsb0JBQW9CNVksU0FBUyxFQUFFNlksb0JBQW9CLEVBQUU1WSxnQkFBZ0IsRUFBRUkscUJBQXFCO1lBQ25HLElBQUlnRCxnQkFBZ0J0RCxzQkFBc0JDLFdBQVdDLGtCQUFrQjlJLFdBQVdBLFdBQVdBLFdBQVdBLFdBQVdrSjtZQUNuSCxPQUFPO2dCQUNMLDRDQUE0QztnQkFDNUNHLGlCQUFpQjZDLGNBQWM3QyxlQUFlO2dCQUM5Q2MsbUJBQW1CK0IsY0FBYy9CLGlCQUFpQjtnQkFDbERDLGVBQWU4QixjQUFjOUIsYUFBYTtnQkFDMUNDLGdCQUFnQjZCLGNBQWM3QixjQUFjO2dCQUM1Q2xCLFVBQVUrQyxjQUFjL0MsUUFBUTtnQkFDaENtQixnQkFBZ0I0QixjQUFjNUIsY0FBYztnQkFDNUNmLGlCQUFpQjJDLGNBQWMzQyxlQUFlO2dCQUM5Q3pCLG1CQUFtQm9FLGNBQWNwRSxpQkFBaUI7Z0JBQ2xEeUMsY0FBYzJCLGNBQWMzQixZQUFZO2dCQUN4Q2pCLHVCQUF1QjRDLGNBQWM1QyxxQkFBcUI7Z0JBQzFEa0IsWUFBWTBCLGNBQWMxQixVQUFVO2dCQUNwQ0MsWUFBWXlCLGNBQWN6QixVQUFVO2dCQUNwQ0MsU0FBU3dCLGNBQWN4QixPQUFPO2dCQUM5QkMsZUFBZXVCLGNBQWN2QixhQUFhO2dCQUMxQ0Msa0JBQWtCc0IsY0FBY3RCLGdCQUFnQjtnQkFDaERDLGVBQWVxQixjQUFjckIsYUFBYTtnQkFDMUNDLGlCQUFpQm9CLGNBQWNwQixlQUFlO2dCQUM5Q0MsZUFBZW1CLGNBQWNuQixhQUFhO2dCQUMxQyxpREFBaUQ7Z0JBQ2pEMlcsc0JBQXNCQTtZQUN4QjtRQUNGO1FBQ0EsU0FBU0M7WUFDUCxPQUFPO2dCQUNMalcsZUFBZVI7Z0JBQ2Ysa0ZBQWtGO2dCQUNsRlMsZUFBZTtnQkFDZkMsb0JBQW9CO1lBQ3RCO1FBQ0Y7UUFDQSxTQUFTZ1csaUJBQWlCenlCLE1BQU0sRUFBRWtULElBQUksRUFBRTZKLGFBQWEsRUFBRVMsWUFBWTtZQUNqRSxJQUFJVCxjQUFjd1Ysb0JBQW9CLEVBQUU7Z0JBQ3RDdnlCLE9BQU90TyxJQUFJLENBQUNHLGNBQWNvaEIscUJBQXFCQztnQkFDL0MsT0FBTztZQUNULE9BQU87Z0JBQ0wsT0FBT3FLLG1CQUFtQnZkLFFBQVFrVCxNQUFNNkosZUFBZVM7WUFDekQ7UUFDRjtRQUNBLFNBQVNrVixrQkFBa0IxeUIsTUFBTSxFQUFFK2MsYUFBYSxFQUFFVyxjQUFjLEVBQUVGLFlBQVk7WUFDNUUsSUFBSVQsY0FBY3dWLG9CQUFvQixFQUFFO2dCQUN0QztZQUNGLE9BQU87Z0JBQ0wsT0FBTzlVLG9CQUFvQnpkLFFBQVErYyxlQUFlVyxnQkFBZ0JGO1lBQ3BFO1FBQ0Y7UUFDQSxTQUFTbVYsb0NBQW9DcmhDLFdBQVcsRUFBRXlyQixhQUFhO1lBQ3JFLElBQUlBLGNBQWN3VixvQkFBb0IsRUFBRTtnQkFDdEMsNkVBQTZFO2dCQUM3RSx5Q0FBeUM7Z0JBQ3pDLE9BQU87WUFDVDtZQUVBLE9BQU94SyxzQ0FBc0N6MkI7UUFDL0M7UUFDQSxTQUFTc2hDLHlDQUF5Q3RoQyxXQUFXLEVBQUV5ckIsYUFBYSxFQUM1RW1MLFdBQVcsRUFBRXVFLFlBQVksRUFBRXJFLG1CQUFtQjtZQUM1QyxJQUFJckwsY0FBY3dWLG9CQUFvQixFQUFFO2dCQUN0QyxtRkFBbUY7Z0JBQ25GLGdGQUFnRjtnQkFDaEYsT0FBTztZQUNUO1lBRUEsT0FBT3RLLDJDQUEyQzMyQixhQUFheXJCLGVBQWVtTCxhQUFhdUUsY0FBY3JFO1FBQzNHO1FBQ0EsU0FBU3lLLGtDQUFrQ3ZoQyxXQUFXLEVBQUV5ckIsYUFBYTtZQUNuRSxJQUFJQSxjQUFjd1Ysb0JBQW9CLEVBQUU7Z0JBQ3RDLE9BQU87WUFDVDtZQUVBLE9BQU9sSyxvQ0FBb0MvMkI7UUFDN0M7UUFDQSxTQUFTd2hDLHVDQUF1Q3hoQyxXQUFXLEVBQUV5ckIsYUFBYTtZQUN4RSxJQUFJQSxjQUFjd1Ysb0JBQW9CLEVBQUU7Z0JBQ3RDLE9BQU87WUFDVDtZQUVBLE9BQU9oSyx5Q0FBeUNqM0I7UUFDbEQ7UUFFQSxZQUFZO1FBQ1osd0NBQXdDO1FBQ3hDLGtGQUFrRjtRQUNsRixzREFBc0Q7UUFDdEQsSUFBSXloQyxxQkFBcUIxL0IsT0FBT29ILEdBQUcsQ0FBQztRQUNwQyxJQUFJdTRCLG9CQUFvQjMvQixPQUFPb0gsR0FBRyxDQUFDO1FBQ25DLElBQUl3NEIsc0JBQXNCNS9CLE9BQU9vSCxHQUFHLENBQUM7UUFDckMsSUFBSXk0Qix5QkFBeUI3L0IsT0FBT29ILEdBQUcsQ0FBQztRQUN4QyxJQUFJMDRCLHNCQUFzQjkvQixPQUFPb0gsR0FBRyxDQUFDO1FBQ3JDLElBQUkyNEIsc0JBQXNCLy9CLE9BQU9vSCxHQUFHLENBQUM7UUFDckMsSUFBSTQ0QixxQkFBcUJoZ0MsT0FBT29ILEdBQUcsQ0FBQztRQUNwQyxJQUFJNjRCLDRCQUE0QmpnQyxPQUFPb0gsR0FBRyxDQUFDO1FBQzNDLElBQUk4NEIseUJBQXlCbGdDLE9BQU9vSCxHQUFHLENBQUM7UUFDeEMsSUFBSSs0QixzQkFBc0JuZ0MsT0FBT29ILEdBQUcsQ0FBQztRQUNyQyxJQUFJZzVCLDJCQUEyQnBnQyxPQUFPb0gsR0FBRyxDQUFDO1FBQzFDLElBQUlpNUIsa0JBQWtCcmdDLE9BQU9vSCxHQUFHLENBQUM7UUFDakMsSUFBSWs1QixrQkFBa0J0Z0MsT0FBT29ILEdBQUcsQ0FBQztRQUNqQyxJQUFJbTVCLG1CQUFtQnZnQyxPQUFPb0gsR0FBRyxDQUFDO1FBQ2xDLElBQUlvNUIsZ0NBQWdDeGdDLE9BQU9vSCxHQUFHLENBQUM7UUFDL0MsSUFBSXE1Qix1QkFBdUJ6Z0MsT0FBT29ILEdBQUcsQ0FBQztRQUN0QyxJQUFJczVCLDJCQUEyQjFnQyxPQUFPb0gsR0FBRyxDQUFDO1FBQzFDLElBQUl1NUIsbUJBQW1CM2dDLE9BQU9vSCxHQUFHLENBQUM7UUFDbEMsSUFBSXc1QixnREFBZ0Q1Z0MsT0FBT29ILEdBQUcsQ0FBQztRQUMvRCxJQUFJeTVCLHdCQUF3QjdnQyxPQUFPOGdDLFFBQVE7UUFDM0MsSUFBSUMsdUJBQXVCO1FBQzNCLFNBQVNDLGNBQWNDLGFBQWE7WUFDbEMsSUFBSUEsa0JBQWtCLFFBQVEsT0FBT0Esa0JBQWtCLFVBQVU7Z0JBQy9ELE9BQU87WUFDVDtZQUVBLElBQUlDLGdCQUFnQkwseUJBQXlCSSxhQUFhLENBQUNKLHNCQUFzQixJQUFJSSxhQUFhLENBQUNGLHFCQUFxQjtZQUV4SCxJQUFJLE9BQU9HLGtCQUFrQixZQUFZO2dCQUN2QyxPQUFPQTtZQUNUO1lBRUEsT0FBTztRQUNUO1FBRUEsU0FBU0MsZUFBZUMsU0FBUyxFQUFFQyxTQUFTLEVBQUVDLFdBQVc7WUFDdkQsSUFBSUMsY0FBY0gsVUFBVUcsV0FBVztZQUV2QyxJQUFJQSxhQUFhO2dCQUNmLE9BQU9BO1lBQ1Q7WUFFQSxJQUFJQyxlQUFlSCxVQUFVRSxXQUFXLElBQUlGLFVBQVVsaEMsSUFBSSxJQUFJO1lBQzlELE9BQU9xaEMsaUJBQWlCLEtBQUtGLGNBQWMsTUFBTUUsZUFBZSxNQUFNRjtRQUN4RSxFQUFFLCtEQUErRDtRQUdqRSxTQUFTRyxlQUFldmhDLElBQUk7WUFDMUIsT0FBT0EsS0FBS3FoQyxXQUFXLElBQUk7UUFDN0IsRUFBRSx1R0FBdUc7UUFHekcsU0FBU0cseUJBQXlCeGhDLElBQUk7WUFDcEMsSUFBSUEsUUFBUSxNQUFNO2dCQUNoQiw2Q0FBNkM7Z0JBQzdDLE9BQU87WUFDVDtZQUVBO2dCQUNFLElBQUksT0FBT0EsS0FBSzR4QixHQUFHLEtBQUssVUFBVTtvQkFDaENsMUIsTUFBTSxrRUFBa0U7Z0JBQzFFO1lBQ0Y7WUFFQSxJQUFJLE9BQU9zRCxTQUFTLFlBQVk7Z0JBQzlCLE9BQU9BLEtBQUtxaEMsV0FBVyxJQUFJcmhDLEtBQUtDLElBQUksSUFBSTtZQUMxQztZQUVBLElBQUksT0FBT0QsU0FBUyxVQUFVO2dCQUM1QixPQUFPQTtZQUNUO1lBRUEsT0FBUUE7Z0JBQ04sS0FBSzAvQjtvQkFDSCxPQUFPO2dCQUVULEtBQUtEO29CQUNILE9BQU87Z0JBRVQsS0FBS0c7b0JBQ0gsT0FBTztnQkFFVCxLQUFLRDtvQkFDSCxPQUFPO2dCQUVULEtBQUtNO29CQUNILE9BQU87Z0JBRVQsS0FBS0M7b0JBQ0gsT0FBTztnQkFFVCxLQUFLTztvQkFDSDt3QkFDRSxPQUFPO29CQUNUO1lBRUo7WUFFQSxJQUFJLE9BQU96Z0MsU0FBUyxVQUFVO2dCQUM1QixPQUFRQSxLQUFLK3hCLFFBQVE7b0JBQ25CLEtBQUsrTjt3QkFDSCxJQUFJMkIsVUFBVXpoQzt3QkFDZCxPQUFPdWhDLGVBQWVFLFdBQVc7b0JBRW5DLEtBQUs1Qjt3QkFDSCxJQUFJNkIsV0FBVzFoQzt3QkFDZixPQUFPdWhDLGVBQWVHLFNBQVNDLFFBQVEsSUFBSTtvQkFFN0MsS0FBSzNCO3dCQUNILE9BQU9pQixlQUFlamhDLE1BQU1BLEtBQUs0aEMsTUFBTSxFQUFFO29CQUUzQyxLQUFLekI7d0JBQ0gsSUFBSTBCLFlBQVk3aEMsS0FBS3FoQyxXQUFXLElBQUk7d0JBRXBDLElBQUlRLGNBQWMsTUFBTTs0QkFDdEIsT0FBT0E7d0JBQ1Q7d0JBRUEsT0FBT0wseUJBQXlCeGhDLEtBQUtBLElBQUksS0FBSztvQkFFaEQsS0FBS29nQzt3QkFDSDs0QkFDRSxJQUFJMEIsZ0JBQWdCOWhDOzRCQUNwQixJQUFJK2hDLFVBQVVELGNBQWNFLFFBQVE7NEJBQ3BDLElBQUlDLE9BQU9ILGNBQWNJLEtBQUs7NEJBRTlCLElBQUk7Z0NBQ0YsT0FBT1YseUJBQXlCUyxLQUFLRjs0QkFDdkMsRUFBRSxPQUFPeG1CLEdBQUc7Z0NBQ1YsT0FBTzs0QkFDVDt3QkFDRjtvQkFFRixLQUFLd2tCO3dCQUNIOzRCQUNFLElBQUlvQyxXQUFXbmlDOzRCQUNmLE9BQU8sQ0FBQ21pQyxTQUFTZCxXQUFXLElBQUljLFNBQVNDLFdBQVcsSUFBSTt3QkFDMUQ7Z0JBRUo7WUFDRjtZQUVBLE9BQU87UUFDVDtRQUVBLHlFQUF5RTtRQUN6RSx1RUFBdUU7UUFDdkUsc0VBQXNFO1FBQ3RFLDBDQUEwQztRQUMxQyxJQUFJQyxnQkFBZ0I7UUFDcEIsSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBQ0osSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBQ0osSUFBSUM7UUFFSixTQUFTQyxlQUFlO1FBRXhCQSxZQUFZQyxrQkFBa0IsR0FBRztRQUNqQyxTQUFTQztZQUNQO2dCQUNFLElBQUlWLGtCQUFrQixHQUFHO29CQUN2Qix1REFBdUQsR0FDdkRDLFVBQVUza0MsUUFBUXFsQyxHQUFHO29CQUNyQlQsV0FBVzVrQyxRQUFRc2xDLElBQUk7b0JBQ3ZCVCxXQUFXN2tDLFFBQVExQixJQUFJO29CQUN2QndtQyxZQUFZOWtDLFFBQVFqQixLQUFLO29CQUN6QmdtQyxZQUFZL2tDLFFBQVF1bEMsS0FBSztvQkFDekJQLHFCQUFxQmhsQyxRQUFRd2xDLGNBQWM7b0JBQzNDUCxlQUFlamxDLFFBQVF5bEMsUUFBUSxFQUFFLGlEQUFpRDtvQkFFbEYsSUFBSTlnQyxRQUFRO3dCQUNWbkQsY0FBYzt3QkFDZEQsWUFBWTt3QkFDWkgsT0FBTzhqQzt3QkFDUHpqQyxVQUFVO29CQUNaLEdBQUcsNkRBQTZEO29CQUVoRUosT0FBT3FrQyxnQkFBZ0IsQ0FBQzFsQyxTQUFTO3dCQUMvQnNsQyxNQUFNM2dDO3dCQUNOMGdDLEtBQUsxZ0M7d0JBQ0xyRyxNQUFNcUc7d0JBQ041RixPQUFPNEY7d0JBQ1A0Z0MsT0FBTzVnQzt3QkFDUDZnQyxnQkFBZ0I3Z0M7d0JBQ2hCOGdDLFVBQVU5Z0M7b0JBQ1o7Z0JBQ0Esc0RBQXNELEdBQ3hEO2dCQUVBKy9CO1lBQ0Y7UUFDRjtRQUNBLFNBQVNpQjtZQUNQO2dCQUNFakI7Z0JBRUEsSUFBSUEsa0JBQWtCLEdBQUc7b0JBQ3ZCLHVEQUF1RCxHQUN2RCxJQUFJLy9CLFFBQVE7d0JBQ1ZuRCxjQUFjO3dCQUNkRCxZQUFZO3dCQUNaRSxVQUFVO29CQUNaLEdBQUcsNkRBQTZEO29CQUVoRUosT0FBT3FrQyxnQkFBZ0IsQ0FBQzFsQyxTQUFTO3dCQUMvQnFsQyxLQUFLcmpDLE9BQU8sQ0FBQyxHQUFHMkMsT0FBTzs0QkFDckJ2RCxPQUFPdWpDO3dCQUNUO3dCQUNBVyxNQUFNdGpDLE9BQU8sQ0FBQyxHQUFHMkMsT0FBTzs0QkFDdEJ2RCxPQUFPd2pDO3dCQUNUO3dCQUNBdG1DLE1BQU0wRCxPQUFPLENBQUMsR0FBRzJDLE9BQU87NEJBQ3RCdkQsT0FBT3lqQzt3QkFDVDt3QkFDQTlsQyxPQUFPaUQsT0FBTyxDQUFDLEdBQUcyQyxPQUFPOzRCQUN2QnZELE9BQU8wakM7d0JBQ1Q7d0JBQ0FTLE9BQU92akMsT0FBTyxDQUFDLEdBQUcyQyxPQUFPOzRCQUN2QnZELE9BQU8yakM7d0JBQ1Q7d0JBQ0FTLGdCQUFnQnhqQyxPQUFPLENBQUMsR0FBRzJDLE9BQU87NEJBQ2hDdkQsT0FBTzRqQzt3QkFDVDt3QkFDQVMsVUFBVXpqQyxPQUFPLENBQUMsR0FBRzJDLE9BQU87NEJBQzFCdkQsT0FBTzZqQzt3QkFDVDtvQkFDRjtnQkFDQSxzREFBc0QsR0FDeEQ7Z0JBRUEsSUFBSVAsZ0JBQWdCLEdBQUc7b0JBQ3JCM2xDLE1BQU0sb0NBQW9DO2dCQUM1QztZQUNGO1FBQ0Y7UUFFQSxJQUFJNm1DLDJCQUEyQnhuQyxxQkFBcUJ5bkMsc0JBQXNCO1FBQzFFLElBQUk3dEI7UUFDSixTQUFTOHRCLDhCQUE4QnhqQyxJQUFJLEVBQUV1K0IsTUFBTSxFQUFFa0YsT0FBTztZQUMxRDtnQkFDRSxJQUFJL3RCLFdBQVcySCxXQUFXO29CQUN4QixvREFBb0Q7b0JBQ3BELElBQUk7d0JBQ0YsTUFBTXNOO29CQUNSLEVBQUUsT0FBT3JQLEdBQUc7d0JBQ1YsSUFBSTRELFFBQVE1RCxFQUFFeGUsS0FBSyxDQUFDbXVCLElBQUksR0FBRy9MLEtBQUssQ0FBQzt3QkFDakN4SixTQUFTd0osU0FBU0EsS0FBSyxDQUFDLEVBQUUsSUFBSTtvQkFDaEM7Z0JBQ0YsRUFBRSwyRUFBMkU7Z0JBRzdFLE9BQU8sT0FBT3hKLFNBQVMxVjtZQUN6QjtRQUNGO1FBQ0EsSUFBSTBqQyxVQUFVO1FBQ2QsSUFBSUM7UUFFSjtZQUNFLElBQUlDLGtCQUFrQixPQUFPQyxZQUFZLGFBQWFBLFVBQVVyaUM7WUFDaEVtaUMsc0JBQXNCLElBQUlDO1FBQzVCO1FBRUEsU0FBU0UsNkJBQTZCQyxFQUFFLEVBQUVDLFNBQVM7WUFDakQsOEVBQThFO1lBQzlFLElBQUksQ0FBQ0QsTUFBTUwsU0FBUztnQkFDbEIsT0FBTztZQUNUO1lBRUE7Z0JBQ0UsSUFBSU8sUUFBUU4sb0JBQW9CamlDLEdBQUcsQ0FBQ3FpQztnQkFFcEMsSUFBSUUsVUFBVTVtQixXQUFXO29CQUN2QixPQUFPNG1CO2dCQUNUO1lBQ0Y7WUFFQSxJQUFJQztZQUNKUixVQUFVO1lBQ1YsSUFBSVMsNEJBQTRCeFosTUFBTXlaLGlCQUFpQixFQUFFLDBEQUEwRDtZQUVuSHpaLE1BQU15WixpQkFBaUIsR0FBRy9tQjtZQUMxQixJQUFJZ25CO1lBRUo7Z0JBQ0VBLHFCQUFxQmYseUJBQXlCNWUsT0FBTyxFQUFFLDhFQUE4RTtnQkFDckksZ0JBQWdCO2dCQUVoQjRlLHlCQUF5QjVlLE9BQU8sR0FBRztnQkFDbkNvZTtZQUNGO1lBRUEsSUFBSTtnQkFDRixxQkFBcUI7Z0JBQ3JCLElBQUlrQixXQUFXO29CQUNiLDREQUE0RDtvQkFDNUQsSUFBSU0sT0FBTzt3QkFDVCxNQUFNM1o7b0JBQ1IsR0FBRywyQkFBMkI7b0JBRzlCNXJCLE9BQU9DLGNBQWMsQ0FBQ3NsQyxLQUFLL21DLFNBQVMsRUFBRSxTQUFTO3dCQUM3QytzQixLQUFLOzRCQUNILG1FQUFtRTs0QkFDbkUsMERBQTBEOzRCQUMxRCxNQUFNSzt3QkFDUjtvQkFDRjtvQkFFQSxJQUFJLE9BQU80WixZQUFZLFlBQVlBLFFBQVFQLFNBQVMsRUFBRTt3QkFDcEQsc0VBQXNFO3dCQUN0RSxzQ0FBc0M7d0JBQ3RDLElBQUk7NEJBQ0ZPLFFBQVFQLFNBQVMsQ0FBQ00sTUFBTSxFQUFFO3dCQUM1QixFQUFFLE9BQU9ocEIsR0FBRzs0QkFDVjRvQixVQUFVNW9CO3dCQUNaO3dCQUVBaXBCLFFBQVFQLFNBQVMsQ0FBQ0QsSUFBSSxFQUFFLEVBQUVPO29CQUM1QixPQUFPO3dCQUNMLElBQUk7NEJBQ0ZBLEtBQUs3bUMsSUFBSTt3QkFDWCxFQUFFLE9BQU82ZCxHQUFHOzRCQUNWNG9CLFVBQVU1b0I7d0JBQ1osRUFBRSxxREFBcUQ7d0JBR3ZEeW9CLEdBQUd0bUMsSUFBSSxDQUFDNm1DLEtBQUsvbUMsU0FBUztvQkFDeEI7Z0JBQ0YsT0FBTztvQkFDTCxJQUFJO3dCQUNGLE1BQU1vdEI7b0JBQ1IsRUFBRSxPQUFPclAsR0FBRzt3QkFDVjRvQixVQUFVNW9CO29CQUNaLEVBQUUsdUVBQXVFO29CQUN6RSwyRUFBMkU7b0JBQzNFLDJCQUEyQjtvQkFHM0IsSUFBSWtwQixlQUFlVCxNQUFNLG9FQUFvRTtvQkFDN0Ysd0VBQXdFO29CQUN4RSxxQkFBcUI7b0JBQ3JCLGdFQUFnRTtvQkFFaEUsSUFBSVMsZ0JBQWdCLE9BQU9BLGFBQWFDLEtBQUssS0FBSyxZQUFZO3dCQUM1REQsYUFBYUMsS0FBSyxDQUFDLFlBQWE7b0JBQ2xDO2dCQUNGO1lBQ0YsRUFBRSxPQUFPQyxRQUFRO2dCQUNmLGlFQUFpRTtnQkFDakUsSUFBSUEsVUFBVVIsV0FBVyxPQUFPUSxPQUFPNW5DLEtBQUssS0FBSyxVQUFVO29CQUN6RCxnRkFBZ0Y7b0JBQ2hGLHFFQUFxRTtvQkFDckUsSUFBSTZuQyxjQUFjRCxPQUFPNW5DLEtBQUssQ0FBQzhuQyxLQUFLLENBQUM7b0JBQ3JDLElBQUlDLGVBQWVYLFFBQVFwbkMsS0FBSyxDQUFDOG5DLEtBQUssQ0FBQztvQkFDdkMsSUFBSTdlLElBQUk0ZSxZQUFZdm9DLE1BQU0sR0FBRztvQkFDN0IsSUFBSTBvQyxJQUFJRCxhQUFhem9DLE1BQU0sR0FBRztvQkFFOUIsTUFBTzJwQixLQUFLLEtBQUsrZSxLQUFLLEtBQUtILFdBQVcsQ0FBQzVlLEVBQUUsS0FBSzhlLFlBQVksQ0FBQ0MsRUFBRSxDQUFFO3dCQUM3RCxtREFBbUQ7d0JBQ25ELHlFQUF5RTt3QkFDekUsdUVBQXVFO3dCQUN2RSwwRUFBMEU7d0JBQzFFLDBFQUEwRTt3QkFDMUUsdUNBQXVDO3dCQUN2Q0E7b0JBQ0Y7b0JBRUEsTUFBTy9lLEtBQUssS0FBSytlLEtBQUssR0FBRy9lLEtBQUsrZSxJQUFLO3dCQUNqQyxxRUFBcUU7d0JBQ3JFLHlEQUF5RDt3QkFDekQsSUFBSUgsV0FBVyxDQUFDNWUsRUFBRSxLQUFLOGUsWUFBWSxDQUFDQyxFQUFFLEVBQUU7NEJBQ3RDLHVFQUF1RTs0QkFDdkUsK0VBQStFOzRCQUMvRSw2RUFBNkU7NEJBQzdFLGtGQUFrRjs0QkFDbEYsZ0ZBQWdGOzRCQUNoRixJQUFJL2UsTUFBTSxLQUFLK2UsTUFBTSxHQUFHO2dDQUN0QixHQUFHO29DQUNEL2U7b0NBQ0ErZSxLQUFLLHlFQUF5RTtvQ0FDOUUsK0RBQStEO29DQUUvRCxJQUFJQSxJQUFJLEtBQUtILFdBQVcsQ0FBQzVlLEVBQUUsS0FBSzhlLFlBQVksQ0FBQ0MsRUFBRSxFQUFFO3dDQUMvQyxrRkFBa0Y7d0NBQ2xGLElBQUlDLFNBQVMsT0FBT0osV0FBVyxDQUFDNWUsRUFBRSxDQUFDNUgsT0FBTyxDQUFDLFlBQVksU0FBUyxrREFBa0Q7d0NBQ2xILDRDQUE0Qzt3Q0FDNUMsZ0RBQWdEO3dDQUdoRCxJQUFJNGxCLEdBQUczQyxXQUFXLElBQUkyRCxPQUFPN2hCLFFBQVEsQ0FBQyxnQkFBZ0I7NENBQ3BENmhCLFNBQVNBLE9BQU81bUIsT0FBTyxDQUFDLGVBQWU0bEIsR0FBRzNDLFdBQVc7d0NBQ3ZEO3dDQUVBOzRDQUNFLElBQUksT0FBTzJDLE9BQU8sWUFBWTtnREFDNUJKLG9CQUFvQnJaLEdBQUcsQ0FBQ3laLElBQUlnQjs0Q0FDOUI7d0NBQ0Y7d0NBR0EsT0FBT0E7b0NBQ1Q7Z0NBQ0YsUUFBU2hmLEtBQUssS0FBSytlLEtBQUssR0FBRzs0QkFDN0I7NEJBRUE7d0JBQ0Y7b0JBQ0Y7Z0JBQ0Y7WUFDRixTQUFVO2dCQUNScEIsVUFBVTtnQkFFVjtvQkFDRUoseUJBQXlCNWUsT0FBTyxHQUFHMmY7b0JBQ25DaEI7Z0JBQ0Y7Z0JBRUExWSxNQUFNeVosaUJBQWlCLEdBQUdEO1lBQzVCLEVBQUUsZ0VBQWdFO1lBR2xFLElBQUlua0MsT0FBTytqQyxLQUFLQSxHQUFHM0MsV0FBVyxJQUFJMkMsR0FBRy9qQyxJQUFJLEdBQUc7WUFDNUMsSUFBSWdsQyxpQkFBaUJobEMsT0FBT3dqQyw4QkFBOEJ4akMsUUFBUTtZQUVsRTtnQkFDRSxJQUFJLE9BQU8rakMsT0FBTyxZQUFZO29CQUM1Qkosb0JBQW9CclosR0FBRyxDQUFDeVosSUFBSWlCO2dCQUM5QjtZQUNGO1lBRUEsT0FBT0E7UUFDVDtRQUVBLFNBQVNDLDRCQUE0QkMsSUFBSSxFQUFFM0csTUFBTSxFQUFFa0YsT0FBTztZQUN4RDtnQkFDRSxPQUFPSyw2QkFBNkJvQixNQUFNO1lBQzVDO1FBQ0Y7UUFDQSxTQUFTQywrQkFBK0JwQixFQUFFLEVBQUV4RixNQUFNLEVBQUVrRixPQUFPO1lBQ3pEO2dCQUNFLE9BQU9LLDZCQUE2QkMsSUFBSTtZQUMxQztRQUNGO1FBRUEsU0FBU3FCLGtCQUFrQkMsU0FBUztZQUNsQyxJQUFJOW5DLFlBQVk4bkMsVUFBVTluQyxTQUFTO1lBQ25DLE9BQU8sQ0FBQyxDQUFFQSxDQUFBQSxhQUFhQSxVQUFVK25DLGdCQUFnQjtRQUNuRDtRQUVBLFNBQVNDLHFDQUFxQ3hsQyxJQUFJLEVBQUV3K0IsTUFBTSxFQUFFa0YsT0FBTztZQUVqRSxJQUFJMWpDLFFBQVEsTUFBTTtnQkFDaEIsT0FBTztZQUNUO1lBRUEsSUFBSSxPQUFPQSxTQUFTLFlBQVk7Z0JBQzlCO29CQUNFLE9BQU8rakMsNkJBQTZCL2pDLE1BQU1xbEMsa0JBQWtCcmxDO2dCQUM5RDtZQUNGO1lBRUEsSUFBSSxPQUFPQSxTQUFTLFVBQVU7Z0JBQzVCLE9BQU95akMsOEJBQThCempDO1lBQ3ZDO1lBRUEsT0FBUUE7Z0JBQ04sS0FBS2lnQztvQkFDSCxPQUFPd0QsOEJBQThCO2dCQUV2QyxLQUFLdkQ7b0JBQ0gsT0FBT3VELDhCQUE4QjtZQUN6QztZQUVBLElBQUksT0FBT3pqQyxTQUFTLFVBQVU7Z0JBQzVCLE9BQVFBLEtBQUsreEIsUUFBUTtvQkFDbkIsS0FBS2lPO3dCQUNILE9BQU9vRiwrQkFBK0JwbEMsS0FBSzRoQyxNQUFNO29CQUVuRCxLQUFLekI7d0JBQ0gsb0VBQW9FO3dCQUNwRSxPQUFPcUYscUNBQXFDeGxDLEtBQUtBLElBQUksRUFBRXcrQixRQUFRa0Y7b0JBRWpFLEtBQUt0RDt3QkFDSDs0QkFDRSxJQUFJMEIsZ0JBQWdCOWhDOzRCQUNwQixJQUFJK2hDLFVBQVVELGNBQWNFLFFBQVE7NEJBQ3BDLElBQUlDLE9BQU9ILGNBQWNJLEtBQUs7NEJBRTlCLElBQUk7Z0NBQ0Ysb0VBQW9FO2dDQUNwRSxPQUFPc0QscUNBQXFDdkQsS0FBS0YsVUFBVXZELFFBQVFrRjs0QkFDckUsRUFBRSxPQUFPbm9CLEdBQUcsQ0FBQzt3QkFDZjtnQkFDSjtZQUNGO1lBRUEsT0FBTztRQUNUO1FBRUEsSUFBSWtxQixxQkFBcUIsQ0FBQztRQUMxQixJQUFJQywyQkFBMkIzcEMscUJBQXFCZSxzQkFBc0I7UUFFMUUsU0FBUzZvQyw4QkFBOEJDLE9BQU87WUFDNUM7Z0JBQ0UsSUFBSUEsU0FBUztvQkFDWCxJQUFJQyxRQUFRRCxRQUFRRSxNQUFNO29CQUMxQixJQUFJL29DLFFBQVF5b0MscUNBQXFDSSxRQUFRNWxDLElBQUksRUFBRTRsQyxRQUFRRyxPQUFPLEVBQUVGLFFBQVFBLE1BQU03bEMsSUFBSSxHQUFHO29CQUNyRzBsQyx5QkFBeUJNLGtCQUFrQixDQUFDanBDO2dCQUM5QyxPQUFPO29CQUNMMm9DLHlCQUF5Qk0sa0JBQWtCLENBQUM7Z0JBQzlDO1lBQ0Y7UUFDRjtRQUVBLFNBQVNDLGVBQWVDLFNBQVMsRUFBRTdyQixNQUFNLEVBQUU4ckIsUUFBUSxFQUFFQyxhQUFhLEVBQUVSLE9BQU87WUFDekU7Z0JBQ0Usc0VBQXNFO2dCQUN0RSxJQUFJcmtDLE1BQU1oRSxTQUFTRyxJQUFJLENBQUMyb0MsSUFBSSxDQUFDMWxDO2dCQUU3QixJQUFLLElBQUkybEMsZ0JBQWdCSixVQUFXO29CQUNsQyxJQUFJM2tDLElBQUkya0MsV0FBV0ksZUFBZTt3QkFDaEMsSUFBSUMsVUFBVSxLQUFLLEdBQUcsb0VBQW9FO3dCQUMxRixtRUFBbUU7d0JBQ25FLDBEQUEwRDt3QkFFMUQsSUFBSTs0QkFDRixxRUFBcUU7NEJBQ3JFLG1FQUFtRTs0QkFDbkUsSUFBSSxPQUFPTCxTQUFTLENBQUNJLGFBQWEsS0FBSyxZQUFZO2dDQUNqRCwyREFBMkQ7Z0NBQzNELElBQUlFLE1BQU01YixNQUFNLENBQUN3YixpQkFBaUIsYUFBWSxJQUFLLE9BQU9ELFdBQVcsWUFBWUcsZUFBZSxtQkFBbUIsaUZBQWlGLE9BQU9KLFNBQVMsQ0FBQ0ksYUFBYSxHQUFHLE9BQU87Z0NBQzVPRSxJQUFJdm1DLElBQUksR0FBRztnQ0FDWCxNQUFNdW1DOzRCQUNSOzRCQUVBRCxVQUFVTCxTQUFTLENBQUNJLGFBQWEsQ0FBQ2pzQixRQUFRaXNCLGNBQWNGLGVBQWVELFVBQVUsTUFBTTt3QkFDekYsRUFBRSxPQUFPTSxJQUFJOzRCQUNYRixVQUFVRTt3QkFDWjt3QkFFQSxJQUFJRixXQUFXLENBQUVBLENBQUFBLG1CQUFtQjNiLEtBQUksR0FBSTs0QkFDMUMrYSw4QkFBOEJDOzRCQUU5QmxwQyxNQUFNLGlDQUFpQyx3Q0FBd0Msa0VBQWtFLG9FQUFvRSxtRUFBbUUsbUNBQW1DMHBDLGlCQUFpQixlQUFlRCxVQUFVRyxjQUFjLE9BQU9DOzRCQUUxWFosOEJBQThCO3dCQUNoQzt3QkFFQSxJQUFJWSxtQkFBbUIzYixTQUFTLENBQUUyYixDQUFBQSxRQUFRRyxPQUFPLElBQUlqQixrQkFBaUIsR0FBSTs0QkFDeEUsd0VBQXdFOzRCQUN4RSxjQUFjOzRCQUNkQSxrQkFBa0IsQ0FBQ2MsUUFBUUcsT0FBTyxDQUFDLEdBQUc7NEJBQ3RDZiw4QkFBOEJDOzRCQUU5QmxwQyxNQUFNLHNCQUFzQnlwQyxVQUFVSSxRQUFRRyxPQUFPOzRCQUVyRGYsOEJBQThCO3dCQUNoQztvQkFDRjtnQkFDRjtZQUNGO1FBQ0Y7UUFFQSxJQUFJZ0I7UUFFSjtZQUNFQSxvQ0FBb0MsQ0FBQztRQUN2QztRQUVBLElBQUlDLHFCQUFxQixDQUFDO1FBRTFCO1lBQ0U1bkMsT0FBTzZuQyxNQUFNLENBQUNEO1FBQ2hCO1FBRUEsU0FBU0UsaUJBQWlCOW1DLElBQUksRUFBRSttQyxlQUFlO1lBQzdDO2dCQUNFLElBQUlDLGVBQWVobkMsS0FBS2duQyxZQUFZO2dCQUVwQyxJQUFJLENBQUNBLGNBQWM7b0JBQ2pCLE9BQU9KO2dCQUNUO2dCQUVBLElBQUluRixVQUFVLENBQUM7Z0JBRWYsSUFBSyxJQUFJM2lDLE9BQU9rb0MsYUFBYztvQkFDNUJ2RixPQUFPLENBQUMzaUMsSUFBSSxHQUFHaW9DLGVBQWUsQ0FBQ2pvQyxJQUFJO2dCQUNyQztnQkFFQTtvQkFDRSxJQUFJbUIsT0FBT3VoQyx5QkFBeUJ4aEMsU0FBUztvQkFDN0NpbUMsZUFBZWUsY0FBY3ZGLFNBQVMsV0FBV3hoQztnQkFDbkQ7Z0JBRUEsT0FBT3doQztZQUNUO1FBQ0Y7UUFDQSxTQUFTd0Ysb0JBQW9CQyxRQUFRLEVBQUVsbkMsSUFBSSxFQUFFb3BCLGFBQWEsRUFBRStkLGlCQUFpQjtZQUMzRTtnQkFDRSwwRUFBMEU7Z0JBQzFFLGtGQUFrRjtnQkFDbEYsSUFBSSxPQUFPRCxTQUFTRSxlQUFlLEtBQUssWUFBWTtvQkFDbEQ7d0JBQ0UsSUFBSWhCLGdCQUFnQjVFLHlCQUF5QnhoQyxTQUFTO3dCQUV0RCxJQUFJLENBQUMybUMsaUNBQWlDLENBQUNQLGNBQWMsRUFBRTs0QkFDckRPLGlDQUFpQyxDQUFDUCxjQUFjLEdBQUc7NEJBRW5EMXBDLE1BQU0sZ0ZBQWdGLDhFQUE4RSw4QkFBOEIwcEMsZUFBZUE7d0JBQ25OO29CQUNGO29CQUVBLE9BQU9oZDtnQkFDVDtnQkFFQSxJQUFJaWUsZUFBZUgsU0FBU0UsZUFBZTtnQkFFM0MsSUFBSyxJQUFJRSxjQUFjRCxhQUFjO29CQUNuQyxJQUFJLENBQUVDLENBQUFBLGNBQWNILGlCQUFnQixHQUFJO3dCQUN0QyxNQUFNLElBQUl2YyxNQUFNLENBQUM0Vyx5QkFBeUJ4aEMsU0FBUyxTQUFRLElBQUssOEJBQStCc25DLGFBQWE7b0JBQzlHO2dCQUNGO2dCQUVBO29CQUNFLElBQUlybkMsT0FBT3VoQyx5QkFBeUJ4aEMsU0FBUztvQkFDN0NpbUMsZUFBZWtCLG1CQUFtQkUsY0FBYyxpQkFBaUJwbkM7Z0JBQ25FO2dCQUVBLE9BQU9OLE9BQU8sQ0FBQyxHQUFHeXBCLGVBQWVpZTtZQUNuQztRQUNGO1FBRUEsSUFBSUU7UUFFSjtZQUNFLCtEQUErRDtZQUMvREEsZ0JBQWdCLENBQUM7UUFDbkI7UUFDQSwwQkFBMEI7UUFDMUIseUVBQXlFO1FBQ3pFLG1FQUFtRTtRQUduRSxJQUFJQyxzQkFBc0IsTUFBTSxzRkFBc0Y7UUFDdEgsdUZBQXVGO1FBQ3ZGLDJCQUEyQjtRQUUzQixJQUFJQyx3QkFBd0I7UUFFNUIsU0FBU0MsUUFBUUMsSUFBSTtZQUNuQjtnQkFDRUEsS0FBS2xHLE9BQU8sQ0FBQ21HLGNBQWMsR0FBR0QsS0FBS0UsV0FBVztZQUNoRDtRQUNGO1FBRUEsU0FBU0MsU0FBU0MsSUFBSTtZQUNwQjtnQkFDRUEsS0FBS3RHLE9BQU8sQ0FBQ21HLGNBQWMsR0FBR0csS0FBS2hwQyxLQUFLO1lBQzFDO1FBQ0Y7UUFFQSxTQUFTaXBDLDJCQUEyQkwsSUFBSSxFQUFFSSxJQUFJO1lBQzVDLElBQUlKLFNBQVNJO2lCQUFhO2dCQUN4QkwsUUFBUUM7Z0JBQ1IsSUFBSU0sYUFBYU4sS0FBS08sTUFBTTtnQkFDNUIsSUFBSUMsYUFBYUosS0FBS0csTUFBTTtnQkFFNUIsSUFBSUQsZUFBZSxNQUFNO29CQUN2QixJQUFJRSxlQUFlLE1BQU07d0JBQ3ZCLE1BQU0sSUFBSXZkLE1BQU07b0JBQ2xCO2dCQUNGLE9BQU87b0JBQ0wsSUFBSXVkLGVBQWUsTUFBTTt3QkFDdkIsTUFBTSxJQUFJdmQsTUFBTTtvQkFDbEI7b0JBRUFvZCwyQkFBMkJDLFlBQVlFO2dCQUN6QyxFQUFFLDZEQUE2RDtnQkFHL0RMLFNBQVNDO1lBQ1g7UUFDRjtRQUVBLFNBQVNLLGVBQWVULElBQUk7WUFDMUJELFFBQVFDO1lBQ1IsSUFBSU0sYUFBYU4sS0FBS08sTUFBTTtZQUU1QixJQUFJRCxlQUFlLE1BQU07Z0JBQ3ZCRyxlQUFlSDtZQUNqQjtRQUNGO1FBRUEsU0FBU0ksWUFBWU4sSUFBSTtZQUN2QixJQUFJSSxhQUFhSixLQUFLRyxNQUFNO1lBRTVCLElBQUlDLGVBQWUsTUFBTTtnQkFDdkJFLFlBQVlGO1lBQ2Q7WUFFQUwsU0FBU0M7UUFDWDtRQUVBLFNBQVNPLHlCQUF5QlgsSUFBSSxFQUFFSSxJQUFJO1lBQzFDTCxRQUFRQztZQUNSLElBQUlNLGFBQWFOLEtBQUtPLE1BQU07WUFFNUIsSUFBSUQsZUFBZSxNQUFNO2dCQUN2QixNQUFNLElBQUlyZCxNQUFNO1lBQ2xCO1lBRUEsSUFBSXFkLFdBQVdNLEtBQUssS0FBS1IsS0FBS1EsS0FBSyxFQUFFO2dCQUNuQyx1RUFBdUU7Z0JBQ3ZFUCwyQkFBMkJDLFlBQVlGO1lBQ3pDLE9BQU87Z0JBQ0wsMkJBQTJCO2dCQUMzQk8seUJBQXlCTCxZQUFZRjtZQUN2QztRQUNGO1FBRUEsU0FBU1MscUJBQXFCYixJQUFJLEVBQUVJLElBQUk7WUFDdEMsSUFBSUksYUFBYUosS0FBS0csTUFBTTtZQUU1QixJQUFJQyxlQUFlLE1BQU07Z0JBQ3ZCLE1BQU0sSUFBSXZkLE1BQU07WUFDbEI7WUFFQSxJQUFJK2MsS0FBS1ksS0FBSyxLQUFLSixXQUFXSSxLQUFLLEVBQUU7Z0JBQ25DLHVFQUF1RTtnQkFDdkVQLDJCQUEyQkwsTUFBTVE7WUFDbkMsT0FBTztnQkFDTCwyQkFBMkI7Z0JBQzNCSyxxQkFBcUJiLE1BQU1RO1lBQzdCO1lBRUFMLFNBQVNDO1FBQ1gsRUFBRSxpREFBaUQ7UUFDbkQsOEZBQThGO1FBQzlGLGlHQUFpRztRQUNqRywrRUFBK0U7UUFHL0UsU0FBU1UsY0FBY0MsV0FBVztZQUNoQyxpR0FBaUc7WUFDakcsNEZBQTRGO1lBQzVGLDJGQUEyRjtZQUMzRiw4RkFBOEY7WUFDOUYsbURBQW1EO1lBQ25ELHVGQUF1RjtZQUN2Rix5RkFBeUY7WUFDekYsZ0VBQWdFO1lBQ2hFLElBQUlmLE9BQU9GO1lBQ1gsSUFBSU0sT0FBT1c7WUFFWCxJQUFJZixTQUFTSSxNQUFNO2dCQUNqQixJQUFJSixTQUFTLE1BQU07b0JBQ2pCLHVGQUF1RjtvQkFDdkZVLFlBQVlOO2dCQUNkLE9BQU8sSUFBSUEsU0FBUyxNQUFNO29CQUN4QkssZUFBZVQ7Z0JBQ2pCLE9BQU8sSUFBSUEsS0FBS1ksS0FBSyxLQUFLUixLQUFLUSxLQUFLLEVBQUU7b0JBQ3BDUCwyQkFBMkJMLE1BQU1JO2dCQUNuQyxPQUFPLElBQUlKLEtBQUtZLEtBQUssR0FBR1IsS0FBS1EsS0FBSyxFQUFFO29CQUNsQ0QseUJBQXlCWCxNQUFNSTtnQkFDakMsT0FBTztvQkFDTFMscUJBQXFCYixNQUFNSTtnQkFDN0I7Z0JBRUFOLHdCQUF3Qk07WUFDMUI7UUFDRjtRQUNBLFNBQVNZLGFBQWFsSCxPQUFPLEVBQUVtSCxTQUFTO1lBQ3RDLElBQUlDO1lBRUo7Z0JBQ0VBLFlBQVlwSCxRQUFRbUcsY0FBYztnQkFDbENuRyxRQUFRbUcsY0FBYyxHQUFHZ0I7Z0JBRXpCO29CQUNFLElBQUluSCxRQUFRcUgsaUJBQWlCLEtBQUt4ckIsYUFBYW1rQixRQUFRcUgsaUJBQWlCLEtBQUssUUFBUXJILFFBQVFxSCxpQkFBaUIsS0FBS3ZCLGVBQWU7d0JBQ2hJN3FDLE1BQU0sNERBQTREO29CQUNwRTtvQkFFQStrQyxRQUFRcUgsaUJBQWlCLEdBQUd2QjtnQkFDOUI7WUFDRjtZQUVBLElBQUl3QixXQUFXdEI7WUFDZixJQUFJdUIsVUFBVTtnQkFDWmQsUUFBUWE7Z0JBQ1JSLE9BQU9RLGFBQWEsT0FBTyxJQUFJQSxTQUFTUixLQUFLLEdBQUc7Z0JBQ2hEOUcsU0FBU0E7Z0JBQ1RvRyxhQUFhZ0I7Z0JBQ2I5cEMsT0FBTzZwQztZQUNUO1lBQ0FuQix3QkFBd0J1QjtZQUN4QixPQUFPQTtRQUNUO1FBQ0EsU0FBU0MsWUFBWXhILE9BQU87WUFDMUIsSUFBSXlILGVBQWV6QjtZQUVuQixJQUFJeUIsaUJBQWlCLE1BQU07Z0JBQ3pCLE1BQU0sSUFBSXRlLE1BQU07WUFDbEI7WUFFQTtnQkFDRSxJQUFJc2UsYUFBYXpILE9BQU8sS0FBS0EsU0FBUztvQkFDcEMva0MsTUFBTTtnQkFDUjtZQUNGO1lBRUE7Z0JBQ0UsSUFBSXlzQyxTQUFTRCxhQUFhckIsV0FBVztnQkFFckMsSUFBSXNCLFdBQVd6SSwrQ0FBK0M7b0JBQzVEd0ksYUFBYXpILE9BQU8sQ0FBQ21HLGNBQWMsR0FBR3NCLGFBQWF6SCxPQUFPLENBQUMySCxhQUFhO2dCQUMxRSxPQUFPO29CQUNMRixhQUFhekgsT0FBTyxDQUFDbUcsY0FBYyxHQUFHdUI7Z0JBQ3hDO2dCQUVBO29CQUNFLElBQUkxSCxRQUFRcUgsaUJBQWlCLEtBQUt4ckIsYUFBYW1rQixRQUFRcUgsaUJBQWlCLEtBQUssUUFBUXJILFFBQVFxSCxpQkFBaUIsS0FBS3ZCLGVBQWU7d0JBQ2hJN3FDLE1BQU0sNERBQTREO29CQUNwRTtvQkFFQStrQyxRQUFRcUgsaUJBQWlCLEdBQUd2QjtnQkFDOUI7WUFDRjtZQUVBLE9BQU9FLHdCQUF3QnlCLGFBQWFoQixNQUFNO1FBQ3BEO1FBQ0EsU0FBU21CO1lBQ1AsT0FBTzVCO1FBQ1Q7UUFDQSxTQUFTNkIsY0FBYzdILE9BQU87WUFDNUIsSUFBSTFpQyxRQUFRMGlDLFFBQVFtRyxjQUFjO1lBQ2xDLE9BQU83b0M7UUFDVDtRQUVBOzs7Ozs7OztDQVFDLEdBQ0QsU0FBUzRDLElBQUk3QyxHQUFHO1lBQ2QsT0FBT0EsSUFBSXlxQyxlQUFlO1FBQzVCO1FBQ0EsU0FBU2hmLElBQUl6ckIsR0FBRyxFQUFFQyxLQUFLO1lBQ3JCRCxJQUFJeXFDLGVBQWUsR0FBR3hxQztRQUN4QjtRQUVBLElBQUl5cUMscUNBQXFDLENBQUM7UUFDMUMsSUFBSUMsa0NBQWtDLENBQUM7UUFDdkMsSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBQ0osSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBQ0osSUFBSUM7UUFDSixJQUFJQztRQUVKO1lBQ0VQLGlDQUFpQyxJQUFJcm9DO1lBQ3JDc29DLHNEQUFzRCxJQUFJdG9DO1lBQzFEdW9DLDhDQUE4QyxJQUFJdm9DO1lBQ2xEeW9DLDRDQUE0QyxJQUFJem9DO1lBQ2hEd29DLG9DQUFvQyxJQUFJeG9DO1lBQ3hDMG9DLHlDQUF5QyxJQUFJMW9DO1lBQzdDMm9DLG9DQUFvQyxJQUFJM29DO1lBQ3hDNG9DLDJCQUEyQixJQUFJNW9DO1FBQ2pDO1FBRUEsU0FBUzZvQyxzQkFBc0Jyc0MsUUFBUSxFQUFFc3NDLFVBQVU7WUFDakQ7Z0JBQ0UsSUFBSXRzQyxhQUFhLFFBQVEsT0FBT0EsYUFBYSxZQUFZO29CQUN2RDtnQkFDRjtnQkFFQSxJQUFJaUIsTUFBTXFyQyxhQUFhLE1BQU10c0M7Z0JBRTdCLElBQUksQ0FBQ29zQyx5QkFBeUIxb0MsR0FBRyxDQUFDekMsTUFBTTtvQkFDdENtckMseUJBQXlCelosR0FBRyxDQUFDMXhCO29CQUU3QnBDLE1BQU0scUVBQXFFLG1DQUFtQ3l0QyxZQUFZdHNDO2dCQUM1SDtZQUNGO1FBQ0Y7UUFFQSxTQUFTdXNDLDRCQUE0QnBxQyxJQUFJLEVBQUVxcUMsWUFBWTtZQUNyRDtnQkFDRSxJQUFJQSxpQkFBaUIvc0IsV0FBVztvQkFDOUIsSUFBSThvQixnQkFBZ0I1RSx5QkFBeUJ4aEMsU0FBUztvQkFFdEQsSUFBSSxDQUFDNnBDLGtDQUFrQ3RvQyxHQUFHLENBQUM2a0MsZ0JBQWdCO3dCQUN6RHlELGtDQUFrQ3JaLEdBQUcsQ0FBQzRWO3dCQUV0QzFwQyxNQUFNLHFGQUFxRixnQ0FBZ0MwcEM7b0JBQzdIO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBLFNBQVNrRSxTQUFTQyxjQUFjLEVBQUVKLFVBQVU7WUFDMUM7Z0JBQ0UsSUFBSUssZUFBZUQsZUFBZTlxQyxXQUFXO2dCQUM3QyxJQUFJMm1DLGdCQUFnQm9FLGdCQUFnQmhKLHlCQUF5QmdKLGlCQUFpQjtnQkFDOUUsSUFBSUMsYUFBYXJFLGdCQUFnQixNQUFNK0Q7Z0JBRXZDLElBQUlYLGtDQUFrQyxDQUFDaUIsV0FBVyxFQUFFO29CQUNsRDtnQkFDRjtnQkFFQS90QyxNQUFNLG9EQUFvRCxvRkFBb0YsbUVBQW1FeXRDLFlBQVlBLFlBQVkvRDtnQkFFek9vRCxrQ0FBa0MsQ0FBQ2lCLFdBQVcsR0FBRztZQUNuRDtRQUNGO1FBRUEsSUFBSUMsd0JBQXdCO1lBQzFCQyxXQUFXLFNBQVVDLElBQUk7Z0JBQ3ZCLE9BQU87WUFDVDtZQUNBLGtDQUFrQztZQUNsQ0MsaUJBQWlCLFNBQVVELElBQUksRUFBRTdJLE9BQU8sRUFBRWxrQyxRQUFRO2dCQUNoRCxJQUFJaXRDLFlBQVlucEMsSUFBSWlwQztnQkFFcEIsSUFBSUUsVUFBVUMsS0FBSyxLQUFLLE1BQU07b0JBQzVCVCxTQUFTTSxNQUFNO2dCQUNqQixPQUFPO29CQUNMRSxVQUFVQyxLQUFLLENBQUM1c0MsSUFBSSxDQUFDNGpDO29CQUVyQjt3QkFDRSxJQUFJbGtDLGFBQWF5ZixhQUFhemYsYUFBYSxNQUFNOzRCQUMvQ3FzQyxzQkFBc0Jyc0MsVUFBVTt3QkFDbEM7b0JBQ0Y7Z0JBQ0Y7WUFDRjtZQUNBbXRDLHFCQUFxQixTQUFVSixJQUFJLEVBQUU3SSxPQUFPLEVBQUVsa0MsUUFBUTtnQkFDcEQsSUFBSWl0QyxZQUFZbnBDLElBQUlpcEM7Z0JBQ3BCRSxVQUFVMXNCLE9BQU8sR0FBRztnQkFDcEIwc0IsVUFBVUMsS0FBSyxHQUFHO29CQUFDaEo7aUJBQVE7Z0JBRTNCO29CQUNFLElBQUlsa0MsYUFBYXlmLGFBQWF6ZixhQUFhLE1BQU07d0JBQy9DcXNDLHNCQUFzQnJzQyxVQUFVO29CQUNsQztnQkFDRjtZQUNGO1lBQ0Esa0NBQWtDO1lBQ2xDb3RDLG9CQUFvQixTQUFVTCxJQUFJLEVBQUUvc0MsUUFBUTtnQkFDMUMsSUFBSWl0QyxZQUFZbnBDLElBQUlpcEM7Z0JBRXBCLElBQUlFLFVBQVVDLEtBQUssS0FBSyxNQUFNO29CQUM1QlQsU0FBU00sTUFBTTtnQkFDakIsT0FBTztvQkFDTDt3QkFDRSxJQUFJL3NDLGFBQWF5ZixhQUFhemYsYUFBYSxNQUFNOzRCQUMvQ3FzQyxzQkFBc0Jyc0MsVUFBVTt3QkFDbEM7b0JBQ0Y7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsU0FBU3F0QywyQkFBMkJoRSxRQUFRLEVBQUUvQixJQUFJLEVBQUVnRyx3QkFBd0IsRUFBRUMsU0FBUyxFQUFFQyxTQUFTO1lBQ2hHLElBQUloQixlQUFlYyx5QkFBeUJFLFdBQVdEO1lBRXZEO2dCQUNFaEIsNEJBQTRCakYsTUFBTWtGO1lBQ3BDO1lBR0EsSUFBSWlCLFdBQVdqQixpQkFBaUIsUUFBUUEsaUJBQWlCL3NCLFlBQVk4dEIsWUFBWXpyQyxPQUFPLENBQUMsR0FBR3lyQyxXQUFXZjtZQUN2RyxPQUFPaUI7UUFDVDtRQUVBLFNBQVNDLHVCQUF1QnBHLElBQUksRUFBRTdpQyxLQUFLLEVBQUVrcEMsbUJBQW1CO1lBQzlELElBQUkvSixVQUFVbUY7WUFDZCxJQUFJNkUsY0FBY3RHLEtBQUtzRyxXQUFXO1lBRWxDO2dCQUNFLElBQUksaUJBQWlCdEcsTUFBTTtvQkFDekIsSUFBSTFoQyxVQUNKZ29DLGdCQUFnQixRQUFRQSxnQkFBZ0JudUIsYUFBYW11QixZQUFZMVosUUFBUSxLQUFLK04sc0JBQXNCMkwsWUFBWTlKLFFBQVEsS0FBS3JrQixXQUFXLDJCQUEyQjtvQkFFbkssSUFBSSxDQUFDN1osV0FBVyxDQUFDdW1DLGtDQUFrQ3pvQyxHQUFHLENBQUM0akMsT0FBTzt3QkFDNUQ2RSxrQ0FBa0N4WixHQUFHLENBQUMyVTt3QkFDdEMsSUFBSXVHLFdBQVc7d0JBRWYsSUFBSUQsZ0JBQWdCbnVCLFdBQVc7NEJBQzdCb3VCLFdBQVcsdUNBQXVDLDZFQUE2RSwyREFBMkQ7d0JBQzVMLE9BQU8sSUFBSSxPQUFPRCxnQkFBZ0IsVUFBVTs0QkFDMUNDLFdBQVcsOEJBQThCLE9BQU9ELGNBQWM7d0JBQ2hFLE9BQU8sSUFBSUEsWUFBWTFaLFFBQVEsS0FBSzhOLHFCQUFxQjs0QkFDdkQ2TCxXQUFXO3dCQUNiLE9BQU8sSUFBSUQsWUFBWTlKLFFBQVEsS0FBS3JrQixXQUFXOzRCQUM3QyxxQkFBcUI7NEJBQ3JCb3VCLFdBQVc7d0JBQ2IsT0FBTzs0QkFDTEEsV0FBVyxpREFBaUQxc0MsT0FBT3FpQixJQUFJLENBQUNvcUIsYUFBYTduQyxJQUFJLENBQUMsUUFBUTt3QkFDcEc7d0JBRUFsSCxNQUFNLHdDQUF3Qyx1RkFBdUY4a0MseUJBQXlCMkQsU0FBUyxhQUFhdUc7b0JBQ3RMO2dCQUNGO1lBQ0Y7WUFFQSxJQUFJLE9BQU9ELGdCQUFnQixZQUFZQSxnQkFBZ0IsTUFBTTtnQkFDM0RoSyxVQUFVNkgsY0FBY21DO1lBQzFCLE9BQU87Z0JBQ0xoSyxVQUFVK0o7WUFDWjtZQUVBLElBQUl0RSxXQUFXLElBQUkvQixLQUFLN2lDLE9BQU9tL0I7WUFFL0I7Z0JBQ0UsSUFBSSxPQUFPMEQsS0FBS2dHLHdCQUF3QixLQUFLLGNBQWVqRSxDQUFBQSxTQUFTclgsS0FBSyxLQUFLLFFBQVFxWCxTQUFTclgsS0FBSyxLQUFLdlMsU0FBUSxHQUFJO29CQUNwSCxJQUFJOG9CLGdCQUFnQjVFLHlCQUF5QjJELFNBQVM7b0JBRXRELElBQUksQ0FBQ3VFLCtCQUErQm5vQyxHQUFHLENBQUM2a0MsZ0JBQWdCO3dCQUN0RHNELCtCQUErQmxaLEdBQUcsQ0FBQzRWO3dCQUVuQzFwQyxNQUFNLG1FQUFtRSx1RUFBdUUscUVBQXFFLG1GQUFtRjBwQyxlQUFlYyxTQUFTclgsS0FBSyxLQUFLLE9BQU8sU0FBUyxhQUFhdVc7b0JBQ3pXO2dCQUNGLEVBQUUsMEVBQTBFO2dCQUM1RSxtREFBbUQ7Z0JBQ25ELHNFQUFzRTtnQkFHdEUsSUFBSSxPQUFPakIsS0FBS2dHLHdCQUF3QixLQUFLLGNBQWMsT0FBT2pFLFNBQVN5RSx1QkFBdUIsS0FBSyxZQUFZO29CQUNqSCxJQUFJQyxxQkFBcUI7b0JBQ3pCLElBQUlDLDRCQUE0QjtvQkFDaEMsSUFBSUMsc0JBQXNCO29CQUUxQixJQUFJLE9BQU81RSxTQUFTNkUsa0JBQWtCLEtBQUssY0FBYzdFLFNBQVM2RSxrQkFBa0IsQ0FBQ0MsNEJBQTRCLEtBQUssTUFBTTt3QkFDMUhKLHFCQUFxQjtvQkFDdkIsT0FBTyxJQUFJLE9BQU8xRSxTQUFTK0UseUJBQXlCLEtBQUssWUFBWTt3QkFDbkVMLHFCQUFxQjtvQkFDdkI7b0JBRUEsSUFBSSxPQUFPMUUsU0FBU2dGLHlCQUF5QixLQUFLLGNBQWNoRixTQUFTZ0YseUJBQXlCLENBQUNGLDRCQUE0QixLQUFLLE1BQU07d0JBQ3hJSCw0QkFBNEI7b0JBQzlCLE9BQU8sSUFBSSxPQUFPM0UsU0FBU2lGLGdDQUFnQyxLQUFLLFlBQVk7d0JBQzFFTiw0QkFBNEI7b0JBQzlCO29CQUVBLElBQUksT0FBTzNFLFNBQVNrRixtQkFBbUIsS0FBSyxjQUFjbEYsU0FBU2tGLG1CQUFtQixDQUFDSiw0QkFBNEIsS0FBSyxNQUFNO3dCQUM1SEYsc0JBQXNCO29CQUN4QixPQUFPLElBQUksT0FBTzVFLFNBQVNtRiwwQkFBMEIsS0FBSyxZQUFZO3dCQUNwRVAsc0JBQXNCO29CQUN4QjtvQkFFQSxJQUFJRix1QkFBdUIsUUFBUUMsOEJBQThCLFFBQVFDLHdCQUF3QixNQUFNO3dCQUNyRyxJQUFJUSxpQkFBaUI5Syx5QkFBeUIyRCxTQUFTO3dCQUV2RCxJQUFJb0gsYUFBYSxPQUFPcEgsS0FBS2dHLHdCQUF3QixLQUFLLGFBQWEsK0JBQStCO3dCQUV0RyxJQUFJLENBQUN2Qiw0Q0FBNENyb0MsR0FBRyxDQUFDK3FDLGlCQUFpQjs0QkFDcEUxQyw0Q0FBNENwWixHQUFHLENBQUM4Yjs0QkFFaEQ1dkMsTUFBTSw2RkFBNkYsNEVBQTRFLGtGQUFrRix3REFBd0Q0dkMsZ0JBQWdCQyxZQUFZWCx1QkFBdUIsT0FBTyxTQUFTQSxxQkFBcUIsSUFBSUMsOEJBQThCLE9BQU8sU0FBU0EsNEJBQTRCLElBQUlDLHdCQUF3QixPQUFPLFNBQVNBLHNCQUFzQjt3QkFDbmlCO29CQUNGO2dCQUNGO1lBQ0Y7WUFFQSxPQUFPNUU7UUFDVDtRQUVBLFNBQVNzRixtQkFBbUJ0RixRQUFRLEVBQUUvQixJQUFJLEVBQUVsa0IsUUFBUTtZQUNsRDtnQkFDRSxJQUFJaGhCLE9BQU91aEMseUJBQXlCMkQsU0FBUztnQkFDN0MsSUFBSXNILGdCQUFnQnZGLFNBQVN0RixNQUFNO2dCQUVuQyxJQUFJLENBQUM2SyxlQUFlO29CQUNsQixJQUFJdEgsS0FBSzNuQyxTQUFTLElBQUksT0FBTzJuQyxLQUFLM25DLFNBQVMsQ0FBQ29rQyxNQUFNLEtBQUssWUFBWTt3QkFDakVsbEMsTUFBTSxpRUFBaUUseUVBQXlFdUQ7b0JBQ2xKLE9BQU87d0JBQ0x2RCxNQUFNLGlFQUFpRSx3REFBd0R1RDtvQkFDakk7Z0JBQ0Y7Z0JBRUEsSUFBSWluQyxTQUFTd0YsZUFBZSxJQUFJLENBQUN4RixTQUFTd0YsZUFBZSxDQUFDQyxvQkFBb0IsSUFBSSxDQUFDekYsU0FBU3JYLEtBQUssRUFBRTtvQkFDakduekIsTUFBTSxrRUFBa0UseUVBQXlFLG9EQUFvRHVEO2dCQUN2TTtnQkFFQSxJQUFJaW5DLFNBQVMwRixlQUFlLElBQUksQ0FBQzFGLFNBQVMwRixlQUFlLENBQUNELG9CQUFvQixFQUFFO29CQUM5RWp3QyxNQUFNLGtFQUFrRSx5RUFBeUUseURBQXlEdUQ7Z0JBQzVNO2dCQUVBLElBQUlpbkMsU0FBUzJGLFNBQVMsRUFBRTtvQkFDdEJud0MsTUFBTSx1RUFBdUUseUNBQXlDdUQ7Z0JBQ3hIO2dCQUVBLElBQUlpbkMsU0FBU3VFLFdBQVcsRUFBRTtvQkFDeEIvdUMsTUFBTSx5RUFBeUUsMkNBQTJDdUQ7Z0JBQzVIO2dCQUVBO29CQUNFLElBQUlpbkMsU0FBU0YsWUFBWSxFQUFFO3dCQUN6QnRxQyxNQUFNLDBFQUEwRSw0Q0FBNEN1RDtvQkFDOUg7b0JBRUEsSUFBSWtsQyxLQUFLc0csV0FBVyxJQUFJdEcsS0FBSzZCLFlBQVksSUFBSSxDQUFDK0MsdUNBQXVDeG9DLEdBQUcsQ0FBQzRqQyxPQUFPO3dCQUM5RjRFLHVDQUF1Q3ZaLEdBQUcsQ0FBQzJVO3dCQUUzQ3pvQyxNQUFNLHNFQUFzRSxxREFBcUR1RDtvQkFDbkk7Z0JBQ0Y7Z0JBRUEsSUFBSSxPQUFPaW5DLFNBQVM0RixxQkFBcUIsS0FBSyxZQUFZO29CQUN4RHB3QyxNQUFNLDRCQUE0QixvRUFBb0UsK0RBQStELCtCQUErQnVEO2dCQUN0TTtnQkFFQSxJQUFJa2xDLEtBQUszbkMsU0FBUyxJQUFJMm5DLEtBQUszbkMsU0FBUyxDQUFDdXZDLG9CQUFvQixJQUFJLE9BQU83RixTQUFTOEYscUJBQXFCLEtBQUssYUFBYTtvQkFDbEh0d0MsTUFBTSxxREFBcUQsa0ZBQWtGLG1FQUFtRThrQyx5QkFBeUIyRCxTQUFTO2dCQUNwUDtnQkFFQSxJQUFJLE9BQU8rQixTQUFTK0YsbUJBQW1CLEtBQUssWUFBWTtvQkFDdER2d0MsTUFBTSw0QkFBNEIsbUVBQW1FLHdDQUF3Q3VEO2dCQUMvSTtnQkFFQSxJQUFJLE9BQU9pbkMsU0FBU2dHLHdCQUF3QixLQUFLLFlBQVk7b0JBQzNEeHdDLE1BQU0sNEJBQTRCLHdFQUF3RSxxRUFBcUUsb0VBQW9FLDJGQUEyRnVEO2dCQUNoVjtnQkFFQSxJQUFJLE9BQU9pbkMsU0FBU2lHLHlCQUF5QixLQUFLLFlBQVk7b0JBQzVEendDLE1BQU0sNEJBQTRCLDBFQUEwRXVEO2dCQUM5RztnQkFFQSxJQUFJLE9BQU9pbkMsU0FBU2tHLGdDQUFnQyxLQUFLLFlBQVk7b0JBQ25FMXdDLE1BQU0sNEJBQTRCLHdGQUF3RnVEO2dCQUM1SDtnQkFFQSxJQUFJb3RDLGtCQUFrQm5HLFNBQVM1a0MsS0FBSyxLQUFLMmU7Z0JBRXpDLElBQUlpbUIsU0FBUzVrQyxLQUFLLEtBQUtnYixhQUFhK3ZCLGlCQUFpQjtvQkFDbkQzd0MsTUFBTSw4REFBOEQsbUVBQW1FdUQsTUFBTUE7Z0JBQy9JO2dCQUVBLElBQUlpbkMsU0FBU29HLFlBQVksRUFBRTtvQkFDekI1d0MsTUFBTSw2RkFBNkYsNkRBQTZEdUQsTUFBTUE7Z0JBQ3hLO2dCQUVBLElBQUksT0FBT2luQyxTQUFTeUUsdUJBQXVCLEtBQUssY0FBYyxPQUFPekUsU0FBU3FHLGtCQUFrQixLQUFLLGNBQWMsQ0FBQzVELG9EQUFvRHBvQyxHQUFHLENBQUM0akMsT0FBTztvQkFDakx3RSxvREFBb0RuWixHQUFHLENBQUMyVTtvQkFFeER6b0MsTUFBTSw2RUFBNkUsMERBQTBEOGtDLHlCQUF5QjJEO2dCQUN4SztnQkFFQSxJQUFJLE9BQU8rQixTQUFTaUUsd0JBQXdCLEtBQUssWUFBWTtvQkFDM0R6dUMsTUFBTSxxRUFBcUUsZ0VBQWdFdUQ7Z0JBQzdJO2dCQUVBLElBQUksT0FBT2luQyxTQUFTc0csd0JBQXdCLEtBQUssWUFBWTtvQkFDM0Q5d0MsTUFBTSxxRUFBcUUsZ0VBQWdFdUQ7Z0JBQzdJO2dCQUVBLElBQUksT0FBT2tsQyxLQUFLd0csdUJBQXVCLEtBQUssWUFBWTtvQkFDdERqdkMsTUFBTSxpRUFBaUUsbUVBQW1FdUQ7Z0JBQzVJO2dCQUVBLElBQUk0dkIsUUFBUXFYLFNBQVNyWCxLQUFLO2dCQUUxQixJQUFJQSxTQUFVLFFBQU9BLFVBQVUsWUFBWXRQLFFBQVFzUCxNQUFLLEdBQUk7b0JBQzFEbnpCLE1BQU0sOENBQThDdUQ7Z0JBQ3REO2dCQUVBLElBQUksT0FBT2luQyxTQUFTRSxlQUFlLEtBQUssY0FBYyxPQUFPakMsS0FBS2dDLGlCQUFpQixLQUFLLFVBQVU7b0JBQ2hHenFDLE1BQU0seUVBQXlFLDBCQUEwQnVEO2dCQUMzRztZQUNGO1FBQ0Y7UUFFQSxTQUFTd3RDLHVCQUF1Qnp0QyxJQUFJLEVBQUVrbkMsUUFBUTtZQUM1QyxJQUFJd0csV0FBV3hHLFNBQVNyWCxLQUFLO1lBRTdCLElBQUksT0FBT3FYLFNBQVM2RSxrQkFBa0IsS0FBSyxZQUFZO2dCQUNyRDtvQkFDRSxJQUFJN0UsU0FBUzZFLGtCQUFrQixDQUFDQyw0QkFBNEIsS0FBSyxNQUFNO3dCQUNyRSxJQUFJNUYsZ0JBQWdCNUUseUJBQXlCeGhDLFNBQVM7d0JBRXRELElBQUksQ0FBQ3lwQywrQkFBK0IsQ0FBQ3JELGNBQWMsRUFBRTs0QkFDbkRucUMsS0FDQSwwRUFBMEUsOEVBQThFLHdGQUF3RiwwQkFBMEIsZ0RBQWdEbXFDOzRCQUUxVHFELCtCQUErQixDQUFDckQsY0FBYyxHQUFHO3dCQUNuRDtvQkFDRjtnQkFDRjtnQkFFQWMsU0FBUzZFLGtCQUFrQjtZQUM3QjtZQUVBLElBQUksT0FBTzdFLFNBQVMrRSx5QkFBeUIsS0FBSyxZQUFZO2dCQUM1RC9FLFNBQVMrRSx5QkFBeUI7WUFDcEM7WUFFQSxJQUFJeUIsYUFBYXhHLFNBQVNyWCxLQUFLLEVBQUU7Z0JBQy9CO29CQUNFbnpCLE1BQU0sa0VBQWtFLDZDQUE2Qyx1Q0FBdUM4a0MseUJBQXlCeGhDLFNBQVM7Z0JBQ2hNO2dCQUVBMHFDLHNCQUFzQk0sbUJBQW1CLENBQUM5RCxVQUFVQSxTQUFTclgsS0FBSyxFQUFFO1lBQ3RFO1FBQ0Y7UUFFQSxTQUFTOGQsbUJBQW1CQyxnQkFBZ0IsRUFBRWhELElBQUksRUFBRXRvQyxLQUFLLEVBQUVrcEMsbUJBQW1CO1lBQzVFLElBQUlvQyxpQkFBaUI3QyxLQUFLLEtBQUssUUFBUTZDLGlCQUFpQjdDLEtBQUssQ0FBQzF1QyxNQUFNLEdBQUcsR0FBRztnQkFDeEUsSUFBSXd4QyxXQUFXRCxpQkFBaUI3QyxLQUFLO2dCQUNyQyxJQUFJK0MsYUFBYUYsaUJBQWlCeHZCLE9BQU87Z0JBQ3pDd3ZCLGlCQUFpQjdDLEtBQUssR0FBRztnQkFDekI2QyxpQkFBaUJ4dkIsT0FBTyxHQUFHO2dCQUUzQixJQUFJMHZCLGNBQWNELFNBQVN4eEMsTUFBTSxLQUFLLEdBQUc7b0JBQ3ZDdXVDLEtBQUsvYSxLQUFLLEdBQUdnZSxRQUFRLENBQUMsRUFBRTtnQkFDMUIsT0FBTztvQkFDTCxJQUFJRSxZQUFZRCxhQUFhRCxRQUFRLENBQUMsRUFBRSxHQUFHakQsS0FBSy9hLEtBQUs7b0JBQ3JELElBQUltZSxhQUFhO29CQUVqQixJQUFLLElBQUkxc0IsSUFBSXdzQixhQUFhLElBQUksR0FBR3hzQixJQUFJdXNCLFNBQVN4eEMsTUFBTSxFQUFFaWxCLElBQUs7d0JBQ3pELElBQUkyc0IsVUFBVUosUUFBUSxDQUFDdnNCLEVBQUU7d0JBQ3pCLElBQUkrb0IsZUFBZSxPQUFPNEQsWUFBWSxhQUFhQSxRQUFRdndDLElBQUksQ0FBQ2t0QyxNQUFNbUQsV0FBV3pyQyxPQUFPa3BDLHVCQUF1QnlDO3dCQUUvRyxJQUFJNUQsZ0JBQWdCLE1BQU07NEJBQ3hCLElBQUkyRCxZQUFZO2dDQUNkQSxhQUFhO2dDQUNiRCxZQUFZcHVDLE9BQU8sQ0FBQyxHQUFHb3VDLFdBQVcxRDs0QkFDcEMsT0FBTztnQ0FDTDFxQyxPQUFPb3VDLFdBQVcxRDs0QkFDcEI7d0JBQ0Y7b0JBQ0Y7b0JBRUFPLEtBQUsvYSxLQUFLLEdBQUdrZTtnQkFDZjtZQUNGLE9BQU87Z0JBQ0xILGlCQUFpQjdDLEtBQUssR0FBRztZQUMzQjtRQUNGLEVBQUUseUVBQXlFO1FBRzNFLFNBQVNtRCxtQkFBbUJoSCxRQUFRLEVBQUUvQixJQUFJLEVBQUVsa0IsUUFBUSxFQUFFdXFCLG1CQUFtQjtZQUN2RTtnQkFDRWdCLG1CQUFtQnRGLFVBQVUvQixNQUFNbGtCO1lBQ3JDO1lBRUEsSUFBSWt0QixlQUFlakgsU0FBU3JYLEtBQUssS0FBS3ZTLFlBQVk0cEIsU0FBU3JYLEtBQUssR0FBRztZQUNuRXFYLFNBQVNrSCxPQUFPLEdBQUcxRDtZQUNuQnhELFNBQVM1a0MsS0FBSyxHQUFHMmU7WUFDakJpbUIsU0FBU3JYLEtBQUssR0FBR3NlLGNBQWMsNEdBQTRHO1lBQzNJLHNGQUFzRjtZQUV0RixJQUFJUCxtQkFBbUI7Z0JBQ3JCN0MsT0FBTyxFQUFFO2dCQUNUM3NCLFNBQVM7WUFDWDtZQUNBbU0sSUFBSTJjLFVBQVUwRztZQUNkLElBQUluQyxjQUFjdEcsS0FBS3NHLFdBQVc7WUFFbEMsSUFBSSxPQUFPQSxnQkFBZ0IsWUFBWUEsZ0JBQWdCLE1BQU07Z0JBQzNEdkUsU0FBU3pGLE9BQU8sR0FBRzZILGNBQWNtQztZQUNuQyxPQUFPO2dCQUNMdkUsU0FBU3pGLE9BQU8sR0FBRytKO1lBQ3JCO1lBRUE7Z0JBQ0UsSUFBSXRFLFNBQVNyWCxLQUFLLEtBQUs1TyxVQUFVO29CQUMvQixJQUFJbWxCLGdCQUFnQjVFLHlCQUF5QjJELFNBQVM7b0JBRXRELElBQUksQ0FBQzJFLDBDQUEwQ3ZvQyxHQUFHLENBQUM2a0MsZ0JBQWdCO3dCQUNqRTBELDBDQUEwQ3RaLEdBQUcsQ0FBQzRWO3dCQUU5QzFwQyxNQUFNLGlFQUFpRSwyREFBMkQsc0RBQXNEMHBDO29CQUMxTDtnQkFDRjtZQUNGO1lBRUEsSUFBSStFLDJCQUEyQmhHLEtBQUtnRyx3QkFBd0I7WUFFNUQsSUFBSSxPQUFPQSw2QkFBNkIsWUFBWTtnQkFDbERqRSxTQUFTclgsS0FBSyxHQUFHcWIsMkJBQTJCaEUsVUFBVS9CLE1BQU1nRywwQkFBMEJnRCxjQUFjbHRCO1lBQ3RHLEVBQUUscUVBQXFFO1lBQ3ZFLDZFQUE2RTtZQUc3RSxJQUFJLE9BQU9ra0IsS0FBS2dHLHdCQUF3QixLQUFLLGNBQWMsT0FBT2pFLFNBQVN5RSx1QkFBdUIsS0FBSyxjQUFlLFFBQU96RSxTQUFTK0UseUJBQXlCLEtBQUssY0FBYyxPQUFPL0UsU0FBUzZFLGtCQUFrQixLQUFLLFVBQVMsR0FBSTtnQkFDcE8wQix1QkFBdUJ0SSxNQUFNK0IsV0FBVyxtRUFBbUU7Z0JBQzNHLG9CQUFvQjtnQkFFcEJ5RyxtQkFBbUJDLGtCQUFrQjFHLFVBQVVqbUIsVUFBVXVxQjtZQUMzRDtRQUNGO1FBRUEseUVBQXlFO1FBQ3pFLGdDQUFnQztRQUNoQyw4RUFBOEU7UUFDOUUsK0VBQStFO1FBQy9FLDZCQUE2QjtRQUM3QixFQUFFO1FBQ0YscUNBQXFDO1FBQ3JDLHFDQUFxQztRQUNyQyxpQ0FBaUM7UUFDakMsRUFBRTtRQUNGLDhFQUE4RTtRQUM5RSwyRUFBMkU7UUFDM0UsdUVBQXVFO1FBQ3ZFLEVBQUU7UUFDRiw2RUFBNkU7UUFDN0UsdUVBQXVFO1FBQ3ZFLEVBQUU7UUFDRiw4RUFBOEU7UUFDOUUseUVBQXlFO1FBQ3pFLDhFQUE4RTtRQUM5RSw4QkFBOEI7UUFDOUIsRUFBRTtRQUNGLGlDQUFpQztRQUNqQyxzQ0FBc0M7UUFDdEMsc0NBQXNDO1FBQ3RDLGtDQUFrQztRQUNsQyxVQUFVO1FBQ1YsTUFBTTtRQUNOLEVBQUU7UUFDRixnRkFBZ0Y7UUFDaEYsMEVBQTBFO1FBQzFFLHVFQUF1RTtRQUN2RSxpQkFBaUI7UUFDakIsRUFBRTtRQUNGLFdBQVc7UUFDWCxjQUFjO1FBQ2QsWUFBWTtRQUNaLEVBQUU7UUFDRiwwRUFBMEU7UUFDMUUsOEVBQThFO1FBQzlFLGdEQUFnRDtRQUNoRCxFQUFFO1FBQ0Ysd0VBQXdFO1FBQ3hFLHVFQUF1RTtRQUN2RSxnRkFBZ0Y7UUFDaEYsOEVBQThFO1FBQzlFLDhFQUE4RTtRQUM5RSw4RUFBOEU7UUFDOUUsOEVBQThFO1FBQzlFLGdGQUFnRjtRQUNoRiw4QkFBOEI7UUFDOUIsSUFBSTZDLG1CQUFtQjtZQUNyQm5tQyxJQUFJO1lBQ0oyTSxVQUFVO1FBQ1o7UUFDQSxTQUFTeTVCLFVBQVU3TSxPQUFPO1lBQ3hCLElBQUk1c0IsV0FBVzRzQixRQUFRNXNCLFFBQVE7WUFDL0IsSUFBSTA1QixtQkFBbUI5TSxRQUFRdjVCLEVBQUU7WUFDakMsSUFBSUEsS0FBS3FtQyxtQkFBbUIsQ0FBQ0MsY0FBY0Q7WUFDM0MsT0FBT3JtQyxHQUFHd2hCLFFBQVEsQ0FBQyxNQUFNN1U7UUFDM0I7UUFDQSxTQUFTNDVCLGdCQUFnQkMsV0FBVyxFQUFFQyxhQUFhLEVBQUVwdkIsS0FBSztZQUN4RCxJQUFJcXZCLHVCQUF1QkYsWUFBWXhtQyxFQUFFO1lBQ3pDLElBQUkybUMsZUFBZUgsWUFBWTc1QixRQUFRLEVBQUUsNkVBQTZFO1lBQ3RILGtEQUFrRDtZQUVsRCxJQUFJaTZCLGFBQWFDLGFBQWFILHdCQUF3QjtZQUN0RCxJQUFJSSxTQUFTSix1QkFBdUIsQ0FBRSxNQUFLRSxVQUFTO1lBQ3BELElBQUlHLE9BQU8xdkIsUUFBUTtZQUNuQixJQUFJbGpCLFNBQVMweUMsYUFBYUosaUJBQWlCRyxZQUFZLHFFQUFxRTtZQUM1SCxzRUFBc0U7WUFFdEUsSUFBSXp5QyxTQUFTLElBQUk7Z0JBQ2YsdUVBQXVFO2dCQUN2RSw0RUFBNEU7Z0JBQzVFLCtEQUErRDtnQkFDL0QsRUFBRTtnQkFDRixrRUFBa0U7Z0JBQ2xFLG9CQUFvQjtnQkFDcEIsRUFBRTtnQkFDRix3RUFBd0U7Z0JBQ3hFLHlFQUF5RTtnQkFDekUsNkRBQTZEO2dCQUM3RCxFQUFFO2dCQUNGLG9FQUFvRTtnQkFDcEUsMEJBQTBCO2dCQUMxQixJQUFJNnlDLHVCQUF1QkosYUFBYUEsYUFBYSxHQUFHLHNEQUFzRDtnQkFFOUcsSUFBSUssa0JBQWtCLENBQUMsS0FBS0Qsb0JBQW1CLElBQUssR0FBRyx5REFBeUQ7Z0JBRWhILElBQUlFLGNBQWMsQ0FBQ0osU0FBU0csZUFBYyxFQUFHemxCLFFBQVEsQ0FBQyxLQUFLLGlEQUFpRDtnQkFFNUcsSUFBSTJsQixlQUFlTCxVQUFVRTtnQkFDN0IsSUFBSUksbUJBQW1CUixhQUFhSSxzQkFBc0IsMkVBQTJFO2dCQUNySSxrREFBa0Q7Z0JBRWxELElBQUlLLGVBQWVSLGFBQWFKLGlCQUFpQlc7Z0JBQ2pELElBQUlFLGdCQUFnQlAsUUFBUUs7Z0JBQzVCLElBQUlwbkMsS0FBS3NuQyxnQkFBZ0JIO2dCQUN6QixJQUFJeDZCLFdBQVd1NkIsY0FBY1A7Z0JBQzdCLE9BQU87b0JBQ0wzbUMsSUFBSSxLQUFLcW5DLGVBQWVybkM7b0JBQ3hCMk0sVUFBVUE7Z0JBQ1o7WUFDRixPQUFPO2dCQUNMLGNBQWM7Z0JBQ2QsSUFBSTQ2QixVQUFVUixRQUFRSDtnQkFFdEIsSUFBSVksTUFBTUQsVUFBVVQ7Z0JBRXBCLElBQUlXLFlBQVlkO2dCQUNoQixPQUFPO29CQUNMM21DLElBQUksS0FBSzdMLFNBQVNxekM7b0JBQ2xCNzZCLFVBQVU4NkI7Z0JBQ1o7WUFDRjtRQUNGO1FBRUEsU0FBU1osYUFBYWEsTUFBTTtZQUMxQixPQUFPLEtBQUtDLE1BQU1EO1FBQ3BCO1FBRUEsU0FBU3BCLGNBQWN0bUMsRUFBRTtZQUN2QixPQUFPLEtBQUs2bUMsYUFBYTdtQyxNQUFNO1FBQ2pDLEVBQUUsNkVBQTZFO1FBRy9FLElBQUkybkMsUUFBUUMsS0FBS0QsS0FBSyxHQUFHQyxLQUFLRCxLQUFLLEdBQUdFLGVBQWUsdUJBQXVCO1FBQzVFLFlBQVk7UUFDWiw4RkFBOEY7UUFFOUYsSUFBSS9NLE1BQU04TSxLQUFLOU0sR0FBRztRQUNsQixJQUFJZ04sTUFBTUYsS0FBS0UsR0FBRztRQUVsQixTQUFTRCxjQUFjeDBCLENBQUM7WUFDdEIsSUFBSTAwQixTQUFTMTBCLE1BQU07WUFFbkIsSUFBSTAwQixXQUFXLEdBQUc7Z0JBQ2hCLE9BQU87WUFDVDtZQUVBLE9BQU8sS0FBTWpOLENBQUFBLElBQUlpTixVQUFVRCxNQUFNLEtBQUs7UUFDeEM7UUFFQSxnRkFBZ0Y7UUFDaEYsMkRBQTJEO1FBQzNELHlFQUF5RTtRQUN6RSw4REFBOEQ7UUFDOUQscUVBQXFFO1FBQ3JFLDBFQUEwRTtRQUMxRSxJQUFJRSxvQkFBb0IsSUFBSXRsQixNQUFNLDBFQUEwRSxzRUFBc0UsbUVBQW1FLGtFQUFrRSw2QkFBNkIsMEVBQTBFO1FBQzlaLFNBQVN1bEI7WUFDUCwwRUFBMEU7WUFDMUUsOENBQThDO1lBQzlDLE9BQU8sRUFBRTtRQUNYO1FBRUEsU0FBU0MsVUFBVTtRQUVuQixTQUFTQyxrQkFBa0JDLGFBQWEsRUFBRUMsUUFBUSxFQUFFaHhCLEtBQUs7WUFDdkQsSUFBSWl4QixXQUFXRixhQUFhLENBQUMvd0IsTUFBTTtZQUVuQyxJQUFJaXhCLGFBQWFsekIsV0FBVztnQkFDMUJnekIsY0FBY255QyxJQUFJLENBQUNveUM7WUFDckIsT0FBTztnQkFDTCxJQUFJQyxhQUFhRCxVQUFVO29CQUN6QixtRUFBbUU7b0JBQ25FLG9FQUFvRTtvQkFDcEUsa0VBQWtFO29CQUNsRSx3QkFBd0I7b0JBQ3hCQSxTQUFTRSxJQUFJLENBQUNMLFFBQVFBO29CQUN0QkcsV0FBV0M7Z0JBQ2I7WUFDRixFQUFFLDRFQUE0RTtZQUM5RSwyRUFBMkU7WUFDM0UscUVBQXFFO1lBQ3JFLEVBQUU7WUFDRix3RUFBd0U7WUFDeEUsc0VBQXNFO1lBR3RFLE9BQVFELFNBQVNHLE1BQU07Z0JBQ3JCLEtBQUs7b0JBQ0g7d0JBQ0UsSUFBSUMsaUJBQWlCSixTQUFTeHhDLEtBQUs7d0JBQ25DLE9BQU80eEM7b0JBQ1Q7Z0JBRUYsS0FBSztvQkFDSDt3QkFDRSxJQUFJQyxnQkFBZ0JMLFNBQVNNLE1BQU07d0JBQ25DLE1BQU1EO29CQUNSO2dCQUVGO29CQUNFO3dCQUNFLElBQUksT0FBT0wsU0FBU0csTUFBTSxLQUFLOzZCQUFpQjs0QkFDOUMsSUFBSUksa0JBQWtCUDs0QkFDdEJPLGdCQUFnQkosTUFBTSxHQUFHOzRCQUN6QkksZ0JBQWdCTCxJQUFJLENBQUMsU0FBVUUsY0FBYztnQ0FDM0MsSUFBSUosU0FBU0csTUFBTSxLQUFLLFdBQVc7b0NBQ2pDLElBQUlLLG9CQUFvQlI7b0NBQ3hCUSxrQkFBa0JMLE1BQU0sR0FBRztvQ0FDM0JLLGtCQUFrQmh5QyxLQUFLLEdBQUc0eEM7Z0NBQzVCOzRCQUNGLEdBQUcsU0FBVWowQyxLQUFLO2dDQUNoQixJQUFJNnpDLFNBQVNHLE1BQU0sS0FBSyxXQUFXO29DQUNqQyxJQUFJTSxtQkFBbUJUO29DQUN2QlMsaUJBQWlCTixNQUFNLEdBQUc7b0NBQzFCTSxpQkFBaUJILE1BQU0sR0FBR24wQztnQ0FDNUI7NEJBQ0YsSUFBSSxrRUFBa0U7NEJBRXRFLE9BQVE2ekMsU0FBU0csTUFBTTtnQ0FDckIsS0FBSztvQ0FDSDt3Q0FDRSxJQUFJSyxvQkFBb0JSO3dDQUN4QixPQUFPUSxrQkFBa0JoeUMsS0FBSztvQ0FDaEM7Z0NBRUYsS0FBSztvQ0FDSDt3Q0FDRSxJQUFJaXlDLG1CQUFtQlQ7d0NBQ3ZCLE1BQU1TLGlCQUFpQkgsTUFBTTtvQ0FDL0I7NEJBQ0o7d0JBQ0YsRUFBRSxXQUFXO3dCQUNiLEVBQUU7d0JBQ0YseUVBQXlFO3dCQUN6RSx5RUFBeUU7d0JBQ3pFLHlFQUF5RTt3QkFDekUsbUVBQW1FO3dCQUNuRSw4Q0FBOEM7d0JBRzlDSSxvQkFBb0JWO3dCQUNwQixNQUFNTDtvQkFDUjtZQUNKO1FBQ0YsRUFBRSx3RUFBd0U7UUFDMUUsNEVBQTRFO1FBQzVFLDBDQUEwQztRQUUxQyxJQUFJZSxvQkFBb0I7UUFDeEIsU0FBU0M7WUFDUCw0RUFBNEU7WUFDNUUsNEVBQTRFO1lBQzVFLDZFQUE2RTtZQUM3RSxpQkFBaUI7WUFDakIsSUFBSUQsc0JBQXNCLE1BQU07Z0JBQzlCLE1BQU0sSUFBSXJtQixNQUFNLHdFQUF3RTtZQUMxRjtZQUVBLElBQUkybEIsV0FBV1U7WUFDZkEsb0JBQW9CO1lBQ3BCLE9BQU9WO1FBQ1Q7UUFFQTs7O0NBR0MsR0FDRCxTQUFTL25DLEdBQUcrUyxDQUFDLEVBQUVpQixDQUFDO1lBQ2QsT0FBT2pCLE1BQU1pQixLQUFNakIsQ0FBQUEsTUFBTSxLQUFLLElBQUlBLE1BQU0sSUFBSWlCLENBQUFBLEtBQU1qQixNQUFNQSxLQUFLaUIsTUFBTUEsRUFBRSxzQ0FBc0M7O1FBRTdHO1FBRUEsSUFBSTIwQixXQUNKLE9BQU9ueUMsT0FBT3dKLEVBQUUsS0FBSyxhQUFheEosT0FBT3dKLEVBQUUsR0FBR0E7UUFFOUMsSUFBSTRvQyw4QkFBOEI7UUFDbEMsSUFBSUMseUJBQXlCO1FBQzdCLElBQUlDLDBCQUEwQjtRQUM5QixJQUFJQyxxQkFBcUIsTUFBTSwwREFBMEQ7UUFFekYsSUFBSUMsYUFBYSxPQUFPLDhFQUE4RTtRQUV0RyxJQUFJQywrQkFBK0IsT0FBTyxxREFBcUQ7UUFFL0YsSUFBSUMsaUJBQWlCLEdBQUcsNkRBQTZEO1FBRXJGLElBQUlDLHVCQUF1QjtRQUMzQixJQUFJckIsZ0JBQWdCLE1BQU0sNkNBQTZDO1FBRXZFLElBQUlzQixxQkFBcUIsTUFBTSxxQ0FBcUM7UUFFcEUsSUFBSUMsb0JBQW9CO1FBQ3hCLElBQUlDLGtCQUFrQjtRQUN0QixJQUFJQyx3QkFBd0IsT0FBTyxxRUFBcUU7UUFFeEcsSUFBSUM7UUFFSixTQUFTQztZQUNQLElBQUliLGdDQUFnQyxNQUFNO2dCQUN4QyxNQUFNLElBQUl4bUIsTUFBTSxrSEFBa0gscUNBQXFDLDJGQUEyRixrREFBa0Qsb0VBQW9FO1lBQzFYO1lBRUE7Z0JBQ0UsSUFBSW1uQix1QkFBdUI7b0JBQ3pCcjFDLE1BQU0scUZBQXFGLHNFQUFzRSwrQkFBK0I7Z0JBQ2xNO1lBQ0Y7WUFFQSxPQUFPMDBDO1FBQ1Q7UUFFQSxTQUFTYyxtQkFBbUJDLFFBQVEsRUFBRUMsUUFBUTtZQUM1QyxJQUFJQSxhQUFhLE1BQU07Z0JBQ3JCO29CQUNFMTFDLE1BQU0scUVBQXFFLHNFQUFzRSwyQ0FBMkNzMUM7Z0JBQzlMO2dCQUVBLE9BQU87WUFDVDtZQUVBO2dCQUNFLHdFQUF3RTtnQkFDeEUsaUJBQWlCO2dCQUNqQixJQUFJRyxTQUFTOTFDLE1BQU0sS0FBSysxQyxTQUFTLzFDLE1BQU0sRUFBRTtvQkFDdkNLLE1BQU0sdUVBQXVFLDJEQUEyRCxtQkFBbUIsZ0JBQWdCczFDLHNCQUFzQixNQUFNRyxTQUFTdnVDLElBQUksQ0FBQyxRQUFRLEtBQUssTUFBTXd1QyxTQUFTeHVDLElBQUksQ0FBQyxRQUFRO2dCQUNoUTtZQUNGO1lBR0EsSUFBSyxJQUFJMGQsSUFBSSxHQUFHQSxJQUFJOHdCLFNBQVMvMUMsTUFBTSxJQUFJaWxCLElBQUk2d0IsU0FBUzkxQyxNQUFNLEVBQUVpbEIsSUFBSztnQkFDL0QseURBQXlEO2dCQUN6RCxJQUFJNnZCLFNBQVNnQixRQUFRLENBQUM3d0IsRUFBRSxFQUFFOHdCLFFBQVEsQ0FBQzl3QixFQUFFLEdBQUc7b0JBQ3RDO2dCQUNGO2dCQUVBLE9BQU87WUFDVDtZQUVBLE9BQU87UUFDVDtRQUVBLFNBQVMrd0I7WUFDUCxJQUFJUixvQkFBb0IsR0FBRztnQkFDekIsTUFBTSxJQUFJam5CLE1BQU07WUFDbEI7WUFFQSxPQUFPO2dCQUNMMG5CLGVBQWU7Z0JBQ2Z2SCxPQUFPO2dCQUNQaEQsTUFBTTtZQUNSO1FBQ0Y7UUFFQSxTQUFTd0s7WUFDUCxJQUFJaEIsdUJBQXVCLE1BQU07Z0JBQy9CLHFDQUFxQztnQkFDckMsSUFBSUQsNEJBQTRCLE1BQU07b0JBQ3BDRSxhQUFhO29CQUNiRiwwQkFBMEJDLHFCQUFxQmM7Z0JBQ2pELE9BQU87b0JBQ0wsZ0RBQWdEO29CQUNoRGIsYUFBYTtvQkFDYkQscUJBQXFCRDtnQkFDdkI7WUFDRixPQUFPO2dCQUNMLElBQUlDLG1CQUFtQnhKLElBQUksS0FBSyxNQUFNO29CQUNwQ3lKLGFBQWEsT0FBTyxnQ0FBZ0M7b0JBRXBERCxxQkFBcUJBLG1CQUFtQnhKLElBQUksR0FBR3NLO2dCQUNqRCxPQUFPO29CQUNMLGdEQUFnRDtvQkFDaERiLGFBQWE7b0JBQ2JELHFCQUFxQkEsbUJBQW1CeEosSUFBSTtnQkFDOUM7WUFDRjtZQUVBLE9BQU93SjtRQUNUO1FBRUEsU0FBU2lCLGtCQUFrQkMsSUFBSSxFQUFFQyxpQkFBaUIsRUFBRUMsaUJBQWlCO1lBQ25FdkIsOEJBQThCc0I7WUFDOUJyQix5QkFBeUJvQjtZQUV6QjtnQkFDRVYsd0JBQXdCO1lBQzFCO1lBQ0Esd0NBQXdDO1lBQ3hDLGtDQUFrQztZQUNsQyx5QkFBeUI7WUFDekIsNkJBQTZCO1lBQzdCLDZCQUE2QjtZQUc3QkwsaUJBQWlCO1lBQ2pCQyx1QkFBdUI7WUFDdkJyQixnQkFBZ0JxQztRQUNsQjtRQUNBLFNBQVNDLFlBQVl0TixTQUFTLEVBQUVoakMsS0FBSyxFQUFFZ0QsUUFBUSxFQUFFdXRDLFlBQVk7WUFDM0QsMkVBQTJFO1lBQzNFLHlCQUF5QjtZQUN6QixNQUFPcEIsNkJBQThCO2dCQUNuQyxxRUFBcUU7Z0JBQ3JFLHNFQUFzRTtnQkFDdEUsMEVBQTBFO2dCQUMxRSxrREFBa0Q7Z0JBQ2xEQSwrQkFBK0I7Z0JBQy9CQyxpQkFBaUI7Z0JBQ2pCQyx1QkFBdUI7Z0JBQ3ZCRSxxQkFBcUIsR0FBRyw0Q0FBNEM7Z0JBRXBFTixxQkFBcUI7Z0JBQ3JCanNDLFdBQVdnZ0MsVUFBVWhqQyxPQUFPdXdDO1lBQzlCO1lBRUFDO1lBQ0EsT0FBT3h0QztRQUNUO1FBQ0EsU0FBU3l0QztZQUNQLElBQUlsakIsUUFBUXlnQjtZQUNaQSxnQkFBZ0I7WUFDaEIsT0FBT3pnQjtRQUNUO1FBQ0EsU0FBU21qQjtZQUNQLGtFQUFrRTtZQUNsRSwwRUFBMEU7WUFDMUUsbURBQW1EO1lBQ25ELElBQUlDLGtCQUFrQnZCLG1CQUFtQjtZQUN6QyxPQUFPdUI7UUFDVCxFQUFFLGdGQUFnRjtRQUVsRixTQUFTSDtZQUNQO2dCQUNFZix3QkFBd0I7WUFDMUI7WUFFQVgsOEJBQThCO1lBQzlCQyx5QkFBeUI7WUFDekJJLCtCQUErQjtZQUMvQkgsMEJBQTBCO1lBQzFCTyxvQkFBb0I7WUFDcEJELHFCQUFxQjtZQUNyQkwscUJBQXFCO1FBQ3ZCO1FBRUEsU0FBUzJCLFlBQVl6UixPQUFPO1lBQzFCO2dCQUNFLElBQUlzUSx1QkFBdUI7b0JBQ3pCcjFDLE1BQU0sd0RBQXdELG1GQUFtRixvRkFBb0Y7Z0JBQ3ZPO1lBQ0Y7WUFFQSxPQUFPNHNDLGNBQWM3SDtRQUN2QjtRQUVBLFNBQVMwUixXQUFXMVIsT0FBTztZQUN6QjtnQkFDRXVRLHVCQUF1QjtZQUN6QjtZQUVBQztZQUNBLE9BQU8zSSxjQUFjN0g7UUFDdkI7UUFFQSxTQUFTMlIsa0JBQWtCdmpCLEtBQUssRUFBRXZyQixNQUFNO1lBQ3RDLDhEQUE4RDtZQUM5RCxPQUFPLE9BQU9BLFdBQVcsYUFBYUEsT0FBT3VyQixTQUFTdnJCO1FBQ3hEO1FBRUEsU0FBUyt1QyxTQUFTbEYsWUFBWTtZQUM1QjtnQkFDRTZELHVCQUF1QjtZQUN6QjtZQUVBLE9BQU9zQixXQUFXRixtQkFDbEJqRjtRQUNGO1FBQ0EsU0FBU21GLFdBQVdDLE9BQU8sRUFBRUMsVUFBVSxFQUFFdlIsSUFBSTtZQUMzQztnQkFDRSxJQUFJc1IsWUFBWUgsbUJBQW1CO29CQUNqQ3BCLHVCQUF1QjtnQkFDekI7WUFDRjtZQUVBWiw4QkFBOEJhO1lBQzlCVixxQkFBcUJnQjtZQUVyQixJQUFJZixZQUFZO2dCQUNkLDBFQUEwRTtnQkFDMUUsZ0JBQWdCO2dCQUNoQixJQUFJekcsUUFBUXdHLG1CQUFtQnhHLEtBQUs7Z0JBQ3BDLElBQUkwSSxXQUFXMUksTUFBTTBJLFFBQVE7Z0JBRTdCLElBQUk3Qix1QkFBdUIsTUFBTTtvQkFDL0IsbUVBQW1FO29CQUNuRSxJQUFJOEIseUJBQXlCOUIsbUJBQW1CandDLEdBQUcsQ0FBQ29wQztvQkFFcEQsSUFBSTJJLDJCQUEyQnAyQixXQUFXO3dCQUN4Qyx5REFBeUQ7d0JBQ3pEczBCLG1CQUFtQm5YLE1BQU0sQ0FBQ3NRLFFBQVEseURBQXlEO3dCQUUzRixJQUFJTyxXQUFXaUcsbUJBQW1CZSxhQUFhO3dCQUMvQyxJQUFJcUIsU0FBU0Q7d0JBRWIsR0FBRzs0QkFDRCwrREFBK0Q7NEJBQy9ELDZEQUE2RDs0QkFDN0QsWUFBWTs0QkFDWixJQUFJcHZDLFNBQVNxdkMsT0FBT3J2QyxNQUFNOzRCQUUxQjtnQ0FDRXl0Qyx3QkFBd0I7NEJBQzFCOzRCQUVBekcsV0FBV2lJLFFBQVFqSSxVQUFVaG5DOzRCQUU3QjtnQ0FDRXl0Qyx3QkFBd0I7NEJBQzFCOzRCQUdBNEIsU0FBU0EsT0FBTzVMLElBQUk7d0JBQ3RCLFFBQVM0TCxXQUFXLE1BQU0sQ0FBQyx5REFBeUQ7d0JBR3BGcEMsbUJBQW1CZSxhQUFhLEdBQUdoSDt3QkFDbkMsT0FBTzs0QkFBQ0E7NEJBQVVtSTt5QkFBUztvQkFDN0I7Z0JBQ0YsRUFBRSx5REFBeUQ7Z0JBRzNELE9BQU87b0JBQUNsQyxtQkFBbUJlLGFBQWE7b0JBQUVtQjtpQkFBUztZQUNyRCxPQUFPO2dCQUNMO29CQUNFMUIsd0JBQXdCO2dCQUMxQjtnQkFFQSxJQUFJNUQ7Z0JBRUosSUFBSW9GLFlBQVlILG1CQUFtQjtvQkFDakMsK0JBQStCO29CQUMvQmpGLGVBQWUsT0FBT3FGLGVBQWUsYUFBYUEsZUFBZUE7Z0JBQ25FLE9BQU87b0JBQ0xyRixlQUFlbE0sU0FBUzNrQixZQUFZMmtCLEtBQUt1UixjQUFjQTtnQkFDekQ7Z0JBRUE7b0JBQ0V6Qix3QkFBd0I7Z0JBQzFCO2dCQUdBUixtQkFBbUJlLGFBQWEsR0FBR25FLGNBQWMseURBQXlEO2dCQUUxRyxJQUFJeUYsU0FBU3JDLG1CQUFtQnhHLEtBQUssR0FBRztvQkFDdEM4SSxNQUFNO29CQUNOSixVQUFVO2dCQUNaO2dCQUVBLElBQUlLLFlBQVlGLE9BQU9ILFFBQVEsR0FBR00sZUFBZTFOLElBQUksQ0FBQyxNQUFNK0ssNkJBQTZCd0MsU0FBUyx5REFBeUQ7Z0JBRzNKLE9BQU87b0JBQUNyQyxtQkFBbUJlLGFBQWE7b0JBQUV3QjtpQkFBVTtZQUN0RDtRQUNGO1FBRUEsU0FBU0UsUUFBUUMsVUFBVSxFQUFFQyxJQUFJO1lBQy9COUMsOEJBQThCYTtZQUM5QlYscUJBQXFCZ0I7WUFDckIsSUFBSUosV0FBVytCLFNBQVM1MkIsWUFBWSxPQUFPNDJCO1lBRTNDLElBQUkzQyx1QkFBdUIsTUFBTTtnQkFDL0IsSUFBSW5HLFlBQVltRyxtQkFBbUJlLGFBQWE7Z0JBRWhELElBQUlsSCxjQUFjLE1BQU07b0JBQ3RCLElBQUkrRyxhQUFhLE1BQU07d0JBQ3JCLElBQUlDLFdBQVdoSCxTQUFTLENBQUMsRUFBRTt3QkFFM0IsSUFBSThHLG1CQUFtQkMsVUFBVUMsV0FBVzs0QkFDMUMsT0FBT2hILFNBQVMsQ0FBQyxFQUFFO3dCQUNyQjtvQkFDRjtnQkFDRjtZQUNGO1lBRUE7Z0JBQ0UyRyx3QkFBd0I7WUFDMUI7WUFFQSxJQUFJbkosWUFBWXFMO1lBRWhCO2dCQUNFbEMsd0JBQXdCO1lBQzFCO1lBR0FSLG1CQUFtQmUsYUFBYSxHQUFHO2dCQUFDMUo7Z0JBQVd1SjthQUFTO1lBQ3hELE9BQU92SjtRQUNUO1FBRUEsU0FBU3VMLE9BQU9DLFlBQVk7WUFDMUJoRCw4QkFBOEJhO1lBQzlCVixxQkFBcUJnQjtZQUNyQixJQUFJOEIsY0FBYzlDLG1CQUFtQmUsYUFBYTtZQUVsRCxJQUFJK0IsZ0JBQWdCLE1BQU07Z0JBQ3hCLElBQUlDLE1BQU07b0JBQ1IzdkIsU0FBU3l2QjtnQkFDWDtnQkFFQTtvQkFDRXAxQyxPQUFPdTFDLElBQUksQ0FBQ0Q7Z0JBQ2Q7Z0JBR0EvQyxtQkFBbUJlLGFBQWEsR0FBR2dDO2dCQUNuQyxPQUFPQTtZQUNULE9BQU87Z0JBQ0wsT0FBT0Q7WUFDVDtRQUNGO1FBRUEsU0FBU04sZUFBZXJCLGlCQUFpQixFQUFFM0gsS0FBSyxFQUFFem1DLE1BQU07WUFDdEQsSUFBSXV0QyxxQkFBcUJDLGlCQUFpQjtnQkFDeEMsTUFBTSxJQUFJbG5CLE1BQU0sd0VBQXdFO1lBQzFGO1lBRUEsSUFBSThuQixzQkFBc0J0Qiw2QkFBNkI7Z0JBQ3JELHFFQUFxRTtnQkFDckUseUVBQXlFO2dCQUN6RSxxRUFBcUU7Z0JBQ3JFSywrQkFBK0I7Z0JBQy9CLElBQUlrQyxTQUFTO29CQUNYcnZDLFFBQVFBO29CQUNSeWpDLE1BQU07Z0JBQ1I7Z0JBRUEsSUFBSTZKLHVCQUF1QixNQUFNO29CQUMvQkEscUJBQXFCLElBQUlud0M7Z0JBQzNCO2dCQUVBLElBQUlpeUMseUJBQXlCOUIsbUJBQW1CandDLEdBQUcsQ0FBQ29wQztnQkFFcEQsSUFBSTJJLDJCQUEyQnAyQixXQUFXO29CQUN4Qyx5REFBeUQ7b0JBQ3pEczBCLG1CQUFtQnJuQixHQUFHLENBQUN3Z0IsT0FBTzRJO2dCQUNoQyxPQUFPO29CQUNMLDRDQUE0QztvQkFDNUMsSUFBSWEsd0JBQXdCZDtvQkFFNUIsTUFBT2Msc0JBQXNCek0sSUFBSSxLQUFLLEtBQU07d0JBQzFDeU0sd0JBQXdCQSxzQkFBc0J6TSxJQUFJO29CQUNwRDtvQkFFQXlNLHNCQUFzQnpNLElBQUksR0FBRzRMO2dCQUMvQjtZQUNGO1FBQ0Y7UUFFQSxTQUFTYyxZQUFZNTJDLFFBQVEsRUFBRXEyQyxJQUFJO1lBQ2pDLE9BQU9GLFFBQVE7Z0JBQ2IsT0FBT24yQztZQUNULEdBQUdxMkM7UUFDTDtRQUVBLFNBQVNRLHFCQUFxQkMsU0FBUyxFQUFFQyxXQUFXLEVBQUVDLGlCQUFpQjtZQUNyRSxJQUFJQSxzQkFBc0J2M0IsV0FBVztnQkFDbkMsTUFBTSxJQUFJc04sTUFBTSxzREFBc0Q7WUFDeEU7WUFFQSxPQUFPaXFCO1FBQ1Q7UUFFQSxTQUFTQyxpQkFBaUIvMUMsS0FBSztZQUM3Qmt6QztZQUNBLE9BQU9sekM7UUFDVDtRQUVBLFNBQVNnMkM7WUFDUCxNQUFNLElBQUlucUIsTUFBTTtRQUNsQjtRQUVBLFNBQVNvcUI7WUFDUC9DO1lBQ0EsT0FBTztnQkFBQztnQkFBTzhDO2FBQTJCO1FBQzVDO1FBRUEsU0FBU0U7WUFDUCxJQUFJeEMsT0FBT3BCO1lBQ1gsSUFBSXpuQixTQUFTMGtCLFVBQVVtRSxLQUFLeUMsV0FBVztZQUN2QyxJQUFJMXJCLGdCQUFnQjJyQjtZQUVwQixJQUFJM3JCLGtCQUFrQixNQUFNO2dCQUMxQixNQUFNLElBQUlvQixNQUFNO1lBQ2xCO1lBRUEsSUFBSWYsVUFBVTZuQjtZQUNkLE9BQU8vbkIsT0FBT0gsZUFBZUksUUFBUUM7UUFDdkM7UUFFQSxTQUFTdXJCLElBQUlDLE1BQU07WUFDakIsSUFBSUEsV0FBVyxRQUFRLE9BQU9BLFdBQVcsVUFBVTtnQkFDakQsK0JBQStCO2dCQUMvQixJQUFJLE9BQU9BLE9BQU81RSxJQUFJLEtBQUssWUFBWTtvQkFDckMsc0JBQXNCO29CQUN0QixJQUFJRixXQUFXOEU7b0JBQ2YsT0FBT0MsZUFBZS9FO2dCQUN4QixPQUFPLElBQUk4RSxPQUFPdGpCLFFBQVEsS0FBSytOLHNCQUFzQnVWLE9BQU90akIsUUFBUSxLQUFLZ08sMkJBQTJCO29CQUNsRyxJQUFJMEIsVUFBVTRUO29CQUNkLE9BQU9uQyxZQUFZelI7Z0JBQ3JCO1lBQ0YsRUFBRSwrREFBK0Q7WUFHakUsTUFBTSxJQUFJN1csTUFBTSw4Q0FBOEN2dEIsT0FBT2c0QztRQUN2RTtRQUVBLFNBQVNDLGVBQWUvRSxRQUFRO1lBQzlCLElBQUloeEIsUUFBUW95QjtZQUNaQSx3QkFBd0I7WUFFeEIsSUFBSXJCLGtCQUFrQixNQUFNO2dCQUMxQkEsZ0JBQWdCSDtZQUNsQjtZQUVBLE9BQU9FLGtCQUFrQkMsZUFBZUMsVUFBVWh4QjtRQUNwRDtRQUVBLFNBQVNnMkI7WUFDUCxNQUFNLElBQUkzcUIsTUFBTTtRQUNsQjtRQUVBLFNBQVM0cUI7WUFDUCxPQUFPRDtRQUNUO1FBRUEsU0FBU0UsVUFBVTtRQUVuQixJQUFJQyxrQkFBa0I7WUFDcEJ4QyxhQUFhQTtZQUNia0MsS0FBS0E7WUFDTGpDLFlBQVlBO1lBQ1phLFNBQVNBO1lBQ1RWLFlBQVlBO1lBQ1phLFFBQVFBO1lBQ1JkLFVBQVVBO1lBQ1ZzQyxvQkFBb0JGO1lBQ3BCRyxpQkFBaUJIO1lBQ2pCaEIsYUFBYUE7WUFDYiwyREFBMkQ7WUFDM0RvQixxQkFBcUJKO1lBQ3JCLGlEQUFpRDtZQUNqREssV0FBV0w7WUFDWCxtQkFBbUI7WUFDbkJNLGVBQWVOO1lBQ2ZYLGtCQUFrQkE7WUFDbEJFLGVBQWVBO1lBQ2ZDLE9BQU9BO1lBQ1AsdURBQXVEO1lBQ3ZEUCxzQkFBc0JBO1FBQ3hCO1FBRUE7WUFDRWdCLGdCQUFnQkYsZUFBZSxHQUFHQTtRQUNwQztRQUVBLElBQUlMLHVCQUF1QjtRQUMzQixTQUFTYSx3QkFBd0J4c0IsYUFBYTtZQUM1QzJyQix1QkFBdUIzckI7UUFDekI7UUFFQSxTQUFTeXNCO1lBQ1AsTUFBTSxJQUFJcnJCLE1BQU07UUFDbEI7UUFFQSxTQUFTc3JCLGdCQUFnQkMsWUFBWTtZQUNuQyxNQUFNLElBQUl2ckIsTUFBTTtRQUNsQjtRQUVBLElBQUl3ckIseUJBQXlCO1lBQzNCSCxnQkFBZ0JBO1lBQ2hCQyxpQkFBaUJBO1FBQ25CO1FBRUEsU0FBU0csNkJBQTZCQyxjQUFjO1lBQ2xELElBQUk7Z0JBQ0YsSUFBSXJULE9BQU87Z0JBQ1gsSUFBSXNULE9BQU9EO2dCQUVYLEdBQUc7b0JBQ0QsT0FBUUMsS0FBSzNrQixHQUFHO3dCQUNkLEtBQUs7NEJBQ0hxUixRQUFRUSw4QkFBOEI4UyxLQUFLdjJDLElBQUksRUFBRSxNQUFNOzRCQUN2RDt3QkFFRixLQUFLOzRCQUNIaWpDLFFBQVFtQywrQkFBK0JtUixLQUFLdjJDLElBQUksRUFBRSxNQUFNOzRCQUN4RDt3QkFFRixLQUFLOzRCQUNIaWpDLFFBQVFpQyw0QkFBNEJxUixLQUFLdjJDLElBQUksRUFBRSxNQUFNOzRCQUNyRDtvQkFDSixFQUFFLCtEQUErRDtvQkFHakV1MkMsT0FBT0EsS0FBS3JPLE1BQU07Z0JBQ3BCLFFBQVNxTyxNQUFNO2dCQUVmLE9BQU90VDtZQUNULEVBQUUsT0FBTzFuQixHQUFHO2dCQUNWLE9BQU8sK0JBQStCQSxFQUFFbXJCLE9BQU8sR0FBRyxPQUFPbnJCLEVBQUV4ZSxLQUFLO1lBQ2xFO1FBQ0Y7UUFFQSxJQUFJeW1DLHlCQUF5QnpuQyxxQkFBcUJ5bkMsc0JBQXNCO1FBQ3hFLElBQUlnVCxvQkFBb0J6NkMscUJBQXFCeTZDLGlCQUFpQjtRQUM5RCxJQUFJMTVDLHlCQUF5QmYscUJBQXFCZSxzQkFBc0I7UUFDeEUsSUFBSTI1QyxVQUFVO1FBQ2QsSUFBSUMsWUFBWTtRQUNoQixJQUFJQyxVQUFVO1FBQ2QsSUFBSUMsVUFBVTtRQUNkLElBQUlDLFVBQVU7UUFDZCxJQUFJQyxPQUFPO1FBQ1gsSUFBSUMsVUFBVTtRQUNkLElBQUlDLFNBQVMsR0FBRyxvRkFBb0Y7UUFDcEcsdUZBQXVGO1FBQ3ZGLGlGQUFpRjtRQUNqRix1RkFBdUY7UUFDdkYsbUZBQW1GO1FBQ25GLG9FQUFvRTtRQUNwRSxrRkFBa0Y7UUFDbEYsbUZBQW1GO1FBQ25GLG1GQUFtRjtRQUNuRixxRkFBcUY7UUFDckYsc0ZBQXNGO1FBQ3RGLGlGQUFpRjtRQUNqRixpRkFBaUY7UUFDakYsU0FBUztRQUNULGdDQUFnQztRQUVoQyxJQUFJQyxpQ0FBaUM7UUFFckMsU0FBU0Msb0JBQW9CeDZDLEtBQUs7WUFDaENpQixPQUFPLENBQUMsUUFBUSxDQUFDakIsUUFBUSxpQ0FBaUM7WUFFMUQsT0FBTztRQUNUO1FBRUEsU0FBU3k2QyxRQUFRO1FBRWpCLFNBQVNDLGNBQWM5eEMsUUFBUSxFQUFFNmdCLFNBQVMsRUFBRXFELGFBQWEsRUFBRTZ0QixpQkFBaUIsRUFBRUMsb0JBQW9CLEVBQUV2b0IsT0FBTyxFQUFFd29CLFVBQVUsRUFBRUMsWUFBWSxFQUFFQyxZQUFZLEVBQUVDLFlBQVk7WUFDL0poekI7WUFDQSxJQUFJaXpCLGNBQWMsRUFBRTtZQUNwQixJQUFJQyxXQUFXLElBQUl2MkM7WUFDbkIsSUFBSTA3QixVQUFVO2dCQUNaaC9CLGFBQWE7Z0JBQ2I4NUMsZ0JBQWdCO2dCQUNoQnJ1QixlQUFlQTtnQkFDZjh0QixzQkFBc0JBLHlCQUF5Qmg2QixZQUFZMjVCLGlDQUFpQ0s7Z0JBQzVGNUcsUUFBUW9HO2dCQUNSZ0IsWUFBWTtnQkFDWkMsZUFBZTtnQkFDZkMsaUJBQWlCO2dCQUNqQkMsa0JBQWtCO2dCQUNsQjl4QixXQUFXQTtnQkFDWCt4QixzQkFBc0I7Z0JBQ3RCQyxnQkFBZ0JQO2dCQUNoQkQsYUFBYUE7Z0JBQ2JTLDBCQUEwQixFQUFFO2dCQUM1QkMscUJBQXFCLEVBQUU7Z0JBQ3ZCQyxtQkFBbUIsRUFBRTtnQkFDckJ2cEIsU0FBU0EsWUFBWXpSLFlBQVk0NUIsc0JBQXNCbm9CO2dCQUN2RHdvQixZQUFZQSxlQUFlajZCLFlBQVk2NUIsT0FBT0k7Z0JBQzlDQyxjQUFjQSxpQkFBaUJsNkIsWUFBWTY1QixPQUFPSztnQkFDbERDLGNBQWNBLGlCQUFpQm42QixZQUFZNjVCLE9BQU9NO2dCQUNsREMsY0FBY0EsaUJBQWlCcDZCLFlBQVk2NUIsT0FBT087WUFDcEQsR0FBRyw2Q0FBNkM7WUFFaEQsSUFBSWEsY0FBY0MscUJBQXFCemIsU0FBUyxHQUFHLE1BQU1zYSxtQkFDekQsT0FBTyxRQUFRLDZFQUE2RTtZQUU1RmtCLFlBQVlFLGFBQWEsR0FBRztZQUM1QixJQUFJQyxXQUFXQyxXQUFXNWIsU0FBUyxNQUFNejNCLFVBQVUsTUFBTWl6QyxhQUFhWCxVQUFVaFIsb0JBQW9CWSxxQkFBcUI2RztZQUN6SHNKLFlBQVl4NUMsSUFBSSxDQUFDdTZDO1lBQ2pCLE9BQU8zYjtRQUNUO1FBQ0EsSUFBSTZiLGlCQUFpQjtRQUNyQixTQUFTNWI7WUFDUCxJQUFJNGIsZ0JBQWdCLE9BQU9BO1lBRTNCLE9BQU87UUFDVDtRQUVBLFNBQVNDLFNBQVM5YixPQUFPLEVBQUUwVixJQUFJO1lBQzdCLElBQUlrRixjQUFjNWEsUUFBUTRhLFdBQVc7WUFDckNBLFlBQVl4NUMsSUFBSSxDQUFDczBDO1lBRWpCLElBQUkxVixRQUFRNGEsV0FBVyxDQUFDdDdDLE1BQU0sS0FBSyxHQUFHO2dCQUNwQzBnQyxRQUFROGEsY0FBYyxHQUFHOWEsUUFBUWgvQixXQUFXLEtBQUs7Z0JBQ2pESCxhQUFhO29CQUNYLE9BQU9rN0MsWUFBWS9iO2dCQUNyQjtZQUNGO1FBQ0Y7UUFFQSxTQUFTZ2MsdUJBQXVCaGMsT0FBTyxFQUFFaWMsc0JBQXNCO1lBQzdELE9BQU87Z0JBQ0w5d0MsSUFBSW9oQjtnQkFDSjJ2QixlQUFlLENBQUM7Z0JBQ2hCUixlQUFlO2dCQUNmUyxjQUFjO2dCQUNkQyxtQkFBbUI7Z0JBQ25CQyxtQkFBbUIsRUFBRTtnQkFDckJDLFVBQVU7Z0JBQ1ZMLHdCQUF3QkE7Z0JBQ3hCcmtCLGFBQWE7Z0JBQ2J4TyxXQUFXeVc7WUFDYjtRQUNGO1FBRUEsU0FBUytiLFdBQVc1YixPQUFPLEVBQUV1VCxhQUFhLEVBQUVpRyxJQUFJLEVBQUUrQyxlQUFlLEVBQUVDLGNBQWMsRUFBRTNCLFFBQVEsRUFBRTRCLGFBQWEsRUFBRS9YLE9BQU8sRUFBRXlULFdBQVc7WUFDOUhuWSxRQUFRaWIsZUFBZTtZQUV2QixJQUFJc0Isb0JBQW9CLE1BQU07Z0JBQzVCdmMsUUFBUWtiLGdCQUFnQjtZQUMxQixPQUFPO2dCQUNMcUIsZ0JBQWdCSixZQUFZO1lBQzlCO1lBRUEsSUFBSXpHLE9BQU87Z0JBQ1Q4RCxNQUFNQTtnQkFDTmtELE1BQU07b0JBQ0osT0FBT1osU0FBUzliLFNBQVMwVjtnQkFDM0I7Z0JBQ0E2RyxpQkFBaUJBO2dCQUNqQkMsZ0JBQWdCQTtnQkFDaEIzQixVQUFVQTtnQkFDVjRCLGVBQWVBO2dCQUNmL1gsU0FBU0E7Z0JBQ1R5VCxhQUFhQTtnQkFDYjVFLGVBQWVBO1lBQ2pCO1lBRUE7Z0JBQ0VtQyxLQUFLNkQsY0FBYyxHQUFHO1lBQ3hCO1lBRUFzQixTQUFTcG5CLEdBQUcsQ0FBQ2lpQjtZQUNiLE9BQU9BO1FBQ1Q7UUFFQSxTQUFTK0YscUJBQXFCemIsT0FBTyxFQUFFeGQsS0FBSyxFQUFFbTZCLFFBQVEsRUFBRTdyQixhQUFhLEVBQUUxRCxjQUFjLEVBQUVGLFlBQVk7WUFDakcsT0FBTztnQkFDTHltQixRQUFRK0Y7Z0JBQ1J2dUMsSUFBSSxDQUFDO2dCQUNMLHdCQUF3QjtnQkFDeEJxWCxPQUFPQTtnQkFDUGs1QixlQUFlO2dCQUNmM3hCLFFBQVEsRUFBRTtnQkFDVnhoQixVQUFVLEVBQUU7Z0JBQ1p1b0IsZUFBZUE7Z0JBQ2Y2ckIsVUFBVUE7Z0JBQ1Z2dkIsZ0JBQWdCQTtnQkFDaEJGLGNBQWNBO1lBQ2hCO1FBQ0YsRUFBRSw0REFBNEQ7UUFHOUQsSUFBSTB2QixtQkFBbUI7UUFFdkIsU0FBU0M7WUFDUDtnQkFDRSxJQUFJRCxxQkFBcUIsUUFBUUEsaUJBQWlCckQsY0FBYyxLQUFLLE1BQU07b0JBQ3pFLE9BQU87Z0JBQ1Q7Z0JBRUEsT0FBT0QsNkJBQTZCc0QsaUJBQWlCckQsY0FBYztZQUNyRTtRQUNGO1FBRUEsU0FBU3VELCtCQUErQnBILElBQUksRUFBRXp5QyxJQUFJO1lBQ2hEO2dCQUNFeXlDLEtBQUs2RCxjQUFjLEdBQUc7b0JBQ3BCMWtCLEtBQUs7b0JBQ0xzVyxRQUFRdUssS0FBSzZELGNBQWM7b0JBQzNCdDJDLE1BQU1BO2dCQUNSO1lBQ0Y7UUFDRjtRQUVBLFNBQVM4NUMsZ0NBQWdDckgsSUFBSSxFQUFFenlDLElBQUk7WUFDakQ7Z0JBQ0V5eUMsS0FBSzZELGNBQWMsR0FBRztvQkFDcEIxa0IsS0FBSztvQkFDTHNXLFFBQVF1SyxLQUFLNkQsY0FBYztvQkFDM0J0MkMsTUFBTUE7Z0JBQ1I7WUFDRjtRQUNGO1FBRUEsU0FBUys1Qyw2QkFBNkJ0SCxJQUFJLEVBQUV6eUMsSUFBSTtZQUM5QztnQkFDRXl5QyxLQUFLNkQsY0FBYyxHQUFHO29CQUNwQjFrQixLQUFLO29CQUNMc1csUUFBUXVLLEtBQUs2RCxjQUFjO29CQUMzQnQyQyxNQUFNQTtnQkFDUjtZQUNGO1FBQ0Y7UUFFQSxTQUFTZzZDLHVCQUF1QnZILElBQUk7WUFDbEM7Z0JBQ0UsSUFBSUEsS0FBSzZELGNBQWMsS0FBSyxNQUFNO29CQUNoQzU1QyxNQUFNO2dCQUNSLE9BQU87b0JBQ0wrMUMsS0FBSzZELGNBQWMsR0FBRzdELEtBQUs2RCxjQUFjLENBQUNwTyxNQUFNO2dCQUNsRDtZQUNGO1FBQ0YsRUFBRSx3RUFBd0U7UUFHMUUsSUFBSStSLHFDQUFxQztRQUV6QyxTQUFTQywrQkFBK0JSLFFBQVEsRUFBRWg5QyxLQUFLO1lBQ3JEO2dCQUNFLElBQUl3OEI7Z0JBRUosSUFBSSxPQUFPeDhCLFVBQVUsVUFBVTtvQkFDN0J3OEIsZUFBZXg4QjtnQkFDakIsT0FBTyxJQUFJQSxTQUFTLE9BQU9BLE1BQU1ncUMsT0FBTyxLQUFLLFVBQVU7b0JBQ3JEeE4sZUFBZXg4QixNQUFNZ3FDLE9BQU87Z0JBQzlCLE9BQU87b0JBQ0wsK0RBQStEO29CQUMvRHhOLGVBQWU3N0IsT0FBT1g7Z0JBQ3hCO2dCQUVBLElBQUltNEIsc0JBQXNCb2xCLHNDQUFzQ0w7Z0JBQ2hFSyxxQ0FBcUM7Z0JBQ3JDUCxTQUFTeGdCLFlBQVksR0FBR0E7Z0JBQ3hCd2dCLFNBQVM3a0IsbUJBQW1CLEdBQUdBO1lBQ2pDO1FBQ0Y7UUFFQSxTQUFTc2xCLG9CQUFvQnBkLE9BQU8sRUFBRXJnQyxLQUFLO1lBQ3pDLDZGQUE2RjtZQUM3RixrRUFBa0U7WUFDbEUsSUFBSWk0QixjQUFjb0ksUUFBUWhPLE9BQU8sQ0FBQ3J5QjtZQUVsQyxJQUFJaTRCLGVBQWUsUUFBUSxPQUFPQSxnQkFBZ0IsVUFBVTtnQkFDMUQsMkRBQTJEO2dCQUMzRCxNQUFNLElBQUkvSixNQUFNLG1NQUFzTSxPQUFPK0osY0FBYztZQUM3TztZQUVBLE9BQU9BO1FBQ1Q7UUFFQSxTQUFTbWpCLFdBQVcvYSxPQUFPLEVBQUVyZ0MsS0FBSztZQUNoQyxnRkFBZ0Y7WUFDaEYsMEVBQTBFO1lBQzFFLCtEQUErRDtZQUMvRCxJQUFJKzZDLGVBQWUxYSxRQUFRMGEsWUFBWTtZQUN2Q0EsYUFBYS82QztZQUNiLElBQUlnN0MsZUFBZTNhLFFBQVEyYSxZQUFZO1lBQ3ZDQSxhQUFhaDdDO1lBRWIsSUFBSXFnQyxRQUFRaC9CLFdBQVcsS0FBSyxNQUFNO2dCQUNoQ2cvQixRQUFRMlQsTUFBTSxHQUFHc0c7Z0JBQ2pCdDRDLGVBQWVxK0IsUUFBUWgvQixXQUFXLEVBQUVyQjtZQUN0QyxPQUFPO2dCQUNMcWdDLFFBQVEyVCxNQUFNLEdBQUdxRztnQkFDakJoYSxRQUFRK2EsVUFBVSxHQUFHcDdDO1lBQ3ZCO1FBQ0Y7UUFFQSxTQUFTMDlDLHVCQUF1QnJkLE9BQU8sRUFBRTBWLElBQUksRUFBRW53QyxLQUFLO1lBQ2xEdTNDLCtCQUErQnBILE1BQU07WUFDckMsSUFBSTRILGlCQUFpQjVILEtBQUs2RyxlQUFlO1lBQ3pDLElBQUlnQixnQkFBZ0I3SCxLQUFLOEcsY0FBYyxFQUFFLDhFQUE4RTtZQUN2SCwyRUFBMkU7WUFDM0UsMkVBQTJFO1lBQzNFLDREQUE0RDtZQUU1RCxJQUFJZ0IsV0FBV2o0QyxNQUFNaTRDLFFBQVE7WUFDN0IsSUFBSWg4QyxVQUFVK0QsTUFBTWdELFFBQVE7WUFDNUIsSUFBSWsxQyxtQkFBbUIsSUFBSW41QztZQUMzQixJQUFJbzVDLGNBQWMxQix1QkFBdUJoYyxTQUFTeWQ7WUFDbEQsSUFBSUUsaUJBQWlCSixjQUFjeHpCLE1BQU0sQ0FBQ3pxQixNQUFNLEVBQUUsaUVBQWlFO1lBRW5ILElBQUlzK0Msa0JBQWtCbkMscUJBQXFCemIsU0FBUzJkLGdCQUFnQkQsYUFBYUgsY0FBY3pzQixhQUFhLEVBQzVHLE9BQU87WUFDUHlzQixjQUFjaDFDLFFBQVEsQ0FBQ25ILElBQUksQ0FBQ3c4QyxrQkFBa0IsMEdBQTBHO1lBRXhKTCxjQUFjbndCLGNBQWMsR0FBRyxPQUFPLHFGQUFxRjtZQUUzSCxJQUFJeXdCLHFCQUFxQnBDLHFCQUFxQnpiLFNBQVMsR0FBRyxNQUFNdWQsY0FBY3pzQixhQUFhLEVBQzNGLE9BQU8sUUFBUSw4RkFBOEY7WUFDN0csbURBQW1EO1lBRW5EK3NCLG1CQUFtQm5DLGFBQWEsR0FBRyxNQUFNLDBGQUEwRjtZQUNuSSw4RkFBOEY7WUFDOUYsZ0RBQWdEO1lBQ2hELGtGQUFrRjtZQUNsRixzRkFBc0Y7WUFDdEYseUZBQXlGO1lBQ3pGLDZGQUE2RjtZQUU3RmhHLEtBQUs2RyxlQUFlLEdBQUdtQjtZQUN2QmhJLEtBQUs4RyxjQUFjLEdBQUdxQjtZQUV0QjtnQkFDRS9kLDZDQUE2Q0UsUUFBUTVXLFNBQVMsRUFBRXMwQixZQUFZdDBCLFNBQVM7WUFDdkY7WUFFQSxJQUFJO2dCQUNGLHFGQUFxRjtnQkFDckYwMEIsV0FBVzlkLFNBQVMwVixNQUFNbDBDO2dCQUMxQjRnQyxrQkFBa0J5YixtQkFBbUI5ekIsTUFBTSxFQUFFaVcsUUFBUXZULGFBQWEsRUFBRW94QixtQkFBbUJ6d0IsY0FBYyxFQUFFeXdCLG1CQUFtQjN3QixZQUFZO2dCQUN0STJ3QixtQkFBbUJsSyxNQUFNLEdBQUdnRztnQkFDNUJvRSxzQkFBc0JMLGFBQWFHO2dCQUVuQyxJQUFJSCxZQUFZdkIsWUFBWSxLQUFLLEdBQUc7b0JBQ2xDLDBGQUEwRjtvQkFDMUYsd0ZBQXdGO29CQUN4RixnQkFBZ0I7b0JBQ2hCYyx1QkFBdUJ2SDtvQkFDdkI7Z0JBQ0Y7WUFDRixFQUFFLE9BQU8vMUMsT0FBTztnQkFDZGsrQyxtQkFBbUJsSyxNQUFNLEdBQUdtRztnQkFDNUI0RCxZQUFZdEIsaUJBQWlCLEdBQUc7Z0JBQ2hDc0IsWUFBWTlsQixXQUFXLEdBQUd3bEIsb0JBQW9CcGQsU0FBU3JnQztnQkFFdkQ7b0JBQ0V3OUMsK0JBQStCTyxhQUFhLzlDO2dCQUM5QztZQUNBLGlGQUFpRjtZQUNqRiwyREFBMkQ7WUFFN0QsU0FBVTtnQkFDUjtvQkFDRW1nQyw2Q0FBNkNFLFFBQVE1VyxTQUFTLEVBQUVrMEIsaUJBQWlCQSxlQUFlbDBCLFNBQVMsR0FBRztnQkFDOUc7Z0JBRUFzc0IsS0FBSzZHLGVBQWUsR0FBR2U7Z0JBQ3ZCNUgsS0FBSzhHLGNBQWMsR0FBR2U7WUFDeEIsRUFBRSxtRkFBbUY7WUFDckYsdUVBQXVFO1lBR3ZFLElBQUlTLHdCQUF3QnBDLFdBQVc1YixTQUFTLE1BQU13ZCxVQUFVRixnQkFBZ0JNLGlCQUFpQkgsa0JBQWtCL0gsS0FBSytHLGFBQWEsRUFBRS9HLEtBQUtoUixPQUFPLEVBQUVnUixLQUFLeUMsV0FBVztZQUVySztnQkFDRTZGLHNCQUFzQnpFLGNBQWMsR0FBRzdELEtBQUs2RCxjQUFjO1lBQzVEO1lBQ0EsNEVBQTRFO1lBRzVFdlosUUFBUTRhLFdBQVcsQ0FBQ3g1QyxJQUFJLENBQUM0OEM7WUFDekJmLHVCQUF1QnZIO1FBQ3pCO1FBRUEsU0FBU3VJLGtCQUFrQmplLE9BQU8sRUFBRTBWLElBQUksRUFBRXp5QyxJQUFJLEVBQUVzQyxLQUFLO1lBQ25EdTNDLCtCQUErQnBILE1BQU16eUM7WUFDckMsSUFBSWk3QyxVQUFVeEksS0FBSzhHLGNBQWM7WUFDakMsSUFBSWowQyxXQUFXNHRCLGtCQUFrQituQixRQUFRbjBCLE1BQU0sRUFBRTltQixNQUFNc0MsT0FBT3k2QixRQUFRNVcsU0FBUyxFQUFFNFcsUUFBUXZULGFBQWEsRUFBRXl4QixRQUFRcHRCLGFBQWEsRUFBRW90QixRQUFROXdCLGNBQWM7WUFDcko4d0IsUUFBUTl3QixjQUFjLEdBQUc7WUFDekIsSUFBSSt3QixjQUFjRCxRQUFRcHRCLGFBQWE7WUFDdkNvdEIsUUFBUXB0QixhQUFhLEdBQUcxRSxzQkFBc0IreEIsYUFBYWw3QyxNQUFNc0MsUUFBUSwwRUFBMEU7WUFDbkosdURBQXVEO1lBRXZEdTRDLFdBQVc5ZCxTQUFTMFYsTUFBTW50QyxXQUFXLHlFQUF5RTtZQUM5RywyREFBMkQ7WUFFM0QyMUMsUUFBUXB0QixhQUFhLEdBQUdxdEI7WUFDeEI3bkIsZ0JBQWdCNG5CLFFBQVFuMEIsTUFBTSxFQUFFOW1CLE1BQU1zQyxPQUFPeTZCLFFBQVF2VCxhQUFhLEVBQUUweEI7WUFDcEVELFFBQVE5d0IsY0FBYyxHQUFHO1lBQ3pCNnZCLHVCQUF1QnZIO1FBQ3pCO1FBRUEsU0FBUzBJLGdCQUFnQjdWLFNBQVM7WUFDaEMsT0FBT0EsVUFBVTluQyxTQUFTLElBQUk4bkMsVUFBVTluQyxTQUFTLENBQUMrbkMsZ0JBQWdCO1FBQ3BFO1FBRUEsU0FBUzZWLGdCQUFnQnJlLE9BQU8sRUFBRTBWLElBQUksRUFBRUUsaUJBQWlCLEVBQUVyTixTQUFTLEVBQUVoakMsS0FBSyxFQUFFKzRDLFNBQVM7WUFDcEYsSUFBSTNJLG9CQUFvQixDQUFDO1lBQ3pCRixrQkFBa0JDLE1BQU1DLG1CQUFtQkM7WUFDM0MsSUFBSWg4QixTQUFTMnVCLFVBQVVoakMsT0FBTys0QztZQUM5QixPQUFPekksWUFBWXROLFdBQVdoakMsT0FBT3FVLFFBQVEwa0M7UUFDL0M7UUFFQSxTQUFTQyxxQkFBcUJ2ZSxPQUFPLEVBQUUwVixJQUFJLEVBQUV2TCxRQUFRLEVBQUU1QixTQUFTLEVBQUVoakMsS0FBSztZQUNyRSxJQUFJaTVDLGVBQWVyVSxTQUFTdEYsTUFBTTtZQUVsQztnQkFDRSxJQUFJc0YsU0FBUzVrQyxLQUFLLEtBQUtBLE9BQU87b0JBQzVCLElBQUksQ0FBQ2s1Qyw4QkFBOEI7d0JBQ2pDOStDLE1BQU0sMkVBQTJFLHlEQUF5RDhrQyx5QkFBeUI4RCxjQUFjO29CQUNuTDtvQkFFQWtXLCtCQUErQjtnQkFDakM7WUFDRjtZQUVBO2dCQUNFLElBQUlyVSxvQkFBb0I3QixVQUFVNkIsaUJBQWlCO2dCQUVuRCxJQUFJQSxzQkFBc0IsUUFBUUEsc0JBQXNCN3BCLFdBQVc7b0JBQ2pFLElBQUltK0Isa0JBQWtCaEosS0FBSytHLGFBQWE7b0JBQ3hDLElBQUlrQyxnQkFBZ0J6VSxvQkFBb0JDLFVBQVU1QixXQUFXbVcsaUJBQWlCdFU7b0JBQzlFc0wsS0FBSytHLGFBQWEsR0FBR2tDO29CQUNyQkMsc0JBQXNCNWUsU0FBUzBWLE1BQU0sTUFBTThJO29CQUMzQzlJLEtBQUsrRyxhQUFhLEdBQUdpQztvQkFDckI7Z0JBQ0Y7WUFDRjtZQUVBRSxzQkFBc0I1ZSxTQUFTMFYsTUFBTSxNQUFNOEk7UUFDN0M7UUFFQSxTQUFTSyxxQkFBcUI3ZSxPQUFPLEVBQUUwVixJQUFJLEVBQUVuTixTQUFTLEVBQUVoakMsS0FBSztZQUMzRHkzQyw2QkFBNkJ0SCxNQUFNbk47WUFDbkMsSUFBSXVXLGdCQUFnQi9VLGlCQUFpQnhCLFdBQVdtTixLQUFLK0csYUFBYTtZQUNsRSxJQUFJdFMsV0FBV3FFLHVCQUF1QmpHLFdBQVdoakMsT0FBT3U1QztZQUN4RDNOLG1CQUFtQmhILFVBQVU1QixXQUFXaGpDLE9BQU91NUM7WUFDL0NQLHFCQUFxQnZlLFNBQVMwVixNQUFNdkwsVUFBVTVCLFdBQVdoakM7WUFDekQwM0MsdUJBQXVCdkg7UUFDekI7UUFFQSxJQUFJcUosdUJBQXVCLENBQUM7UUFDNUIsSUFBSUMscUNBQXFDLENBQUM7UUFDMUMsSUFBSUMsNkNBQTZDLENBQUM7UUFDbEQsSUFBSUMsaURBQWlELENBQUM7UUFDdEQsSUFBSVQsK0JBQStCO1FBQ25DLElBQUlVLDhDQUE4QyxDQUFDO1FBQ25ELElBQUlDLHlCQUF5QjtRQUM3QixJQUFJQyxtQkFBbUI7UUFDdkIsSUFBSUMsdUNBQXVDLE9BQU8sbUZBQW1GO1FBQ3JJLDhCQUE4QjtRQUU5QixTQUFTQyw2QkFBNkJ2ZixPQUFPLEVBQUUwVixJQUFJLEVBQUVFLGlCQUFpQixFQUFFck4sU0FBUyxFQUFFaGpDLEtBQUs7WUFDdEYsSUFBSWszQztZQUVKO2dCQUNFQSxnQkFBZ0IxUyxpQkFBaUJ4QixXQUFXbU4sS0FBSytHLGFBQWE7WUFDaEU7WUFFQU0sZ0NBQWdDckgsTUFBTW5OO1lBRXRDO2dCQUNFLElBQUlBLFVBQVU5bkMsU0FBUyxJQUFJLE9BQU84bkMsVUFBVTluQyxTQUFTLENBQUNva0MsTUFBTSxLQUFLLFlBQVk7b0JBQzNFLElBQUl3RSxnQkFBZ0I1RSx5QkFBeUI4RCxjQUFjO29CQUUzRCxJQUFJLENBQUN3VyxvQkFBb0IsQ0FBQzFWLGNBQWMsRUFBRTt3QkFDeEMxcEMsTUFBTSwrRkFBK0YsZ0ZBQWdGMHBDLGVBQWVBO3dCQUVwTTBWLG9CQUFvQixDQUFDMVYsY0FBYyxHQUFHO29CQUN4QztnQkFDRjtZQUNGO1lBRUEsSUFBSXJuQyxRQUFRcThDLGdCQUFnQnJlLFNBQVMwVixNQUFNRSxtQkFBbUJyTixXQUFXaGpDLE9BQU9rM0M7WUFDaEYsSUFBSStDLFFBQVF2SjtZQUVaO2dCQUNFLDRFQUE0RTtnQkFDNUUsb0ZBQW9GO2dCQUNwRixJQUFJLE9BQU9qMEMsVUFBVSxZQUFZQSxVQUFVLFFBQVEsT0FBT0EsTUFBTTZpQyxNQUFNLEtBQUssY0FBYzdpQyxNQUFNZ3pCLFFBQVEsS0FBS3pVLFdBQVc7b0JBQ3JILElBQUlndkIsaUJBQWlCOUsseUJBQXlCOEQsY0FBYztvQkFFNUQsSUFBSSxDQUFDeVcsa0NBQWtDLENBQUN6UCxlQUFlLEVBQUU7d0JBQ3ZENXZDLE1BQU0sNEZBQTRGLGdFQUFnRSwyRkFBMkYsc0ZBQXNGLHlDQUF5QzR2QyxnQkFBZ0JBLGdCQUFnQkE7d0JBRTVaeVAsa0NBQWtDLENBQUN6UCxlQUFlLEdBQUc7b0JBQ3ZEO2dCQUNGO1lBQ0Y7WUFFQSxJQUNBLGtEQUFrRDtZQUNsRCxPQUFPdnRDLFVBQVUsWUFBWUEsVUFBVSxRQUFRLE9BQU9BLE1BQU02aUMsTUFBTSxLQUFLLGNBQWM3aUMsTUFBTWd6QixRQUFRLEtBQUt6VSxXQUFXO2dCQUNqSDtvQkFDRSxJQUFJay9CLGtCQUFrQmhiLHlCQUF5QjhELGNBQWM7b0JBRTdELElBQUksQ0FBQ3lXLGtDQUFrQyxDQUFDUyxnQkFBZ0IsRUFBRTt3QkFDeEQ5L0MsTUFBTSw0RkFBNEYsZ0VBQWdFLDJGQUEyRixzRkFBc0YseUNBQXlDOC9DLGlCQUFpQkEsaUJBQWlCQTt3QkFFOVpULGtDQUFrQyxDQUFDUyxnQkFBZ0IsR0FBRztvQkFDeEQ7Z0JBQ0Y7Z0JBRUF0TyxtQkFBbUJudkMsT0FBT3VtQyxXQUFXaGpDLE9BQU9rM0M7Z0JBQzVDOEIscUJBQXFCdmUsU0FBUzBWLE1BQU0xekMsT0FBT3VtQyxXQUFXaGpDO1lBQ3hELE9BQU87Z0JBRUw7b0JBQ0VtNkMsK0JBQStCblg7Z0JBQ2pDO2dCQUNBLCtFQUErRTtnQkFHL0UsSUFBSWlYLE9BQU87b0JBQ1QsMEVBQTBFO29CQUMxRSx5QkFBeUI7b0JBQ3pCLElBQUlHLGtCQUFrQmpLLEtBQUt5QyxXQUFXO29CQUN0QyxJQUFJdkcsZ0JBQWdCO29CQUNwQixJQUFJcHZCLFFBQVE7b0JBQ1prekIsS0FBS3lDLFdBQVcsR0FBR3pHLGdCQUFnQmlPLGlCQUFpQi9OLGVBQWVwdkI7b0JBRW5FLElBQUk7d0JBQ0ZvOEIsc0JBQXNCNWUsU0FBUzBWLE1BQU0sTUFBTTF6QztvQkFDN0MsU0FBVTt3QkFDUjB6QyxLQUFLeUMsV0FBVyxHQUFHd0g7b0JBQ3JCO2dCQUNGLE9BQU87b0JBQ0xmLHNCQUFzQjVlLFNBQVMwVixNQUFNLE1BQU0xekM7Z0JBQzdDO1lBQ0Y7WUFFQWk3Qyx1QkFBdUJ2SDtRQUN6QjtRQUVBLFNBQVNnSywrQkFBK0JuWCxTQUFTO1lBQy9DO2dCQUNFLElBQUlBLFdBQVc7b0JBQ2IsSUFBSUEsVUFBVTZCLGlCQUFpQixFQUFFO3dCQUMvQnpxQyxNQUFNLHlFQUF5RTRvQyxVQUFVakUsV0FBVyxJQUFJaUUsVUFBVXJsQyxJQUFJLElBQUk7b0JBQzVIO2dCQUNGO2dCQUVBLElBQUlxbEMsVUFBVWdJLFlBQVksS0FBS2h3QixXQUFXO29CQUN4QyxJQUFJOG9CLGdCQUFnQjVFLHlCQUF5QjhELGNBQWM7b0JBRTNELElBQUksQ0FBQzRXLDJDQUEyQyxDQUFDOVYsY0FBYyxFQUFFO3dCQUMvRDFwQyxNQUFNLDJFQUEyRSx5RUFBeUUwcEM7d0JBRTFKOFYsMkNBQTJDLENBQUM5VixjQUFjLEdBQUc7b0JBQy9EO2dCQUNGO2dCQUVBLElBQUksT0FBT2QsVUFBVTZGLHdCQUF3QixLQUFLLFlBQVk7b0JBQzVELElBQUl3UixrQkFBa0JuYix5QkFBeUI4RCxjQUFjO29CQUU3RCxJQUFJLENBQUMyVyw4Q0FBOEMsQ0FBQ1UsZ0JBQWdCLEVBQUU7d0JBQ3BFamdELE1BQU0sb0VBQW9FaWdEO3dCQUUxRVYsOENBQThDLENBQUNVLGdCQUFnQixHQUFHO29CQUNwRTtnQkFDRjtnQkFFQSxJQUFJLE9BQU9yWCxVQUFVbUcsV0FBVyxLQUFLLFlBQVluRyxVQUFVbUcsV0FBVyxLQUFLLE1BQU07b0JBQy9FLElBQUltUixrQkFBa0JwYix5QkFBeUI4RCxjQUFjO29CQUU3RCxJQUFJLENBQUMwVywwQ0FBMEMsQ0FBQ1ksZ0JBQWdCLEVBQUU7d0JBQ2hFbGdELE1BQU0sdURBQXVEa2dEO3dCQUU3RFosMENBQTBDLENBQUNZLGdCQUFnQixHQUFHO29CQUNoRTtnQkFDRjtZQUNGO1FBQ0Y7UUFFQSxTQUFTQyxvQkFBb0J2WCxTQUFTLEVBQUV3WCxTQUFTO1lBQy9DLElBQUl4WCxhQUFhQSxVQUFVZ0ksWUFBWSxFQUFFO2dCQUN2QyxpREFBaUQ7Z0JBQ2pELElBQUlockMsUUFBUTNDLE9BQU8sQ0FBQyxHQUFHbTlDO2dCQUN2QixJQUFJeFAsZUFBZWhJLFVBQVVnSSxZQUFZO2dCQUV6QyxJQUFLLElBQUk5c0MsWUFBWThzQyxhQUFjO29CQUNqQyxJQUFJaHJDLEtBQUssQ0FBQzlCLFNBQVMsS0FBSzhjLFdBQVc7d0JBQ2pDaGIsS0FBSyxDQUFDOUIsU0FBUyxHQUFHOHNDLFlBQVksQ0FBQzlzQyxTQUFTO29CQUMxQztnQkFDRjtnQkFFQSxPQUFPOEI7WUFDVDtZQUVBLE9BQU93NkM7UUFDVDtRQUVBLFNBQVNDLGlCQUFpQmhnQixPQUFPLEVBQUUwVixJQUFJLEVBQUVFLGlCQUFpQixFQUFFM3lDLElBQUksRUFBRXNDLEtBQUssRUFBRWd5QyxHQUFHO1lBQzFFd0YsZ0NBQWdDckgsTUFBTXp5QyxLQUFLNGhDLE1BQU07WUFDakQsSUFBSXQ4QixXQUFXODFDLGdCQUFnQnJlLFNBQVMwVixNQUFNRSxtQkFBbUIzeUMsS0FBSzRoQyxNQUFNLEVBQUV0L0IsT0FBT2d5QztZQUNyRixJQUFJaUksUUFBUXZKO1lBRVosSUFBSXVKLE9BQU87Z0JBQ1QsMEVBQTBFO2dCQUMxRSx5QkFBeUI7Z0JBQ3pCLElBQUlHLGtCQUFrQmpLLEtBQUt5QyxXQUFXO2dCQUN0QyxJQUFJdkcsZ0JBQWdCO2dCQUNwQixJQUFJcHZCLFFBQVE7Z0JBQ1prekIsS0FBS3lDLFdBQVcsR0FBR3pHLGdCQUFnQmlPLGlCQUFpQi9OLGVBQWVwdkI7Z0JBRW5FLElBQUk7b0JBQ0ZvOEIsc0JBQXNCNWUsU0FBUzBWLE1BQU0sTUFBTW50QztnQkFDN0MsU0FBVTtvQkFDUm10QyxLQUFLeUMsV0FBVyxHQUFHd0g7Z0JBQ3JCO1lBQ0YsT0FBTztnQkFDTGYsc0JBQXNCNWUsU0FBUzBWLE1BQU0sTUFBTW50QztZQUM3QztZQUVBMDBDLHVCQUF1QnZIO1FBQ3pCO1FBRUEsU0FBU3VLLFdBQVdqZ0IsT0FBTyxFQUFFMFYsSUFBSSxFQUFFRSxpQkFBaUIsRUFBRTN5QyxJQUFJLEVBQUVzQyxLQUFLLEVBQUVneUMsR0FBRztZQUNwRSxJQUFJblQsWUFBWW5oQyxLQUFLQSxJQUFJO1lBQ3pCLElBQUlpOUMsZ0JBQWdCSixvQkFBb0IxYixXQUFXNytCO1lBQ25ENDZDLGNBQWNuZ0IsU0FBUzBWLE1BQU1FLG1CQUFtQnhSLFdBQVc4YixlQUFlM0k7UUFDNUU7UUFFQSxTQUFTNkksc0JBQXNCcGdCLE9BQU8sRUFBRTBWLElBQUksRUFBRWhSLE9BQU8sRUFBRW4vQixLQUFLO1lBQzFELHdFQUF3RTtZQUN4RSx1RUFBdUU7WUFDdkUsMkVBQTJFO1lBQzNFLHVFQUF1RTtZQUN2RSx1RUFBdUU7WUFDdkUseUVBQXlFO1lBQ3pFLHNFQUFzRTtZQUN0RTtnQkFDRSxJQUFJbS9CLFFBQVFFLFFBQVEsS0FBS3JrQixXQUFXO29CQUNsQywrREFBK0Q7b0JBQy9ELHNFQUFzRTtvQkFDdEUsdURBQXVEO29CQUN2RCxJQUFJbWtCLFlBQVlBLFFBQVEyYixRQUFRLEVBQUU7d0JBQ2hDLElBQUksQ0FBQ2Ysc0NBQXNDOzRCQUN6Q0EsdUNBQXVDOzRCQUV2QzMvQyxNQUFNLDBFQUEwRTt3QkFDbEY7b0JBQ0Y7Z0JBQ0YsT0FBTztvQkFDTCtrQyxVQUFVQSxRQUFRRSxRQUFRO2dCQUM1QjtZQUNGO1lBRUEsSUFBSUMsU0FBU3QvQixNQUFNZ0QsUUFBUTtZQUUzQjtnQkFDRSxJQUFJLE9BQU9zOEIsV0FBVyxZQUFZO29CQUNoQ2xsQyxNQUFNLHdFQUF3RSxzRUFBc0UscUVBQXFFO2dCQUMzTjtZQUNGO1lBRUEsSUFBSTZrQixXQUFXK25CLGNBQWM3SDtZQUM3QixJQUFJNGIsY0FBY3piLE9BQU9yZ0I7WUFDekJvNkIsc0JBQXNCNWUsU0FBUzBWLE1BQU0sTUFBTTRLO1FBQzdDO1FBRUEsU0FBU0Msc0JBQXNCdmdCLE9BQU8sRUFBRTBWLElBQUksRUFBRXp5QyxJQUFJLEVBQUVzQyxLQUFLO1lBQ3ZELElBQUltL0IsVUFBVXpoQyxLQUFLMmhDLFFBQVE7WUFDM0IsSUFBSTVpQyxRQUFRdUQsTUFBTXZELEtBQUs7WUFDdkIsSUFBSXVHLFdBQVdoRCxNQUFNZ0QsUUFBUTtZQUM3QixJQUFJNGpDO1lBRUo7Z0JBQ0VBLGVBQWV1SixLQUFLaFIsT0FBTztZQUM3QjtZQUVBZ1IsS0FBS2hSLE9BQU8sR0FBR2tILGFBQWFsSCxTQUFTMWlDO1lBQ3JDNDhDLHNCQUFzQjVlLFNBQVMwVixNQUFNLE1BQU1udEM7WUFDM0NtdEMsS0FBS2hSLE9BQU8sR0FBR3dILFlBQVl4SDtZQUUzQjtnQkFDRSxJQUFJeUgsaUJBQWlCdUosS0FBS2hSLE9BQU8sRUFBRTtvQkFDakMva0MsTUFBTTtnQkFDUjtZQUNGO1FBQ0Y7UUFFQSxTQUFTNmdELG9CQUFvQnhnQixPQUFPLEVBQUUwVixJQUFJLEVBQUVFLGlCQUFpQixFQUFFN1EsYUFBYSxFQUFFeC9CLEtBQUssRUFBRWd5QyxHQUFHO1lBQ3RGdUYsK0JBQStCcEgsTUFBTTtZQUNyQyxJQUFJMVEsVUFBVUQsY0FBY0UsUUFBUTtZQUNwQyxJQUFJQyxPQUFPSCxjQUFjSSxLQUFLO1lBQzlCLElBQUlvRCxZQUFZckQsS0FBS0Y7WUFDckIsSUFBSWtiLGdCQUFnQkosb0JBQW9CdlgsV0FBV2hqQztZQUNuRDQ2QyxjQUFjbmdCLFNBQVMwVixNQUFNRSxtQkFBbUJyTixXQUFXMlgsZUFBZTNJO1lBQzFFMEYsdUJBQXVCdkg7UUFDekI7UUFFQSxTQUFTK0ssZ0JBQWdCemdCLE9BQU8sRUFBRTBWLElBQUksRUFBRW53QyxLQUFLO1lBQzNDLElBQUk4UixPQUFPOVIsTUFBTThSLElBQUk7WUFFckIsSUFBSUEsU0FBUztpQkFBaUI7Z0JBQzVCLHFFQUFxRTtnQkFDckUsb0JBQW9CO2dCQUNwQnVuQyxzQkFBc0I1ZSxTQUFTMFYsTUFBTSxNQUFNbndDLE1BQU1nRCxRQUFRO1lBQzNEO1FBQ0Y7UUFFQSxTQUFTNDNDLGNBQWNuZ0IsT0FBTyxFQUFFMFYsSUFBSSxFQUFFRSxpQkFBaUIsRUFBRTN5QyxJQUFJLEVBQUVzQyxLQUFLLEVBQUVneUMsR0FBRztZQUN2RSxJQUFJLE9BQU90MEMsU0FBUyxZQUFZO2dCQUM5QixJQUFJbTdDLGdCQUFnQm43QyxPQUFPO29CQUN6QjQ3QyxxQkFBcUI3ZSxTQUFTMFYsTUFBTXp5QyxNQUFNc0M7b0JBQzFDO2dCQUNGLE9BQU87b0JBQ0xnNkMsNkJBQTZCdmYsU0FBUzBWLE1BQU1FLG1CQUFtQjN5QyxNQUFNc0M7b0JBQ3JFO2dCQUNGO1lBQ0Y7WUFFQSxJQUFJLE9BQU90QyxTQUFTLFVBQVU7Z0JBQzVCZzdDLGtCQUFrQmplLFNBQVMwVixNQUFNenlDLE1BQU1zQztnQkFDdkM7WUFDRjtZQUVBLE9BQVF0QztnQkFDTix1RUFBdUU7Z0JBQ3ZFLDJFQUEyRTtnQkFDM0UsNEVBQTRFO2dCQUM1RSwwRUFBMEU7Z0JBQzFFLDBFQUEwRTtnQkFDMUUsc0VBQXNFO2dCQUN0RSxzRUFBc0U7Z0JBQ3RFLDJFQUEyRTtnQkFDM0UscUVBQXFFO2dCQUNyRSxLQUFLd2dDO2dCQUNMLEtBQUtGO2dCQUNMLEtBQUtYO2dCQUNMLEtBQUtDO2dCQUNMLEtBQUtGO29CQUNIO3dCQUNFaWMsc0JBQXNCNWUsU0FBUzBWLE1BQU0sTUFBTW53QyxNQUFNZ0QsUUFBUTt3QkFDekQ7b0JBQ0Y7Z0JBRUYsS0FBS2k3QjtvQkFDSDt3QkFDRWlkLGdCQUFnQnpnQixTQUFTMFYsTUFBTW53Qzt3QkFDL0I7b0JBQ0Y7Z0JBRUYsS0FBSzQ5QjtvQkFDSDt3QkFDRTJaLCtCQUErQnBILE1BQU0saUJBQWlCLG9EQUFvRDt3QkFFMUdrSixzQkFBc0I1ZSxTQUFTMFYsTUFBTSxNQUFNbndDLE1BQU1nRCxRQUFRO3dCQUN6RDAwQyx1QkFBdUJ2SDt3QkFDdkI7b0JBQ0Y7Z0JBRUYsS0FBS3BTO29CQUNIO3dCQUVFLE1BQU0sSUFBSXpWLE1BQU07b0JBQ2xCO2dCQUVGLEtBQUtxVjtvQkFDSDt3QkFDRTs0QkFDRW1hLHVCQUF1QnJkLFNBQVMwVixNQUFNbndDO3dCQUN4Qzt3QkFFQTtvQkFDRjtZQUNKO1lBRUEsSUFBSSxPQUFPdEMsU0FBUyxZQUFZQSxTQUFTLE1BQU07Z0JBQzdDLE9BQVFBLEtBQUsreEIsUUFBUTtvQkFDbkIsS0FBS2lPO3dCQUNIOzRCQUNFK2MsaUJBQWlCaGdCLFNBQVMwVixNQUFNRSxtQkFBbUIzeUMsTUFBTXNDLE9BQU9neUM7NEJBQ2hFO3dCQUNGO29CQUVGLEtBQUtuVTt3QkFDSDs0QkFDRTZjLFdBQVdqZ0IsU0FBUzBWLE1BQU1FLG1CQUFtQjN5QyxNQUFNc0MsT0FBT2d5Qzs0QkFDMUQ7d0JBQ0Y7b0JBRUYsS0FBS3pVO3dCQUNIOzRCQUNFeWQsc0JBQXNCdmdCLFNBQVMwVixNQUFNenlDLE1BQU1zQzs0QkFDM0M7d0JBQ0Y7b0JBRUYsS0FBS3c5Qjt3QkFDSDs0QkFDRXFkLHNCQUFzQnBnQixTQUFTMFYsTUFBTXp5QyxNQUFNc0M7NEJBQzNDO3dCQUNGO29CQUVGLEtBQUs4OUI7d0JBQ0g7NEJBQ0VtZCxvQkFBb0J4Z0IsU0FBUzBWLE1BQU1FLG1CQUFtQjN5QyxNQUFNc0M7NEJBQzVEO3dCQUNGO2dCQUNKO1lBQ0Y7WUFFQSxJQUFJMmdDLE9BQU87WUFFWDtnQkFDRSxJQUFJampDLFNBQVNzZCxhQUFhLE9BQU90ZCxTQUFTLFlBQVlBLFNBQVMsUUFBUWhCLE9BQU9xaUIsSUFBSSxDQUFDcmhCLE1BQU0zRCxNQUFNLEtBQUssR0FBRztvQkFDckc0bUMsUUFBUSwrREFBK0QsNkRBQTZEO2dCQUN0STtZQUNGO1lBRUEsTUFBTSxJQUFJclksTUFBTSw4REFBOEQsZ0VBQWlFLGVBQWU1cUIsQ0FBQUEsUUFBUSxPQUFPQSxPQUFPLE9BQU9BLElBQUcsSUFBSyxNQUFNaWpDLElBQUc7UUFDOU0sRUFBRSxrQ0FBa0M7UUFHcEMsU0FBU3dhLGlCQUFpQkMsUUFBUSxFQUFFQyxVQUFVO1lBQzVDO2dCQUNFLGlFQUFpRTtnQkFDakUscURBQXFEO2dCQUNyRCxJQUFJLE9BQU83OUMsV0FBVyxjQUFjNDlDLFFBQVEsQ0FBQzU5QyxPQUFPQyxXQUFXLENBQUMsS0FBSyxhQUFhO29CQUNoRixJQUFJLENBQUNvOEMsd0JBQXdCO3dCQUMzQnovQyxNQUFNLHVFQUF1RSxvRUFBb0UsK0RBQStELDJEQUEyRDtvQkFDN1E7b0JBRUF5L0MseUJBQXlCO2dCQUMzQixFQUFFLG9DQUFvQztnQkFHdEMsSUFBSXVCLFNBQVNFLE9BQU8sS0FBS0QsWUFBWTtvQkFDbkMsSUFBSSxDQUFDdkIsa0JBQWtCO3dCQUNyQjEvQyxNQUFNLDhDQUE4QztvQkFDdEQ7b0JBRUEwL0MsbUJBQW1CO2dCQUNyQjtZQUNGO1FBQ0Y7UUFFQSxTQUFTVCxzQkFBc0I1ZSxPQUFPLEVBQUUwVixJQUFJLEVBQzVDLGdEQUFnRDtRQUNoREUsaUJBQWlCLEVBQUU0RCxJQUFJO1lBQ3JCO2dCQUNFLDhFQUE4RTtnQkFDOUUsbUZBQW1GO2dCQUNuRiw2RUFBNkU7Z0JBQzdFLElBQUk7b0JBQ0YsT0FBT3NILDBCQUEwQjlnQixTQUFTMFYsTUFBTUUsbUJBQW1CNEQ7Z0JBQ3JFLEVBQUUsT0FBT2g3QixHQUFHO29CQUNWLElBQUksT0FBT0EsTUFBTSxZQUFZQSxNQUFNLFFBQVEsT0FBT0EsRUFBRWsxQixJQUFJLEtBQUs7eUJBQW1CO3dCQUM5RSw2REFBNkQ7d0JBQzdEd0oscUNBQXFDQSx1Q0FBdUMsT0FBT0EscUNBQXFDTDtvQkFDMUgsRUFBRSx1RUFBdUU7b0JBR3pFLE1BQU1yK0I7Z0JBQ1I7WUFDRjtRQUNGLEVBQUUsK0VBQStFO1FBQ2pGLHlDQUF5QztRQUd6QyxTQUFTc2lDLDBCQUEwQjlnQixPQUFPLEVBQUUwVixJQUFJLEVBQUVFLGlCQUFpQixFQUFFNEQsSUFBSTtZQUN2RSx3RUFBd0U7WUFDeEUsc0JBQXNCO1lBQ3RCOUQsS0FBSzhELElBQUksR0FBR0EsTUFBTSxzQkFBc0I7WUFFeEMsSUFBSSxPQUFPQSxTQUFTLFlBQVlBLFNBQVMsTUFBTTtnQkFDN0MsT0FBUUEsS0FBS3hrQixRQUFRO29CQUNuQixLQUFLeU47d0JBQ0g7NEJBQ0UsSUFBSW9HLFVBQVUyUTs0QkFDZCxJQUFJdjJDLE9BQU80bEMsUUFBUTVsQyxJQUFJOzRCQUN2QixJQUFJc0MsUUFBUXNqQyxRQUFRdGpDLEtBQUs7NEJBQ3pCLElBQUlneUMsTUFBTTFPLFFBQVEwTyxHQUFHOzRCQUNyQjRJLGNBQWNuZ0IsU0FBUzBWLE1BQU1FLG1CQUFtQjN5QyxNQUFNc0MsT0FBT2d5Qzs0QkFDN0Q7d0JBQ0Y7b0JBRUYsS0FBSzdVO3dCQUNILE1BQU0sSUFBSTdVLE1BQU0saUVBQWlFO29CQUVuRixLQUFLd1Y7d0JBQ0g7NEJBQ0UsSUFBSTBkLFdBQVd2SDs0QkFDZixJQUFJeFUsVUFBVStiLFNBQVM5YixRQUFROzRCQUMvQixJQUFJQyxPQUFPNmIsU0FBUzViLEtBQUs7NEJBQ3pCLElBQUk2Yjs0QkFFSjtnQ0FDRSxJQUFJO29DQUNGQSxlQUFlOWIsS0FBS0Y7Z0NBQ3RCLEVBQUUsT0FBT3htQixHQUFHO29DQUNWLElBQUksT0FBT0EsTUFBTSxZQUFZQSxNQUFNLFFBQVEsT0FBT0EsRUFBRWsxQixJQUFJLEtBQUssWUFBWTt3Q0FDdkUsMEZBQTBGO3dDQUMxRixtR0FBbUc7d0NBQ25HLDBGQUEwRjt3Q0FDMUYsc0JBQXNCO3dDQUN0Qm9KLCtCQUErQnBILE1BQU07b0NBQ3ZDO29DQUVBLE1BQU1sM0I7Z0NBQ1I7NEJBQ0Y7NEJBRUFvZ0Msc0JBQXNCNWUsU0FBUzBWLE1BQU0sTUFBTXNMOzRCQUMzQzt3QkFDRjtnQkFDSjtnQkFFQSxJQUFJeDlCLFFBQVFnMkIsT0FBTztvQkFDakJ5SCxvQkFBb0JqaEIsU0FBUzBWLE1BQU04RDtvQkFDbkM7Z0JBQ0Y7Z0JBRUEsSUFBSW9ILGFBQWE3YyxjQUFjeVY7Z0JBRS9CLElBQUlvSCxZQUFZO29CQUNkO3dCQUNFRixpQkFBaUJsSCxNQUFNb0g7b0JBQ3pCO29CQUVBLElBQUkvYyxXQUFXK2MsV0FBV2pnRCxJQUFJLENBQUM2NEM7b0JBRS9CLElBQUkzVixVQUFVO3dCQUNaLHNFQUFzRTt3QkFDdEUsc0VBQXNFO3dCQUN0RSxtRUFBbUU7d0JBQ25FLDhEQUE4RDt3QkFDOUQsd0JBQXdCO3dCQUN4QixJQUFJdjBCLE9BQU91MEIsU0FBU21ILElBQUksSUFBSSxtRkFBbUY7d0JBRS9HLElBQUksQ0FBQzE3QixLQUFLNHhDLElBQUksRUFBRTs0QkFDZCxJQUFJMzRDLFdBQVcsRUFBRTs0QkFFakIsR0FBRztnQ0FDREEsU0FBU25ILElBQUksQ0FBQ2tPLEtBQUt0TixLQUFLO2dDQUN4QnNOLE9BQU91MEIsU0FBU21ILElBQUk7NEJBQ3RCLFFBQVMsQ0FBQzE3QixLQUFLNHhDLElBQUksRUFBRTs0QkFFckJELG9CQUFvQmpoQixTQUFTMFYsTUFBTW50Qzs0QkFDbkM7d0JBQ0Y7d0JBRUE7b0JBQ0Y7Z0JBQ0YsRUFBRSx5RUFBeUU7Z0JBQzNFLHlFQUF5RTtnQkFDekUscUVBQXFFO2dCQUNyRSw4REFBOEQ7Z0JBQzlELEVBQUU7Z0JBQ0YsdUVBQXVFO2dCQUN2RSxzQ0FBc0M7Z0JBQ3RDLEVBQUU7Z0JBQ0YscURBQXFEO2dCQUdyRCxJQUFJNDRDLGNBQWMzSDtnQkFFbEIsSUFBSSxPQUFPMkgsWUFBWXpOLElBQUksS0FBSyxZQUFZO29CQUMxQyxJQUFJRixXQUFXMk47b0JBQ2YsT0FBT0wsMEJBQTBCOWdCLFNBQVMwVixNQUFNLE1BQU02QyxlQUFlL0U7Z0JBQ3ZFO2dCQUVBLElBQUkyTixZQUFZbnNCLFFBQVEsS0FBSytOLHNCQUFzQm9lLFlBQVluc0IsUUFBUSxLQUFLZ08sMkJBQTJCO29CQUNyRyxJQUFJMEIsVUFBVXljO29CQUNkLE9BQU9MLDBCQUEwQjlnQixTQUFTMFYsTUFBTSxNQUFNbkosY0FBYzdIO2dCQUN0RSxFQUFFLCtCQUErQjtnQkFHakMsSUFBSTBjLGNBQWNuL0MsT0FBT3hCLFNBQVMsQ0FBQ2tzQixRQUFRLENBQUNoc0IsSUFBSSxDQUFDNjRDO2dCQUNqRCxNQUFNLElBQUkzckIsTUFBTSxvREFBcUR1ekIsQ0FBQUEsZ0JBQWdCLG9CQUFvQix1QkFBdUJuL0MsT0FBT3FpQixJQUFJLENBQUNrMUIsTUFBTTN5QyxJQUFJLENBQUMsUUFBUSxNQUFNdTZDLFdBQVUsSUFBSyxRQUFRLG1FQUFtRTtZQUNqUTtZQUVBLElBQUksT0FBTzVILFNBQVMsVUFBVTtnQkFDNUIsSUFBSTBFLFVBQVV4SSxLQUFLOEcsY0FBYztnQkFDakMwQixRQUFROXdCLGNBQWMsR0FBRytVLGlCQUFpQnVULEtBQUs4RyxjQUFjLENBQUN6eUIsTUFBTSxFQUFFeXZCLE1BQU14WixRQUFRdlQsYUFBYSxFQUFFeXhCLFFBQVE5d0IsY0FBYztnQkFDekg7WUFDRjtZQUVBLElBQUksT0FBT29zQixTQUFTLFVBQVU7Z0JBQzVCLElBQUk2SCxXQUFXM0wsS0FBSzhHLGNBQWM7Z0JBQ2xDNkUsU0FBU2owQixjQUFjLEdBQUcrVSxpQkFBaUJ1VCxLQUFLOEcsY0FBYyxDQUFDenlCLE1BQU0sRUFBRSxLQUFLeXZCLE1BQU14WixRQUFRdlQsYUFBYSxFQUFFNDBCLFNBQVNqMEIsY0FBYztnQkFDaEk7WUFDRjtZQUVBO2dCQUNFLElBQUksT0FBT29zQixTQUFTLFlBQVk7b0JBQzlCNzVDLE1BQU0sa0VBQWtFLGtFQUFrRTtnQkFDNUk7WUFDRjtRQUNGO1FBRUEsU0FBU3NoRCxvQkFBb0JqaEIsT0FBTyxFQUFFMFYsSUFBSSxFQUFFbnRDLFFBQVE7WUFDbEQsSUFBSXFwQyxnQkFBZ0JycEMsU0FBU2pKLE1BQU07WUFFbkMsSUFBSyxJQUFJaWxCLElBQUksR0FBR0EsSUFBSXF0QixlQUFlcnRCLElBQUs7Z0JBQ3RDLElBQUlvN0Isa0JBQWtCakssS0FBS3lDLFdBQVc7Z0JBQ3RDekMsS0FBS3lDLFdBQVcsR0FBR3pHLGdCQUFnQmlPLGlCQUFpQi9OLGVBQWVydEI7Z0JBRW5FLElBQUk7b0JBQ0YseUVBQXlFO29CQUN6RSxtREFBbUQ7b0JBQ25EdTVCLFdBQVc5ZCxTQUFTMFYsTUFBTW50QyxRQUFRLENBQUNnYyxFQUFFO2dCQUN2QyxTQUFVO29CQUNSbXhCLEtBQUt5QyxXQUFXLEdBQUd3SDtnQkFDckI7WUFDRjtRQUNGO1FBRUEsU0FBUzJCLHNCQUFzQnRoQixPQUFPLEVBQUUwVixJQUFJLEVBQUVuQyxhQUFhLEVBQUUvMEIsQ0FBQztZQUM1RCxnRkFBZ0Y7WUFDaEYsSUFBSTAvQixVQUFVeEksS0FBSzhHLGNBQWM7WUFDakMsSUFBSW1CLGlCQUFpQk8sUUFBUW4wQixNQUFNLENBQUN6cUIsTUFBTTtZQUMxQyxJQUFJaWlELGFBQWE5RixxQkFBcUJ6YixTQUFTMmQsZ0JBQWdCLE1BQU1PLFFBQVFwdEIsYUFBYSxFQUMxRm90QixRQUFROXdCLGNBQWMsRUFDdEI7WUFDQTh3QixRQUFRMzFDLFFBQVEsQ0FBQ25ILElBQUksQ0FBQ21nRCxhQUFhLCtFQUErRTtZQUVsSHJELFFBQVE5d0IsY0FBYyxHQUFHO1lBQ3pCLElBQUlvMEIsVUFBVTVGLFdBQVc1YixTQUFTdVQsZUFBZW1DLEtBQUs4RCxJQUFJLEVBQUU5RCxLQUFLNkcsZUFBZSxFQUFFZ0YsWUFBWTdMLEtBQUttRixRQUFRLEVBQUVuRixLQUFLK0csYUFBYSxFQUFFL0csS0FBS2hSLE9BQU8sRUFBRWdSLEtBQUt5QyxXQUFXO1lBRS9KO2dCQUNFLElBQUl6QyxLQUFLNkQsY0FBYyxLQUFLLE1BQU07b0JBQ2hDLHFGQUFxRjtvQkFDckYseUNBQXlDO29CQUN6Q2lJLFFBQVFqSSxjQUFjLEdBQUc3RCxLQUFLNkQsY0FBYyxDQUFDcE8sTUFBTTtnQkFDckQ7WUFDRjtZQUVBLElBQUl1UixPQUFPOEUsUUFBUTlFLElBQUk7WUFDdkJsK0IsRUFBRWsxQixJQUFJLENBQUNnSixNQUFNQTtRQUNmLEVBQUUsK0VBQStFO1FBQ2pGLDBFQUEwRTtRQUcxRSxTQUFTb0IsV0FBVzlkLE9BQU8sRUFBRTBWLElBQUksRUFBRThELElBQUk7WUFDckMsaUZBQWlGO1lBQ2pGLGlEQUFpRDtZQUNqRCxJQUFJMEUsVUFBVXhJLEtBQUs4RyxjQUFjO1lBQ2pDLElBQUlpRixpQkFBaUJ2RCxRQUFRMzFDLFFBQVEsQ0FBQ2pKLE1BQU07WUFDNUMsSUFBSW9pRCxjQUFjeEQsUUFBUW4wQixNQUFNLENBQUN6cUIsTUFBTSxFQUFFLHlFQUF5RTtZQUNsSCxXQUFXO1lBRVgsSUFBSXFpRCx3QkFBd0JqTSxLQUFLOEcsY0FBYyxDQUFDMXJCLGFBQWE7WUFDN0QsSUFBSTh3Qix3QkFBd0JsTSxLQUFLK0csYUFBYTtZQUM5QyxJQUFJaUMsa0JBQWtCaEosS0FBS2hSLE9BQU87WUFDbEMsSUFBSW1kLHlCQUF5QjtZQUU3QjtnQkFDRUEseUJBQXlCbk0sS0FBSzZELGNBQWM7WUFDOUM7WUFFQSxJQUFJO2dCQUNGLE9BQU9xRixzQkFBc0I1ZSxTQUFTMFYsTUFBTSxNQUFNOEQ7WUFDcEQsRUFBRSxPQUFPc0ksYUFBYTtnQkFDcEIvTCxtQkFBbUIsZ0RBQWdEO2dCQUVuRW1JLFFBQVEzMUMsUUFBUSxDQUFDakosTUFBTSxHQUFHbWlEO2dCQUMxQnZELFFBQVFuMEIsTUFBTSxDQUFDenFCLE1BQU0sR0FBR29pRDtnQkFDeEIsSUFBSWxqQyxJQUFJc2pDLGdCQUFnQjNPLG9CQUN4QixzRUFBc0U7Z0JBQ3RFLG9FQUFvRTtnQkFDcEUsdUVBQXVFO2dCQUN2RSwwREFBMEQ7Z0JBQzFEZ0IseUJBQXlCMk4sYUFBYSwrQkFBK0I7Z0JBRXJFLElBQUksT0FBT3RqQyxNQUFNLFlBQVlBLE1BQU0sUUFBUSxPQUFPQSxFQUFFazFCLElBQUksS0FBSyxZQUFZO29CQUN2RSxJQUFJcU8sV0FBV3ZqQztvQkFDZixJQUFJKzBCLGdCQUFnQnlDO29CQUNwQnNMLHNCQUFzQnRoQixTQUFTMFYsTUFBTW5DLGVBQWV3TyxXQUFXLHlFQUF5RTtvQkFDeEksbUVBQW1FO29CQUVuRXJNLEtBQUs4RyxjQUFjLENBQUMxckIsYUFBYSxHQUFHNndCO29CQUNwQ2pNLEtBQUsrRyxhQUFhLEdBQUdtRjtvQkFDckJsTSxLQUFLaFIsT0FBTyxHQUFHZ2EsaUJBQWlCLDZEQUE2RDtvQkFFN0ZoVCxjQUFjZ1Q7b0JBRWQ7d0JBQ0VoSixLQUFLNkQsY0FBYyxHQUFHc0k7b0JBQ3hCO29CQUVBO2dCQUNGLE9BQU87b0JBQ0wseUVBQXlFO29CQUN6RSxtRUFBbUU7b0JBQ25Fbk0sS0FBSzhHLGNBQWMsQ0FBQzFyQixhQUFhLEdBQUc2d0I7b0JBQ3BDak0sS0FBSytHLGFBQWEsR0FBR21GO29CQUNyQmxNLEtBQUtoUixPQUFPLEdBQUdnYSxpQkFBaUIsNkRBQTZEO29CQUU3RmhULGNBQWNnVDtvQkFFZDt3QkFDRWhKLEtBQUs2RCxjQUFjLEdBQUdzSTtvQkFDeEI7b0JBQ0Esc0VBQXNFO29CQUd0RSxNQUFNcmpDO2dCQUNSO1lBQ0Y7UUFDRjtRQUVBLFNBQVN3akMsWUFBWWhpQixPQUFPLEVBQUUyYyxRQUFRLEVBQUV1QixPQUFPLEVBQUV2K0MsS0FBSztZQUNwRCx3Q0FBd0M7WUFDeEMsSUFBSWk0QixjQUFjd2xCLG9CQUFvQnBkLFNBQVNyZ0M7WUFFL0MsSUFBSWc5QyxhQUFhLE1BQU07Z0JBQ3JCNUIsV0FBVy9hLFNBQVNyZ0M7WUFDdEIsT0FBTztnQkFDTGc5QyxTQUFTUixZQUFZO2dCQUVyQixJQUFJLENBQUNRLFNBQVNQLGlCQUFpQixFQUFFO29CQUMvQk8sU0FBU1AsaUJBQWlCLEdBQUc7b0JBQzdCTyxTQUFTL2tCLFdBQVcsR0FBR0E7b0JBRXZCO3dCQUNFdWxCLCtCQUErQlIsVUFBVWg5QztvQkFDM0M7b0JBQ0EscURBQXFEO29CQUdyRCxJQUFJZzlDLFNBQVNqQixhQUFhLEVBQUU7d0JBQzFCLDRFQUE0RTt3QkFDNUUsd0VBQXdFO3dCQUN4RSw2RUFBNkU7d0JBQzdFLHNDQUFzQzt3QkFDdEMxYixRQUFRcWIsd0JBQXdCLENBQUNqNkMsSUFBSSxDQUFDdTdDO29CQUN4QztnQkFDRjtZQUNGO1lBRUEzYyxRQUFRaWIsZUFBZTtZQUV2QixJQUFJamIsUUFBUWliLGVBQWUsS0FBSyxHQUFHO2dCQUNqQyxJQUFJVCxhQUFheGEsUUFBUXdhLFVBQVU7Z0JBQ25DQTtZQUNGO1FBQ0Y7UUFFQSxTQUFTeUgsY0FBY3ZNLElBQUk7WUFDekIsd0VBQXdFO1lBQ3hFLG9FQUFvRTtZQUNwRSw0REFBNEQ7WUFDNUQsSUFBSTFWLFVBQVUsSUFBSTtZQUNsQixJQUFJMmMsV0FBV2pILEtBQUs2RyxlQUFlO1lBQ25DLElBQUkyQixVQUFVeEksS0FBSzhHLGNBQWM7WUFDakMwQixRQUFRdkssTUFBTSxHQUFHa0c7WUFDakJxSSxhQUFhbGlCLFNBQVMyYyxVQUFVdUI7UUFDbEM7UUFFQSxTQUFTaUUsVUFBVXpNLElBQUksRUFBRTFWLE9BQU8sRUFBRXJnQyxLQUFLO1lBQ3JDLDZFQUE2RTtZQUM3RSx3QkFBd0I7WUFDeEIsSUFBSWc5QyxXQUFXakgsS0FBSzZHLGVBQWU7WUFDbkMsSUFBSTJCLFVBQVV4SSxLQUFLOEcsY0FBYztZQUNqQzBCLFFBQVF2SyxNQUFNLEdBQUdrRztZQUVqQixJQUFJOEMsYUFBYSxNQUFNO2dCQUNyQjNjLFFBQVFpYixlQUFlLElBQUksdUVBQXVFO2dCQUNsRyxlQUFlO2dCQUVmLElBQUlqYixRQUFRMlQsTUFBTSxLQUFLcUcsV0FBV2hhLFFBQVEyVCxNQUFNLEtBQUtzRyxRQUFRO29CQUMzRG1ELG9CQUFvQnBkLFNBQVNyZ0M7b0JBQzdCbzdDLFdBQVcvYSxTQUFTcmdDO2dCQUN0QjtZQUNGLE9BQU87Z0JBQ0xnOUMsU0FBU1IsWUFBWTtnQkFFckIsSUFBSSxDQUFDUSxTQUFTUCxpQkFBaUIsRUFBRTtvQkFDL0JPLFNBQVNQLGlCQUFpQixHQUFHO29CQUM3Qk8sU0FBUy9rQixXQUFXLEdBQUdvSSxRQUFRaE8sT0FBTyxDQUFDcnlCO29CQUV2Qzt3QkFDRSxJQUFJeWlELGNBQWM7d0JBQ2xCLElBQUlqbUI7d0JBRUosSUFBSXg4QixTQUFTLE9BQU9BLE1BQU1ncUMsT0FBTyxLQUFLLFVBQVU7NEJBQzlDeE4sZUFBZWltQixjQUFjemlELE1BQU1ncUMsT0FBTzt3QkFDNUMsT0FBTzs0QkFDTCwrREFBK0Q7NEJBQy9EeE4sZUFBZWltQixjQUFjOWhELE9BQU9YO3dCQUN0Qzt3QkFFQSxJQUFJMGlELG9CQUFvQnpGO3dCQUN4QkEsbUJBQW1CbEg7d0JBRW5CLElBQUk7NEJBQ0Z5SCwrQkFBK0JSLFVBQVV4Z0I7d0JBQzNDLFNBQVU7NEJBQ1J5Z0IsbUJBQW1CeUY7d0JBQ3JCO29CQUNGO29CQUVBLElBQUkxRixTQUFTakIsYUFBYSxFQUFFO3dCQUMxQjFiLFFBQVFxYix3QkFBd0IsQ0FBQ2o2QyxJQUFJLENBQUN1N0M7b0JBQ3hDO2dCQUNGLEVBQUUsc0ZBQXNGO2dCQUN4RixpRkFBaUY7Z0JBR2pGQSxTQUFTVixzQkFBc0IsQ0FBQ2x0QixPQUFPLENBQUMsU0FBVXV6QixZQUFZO29CQUM1RCxPQUFPSCxVQUFVRyxjQUFjdGlCLFNBQVNyZ0M7Z0JBQzFDO2dCQUNBZzlDLFNBQVNWLHNCQUFzQixDQUFDamUsS0FBSztnQkFDckNnQyxRQUFRaWIsZUFBZTtnQkFFdkIsSUFBSWpiLFFBQVFpYixlQUFlLEtBQUssR0FBRztvQkFDakMsSUFBSVQsYUFBYXhhLFFBQVF3YSxVQUFVO29CQUNuQ0E7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsU0FBU3VELHNCQUFzQnBCLFFBQVEsRUFBRXVCLE9BQU87WUFDOUMsSUFBSUEsUUFBUW4wQixNQUFNLENBQUN6cUIsTUFBTSxLQUFLLEtBQUs0K0MsUUFBUTMxQyxRQUFRLENBQUNqSixNQUFNLEtBQUssS0FBSzQrQyxRQUFRMzFDLFFBQVEsQ0FBQyxFQUFFLENBQUNvMEMsUUFBUSxLQUFLLE1BQU07Z0JBQ3pHLHdGQUF3RjtnQkFDeEYscUVBQXFFO2dCQUNyRSxJQUFJNEYsZUFBZXJFLFFBQVEzMUMsUUFBUSxDQUFDLEVBQUU7Z0JBQ3RDZzZDLGFBQWFwM0MsRUFBRSxHQUFHK3lDLFFBQVEveUMsRUFBRTtnQkFDNUJvM0MsYUFBYTdHLGFBQWEsR0FBRztnQkFFN0IsSUFBSTZHLGFBQWE1TyxNQUFNLEtBQUtnRyxXQUFXO29CQUNyQ29FLHNCQUFzQnBCLFVBQVU0RjtnQkFDbEM7WUFDRixPQUFPO2dCQUNMLElBQUlsRyxvQkFBb0JNLFNBQVNOLGlCQUFpQjtnQkFDbERBLGtCQUFrQmo3QyxJQUFJLENBQUM4OEM7WUFDekI7UUFDRjtRQUVBLFNBQVNnRSxhQUFhbGlCLE9BQU8sRUFBRTJjLFFBQVEsRUFBRXVCLE9BQU87WUFDOUMsSUFBSXZCLGFBQWEsTUFBTTtnQkFDckIsSUFBSXVCLFFBQVF4QyxhQUFhLEVBQUU7b0JBQ3pCLElBQUkxYixRQUFRbWIsb0JBQW9CLEtBQUssTUFBTTt3QkFDekMsTUFBTSxJQUFJdHRCLE1BQU07b0JBQ2xCO29CQUVBbVMsUUFBUW1iLG9CQUFvQixHQUFHK0M7Z0JBQ2pDO2dCQUVBbGUsUUFBUWtiLGdCQUFnQjtnQkFFeEIsSUFBSWxiLFFBQVFrYixnQkFBZ0IsS0FBSyxHQUFHO29CQUNsQyxnRUFBZ0U7b0JBQ2hFbGIsUUFBUTBhLFlBQVksR0FBR047b0JBQ3ZCLElBQUlLLGVBQWV6YSxRQUFReWEsWUFBWTtvQkFDdkNBO2dCQUNGO1lBQ0YsT0FBTztnQkFDTGtDLFNBQVNSLFlBQVk7Z0JBRXJCLElBQUlRLFNBQVNQLGlCQUFpQjtxQkFBUyxJQUFJTyxTQUFTUixZQUFZLEtBQUssR0FBRztvQkFDdEUsMEZBQTBGO29CQUMxRixJQUFJK0IsUUFBUXhDLGFBQWEsRUFBRTt3QkFDekIseUZBQXlGO3dCQUN6RiwwRkFBMEY7d0JBQzFGLGNBQWM7d0JBQ2QsSUFBSXdDLFFBQVF2SyxNQUFNLEtBQUtnRyxXQUFXOzRCQUNoQ29FLHNCQUFzQnBCLFVBQVV1Qjt3QkFDbEM7b0JBQ0Y7b0JBRUEsSUFBSXZCLFNBQVNqQixhQUFhLEVBQUU7d0JBQzFCLHNGQUFzRjt3QkFDdEYsa0VBQWtFO3dCQUNsRTFiLFFBQVFzYixtQkFBbUIsQ0FBQ2w2QyxJQUFJLENBQUN1N0M7b0JBQ25DLEVBQUUsNkZBQTZGO29CQUMvRix5RkFBeUY7b0JBQ3pGLDRGQUE0RjtvQkFHNUZBLFNBQVNWLHNCQUFzQixDQUFDbHRCLE9BQU8sQ0FBQ2t6QixlQUFlamlCO29CQUN2RDJjLFNBQVNWLHNCQUFzQixDQUFDamUsS0FBSztnQkFDdkMsT0FBTztvQkFDTCxJQUFJa2dCLFFBQVF4QyxhQUFhLEVBQUU7d0JBQ3pCLGlGQUFpRjt3QkFDakYsMEZBQTBGO3dCQUMxRixjQUFjO3dCQUNkLElBQUl3QyxRQUFRdkssTUFBTSxLQUFLZ0csV0FBVzs0QkFDaENvRSxzQkFBc0JwQixVQUFVdUI7NEJBQ2hDLElBQUk3QixvQkFBb0JNLFNBQVNOLGlCQUFpQjs0QkFFbEQsSUFBSUEsa0JBQWtCLzhDLE1BQU0sS0FBSyxHQUFHO2dDQUNsQywyRUFBMkU7Z0NBQzNFLCtFQUErRTtnQ0FDL0UsK0NBQStDO2dDQUMvQyxJQUFJcTlDLFNBQVNqQixhQUFhLEVBQUU7b0NBQzFCMWIsUUFBUXViLGlCQUFpQixDQUFDbjZDLElBQUksQ0FBQ3U3QztnQ0FDakM7NEJBQ0Y7d0JBQ0Y7b0JBQ0Y7Z0JBQ0Y7WUFDRjtZQUVBM2MsUUFBUWliLGVBQWU7WUFFdkIsSUFBSWpiLFFBQVFpYixlQUFlLEtBQUssR0FBRztnQkFDakMsd0ZBQXdGO2dCQUN4Riw2QkFBNkI7Z0JBQzdCLElBQUlULGFBQWF4YSxRQUFRd2EsVUFBVTtnQkFDbkNBO1lBQ0Y7UUFDRjtRQUVBLFNBQVNnSSxVQUFVeGlCLE9BQU8sRUFBRTBWLElBQUk7WUFDOUI7Z0JBQ0UsSUFBSTZHLGtCQUFrQjdHLEtBQUs2RyxlQUFlO2dCQUMxQ3pjLDZDQUE2Q0UsUUFBUTVXLFNBQVMsRUFBRW16QixrQkFBa0JBLGdCQUFnQm56QixTQUFTLEdBQUc7WUFDaEg7WUFFQSxJQUFJODBCLFVBQVV4SSxLQUFLOEcsY0FBYztZQUVqQyxJQUFJMEIsUUFBUXZLLE1BQU0sS0FBSytGLFNBQVM7Z0JBQzlCLHVFQUF1RTtnQkFDdkU7WUFDRixFQUFFLDJEQUEyRDtZQUM3RCwyRUFBMkU7WUFDM0UsNkNBQTZDO1lBRzdDaE8sY0FBY2dLLEtBQUtoUixPQUFPO1lBQzFCLElBQUkrZCxnQkFBZ0I7WUFFcEI7Z0JBQ0VBLGdCQUFnQjdGO2dCQUNoQkEsbUJBQW1CbEg7WUFDckI7WUFFQSxJQUFJK0wsaUJBQWlCdkQsUUFBUTMxQyxRQUFRLENBQUNqSixNQUFNO1lBQzVDLElBQUlvaUQsY0FBY3hELFFBQVFuMEIsTUFBTSxDQUFDenFCLE1BQU07WUFFdkMsSUFBSTtnQkFDRiw2RUFBNkU7Z0JBQzdFLDRFQUE0RTtnQkFDNUUsd0VBQXdFO2dCQUN4RSxvRUFBb0U7Z0JBQ3BFLGlFQUFpRTtnQkFDakUsSUFBSXMyQyxvQkFBb0JGLEtBQUtuQyxhQUFhO2dCQUMxQ21DLEtBQUtuQyxhQUFhLEdBQUc7Z0JBQ3JCcUwsc0JBQXNCNWUsU0FBUzBWLE1BQU1FLG1CQUFtQkYsS0FBSzhELElBQUk7Z0JBQ2pFcFgsa0JBQWtCOGIsUUFBUW4wQixNQUFNLEVBQUVpVyxRQUFRdlQsYUFBYSxFQUFFeXhCLFFBQVE5d0IsY0FBYyxFQUFFOHdCLFFBQVFoeEIsWUFBWTtnQkFDckd3b0IsS0FBS21GLFFBQVEsQ0FBQ25kLE1BQU0sQ0FBQ2dZO2dCQUNyQndJLFFBQVF2SyxNQUFNLEdBQUdnRztnQkFDakJ1SSxhQUFhbGlCLFNBQVMwVixLQUFLNkcsZUFBZSxFQUFFMkI7WUFDOUMsRUFBRSxPQUFPNEQsYUFBYTtnQkFDcEIvTCxtQkFBbUIsZ0RBQWdEO2dCQUVuRW1JLFFBQVEzMUMsUUFBUSxDQUFDakosTUFBTSxHQUFHbWlEO2dCQUMxQnZELFFBQVFuMEIsTUFBTSxDQUFDenFCLE1BQU0sR0FBR29pRDtnQkFDeEIsSUFBSWxqQyxJQUFJc2pDLGdCQUFnQjNPLG9CQUN4QixzRUFBc0U7Z0JBQ3RFLG9FQUFvRTtnQkFDcEUsdUVBQXVFO2dCQUN2RSwwREFBMEQ7Z0JBQzFEZ0IseUJBQXlCMk4sYUFBYSwrQkFBK0I7Z0JBRXJFLElBQUksT0FBT3RqQyxNQUFNLFlBQVlBLE1BQU0sUUFBUSxPQUFPQSxFQUFFazFCLElBQUksS0FBSyxZQUFZO29CQUN2RSwwREFBMEQ7b0JBQzFELElBQUlnSixPQUFPaEgsS0FBS2dILElBQUk7b0JBQ3BCbCtCLEVBQUVrMUIsSUFBSSxDQUFDZ0osTUFBTUE7b0JBQ2JoSCxLQUFLbkMsYUFBYSxHQUFHeUM7Z0JBQ3ZCLE9BQU87b0JBQ0xOLEtBQUttRixRQUFRLENBQUNuZCxNQUFNLENBQUNnWTtvQkFDckJ3SSxRQUFRdkssTUFBTSxHQUFHbUc7b0JBQ2pCa0ksWUFBWWhpQixTQUFTMFYsS0FBSzZHLGVBQWUsRUFBRTJCLFNBQVMxL0I7Z0JBQ3REO1lBQ0YsU0FBVTtnQkFDUjtvQkFDRXNoQiw2Q0FBNkNFLFFBQVE1VyxTQUFTLEVBQUU7Z0JBQ2xFO2dCQUVBO29CQUNFd3pCLG1CQUFtQjZGO2dCQUNyQjtZQUNGO1FBQ0Y7UUFFQSxTQUFTMUcsWUFBWS9iLE9BQU87WUFDMUIsSUFBSUEsUUFBUTJULE1BQU0sS0FBS3NHLFFBQVE7Z0JBQzdCO1lBQ0Y7WUFFQSxJQUFJa0UsY0FBYzdSO1lBQ2xCLElBQUlvVyxpQkFBaUJqYyx1QkFBdUI3ZSxPQUFPO1lBQ25ENmUsdUJBQXVCN2UsT0FBTyxHQUFHK3dCO1lBQ2pDLElBQUlnSztZQUVKO2dCQUNFQSxzQkFBc0JsSixrQkFBa0I3eEIsT0FBTztnQkFDL0M2eEIsa0JBQWtCN3hCLE9BQU8sR0FBR3l4QjtZQUM5QjtZQUVBLElBQUl1SixjQUFjL0c7WUFDbEJBLGlCQUFpQjdiO1lBQ2pCLElBQUk2aUI7WUFFSjtnQkFDRUEsMEJBQTBCOWlELHVCQUF1QitpRCxlQUFlO2dCQUNoRS9pRCx1QkFBdUIraUQsZUFBZSxHQUFHakc7WUFDM0M7WUFFQSxJQUFJa0csb0JBQW9CM0s7WUFDeEJhLHdCQUF3QmpaLFFBQVF2VCxhQUFhO1lBRTdDLElBQUk7Z0JBQ0YsSUFBSW11QixjQUFjNWEsUUFBUTRhLFdBQVc7Z0JBQ3JDLElBQUlyMkI7Z0JBRUosSUFBS0EsSUFBSSxHQUFHQSxJQUFJcTJCLFlBQVl0N0MsTUFBTSxFQUFFaWxCLElBQUs7b0JBQ3ZDLElBQUlteEIsT0FBT2tGLFdBQVcsQ0FBQ3IyQixFQUFFO29CQUN6QmkrQixVQUFVeGlCLFNBQVMwVjtnQkFDckI7Z0JBRUFrRixZQUFZb0ksTUFBTSxDQUFDLEdBQUd6K0I7Z0JBRXRCLElBQUl5YixRQUFRaC9CLFdBQVcsS0FBSyxNQUFNO29CQUNoQ2lpRCxxQkFBcUJqakIsU0FBU0EsUUFBUWgvQixXQUFXO2dCQUNuRDtZQUNGLEVBQUUsT0FBT3JCLE9BQU87Z0JBQ2R5OUMsb0JBQW9CcGQsU0FBU3JnQztnQkFDN0JvN0MsV0FBVy9hLFNBQVNyZ0M7WUFDdEIsU0FBVTtnQkFDUnM1Qyx3QkFBd0I4SjtnQkFDeEJ0Yyx1QkFBdUI3ZSxPQUFPLEdBQUc4NkI7Z0JBRWpDO29CQUNFakosa0JBQWtCN3hCLE9BQU8sR0FBRys2QjtnQkFDOUI7Z0JBRUE7b0JBQ0U1aUQsdUJBQXVCK2lELGVBQWUsR0FBR0Q7Z0JBQzNDO2dCQUVBLElBQUlILG1CQUFtQi9KLGlCQUFpQjtvQkFDdEMsc0VBQXNFO29CQUN0RSxvRUFBb0U7b0JBQ3BFLGlEQUFpRDtvQkFDakQsd0VBQXdFO29CQUN4RSxvRUFBb0U7b0JBQ3BFLHlFQUF5RTtvQkFDekUsZ0VBQWdFO29CQUNoRWpOLGNBQWN5UztnQkFDaEI7Z0JBRUF0QyxpQkFBaUIrRztZQUNuQjtRQUNGO1FBRUEsU0FBU00sYUFBYWxqQixPQUFPLEVBQUVoL0IsV0FBVyxFQUFFazlDLE9BQU87WUFDakRBLFFBQVF4QyxhQUFhLEdBQUc7WUFFeEIsT0FBUXdDLFFBQVF2SyxNQUFNO2dCQUNwQixLQUFLK0Y7b0JBQ0g7d0JBQ0UsdUVBQXVFO3dCQUN2RSwrREFBK0Q7d0JBQy9ELElBQUl5SixZQUFZakYsUUFBUS95QyxFQUFFLEdBQUc2MEIsUUFBUWdiLGFBQWEsSUFBSSxrR0FBa0c7d0JBRXhKa0QsUUFBUTl3QixjQUFjLEdBQUc7d0JBQ3pCOHdCLFFBQVFoeEIsWUFBWSxHQUFHO3dCQUN2QixPQUFPMEosaUJBQWlCNTFCLGFBQWFnL0IsUUFBUXZULGFBQWEsRUFBRTAyQjtvQkFDOUQ7Z0JBRUYsS0FBS3hKO29CQUNIO3dCQUNFdUUsUUFBUXZLLE1BQU0sR0FBR2lHO3dCQUNqQixJQUFJM2dDLElBQUk7d0JBQ1IsSUFBSThRLFNBQVNtMEIsUUFBUW4wQixNQUFNO3dCQUMzQixJQUFJcTVCLFdBQVc7d0JBQ2YsSUFBSTc2QyxXQUFXMjFDLFFBQVEzMUMsUUFBUTt3QkFFL0IsSUFBSyxJQUFJODZDLFdBQVcsR0FBR0EsV0FBVzk2QyxTQUFTakosTUFBTSxFQUFFK2pELFdBQVk7NEJBQzdELElBQUlDLFlBQVkvNkMsUUFBUSxDQUFDODZDLFNBQVMsRUFBRSxnREFBZ0Q7NEJBRXBGLE1BQU9ELFdBQVdFLFVBQVU5Z0MsS0FBSyxFQUFFNGdDLFdBQVk7Z0NBQzdDbmlELFdBQVdELGFBQWErb0IsTUFBTSxDQUFDcTVCLFNBQVM7NEJBQzFDOzRCQUVBbnFDLElBQUlzcUMsYUFBYXZqQixTQUFTaC9CLGFBQWFzaUQ7d0JBQ3pDLEVBQUUsOENBQThDO3dCQUdoRCxNQUFPRixXQUFXcjVCLE9BQU96cUIsTUFBTSxHQUFHLEdBQUc4akQsV0FBWTs0QkFDL0NuaUQsV0FBV0QsYUFBYStvQixNQUFNLENBQUNxNUIsU0FBUzt3QkFDMUM7d0JBRUEsSUFBSUEsV0FBV3I1QixPQUFPenFCLE1BQU0sRUFBRTs0QkFDNUIyWixJQUFJOVgsb0JBQW9CSCxhQUFhK29CLE1BQU0sQ0FBQ3E1QixTQUFTO3dCQUN2RDt3QkFFQSxPQUFPbnFDO29CQUNUO2dCQUVGO29CQUNFO3dCQUNFLE1BQU0sSUFBSTRVLE1BQU07b0JBQ2xCO1lBQ0o7UUFDRjtRQUVBLFNBQVMwMUIsYUFBYXZqQixPQUFPLEVBQUVoL0IsV0FBVyxFQUFFazlDLE9BQU87WUFDakQsSUFBSXZCLFdBQVd1QixRQUFRdkIsUUFBUTtZQUUvQixJQUFJQSxhQUFhLE1BQU07Z0JBQ3JCLDJCQUEyQjtnQkFDM0IsT0FBT3VHLGFBQWFsakIsU0FBU2gvQixhQUFhazlDO1lBQzVDO1lBRUF2QixTQUFTakIsYUFBYSxHQUFHLE1BQU0sb0VBQW9FO1lBQ25HLHdDQUF3QztZQUV4QyxJQUFJaUIsU0FBU1AsaUJBQWlCLEVBQUU7Z0JBQzlCLG9EQUFvRDtnQkFDcEQseUZBQXlGO2dCQUN6RjlaLHlDQUF5Q3RoQyxhQUFhZy9CLFFBQVF2VCxhQUFhLEVBQUVrd0IsU0FBUy9rQixXQUFXLEVBQUUra0IsU0FBU3hnQixZQUFZLEVBQUV3Z0IsU0FBUzdrQixtQkFBbUIsR0FBRyxzQkFBc0I7Z0JBRS9Lb3JCLGFBQWFsakIsU0FBU2gvQixhQUFhazlDO2dCQUNuQyxPQUFPMWIsdUNBQXVDeGhDLGFBQWFnL0IsUUFBUXZULGFBQWE7WUFDbEYsT0FBTyxJQUFJa3dCLFNBQVNSLFlBQVksR0FBRyxHQUFHO2dCQUNwQyw0RUFBNEU7Z0JBQzVFLGtEQUFrRDtnQkFDbERRLFNBQVNULGFBQWEsR0FBR2xjLFFBQVFnYixhQUFhO2dCQUU5QyxJQUFJMkIsU0FBU04saUJBQWlCLENBQUMvOEMsTUFBTSxHQUFHLEdBQUc7b0JBQ3pDLHlGQUF5RjtvQkFDekYwZ0MsUUFBUXViLGlCQUFpQixDQUFDbjZDLElBQUksQ0FBQ3U3QztnQkFDakMsRUFBRSw2REFBNkQ7Z0JBRy9ELElBQUl4eEMsS0FBS3d4QyxTQUFTeHhDLEVBQUUsR0FBR3FoQix5QkFBeUJ3VCxRQUFRdlQsYUFBYTtnQkFDckVpTCxrQ0FBa0MxMkIsYUFBYWcvQixRQUFRdlQsYUFBYSxFQUFFdGhCLEtBQUssc0JBQXNCO2dCQUVqRyszQyxhQUFhbGpCLFNBQVNoL0IsYUFBYWs5QztnQkFDbkMsT0FBT2xtQixnQ0FBZ0NoM0I7WUFDekMsT0FBTyxJQUFJMjdDLFNBQVNMLFFBQVEsR0FBR3RjLFFBQVF1YSxvQkFBb0IsRUFBRTtnQkFDM0QsMEZBQTBGO2dCQUMxRix3RkFBd0Y7Z0JBQ3hGLHdFQUF3RTtnQkFDeEUsc0ZBQXNGO2dCQUN0RixrREFBa0Q7Z0JBQ2xELGtEQUFrRDtnQkFDbERvQyxTQUFTVCxhQUFhLEdBQUdsYyxRQUFRZ2IsYUFBYTtnQkFDOUNoYixRQUFRc2IsbUJBQW1CLENBQUNsNkMsSUFBSSxDQUFDdTdDLFdBQVcscURBQXFEO2dCQUVqR2psQixrQ0FBa0MxMkIsYUFBYWcvQixRQUFRdlQsYUFBYSxFQUFFa3dCLFNBQVN4eEMsRUFBRSxHQUFHLHNCQUFzQjtnQkFFMUcrM0MsYUFBYWxqQixTQUFTaC9CLGFBQWFrOUM7Z0JBQ25DLE9BQU9sbUIsZ0NBQWdDaDNCO1lBQ3pDLE9BQU87Z0JBQ0w7b0JBQ0V3Z0MsZUFBZXhCLFFBQVE1VyxTQUFTLEVBQUV1ekIsU0FBU3Z6QixTQUFTO2dCQUN0RDtnQkFHQWlaLG9DQUFvQ3JoQyxhQUFhZy9CLFFBQVF2VCxhQUFhO2dCQUN0RSxJQUFJNHZCLG9CQUFvQk0sU0FBU04saUJBQWlCO2dCQUVsRCxJQUFJQSxrQkFBa0IvOEMsTUFBTSxLQUFLLEdBQUc7b0JBQ2xDLE1BQU0sSUFBSXV1QixNQUFNO2dCQUNsQjtnQkFFQSxJQUFJMjFCLGlCQUFpQm5ILGlCQUFpQixDQUFDLEVBQUU7Z0JBQ3pDa0gsYUFBYXZqQixTQUFTaC9CLGFBQWF3aUQ7Z0JBQ25DLE9BQU9qaEIsa0NBQWtDdmhDLGFBQWFnL0IsUUFBUXZULGFBQWE7WUFDN0U7UUFDRjtRQUVBLFNBQVNnM0IsNEJBQTRCempCLE9BQU8sRUFBRWgvQixXQUFXLEVBQUUyN0MsUUFBUTtZQUNqRSxPQUFPemdCLHFDQUFxQ2w3QixhQUFhZy9CLFFBQVF2VCxhQUFhLEVBQUVrd0IsU0FBU3h4QyxFQUFFLEVBQUV3eEMsU0FBUy9rQixXQUFXLEVBQUUra0IsU0FBU3hnQixZQUFZLEVBQUV3Z0IsU0FBUzdrQixtQkFBbUI7UUFDeEs7UUFFQSxTQUFTNHJCLHNCQUFzQjFqQixPQUFPLEVBQUVoL0IsV0FBVyxFQUFFazlDLE9BQU87WUFDMUQza0Isa0JBQWtCdjRCLGFBQWFnL0IsUUFBUXZULGFBQWEsRUFBRXl4QixRQUFRcHRCLGFBQWEsRUFBRW90QixRQUFRL3lDLEVBQUU7WUFDdkZvNEMsYUFBYXZqQixTQUFTaC9CLGFBQWFrOUM7WUFDbkMsT0FBTzFrQixnQkFBZ0J4NEIsYUFBYWs5QyxRQUFRcHRCLGFBQWE7UUFDM0Q7UUFFQSxTQUFTNnlCLHVCQUF1QjNqQixPQUFPLEVBQUVoL0IsV0FBVyxFQUFFMjdDLFFBQVE7WUFDNUQ7Z0JBQ0U3Yyw2Q0FBNkNFLFFBQVE1VyxTQUFTLEVBQUV1ekIsU0FBU3Z6QixTQUFTO1lBQ3BGO1lBRUEsSUFBSWl6QixvQkFBb0JNLFNBQVNOLGlCQUFpQjtZQUNsRCxJQUFJOTNCLElBQUk7WUFFUixNQUFPQSxJQUFJODNCLGtCQUFrQi84QyxNQUFNLEVBQUVpbEIsSUFBSztnQkFDeEMsSUFBSTI1QixVQUFVN0IsaUJBQWlCLENBQUM5M0IsRUFBRTtnQkFDbENxL0IsK0JBQStCNWpCLFNBQVNoL0IsYUFBYTI3QyxVQUFVdUI7WUFDakU7WUFFQTdCLGtCQUFrQi84QyxNQUFNLEdBQUc7WUFFM0I7Z0JBQ0U2OUIsMEJBQTBCbjhCLGFBQWEyN0MsU0FBU3Z6QixTQUFTLEVBQUU0VyxRQUFRdlQsYUFBYTtZQUNsRjtZQUVBLE9BQU93TyxrQ0FBa0NqNkIsYUFBYWcvQixRQUFRdlQsYUFBYSxFQUFFa3dCLFNBQVN4eEMsRUFBRSxFQUFFd3hDLFNBQVNULGFBQWEsRUFBRVMsU0FBU3Z6QixTQUFTO1FBQ3RJO1FBRUEsU0FBU3k2QixxQkFBcUI3akIsT0FBTyxFQUFFaC9CLFdBQVcsRUFBRTI3QyxRQUFRO1lBQzFEO2dCQUNFN2MsNkNBQTZDRSxRQUFRNVcsU0FBUyxFQUFFdXpCLFNBQVN2ekIsU0FBUztZQUNwRjtZQUVBLElBQUlpekIsb0JBQW9CTSxTQUFTTixpQkFBaUI7WUFDbEQsSUFBSTkzQixJQUFJO1lBRVIsTUFBT0EsSUFBSTgzQixrQkFBa0IvOEMsTUFBTSxFQUFFaWxCLElBQUs7Z0JBQ3hDLElBQUkyNUIsVUFBVTdCLGlCQUFpQixDQUFDOTNCLEVBQUU7Z0JBRWxDLElBQUksQ0FBQ3EvQiwrQkFBK0I1akIsU0FBU2gvQixhQUFhMjdDLFVBQVV1QixVQUFVO29CQUM1RTM1QjtvQkFDQTgzQixrQkFBa0IyRyxNQUFNLENBQUMsR0FBR3orQixJQUFJLG9FQUFvRTtvQkFDcEcsNkJBQTZCO29CQUU3QixPQUFPO2dCQUNUO1lBQ0Y7WUFFQTgzQixrQkFBa0IyRyxNQUFNLENBQUMsR0FBR3orQjtZQUU1QjtnQkFDRSw0RUFBNEU7Z0JBQzVFLHdFQUF3RTtnQkFDeEUscUVBQXFFO2dCQUNyRSx5QkFBeUI7Z0JBQ3pCLE9BQU80WSwwQkFBMEJuOEIsYUFBYTI3QyxTQUFTdnpCLFNBQVMsRUFBRTRXLFFBQVF2VCxhQUFhO1lBQ3pGO1FBQ0Y7UUFFQSxTQUFTbTNCLCtCQUErQjVqQixPQUFPLEVBQUVoL0IsV0FBVyxFQUFFMjdDLFFBQVEsRUFBRXVCLE9BQU87WUFDN0UsSUFBSUEsUUFBUXZLLE1BQU0sS0FBS2lHLFNBQVM7Z0JBQzlCLHFDQUFxQztnQkFDckMsT0FBTztZQUNUO1lBRUEsSUFBSXVKLFlBQVlqRixRQUFRL3lDLEVBQUU7WUFFMUIsSUFBSWc0QyxjQUFjLENBQUMsR0FBRztnQkFDcEIsMEVBQTBFO2dCQUMxRSx1RUFBdUU7Z0JBQ3ZFLElBQUlqSCxnQkFBZ0JnQyxRQUFRL3lDLEVBQUUsR0FBR3d4QyxTQUFTVCxhQUFhO2dCQUV2RCxJQUFJQSxrQkFBa0IsQ0FBQyxHQUFHO29CQUN4QixNQUFNLElBQUlydUIsTUFBTTtnQkFDbEI7Z0JBRUEsT0FBTzYxQixzQkFBc0IxakIsU0FBU2gvQixhQUFhazlDO1lBQ3JELE9BQU87Z0JBQ0x3RixzQkFBc0IxakIsU0FBU2gvQixhQUFhazlDO2dCQUM1QyxPQUFPbGtCLGlDQUFpQ2g1QixhQUFhZy9CLFFBQVF2VCxhQUFhLEVBQUUwMkI7WUFDOUU7UUFDRjtRQUVBLFNBQVNGLHFCQUFxQmpqQixPQUFPLEVBQUVoL0IsV0FBVztZQUVoRCxJQUFJO2dCQUNGLHlFQUF5RTtnQkFDekUsZ0ZBQWdGO2dCQUNoRixnRkFBZ0Y7Z0JBQ2hGLDhDQUE4QztnQkFDOUMsSUFBSXVqQjtnQkFDSixJQUFJNDJCLHVCQUF1Qm5iLFFBQVFtYixvQkFBb0I7Z0JBRXZELElBQUlBLHlCQUF5QixNQUFNO29CQUNqQyxJQUFJbmIsUUFBUWtiLGdCQUFnQixLQUFLLEdBQUc7d0JBQ2xDLElBQUl2M0MsYUFBYTs0QkFDZjA2QixjQUFjcjlCLGFBQWFnL0IsUUFBUTVXLFNBQVMsRUFBRTRXLFFBQVF2VCxhQUFhLEVBQUV1VCxRQUFRaWIsZUFBZSxLQUFLO3dCQUNuRzt3QkFFQXNJLGFBQWF2akIsU0FBU2gvQixhQUFhbTZDO3dCQUNuQ25iLFFBQVFtYixvQkFBb0IsR0FBRzt3QkFDL0Ixa0IsbUJBQW1CejFCLGFBQWFnL0IsUUFBUXZULGFBQWE7b0JBQ3ZELE9BQU87d0JBQ0wsNEZBQTRGO3dCQUM1RjtvQkFDRjtnQkFDRixPQUFPLElBQUl1VCxRQUFRa2IsZ0JBQWdCLEdBQUcsR0FBRztvQkFDdkMsOERBQThEO29CQUM5RDtnQkFDRjtnQkFFQSxJQUFJdjNDLGFBQWE7b0JBQ2ZnN0IsZ0JBQWdCMzlCLGFBQWFnL0IsUUFBUTVXLFNBQVMsRUFBRTRXLFFBQVF2VCxhQUFhO2dCQUN2RSxFQUFFLDhFQUE4RTtnQkFDaEYsZ0ZBQWdGO2dCQUNoRixvQkFBb0I7Z0JBR3BCLElBQUk0dUIsMkJBQTJCcmIsUUFBUXFiLHdCQUF3QjtnQkFFL0QsSUFBSzkyQixJQUFJLEdBQUdBLElBQUk4MkIseUJBQXlCLzdDLE1BQU0sRUFBRWlsQixJQUFLO29CQUNwRCxJQUFJbzRCLFdBQVd0Qix3QkFBd0IsQ0FBQzkyQixFQUFFO29CQUUxQyxJQUFJLENBQUNrL0IsNEJBQTRCempCLFNBQVNoL0IsYUFBYTI3QyxXQUFXO3dCQUNoRTNjLFFBQVFoL0IsV0FBVyxHQUFHO3dCQUN0QnVqQjt3QkFDQTgyQix5QkFBeUIySCxNQUFNLENBQUMsR0FBR3orQjt3QkFDbkM7b0JBQ0Y7Z0JBQ0Y7Z0JBRUE4MkIseUJBQXlCMkgsTUFBTSxDQUFDLEdBQUd6K0IsSUFBSSx3RUFBd0U7Z0JBQy9HLCtFQUErRTtnQkFDL0UsOERBQThEO2dCQUU5RCxJQUFJKzJCLHNCQUFzQnRiLFFBQVFzYixtQkFBbUI7Z0JBRXJELElBQUsvMkIsSUFBSSxHQUFHQSxJQUFJKzJCLG9CQUFvQmg4QyxNQUFNLEVBQUVpbEIsSUFBSztvQkFDL0MsSUFBSXUvQixZQUFZeEksbUJBQW1CLENBQUMvMkIsRUFBRTtvQkFFdEMsSUFBSSxDQUFDby9CLHVCQUF1QjNqQixTQUFTaC9CLGFBQWE4aUQsWUFBWTt3QkFDNUQ5akIsUUFBUWgvQixXQUFXLEdBQUc7d0JBQ3RCdWpCO3dCQUNBKzJCLG9CQUFvQjBILE1BQU0sQ0FBQyxHQUFHeitCO3dCQUM5QjtvQkFDRjtnQkFDRjtnQkFFQSsyQixvQkFBb0IwSCxNQUFNLENBQUMsR0FBR3orQixJQUFJLHVFQUF1RTtnQkFDekcscUNBQXFDO2dCQUVyQ2xqQixnQkFBZ0JMO2dCQUNoQkQsYUFBYUMsY0FBYyxnREFBZ0Q7Z0JBQzNFLDBFQUEwRTtnQkFDMUUsMkJBQTJCO2dCQUUzQixJQUFJdTZDLG9CQUFvQnZiLFFBQVF1YixpQkFBaUI7Z0JBRWpELElBQUtoM0IsSUFBSSxHQUFHQSxJQUFJZzNCLGtCQUFrQmo4QyxNQUFNLEVBQUVpbEIsSUFBSztvQkFDN0MsSUFBSXcvQixhQUFheEksaUJBQWlCLENBQUNoM0IsRUFBRTtvQkFFckMsSUFBSSxDQUFDcy9CLHFCQUFxQjdqQixTQUFTaC9CLGFBQWEraUQsYUFBYTt3QkFDM0QvakIsUUFBUWgvQixXQUFXLEdBQUc7d0JBQ3RCdWpCO3dCQUNBZzNCLGtCQUFrQnlILE1BQU0sQ0FBQyxHQUFHeitCO3dCQUM1QjtvQkFDRjtnQkFDRjtnQkFFQWczQixrQkFBa0J5SCxNQUFNLENBQUMsR0FBR3orQixJQUFJLGtFQUFrRTtnQkFDbEcscUVBQXFFO2dCQUNyRSx3Q0FBd0M7Z0JBRXhDLElBQUl5L0Isa0JBQWtCaGtCLFFBQVFzYixtQkFBbUI7Z0JBRWpELElBQUsvMkIsSUFBSSxHQUFHQSxJQUFJeS9CLGdCQUFnQjFrRCxNQUFNLEVBQUVpbEIsSUFBSztvQkFDM0MsSUFBSTAvQixhQUFhRCxlQUFlLENBQUN6L0IsRUFBRTtvQkFFbkMsSUFBSSxDQUFDby9CLHVCQUF1QjNqQixTQUFTaC9CLGFBQWFpakQsYUFBYTt3QkFDN0Rqa0IsUUFBUWgvQixXQUFXLEdBQUc7d0JBQ3RCdWpCO3dCQUNBeS9CLGdCQUFnQmhCLE1BQU0sQ0FBQyxHQUFHeitCO3dCQUMxQjtvQkFDRjtnQkFDRjtnQkFFQXkvQixnQkFBZ0JoQixNQUFNLENBQUMsR0FBR3orQjtZQUM1QixTQUFVO2dCQUNSLElBQUl5YixRQUFRaWIsZUFBZSxLQUFLLEtBQUtqYixRQUFRNGEsV0FBVyxDQUFDdDdDLE1BQU0sS0FBSyxLQUFLMGdDLFFBQVFxYix3QkFBd0IsQ0FBQy83QyxNQUFNLEtBQUssS0FBSzBnQyxRQUFRc2IsbUJBQW1CLENBQUNoOEMsTUFBTSxLQUFLLEVBQUUsa0VBQWtFO2tCQUVuTztvQkFDRTBnQyxRQUFROGEsY0FBYyxHQUFHO29CQUV6Qjt3QkFDRWxjLGVBQWU1OUIsYUFBYWcvQixRQUFRdlQsYUFBYTtvQkFDbkQ7b0JBRUE7d0JBQ0UsSUFBSXVULFFBQVFvYixjQUFjLENBQUN2c0MsSUFBSSxLQUFLLEdBQUc7NEJBQ3JDbFAsTUFBTTt3QkFDUjtvQkFDRjtvQkFHQTJCLE1BQU1OO2dCQUNSO1lBQ0o7UUFDRjtRQUVBLFNBQVNrakQsVUFBVWxrQixPQUFPO1lBQ3hCQSxRQUFROGEsY0FBYyxHQUFHOWEsUUFBUWgvQixXQUFXLEtBQUs7WUFFakQ7Z0JBQ0VILGFBQWE7b0JBQ1gsT0FBT2s3QyxZQUFZL2I7Z0JBQ3JCO1lBQ0Y7UUFDRjtRQUVBLFNBQVNta0IsYUFBYW5rQixPQUFPO1lBQzNCLElBQUlBLFFBQVE4YSxjQUFjLEtBQUssU0FBUyw4RUFBOEU7WUFDdEg5YSxRQUFRNGEsV0FBVyxDQUFDdDdDLE1BQU0sS0FBSyxLQUFLLDRFQUE0RTtZQUNoSCxxQ0FBcUM7WUFDckMwZ0MsUUFBUWgvQixXQUFXLEtBQUssTUFBTTtnQkFDNUIsSUFBSUEsY0FBY2cvQixRQUFRaC9CLFdBQVc7Z0JBQ3JDZy9CLFFBQVE4YSxjQUFjLEdBQUc7Z0JBQ3pCajZDLGFBQWE7b0JBQ1gsT0FBT29pRCxxQkFBcUJqakIsU0FBU2gvQjtnQkFDdkM7WUFDRjtRQUNGO1FBRUEsU0FBU29qRCxhQUFhcGtCLE9BQU8sRUFBRWgvQixXQUFXO1lBQ3hDLElBQUlnL0IsUUFBUTJULE1BQU0sS0FBS3FHLFNBQVM7Z0JBQzlCaGEsUUFBUTJULE1BQU0sR0FBR3NHO2dCQUNqQnQ0QyxlQUFlWCxhQUFhZy9CLFFBQVErYSxVQUFVO2dCQUM5QztZQUNGO1lBRUEsSUFBSS9hLFFBQVEyVCxNQUFNLEtBQUtzRyxRQUFRO2dCQUM3QjtZQUNGO1lBRUEsSUFBSWphLFFBQVFoL0IsV0FBVyxLQUFLLE1BQU07Z0JBQ2hDLHlCQUF5QjtnQkFDekI7WUFDRjtZQUVBZy9CLFFBQVFoL0IsV0FBVyxHQUFHQTtZQUV0QixJQUFJO2dCQUNGaWlELHFCQUFxQmpqQixTQUFTaC9CO1lBQ2hDLEVBQUUsT0FBT3JCLE9BQU87Z0JBQ2R5OUMsb0JBQW9CcGQsU0FBU3JnQztnQkFDN0JvN0MsV0FBVy9hLFNBQVNyZ0M7WUFDdEI7UUFDRixFQUFFLHdHQUF3RztRQUUxRyxTQUFTMGtELE1BQU1ya0IsT0FBTyxFQUFFOFQsTUFBTTtZQUM1QixJQUFJO2dCQUNGLElBQUlzSCxpQkFBaUJwYixRQUFRb2IsY0FBYztnQkFFM0MsSUFBSUEsZUFBZXZzQyxJQUFJLEdBQUcsR0FBRztvQkFDM0IsSUFBSWxQLFFBQVFtMEMsV0FBV3Z6QixZQUFZLElBQUlzTixNQUFNLDREQUE0RGltQjtvQkFDekdzSCxlQUFlcnNCLE9BQU8sQ0FBQyxTQUFVMm1CLElBQUk7d0JBQ25DLE9BQU95TSxVQUFVek0sTUFBTTFWLFNBQVNyZ0M7b0JBQ2xDO29CQUNBeTdDLGVBQWVwZCxLQUFLO2dCQUN0QjtnQkFFQSxJQUFJZ0MsUUFBUWgvQixXQUFXLEtBQUssTUFBTTtvQkFDaENpaUQscUJBQXFCampCLFNBQVNBLFFBQVFoL0IsV0FBVztnQkFDbkQ7WUFDRixFQUFFLE9BQU9yQixPQUFPO2dCQUNkeTlDLG9CQUFvQnBkLFNBQVNyZ0M7Z0JBQzdCbzdDLFdBQVcvYSxTQUFTcmdDO1lBQ3RCO1FBQ0Y7UUFDQSxTQUFTd2dDLGVBQWVILE9BQU87WUFDN0Jta0IsYUFBYW5rQjtRQUNmO1FBQ0EsU0FBU0UsYUFBYUYsT0FBTztZQUMzQixPQUFPQSxRQUFRNVcsU0FBUztRQUMxQjtRQUVBLFNBQVNrN0IsYUFDVDtRQUVBLFNBQVNDLG1CQUFtQmg4QyxRQUFRLEVBQUV3M0IsT0FBTyxFQUFFa0Msb0JBQW9CLEVBQUV1aUIsV0FBVyxFQUFFQywyQkFBMkI7WUFDM0csSUFBSUMsV0FBVztZQUNmLElBQUkzSixhQUFhO1lBQ2pCLElBQUluaEMsU0FBUztZQUNiLElBQUk1WSxjQUFjO2dCQUNoQixrQ0FBa0M7Z0JBQ2xDSSxNQUFNLFNBQVVGLEtBQUs7b0JBQ25CLElBQUlBLFVBQVUsTUFBTTt3QkFDbEIwWSxVQUFVMVk7b0JBQ1o7b0JBRUEsT0FBTztnQkFDVDtnQkFDQSxrQ0FBa0M7Z0JBQ2xDVSxTQUFTLFNBQVVqQyxLQUFLO29CQUN0QitrRCxXQUFXO29CQUNYM0osYUFBYXA3QztnQkFDZjtZQUNGO1lBQ0EsSUFBSWdsRCxnQkFBZ0I7WUFFcEIsU0FBU2xLO2dCQUNQa0ssZ0JBQWdCO1lBQ2xCO1lBRUEsSUFBSXY3QixZQUFZdVc7WUFDaEIsSUFBSUssVUFBVXFhLGNBQWM5eEMsVUFBVTZnQixXQUFXNFksb0JBQW9CNVksV0FBVzZZLHNCQUFzQmxDLFVBQVVBLFFBQVExVyxnQkFBZ0IsR0FBRzlJLFdBQVdra0MsOEJBQThCdmlCLDJCQUEyQjBpQixVQUFVTixXQUFXL2pDLFdBQVdrNkIsY0FBY2w2QixXQUFXQTtZQUN4UTJqQyxVQUFVbGtCLFVBQVUsNkVBQTZFO1lBQ2pHLG9FQUFvRTtZQUVwRXFrQixNQUFNcmtCLFNBQVN3a0I7WUFDZkosYUFBYXBrQixTQUFTaC9CO1lBRXRCLElBQUkwakQsWUFBWTNKLGVBQWV5SixhQUFhO2dCQUMxQyxNQUFNeko7WUFDUjtZQUVBLElBQUksQ0FBQzRKLGVBQWU7Z0JBQ2xCLHVFQUF1RTtnQkFDdkUsMEVBQTBFO2dCQUMxRSxpQ0FBaUM7Z0JBQ2pDLE1BQU0sSUFBSTkyQixNQUFNLHVFQUF1RSx3RUFBd0U7WUFDaks7WUFFQSxPQUFPalU7UUFDVDtRQUVBLElBQUlpckMsNEJBQTRCLFdBQVcsR0FBRSxTQUFVQyxTQUFTO1lBQzlEeGlELGVBQWV1aUQsMkJBQTJCQztZQUUxQyxTQUFTRDtnQkFDUCxJQUFJRTtnQkFFSiw2RUFBNkU7Z0JBQzdFLDZDQUE2QztnQkFDN0NBLFFBQVFELFVBQVVua0QsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLE1BQU0sSUFBSTtnQkFDeENva0QsTUFBTS9rQixPQUFPLEdBQUcsS0FBSztnQkFDckIra0IsTUFBTUMsY0FBYyxHQUFHLEtBQUs7Z0JBQzVCRCxNQUFNL2tCLE9BQU8sR0FBRztnQkFDaEIra0IsTUFBTUMsY0FBYyxHQUFHO2dCQUN2QixPQUFPRDtZQUNULEVBQUUsa0NBQWtDO1lBR3BDLElBQUlFLFNBQVNKLDBCQUEwQnBrRCxTQUFTO1lBRWhEd2tELE9BQU9DLFFBQVEsR0FBRyxTQUFTQSxTQUFTemIsR0FBRyxFQUFFM29DLFFBQVE7Z0JBQy9DdWpELE1BQU0sSUFBSSxDQUFDcmtCLE9BQU87Z0JBQ2xCbC9CLFNBQVMyb0M7WUFDWCxFQUFFLGtDQUFrQzs7WUFHcEN3YixPQUFPRSxLQUFLLEdBQUcsU0FBU0EsTUFBTXQyQyxJQUFJO2dCQUNoQyxJQUFJLElBQUksQ0FBQ20yQyxjQUFjLEVBQUU7b0JBQ3ZCWixhQUFhLElBQUksQ0FBQ3BrQixPQUFPLEVBQUUsSUFBSTtnQkFDakM7WUFDRjtZQUVBLE9BQU82a0I7UUFDVCxFQUFFL2xELE9BQU9zbUQsUUFBUTtRQUVqQixTQUFTcHpCLFdBQ1Q7UUFFQSxTQUFTcXpCLHVCQUF1Qjk4QyxRQUFRLEVBQUV3M0IsT0FBTyxFQUFFa0Msb0JBQW9CO1lBQ3JFLFNBQVN1WTtnQkFDUCxnRUFBZ0U7Z0JBQ2hFLHVFQUF1RTtnQkFDdkV4NUMsWUFBWWdrRCxjQUFjLEdBQUc7Z0JBQzdCWixhQUFhcGtCLFNBQVNoL0I7WUFDeEI7WUFFQSxJQUFJQSxjQUFjLElBQUk2akQ7WUFDdEIsSUFBSXo3QixZQUFZdVc7WUFDaEIsSUFBSUssVUFBVXFhLGNBQWM5eEMsVUFBVTZnQixXQUFXNFksb0JBQW9CNVksV0FBVyxPQUFPMlcsVUFBVUEsUUFBUTFXLGdCQUFnQixHQUFHOUksWUFBWTJoQiwyQkFBMkIwaUIsVUFBVTV5QixTQUFTd29CLFlBQVlqNkIsV0FBV0E7WUFDN012ZixZQUFZZy9CLE9BQU8sR0FBR0E7WUFDdEJra0IsVUFBVWxrQjtZQUNWLE9BQU9oL0I7UUFDVDtRQUVBLFNBQVNza0QsbUJBQW1CLzhDLFFBQVEsRUFBRXczQixPQUFPO1lBQzNDO2dCQUNFcGdDLE1BQU07WUFDUjtZQUVBLE9BQU8wbEQsdUJBQXVCOThDLFVBQVV3M0I7UUFDMUM7UUFFQSxTQUFTd2xCLHlCQUF5Qmg5QyxRQUFRLEVBQUV3M0IsT0FBTztZQUNqRCxPQUFPc2xCLHVCQUF1Qjk4QyxVQUFVdzNCO1FBQzFDO1FBRUEsU0FBU3lsQixlQUFlajlDLFFBQVEsRUFBRXczQixPQUFPO1lBQ3ZDLE9BQU93a0IsbUJBQW1CaDhDLFVBQVV3M0IsU0FBUyxPQUFPO1FBQ3REO1FBRUEsU0FBUzBsQixxQkFBcUJsOUMsUUFBUSxFQUFFdzNCLE9BQU87WUFDN0MsT0FBT3drQixtQkFBbUJoOEMsVUFBVXczQixTQUFTLE1BQU07UUFDckQ7UUFFQTJsQiwwQkFBMEIsR0FBR0o7UUFDN0JJLDRCQUE0QixHQUFHRDtRQUMvQkMsZ0NBQWdDLEdBQUdIO1FBQ25DRyxzQkFBc0IsR0FBR0Y7UUFDekJFLGVBQWUsR0FBRzNtRDtJQUNoQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2FoZWd1cnUtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20tc2VydmVyLWxlZ2FjeS5ub2RlLmRldmVsb3BtZW50LmpzPzVjNTciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtZG9tLXNlcnZlci1sZWdhY3kubm9kZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE4LjMuMC1jYW5hcnktMWEwMDFkYWM2LTIwMjMwODEyJztcblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbi8vIGJ5IGNhbGxzIHRvIHRoZXNlIG1ldGhvZHMgYnkgYSBCYWJlbCBwbHVnaW4uXG4vL1xuLy8gSW4gUFJPRCAob3IgaW4gcGFja2FnZXMgd2l0aG91dCBhY2Nlc3MgdG8gUmVhY3QgaW50ZXJuYWxzKSxcbi8vIHRoZXkgYXJlIGxlZnQgYXMgdGhleSBhcmUgaW5zdGVhZC5cblxuZnVuY3Rpb24gd2Fybihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnd2FybicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlV29yayhjYWxsYmFjaykge1xuICBjYWxsYmFjaygpO1xufVxuZnVuY3Rpb24gYmVnaW5Xcml0aW5nKGRlc3RpbmF0aW9uKSB7fVxuZnVuY3Rpb24gd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2h1bmspIHtcbiAgd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY2h1bmspO1xufVxuZnVuY3Rpb24gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY2h1bmspIHtcbiAgcmV0dXJuIGRlc3RpbmF0aW9uLnB1c2goY2h1bmspO1xufVxuZnVuY3Rpb24gY29tcGxldGVXcml0aW5nKGRlc3RpbmF0aW9uKSB7fVxuZnVuY3Rpb24gY2xvc2UoZGVzdGluYXRpb24pIHtcbiAgZGVzdGluYXRpb24ucHVzaChudWxsKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvQ2h1bmsoY29udGVudCkge1xuICByZXR1cm4gY29udGVudDtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhjb250ZW50KSB7XG4gIHJldHVybiBjb250ZW50O1xufVxuZnVuY3Rpb24gY2xvbmVQcmVjb21wdXRlZENodW5rKGNodW5rKSB7XG4gIHJldHVybiBjaHVuaztcbn1cbmZ1bmN0aW9uIGNsb3NlV2l0aEVycm9yKGRlc3RpbmF0aW9uLCBlcnJvcikge1xuICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogVGhpcyBpcyBhbiBFcnJvciBvYmplY3Qgb3IgdGhlIGRlc3RpbmF0aW9uIGFjY2VwdHMgb3RoZXIgdHlwZXMuXG4gIGRlc3RpbmF0aW9uLmRlc3Ryb3koZXJyb3IpO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQgYCVzYCBhdHRyaWJ1dGUgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgYXR0cmlidXRlTmFtZSwgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24odmFsdWUsIHByb3BOYW1lKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGAlc2AgQ1NTIHByb3BlcnR5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHByb3BOYW1lLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIEhUTUwgbWFya3VwIHVzZXMgYSB2YWx1ZSBvZiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBlbmFibGVGbG9hdCA9IHRydWU7IC8vIEVuYWJsZXMgdW5zdGFibGVfdXNlTWVtb0NhY2hlIGhvb2ssIGludGVuZGVkIGFzIGEgY29tcGlsYXRpb24gdGFyZ2V0IGZvclxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbnZhciBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSID0gXCI6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXCI7XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxudmFyIEFUVFJJQlVURV9OQU1FX0NIQVIgPSBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgXCJcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MFwiO1xudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlsnICsgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICddWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbnZhciB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGlzQXR0cmlidXRlTmFtZVNhZmUoYXR0cmlidXRlTmFtZSkge1xuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUsIGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLCBhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuXG4gIHtcbiAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgbmFtZTogYCVzYCcsIGF0dHJpYnV0ZU5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL1xudmFyIHVuaXRsZXNzTnVtYmVycyA9IG5ldyBTZXQoWydhbmltYXRpb25JdGVyYXRpb25Db3VudCcsICdhc3BlY3RSYXRpbycsICdib3JkZXJJbWFnZU91dHNldCcsICdib3JkZXJJbWFnZVNsaWNlJywgJ2JvcmRlckltYWdlV2lkdGgnLCAnYm94RmxleCcsICdib3hGbGV4R3JvdXAnLCAnYm94T3JkaW5hbEdyb3VwJywgJ2NvbHVtbkNvdW50JywgJ2NvbHVtbnMnLCAnZmxleCcsICdmbGV4R3JvdycsICdmbGV4UG9zaXRpdmUnLCAnZmxleFNocmluaycsICdmbGV4TmVnYXRpdmUnLCAnZmxleE9yZGVyJywgJ2dyaWRBcmVhJywgJ2dyaWRSb3cnLCAnZ3JpZFJvd0VuZCcsICdncmlkUm93U3BhbicsICdncmlkUm93U3RhcnQnLCAnZ3JpZENvbHVtbicsICdncmlkQ29sdW1uRW5kJywgJ2dyaWRDb2x1bW5TcGFuJywgJ2dyaWRDb2x1bW5TdGFydCcsICdmb250V2VpZ2h0JywgJ2xpbmVDbGFtcCcsICdsaW5lSGVpZ2h0JywgJ29wYWNpdHknLCAnb3JkZXInLCAnb3JwaGFucycsICdzY2FsZScsICd0YWJTaXplJywgJ3dpZG93cycsICd6SW5kZXgnLCAnem9vbScsICdmaWxsT3BhY2l0eScsIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbidmbG9vZE9wYWNpdHknLCAnc3RvcE9wYWNpdHknLCAnc3Ryb2tlRGFzaGFycmF5JywgJ3N0cm9rZURhc2hvZmZzZXQnLCAnc3Ryb2tlTWl0ZXJsaW1pdCcsICdzdHJva2VPcGFjaXR5JywgJ3N0cm9rZVdpZHRoJywgJ01vekFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50JywgLy8gS25vd24gUHJlZml4ZWQgUHJvcGVydGllc1xuJ01vekJveEZsZXgnLCAvLyBUT0RPOiBSZW1vdmUgdGhlc2Ugc2luY2UgdGhleSBzaG91bGRuJ3QgYmUgdXNlZCBpbiBtb2Rlcm4gY29kZVxuJ01vekJveEZsZXhHcm91cCcsICdNb3pMaW5lQ2xhbXAnLCAnbXNBbmltYXRpb25JdGVyYXRpb25Db3VudCcsICdtc0ZsZXgnLCAnbXNab29tJywgJ21zRmxleEdyb3cnLCAnbXNGbGV4TmVnYXRpdmUnLCAnbXNGbGV4T3JkZXInLCAnbXNGbGV4UG9zaXRpdmUnLCAnbXNGbGV4U2hyaW5rJywgJ21zR3JpZENvbHVtbicsICdtc0dyaWRDb2x1bW5TcGFuJywgJ21zR3JpZFJvdycsICdtc0dyaWRSb3dTcGFuJywgJ1dlYmtpdEFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50JywgJ1dlYmtpdEJveEZsZXgnLCAnV2ViS2l0Qm94RmxleEdyb3VwJywgJ1dlYmtpdEJveE9yZGluYWxHcm91cCcsICdXZWJraXRDb2x1bW5Db3VudCcsICdXZWJraXRDb2x1bW5zJywgJ1dlYmtpdEZsZXgnLCAnV2Via2l0RmxleEdyb3cnLCAnV2Via2l0RmxleFBvc2l0aXZlJywgJ1dlYmtpdEZsZXhTaHJpbmsnLCAnV2Via2l0TGluZUNsYW1wJ10pO1xuZnVuY3Rpb24gaXNVbml0bGVzc051bWJlciAobmFtZSkge1xuICByZXR1cm4gdW5pdGxlc3NOdW1iZXJzLmhhcyhuYW1lKTtcbn1cblxudmFyIGFsaWFzZXMgPSBuZXcgTWFwKFtbJ2FjY2VwdENoYXJzZXQnLCAnYWNjZXB0LWNoYXJzZXQnXSwgWydodG1sRm9yJywgJ2ZvciddLCBbJ2h0dHBFcXVpdicsICdodHRwLWVxdWl2J10sIC8vIEhUTUwgYW5kIFNWRyBhdHRyaWJ1dGVzLCBidXQgdGhlIFNWRyBhdHRyaWJ1dGUgaXMgY2FzZSBzZW5zaXRpdmUuXSxcblsnY3Jvc3NPcmlnaW4nLCAnY3Jvc3NvcmlnaW4nXSwgLy8gVGhpcyBpcyBhIGxpc3Qgb2YgYWxsIFNWRyBhdHRyaWJ1dGVzIHRoYXQgbmVlZCBzcGVjaWFsIGNhc2luZy5cbi8vIFJlZ3VsYXIgYXR0cmlidXRlcyB0aGF0IGp1c3QgYWNjZXB0IHN0cmluZ3MuXSxcblsnYWNjZW50SGVpZ2h0JywgJ2FjY2VudC1oZWlnaHQnXSwgWydhbGlnbm1lbnRCYXNlbGluZScsICdhbGlnbm1lbnQtYmFzZWxpbmUnXSwgWydhcmFiaWNGb3JtJywgJ2FyYWJpYy1mb3JtJ10sIFsnYmFzZWxpbmVTaGlmdCcsICdiYXNlbGluZS1zaGlmdCddLCBbJ2NhcEhlaWdodCcsICdjYXAtaGVpZ2h0J10sIFsnY2xpcFBhdGgnLCAnY2xpcC1wYXRoJ10sIFsnY2xpcFJ1bGUnLCAnY2xpcC1ydWxlJ10sIFsnY29sb3JJbnRlcnBvbGF0aW9uJywgJ2NvbG9yLWludGVycG9sYXRpb24nXSwgWydjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJywgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyddLCBbJ2NvbG9yUHJvZmlsZScsICdjb2xvci1wcm9maWxlJ10sIFsnY29sb3JSZW5kZXJpbmcnLCAnY29sb3ItcmVuZGVyaW5nJ10sIFsnZG9taW5hbnRCYXNlbGluZScsICdkb21pbmFudC1iYXNlbGluZSddLCBbJ2VuYWJsZUJhY2tncm91bmQnLCAnZW5hYmxlLWJhY2tncm91bmQnXSwgWydmaWxsT3BhY2l0eScsICdmaWxsLW9wYWNpdHknXSwgWydmaWxsUnVsZScsICdmaWxsLXJ1bGUnXSwgWydmbG9vZENvbG9yJywgJ2Zsb29kLWNvbG9yJ10sIFsnZmxvb2RPcGFjaXR5JywgJ2Zsb29kLW9wYWNpdHknXSwgWydmb250RmFtaWx5JywgJ2ZvbnQtZmFtaWx5J10sIFsnZm9udFNpemUnLCAnZm9udC1zaXplJ10sIFsnZm9udFNpemVBZGp1c3QnLCAnZm9udC1zaXplLWFkanVzdCddLCBbJ2ZvbnRTdHJldGNoJywgJ2ZvbnQtc3RyZXRjaCddLCBbJ2ZvbnRTdHlsZScsICdmb250LXN0eWxlJ10sIFsnZm9udFZhcmlhbnQnLCAnZm9udC12YXJpYW50J10sIFsnZm9udFdlaWdodCcsICdmb250LXdlaWdodCddLCBbJ2dseXBoTmFtZScsICdnbHlwaC1uYW1lJ10sIFsnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLCAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCddLCBbJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCddLCBbJ2hvcml6QWR2WCcsICdob3Jpei1hZHYteCddLCBbJ2hvcml6T3JpZ2luWCcsICdob3Jpei1vcmlnaW4teCddLCBbJ2ltYWdlUmVuZGVyaW5nJywgJ2ltYWdlLXJlbmRlcmluZyddLCBbJ2xldHRlclNwYWNpbmcnLCAnbGV0dGVyLXNwYWNpbmcnXSwgWydsaWdodGluZ0NvbG9yJywgJ2xpZ2h0aW5nLWNvbG9yJ10sIFsnbWFya2VyRW5kJywgJ21hcmtlci1lbmQnXSwgWydtYXJrZXJNaWQnLCAnbWFya2VyLW1pZCddLCBbJ21hcmtlclN0YXJ0JywgJ21hcmtlci1zdGFydCddLCBbJ292ZXJsaW5lUG9zaXRpb24nLCAnb3ZlcmxpbmUtcG9zaXRpb24nXSwgWydvdmVybGluZVRoaWNrbmVzcycsICdvdmVybGluZS10aGlja25lc3MnXSwgWydwYWludE9yZGVyJywgJ3BhaW50LW9yZGVyJ10sIFsncGFub3NlLTEnLCAncGFub3NlLTEnXSwgWydwb2ludGVyRXZlbnRzJywgJ3BvaW50ZXItZXZlbnRzJ10sIFsncmVuZGVyaW5nSW50ZW50JywgJ3JlbmRlcmluZy1pbnRlbnQnXSwgWydzaGFwZVJlbmRlcmluZycsICdzaGFwZS1yZW5kZXJpbmcnXSwgWydzdG9wQ29sb3InLCAnc3RvcC1jb2xvciddLCBbJ3N0b3BPcGFjaXR5JywgJ3N0b3Atb3BhY2l0eSddLCBbJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJ10sIFsnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyddLCBbJ3N0cm9rZURhc2hhcnJheScsICdzdHJva2UtZGFzaGFycmF5J10sIFsnc3Ryb2tlRGFzaG9mZnNldCcsICdzdHJva2UtZGFzaG9mZnNldCddLCBbJ3N0cm9rZUxpbmVjYXAnLCAnc3Ryb2tlLWxpbmVjYXAnXSwgWydzdHJva2VMaW5lam9pbicsICdzdHJva2UtbGluZWpvaW4nXSwgWydzdHJva2VNaXRlcmxpbWl0JywgJ3N0cm9rZS1taXRlcmxpbWl0J10sIFsnc3Ryb2tlT3BhY2l0eScsICdzdHJva2Utb3BhY2l0eSddLCBbJ3N0cm9rZVdpZHRoJywgJ3N0cm9rZS13aWR0aCddLCBbJ3RleHRBbmNob3InLCAndGV4dC1hbmNob3InXSwgWyd0ZXh0RGVjb3JhdGlvbicsICd0ZXh0LWRlY29yYXRpb24nXSwgWyd0ZXh0UmVuZGVyaW5nJywgJ3RleHQtcmVuZGVyaW5nJ10sIFsndHJhbnNmb3JtT3JpZ2luJywgJ3RyYW5zZm9ybS1vcmlnaW4nXSwgWyd1bmRlcmxpbmVQb3NpdGlvbicsICd1bmRlcmxpbmUtcG9zaXRpb24nXSwgWyd1bmRlcmxpbmVUaGlja25lc3MnLCAndW5kZXJsaW5lLXRoaWNrbmVzcyddLCBbJ3VuaWNvZGVCaWRpJywgJ3VuaWNvZGUtYmlkaSddLCBbJ3VuaWNvZGVSYW5nZScsICd1bmljb2RlLXJhbmdlJ10sIFsndW5pdHNQZXJFbScsICd1bml0cy1wZXItZW0nXSwgWyd2QWxwaGFiZXRpYycsICd2LWFscGhhYmV0aWMnXSwgWyd2SGFuZ2luZycsICd2LWhhbmdpbmcnXSwgWyd2SWRlb2dyYXBoaWMnLCAndi1pZGVvZ3JhcGhpYyddLCBbJ3ZNYXRoZW1hdGljYWwnLCAndi1tYXRoZW1hdGljYWwnXSwgWyd2ZWN0b3JFZmZlY3QnLCAndmVjdG9yLWVmZmVjdCddLCBbJ3ZlcnRBZHZZJywgJ3ZlcnQtYWR2LXknXSwgWyd2ZXJ0T3JpZ2luWCcsICd2ZXJ0LW9yaWdpbi14J10sIFsndmVydE9yaWdpblknLCAndmVydC1vcmlnaW4teSddLCBbJ3dvcmRTcGFjaW5nJywgJ3dvcmQtc3BhY2luZyddLCBbJ3dyaXRpbmdNb2RlJywgJ3dyaXRpbmctbW9kZSddLCBbJ3htbG5zWGxpbmsnLCAneG1sbnM6eGxpbmsnXSwgWyd4SGVpZ2h0JywgJ3gtaGVpZ2h0J11dKTtcbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZUFsaWFzIChuYW1lKSB7XG4gIHJldHVybiBhbGlhc2VzLmdldChuYW1lKSB8fCBuYW1lO1xufVxuXG52YXIgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgYnV0dG9uOiB0cnVlLFxuICBjaGVja2JveDogdHJ1ZSxcbiAgaW1hZ2U6IHRydWUsXG4gIGhpZGRlbjogdHJ1ZSxcbiAgcmFkaW86IHRydWUsXG4gIHJlc2V0OiB0cnVlLFxuICBzdWJtaXQ6IHRydWVcbn07XG5mdW5jdGlvbiBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKHRhZ05hbWUsIHByb3BzKSB7XG4gIHtcbiAgICBpZiAoIShoYXNSZWFkT25seVZhbHVlW3Byb3BzLnR5cGVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLm9uSW5wdXQgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQgfHwgcHJvcHMudmFsdWUgPT0gbnVsbCkpIHtcbiAgICAgIGVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgIH1cblxuICAgIGlmICghKHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkIHx8IHByb3BzLmNoZWNrZWQgPT0gbnVsbCkpIHtcbiAgICAgIGVycm9yKCdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGFyaWFQcm9wZXJ0aWVzID0ge1xuICAnYXJpYS1jdXJyZW50JzogMCxcbiAgLy8gc3RhdGVcbiAgJ2FyaWEtZGVzY3JpcHRpb24nOiAwLFxuICAnYXJpYS1kZXRhaWxzJzogMCxcbiAgJ2FyaWEtZGlzYWJsZWQnOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1oaWRkZW4nOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1pbnZhbGlkJzogMCxcbiAgLy8gc3RhdGVcbiAgJ2FyaWEta2V5c2hvcnRjdXRzJzogMCxcbiAgJ2FyaWEtbGFiZWwnOiAwLFxuICAnYXJpYS1yb2xlZGVzY3JpcHRpb24nOiAwLFxuICAvLyBXaWRnZXQgQXR0cmlidXRlc1xuICAnYXJpYS1hdXRvY29tcGxldGUnOiAwLFxuICAnYXJpYS1jaGVja2VkJzogMCxcbiAgJ2FyaWEtZXhwYW5kZWQnOiAwLFxuICAnYXJpYS1oYXNwb3B1cCc6IDAsXG4gICdhcmlhLWxldmVsJzogMCxcbiAgJ2FyaWEtbW9kYWwnOiAwLFxuICAnYXJpYS1tdWx0aWxpbmUnOiAwLFxuICAnYXJpYS1tdWx0aXNlbGVjdGFibGUnOiAwLFxuICAnYXJpYS1vcmllbnRhdGlvbic6IDAsXG4gICdhcmlhLXBsYWNlaG9sZGVyJzogMCxcbiAgJ2FyaWEtcHJlc3NlZCc6IDAsXG4gICdhcmlhLXJlYWRvbmx5JzogMCxcbiAgJ2FyaWEtcmVxdWlyZWQnOiAwLFxuICAnYXJpYS1zZWxlY3RlZCc6IDAsXG4gICdhcmlhLXNvcnQnOiAwLFxuICAnYXJpYS12YWx1ZW1heCc6IDAsXG4gICdhcmlhLXZhbHVlbWluJzogMCxcbiAgJ2FyaWEtdmFsdWVub3cnOiAwLFxuICAnYXJpYS12YWx1ZXRleHQnOiAwLFxuICAvLyBMaXZlIFJlZ2lvbiBBdHRyaWJ1dGVzXG4gICdhcmlhLWF0b21pYyc6IDAsXG4gICdhcmlhLWJ1c3knOiAwLFxuICAnYXJpYS1saXZlJzogMCxcbiAgJ2FyaWEtcmVsZXZhbnQnOiAwLFxuICAvLyBEcmFnLWFuZC1Ecm9wIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtZHJvcGVmZmVjdCc6IDAsXG4gICdhcmlhLWdyYWJiZWQnOiAwLFxuICAvLyBSZWxhdGlvbnNoaXAgQXR0cmlidXRlc1xuICAnYXJpYS1hY3RpdmVkZXNjZW5kYW50JzogMCxcbiAgJ2FyaWEtY29sY291bnQnOiAwLFxuICAnYXJpYS1jb2xpbmRleCc6IDAsXG4gICdhcmlhLWNvbHNwYW4nOiAwLFxuICAnYXJpYS1jb250cm9scyc6IDAsXG4gICdhcmlhLWRlc2NyaWJlZGJ5JzogMCxcbiAgJ2FyaWEtZXJyb3JtZXNzYWdlJzogMCxcbiAgJ2FyaWEtZmxvd3RvJzogMCxcbiAgJ2FyaWEtbGFiZWxsZWRieSc6IDAsXG4gICdhcmlhLW93bnMnOiAwLFxuICAnYXJpYS1wb3NpbnNldCc6IDAsXG4gICdhcmlhLXJvd2NvdW50JzogMCxcbiAgJ2FyaWEtcm93aW5kZXgnOiAwLFxuICAnYXJpYS1yb3dzcGFuJzogMCxcbiAgJ2FyaWEtc2V0c2l6ZSc6IDBcbn07XG5cbnZhciB3YXJuZWRQcm9wZXJ0aWVzJDEgPSB7fTtcbnZhciByQVJJQSQxID0gbmV3IFJlZ0V4cCgnXihhcmlhKS1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgckFSSUFDYW1lbCQxID0gbmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5JDEodGFnTmFtZSwgbmFtZSkge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwod2FybmVkUHJvcGVydGllcyQxLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChyQVJJQUNhbWVsJDEudGVzdChuYW1lKSkge1xuICAgICAgdmFyIGFyaWFOYW1lID0gJ2FyaWEtJyArIG5hbWUuc2xpY2UoNCkudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBjb3JyZWN0TmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGFyaWFOYW1lKSA/IGFyaWFOYW1lIDogbnVsbDsgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG5cbiAgICAgIGlmIChjb3JyZWN0TmFtZSA9PSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIEFSSUEgYXR0cmlidXRlcyBmb2xsb3cgdGhlIHBhdHRlcm4gYXJpYS0qIGFuZCBtdXN0IGJlIGxvd2VyY2FzZS4nLCBuYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG5cblxuICAgICAgaWYgKG5hbWUgIT09IGNvcnJlY3ROYW1lKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIGNvcnJlY3ROYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAockFSSUEkMS50ZXN0KG5hbWUpKSB7XG4gICAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgc3RhbmRhcmROYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gbG93ZXJDYXNlZE5hbWUgOiBudWxsOyAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cblxuICAgICAgaWYgKHN0YW5kYXJkTmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG5cblxuICAgICAgaWYgKG5hbWUgIT09IHN0YW5kYXJkTmFtZSkge1xuICAgICAgICBlcnJvcignVW5rbm93biBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBzdGFuZGFyZE5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcykge1xuICB7XG4gICAgdmFyIGludmFsaWRQcm9wcyA9IFtdO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkkMSh0eXBlLCBrZXkpO1xuXG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgaW52YWxpZFByb3BzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSBpbnZhbGlkUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgICB9KS5qb2luKCcsICcpO1xuXG4gICAgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIGFyaWEgcHJvcCAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWFyaWEtcHJvcHMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfSBlbHNlIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID4gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgYXJpYSBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWFyaWEtcHJvcHMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuVmFsdWVOdWxsID0gZmFsc2U7XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcykge1xuICB7XG4gICAgaWYgKHR5cGUgIT09ICdpbnB1dCcgJiYgdHlwZSAhPT0gJ3RleHRhcmVhJyAmJiB0eXBlICE9PSAnc2VsZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wcyAhPSBudWxsICYmIHByb3BzLnZhbHVlID09PSBudWxsICYmICFkaWRXYXJuVmFsdWVOdWxsKSB7XG4gICAgICBkaWRXYXJuVmFsdWVOdWxsID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGUgPT09ICdzZWxlY3QnICYmIHByb3BzLm11bHRpcGxlKSB7XG4gICAgICAgIGVycm9yKCdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgYXJyYXkgd2hlbiBgbXVsdGlwbGVgIGlzIHNldCB0byBgdHJ1ZWAgJyArICd0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgIGZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4nLCB0eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgJyArICdmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzQ3VzdG9tRWxlbWVudCh0YWdOYW1lLCBwcm9wcykge1xuICBpZiAodGFnTmFtZS5pbmRleE9mKCctJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgLy8gVGhlc2UgYXJlIHJlc2VydmVkIFNWRyBhbmQgTWF0aE1MIGVsZW1lbnRzLlxuICAgIC8vIFdlIGRvbid0IG1pbmQgdGhpcyBsaXN0IHRvbyBtdWNoIGJlY2F1c2Ugd2UgZXhwZWN0IGl0IHRvIG5ldmVyIGdyb3cuXG4gICAgLy8gVGhlIGFsdGVybmF0aXZlIGlzIHRvIHRyYWNrIHRoZSBuYW1lc3BhY2UgaW4gYSBmZXcgcGxhY2VzIHdoaWNoIGlzIGNvbnZvbHV0ZWQuXG4gICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9jdXN0b20vI2N1c3RvbS1lbGVtZW50cy1jb3JlLWNvbmNlcHRzXG4gICAgY2FzZSAnYW5ub3RhdGlvbi14bWwnOlxuICAgIGNhc2UgJ2NvbG9yLXByb2ZpbGUnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXNyYyc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXVyaSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLWZvcm1hdCc6XG4gICAgY2FzZSAnZm9udC1mYWNlLW5hbWUnOlxuICAgIGNhc2UgJ21pc3NpbmctZ2x5cGgnOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8vIFdoZW4gYWRkaW5nIGF0dHJpYnV0ZXMgdG8gdGhlIEhUTUwgb3IgU1ZHIGFsbG93ZWQgYXR0cmlidXRlIGxpc3QsIGJlIHN1cmUgdG9cbi8vIGFsc28gYWRkIHRoZW0gdG8gdGhpcyBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0IG5hbWVcbi8vIHdhcm5pbmdzLlxudmFyIHBvc3NpYmxlU3RhbmRhcmROYW1lcyA9IHtcbiAgLy8gSFRNTFxuICBhY2NlcHQ6ICdhY2NlcHQnLFxuICBhY2NlcHRjaGFyc2V0OiAnYWNjZXB0Q2hhcnNldCcsXG4gICdhY2NlcHQtY2hhcnNldCc6ICdhY2NlcHRDaGFyc2V0JyxcbiAgYWNjZXNza2V5OiAnYWNjZXNzS2V5JyxcbiAgYWN0aW9uOiAnYWN0aW9uJyxcbiAgYWxsb3dmdWxsc2NyZWVuOiAnYWxsb3dGdWxsU2NyZWVuJyxcbiAgYWx0OiAnYWx0JyxcbiAgYXM6ICdhcycsXG4gIGFzeW5jOiAnYXN5bmMnLFxuICBhdXRvY2FwaXRhbGl6ZTogJ2F1dG9DYXBpdGFsaXplJyxcbiAgYXV0b2NvbXBsZXRlOiAnYXV0b0NvbXBsZXRlJyxcbiAgYXV0b2NvcnJlY3Q6ICdhdXRvQ29ycmVjdCcsXG4gIGF1dG9mb2N1czogJ2F1dG9Gb2N1cycsXG4gIGF1dG9wbGF5OiAnYXV0b1BsYXknLFxuICBhdXRvc2F2ZTogJ2F1dG9TYXZlJyxcbiAgY2FwdHVyZTogJ2NhcHR1cmUnLFxuICBjZWxscGFkZGluZzogJ2NlbGxQYWRkaW5nJyxcbiAgY2VsbHNwYWNpbmc6ICdjZWxsU3BhY2luZycsXG4gIGNoYWxsZW5nZTogJ2NoYWxsZW5nZScsXG4gIGNoYXJzZXQ6ICdjaGFyU2V0JyxcbiAgY2hlY2tlZDogJ2NoZWNrZWQnLFxuICBjaGlsZHJlbjogJ2NoaWxkcmVuJyxcbiAgY2l0ZTogJ2NpdGUnLFxuICBjbGFzczogJ2NsYXNzTmFtZScsXG4gIGNsYXNzaWQ6ICdjbGFzc0lEJyxcbiAgY2xhc3NuYW1lOiAnY2xhc3NOYW1lJyxcbiAgY29sczogJ2NvbHMnLFxuICBjb2xzcGFuOiAnY29sU3BhbicsXG4gIGNvbnRlbnQ6ICdjb250ZW50JyxcbiAgY29udGVudGVkaXRhYmxlOiAnY29udGVudEVkaXRhYmxlJyxcbiAgY29udGV4dG1lbnU6ICdjb250ZXh0TWVudScsXG4gIGNvbnRyb2xzOiAnY29udHJvbHMnLFxuICBjb250cm9sc2xpc3Q6ICdjb250cm9sc0xpc3QnLFxuICBjb29yZHM6ICdjb29yZHMnLFxuICBjcm9zc29yaWdpbjogJ2Nyb3NzT3JpZ2luJyxcbiAgZGFuZ2Vyb3VzbHlzZXRpbm5lcmh0bWw6ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsXG4gIGRhdGE6ICdkYXRhJyxcbiAgZGF0ZXRpbWU6ICdkYXRlVGltZScsXG4gIGRlZmF1bHQ6ICdkZWZhdWx0JyxcbiAgZGVmYXVsdGNoZWNrZWQ6ICdkZWZhdWx0Q2hlY2tlZCcsXG4gIGRlZmF1bHR2YWx1ZTogJ2RlZmF1bHRWYWx1ZScsXG4gIGRlZmVyOiAnZGVmZXInLFxuICBkaXI6ICdkaXInLFxuICBkaXNhYmxlZDogJ2Rpc2FibGVkJyxcbiAgZGlzYWJsZXBpY3R1cmVpbnBpY3R1cmU6ICdkaXNhYmxlUGljdHVyZUluUGljdHVyZScsXG4gIGRpc2FibGVyZW1vdGVwbGF5YmFjazogJ2Rpc2FibGVSZW1vdGVQbGF5YmFjaycsXG4gIGRvd25sb2FkOiAnZG93bmxvYWQnLFxuICBkcmFnZ2FibGU6ICdkcmFnZ2FibGUnLFxuICBlbmN0eXBlOiAnZW5jVHlwZScsXG4gIGVudGVya2V5aGludDogJ2VudGVyS2V5SGludCcsXG4gIGZldGNocHJpb3JpdHk6ICdmZXRjaFByaW9yaXR5JyxcbiAgZm9yOiAnaHRtbEZvcicsXG4gIGZvcm06ICdmb3JtJyxcbiAgZm9ybW1ldGhvZDogJ2Zvcm1NZXRob2QnLFxuICBmb3JtYWN0aW9uOiAnZm9ybUFjdGlvbicsXG4gIGZvcm1lbmN0eXBlOiAnZm9ybUVuY1R5cGUnLFxuICBmb3Jtbm92YWxpZGF0ZTogJ2Zvcm1Ob1ZhbGlkYXRlJyxcbiAgZm9ybXRhcmdldDogJ2Zvcm1UYXJnZXQnLFxuICBmcmFtZWJvcmRlcjogJ2ZyYW1lQm9yZGVyJyxcbiAgaGVhZGVyczogJ2hlYWRlcnMnLFxuICBoZWlnaHQ6ICdoZWlnaHQnLFxuICBoaWRkZW46ICdoaWRkZW4nLFxuICBoaWdoOiAnaGlnaCcsXG4gIGhyZWY6ICdocmVmJyxcbiAgaHJlZmxhbmc6ICdocmVmTGFuZycsXG4gIGh0bWxmb3I6ICdodG1sRm9yJyxcbiAgaHR0cGVxdWl2OiAnaHR0cEVxdWl2JyxcbiAgJ2h0dHAtZXF1aXYnOiAnaHR0cEVxdWl2JyxcbiAgaWNvbjogJ2ljb24nLFxuICBpZDogJ2lkJyxcbiAgaW1hZ2VzaXplczogJ2ltYWdlU2l6ZXMnLFxuICBpbWFnZXNyY3NldDogJ2ltYWdlU3JjU2V0JyxcbiAgaW5uZXJodG1sOiAnaW5uZXJIVE1MJyxcbiAgaW5wdXRtb2RlOiAnaW5wdXRNb2RlJyxcbiAgaW50ZWdyaXR5OiAnaW50ZWdyaXR5JyxcbiAgaXM6ICdpcycsXG4gIGl0ZW1pZDogJ2l0ZW1JRCcsXG4gIGl0ZW1wcm9wOiAnaXRlbVByb3AnLFxuICBpdGVtcmVmOiAnaXRlbVJlZicsXG4gIGl0ZW1zY29wZTogJ2l0ZW1TY29wZScsXG4gIGl0ZW10eXBlOiAnaXRlbVR5cGUnLFxuICBrZXlwYXJhbXM6ICdrZXlQYXJhbXMnLFxuICBrZXl0eXBlOiAna2V5VHlwZScsXG4gIGtpbmQ6ICdraW5kJyxcbiAgbGFiZWw6ICdsYWJlbCcsXG4gIGxhbmc6ICdsYW5nJyxcbiAgbGlzdDogJ2xpc3QnLFxuICBsb29wOiAnbG9vcCcsXG4gIGxvdzogJ2xvdycsXG4gIG1hbmlmZXN0OiAnbWFuaWZlc3QnLFxuICBtYXJnaW53aWR0aDogJ21hcmdpbldpZHRoJyxcbiAgbWFyZ2luaGVpZ2h0OiAnbWFyZ2luSGVpZ2h0JyxcbiAgbWF4OiAnbWF4JyxcbiAgbWF4bGVuZ3RoOiAnbWF4TGVuZ3RoJyxcbiAgbWVkaWE6ICdtZWRpYScsXG4gIG1lZGlhZ3JvdXA6ICdtZWRpYUdyb3VwJyxcbiAgbWV0aG9kOiAnbWV0aG9kJyxcbiAgbWluOiAnbWluJyxcbiAgbWlubGVuZ3RoOiAnbWluTGVuZ3RoJyxcbiAgbXVsdGlwbGU6ICdtdWx0aXBsZScsXG4gIG11dGVkOiAnbXV0ZWQnLFxuICBuYW1lOiAnbmFtZScsXG4gIG5vbW9kdWxlOiAnbm9Nb2R1bGUnLFxuICBub25jZTogJ25vbmNlJyxcbiAgbm92YWxpZGF0ZTogJ25vVmFsaWRhdGUnLFxuICBvcGVuOiAnb3BlbicsXG4gIG9wdGltdW06ICdvcHRpbXVtJyxcbiAgcGF0dGVybjogJ3BhdHRlcm4nLFxuICBwbGFjZWhvbGRlcjogJ3BsYWNlaG9sZGVyJyxcbiAgcGxheXNpbmxpbmU6ICdwbGF5c0lubGluZScsXG4gIHBvc3RlcjogJ3Bvc3RlcicsXG4gIHByZWxvYWQ6ICdwcmVsb2FkJyxcbiAgcHJvZmlsZTogJ3Byb2ZpbGUnLFxuICByYWRpb2dyb3VwOiAncmFkaW9Hcm91cCcsXG4gIHJlYWRvbmx5OiAncmVhZE9ubHknLFxuICByZWZlcnJlcnBvbGljeTogJ3JlZmVycmVyUG9saWN5JyxcbiAgcmVsOiAncmVsJyxcbiAgcmVxdWlyZWQ6ICdyZXF1aXJlZCcsXG4gIHJldmVyc2VkOiAncmV2ZXJzZWQnLFxuICByb2xlOiAncm9sZScsXG4gIHJvd3M6ICdyb3dzJyxcbiAgcm93c3BhbjogJ3Jvd1NwYW4nLFxuICBzYW5kYm94OiAnc2FuZGJveCcsXG4gIHNjb3BlOiAnc2NvcGUnLFxuICBzY29wZWQ6ICdzY29wZWQnLFxuICBzY3JvbGxpbmc6ICdzY3JvbGxpbmcnLFxuICBzZWFtbGVzczogJ3NlYW1sZXNzJyxcbiAgc2VsZWN0ZWQ6ICdzZWxlY3RlZCcsXG4gIHNoYXBlOiAnc2hhcGUnLFxuICBzaXplOiAnc2l6ZScsXG4gIHNpemVzOiAnc2l6ZXMnLFxuICBzcGFuOiAnc3BhbicsXG4gIHNwZWxsY2hlY2s6ICdzcGVsbENoZWNrJyxcbiAgc3JjOiAnc3JjJyxcbiAgc3JjZG9jOiAnc3JjRG9jJyxcbiAgc3JjbGFuZzogJ3NyY0xhbmcnLFxuICBzcmNzZXQ6ICdzcmNTZXQnLFxuICBzdGFydDogJ3N0YXJ0JyxcbiAgc3RlcDogJ3N0ZXAnLFxuICBzdHlsZTogJ3N0eWxlJyxcbiAgc3VtbWFyeTogJ3N1bW1hcnknLFxuICB0YWJpbmRleDogJ3RhYkluZGV4JyxcbiAgdGFyZ2V0OiAndGFyZ2V0JyxcbiAgdGl0bGU6ICd0aXRsZScsXG4gIHR5cGU6ICd0eXBlJyxcbiAgdXNlbWFwOiAndXNlTWFwJyxcbiAgdmFsdWU6ICd2YWx1ZScsXG4gIHdpZHRoOiAnd2lkdGgnLFxuICB3bW9kZTogJ3dtb2RlJyxcbiAgd3JhcDogJ3dyYXAnLFxuICAvLyBTVkdcbiAgYWJvdXQ6ICdhYm91dCcsXG4gIGFjY2VudGhlaWdodDogJ2FjY2VudEhlaWdodCcsXG4gICdhY2NlbnQtaGVpZ2h0JzogJ2FjY2VudEhlaWdodCcsXG4gIGFjY3VtdWxhdGU6ICdhY2N1bXVsYXRlJyxcbiAgYWRkaXRpdmU6ICdhZGRpdGl2ZScsXG4gIGFsaWdubWVudGJhc2VsaW5lOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICAnYWxpZ25tZW50LWJhc2VsaW5lJzogJ2FsaWdubWVudEJhc2VsaW5lJyxcbiAgYWxsb3dyZW9yZGVyOiAnYWxsb3dSZW9yZGVyJyxcbiAgYWxwaGFiZXRpYzogJ2FscGhhYmV0aWMnLFxuICBhbXBsaXR1ZGU6ICdhbXBsaXR1ZGUnLFxuICBhcmFiaWNmb3JtOiAnYXJhYmljRm9ybScsXG4gICdhcmFiaWMtZm9ybSc6ICdhcmFiaWNGb3JtJyxcbiAgYXNjZW50OiAnYXNjZW50JyxcbiAgYXR0cmlidXRlbmFtZTogJ2F0dHJpYnV0ZU5hbWUnLFxuICBhdHRyaWJ1dGV0eXBlOiAnYXR0cmlidXRlVHlwZScsXG4gIGF1dG9yZXZlcnNlOiAnYXV0b1JldmVyc2UnLFxuICBhemltdXRoOiAnYXppbXV0aCcsXG4gIGJhc2VmcmVxdWVuY3k6ICdiYXNlRnJlcXVlbmN5JyxcbiAgYmFzZWxpbmVzaGlmdDogJ2Jhc2VsaW5lU2hpZnQnLFxuICAnYmFzZWxpbmUtc2hpZnQnOiAnYmFzZWxpbmVTaGlmdCcsXG4gIGJhc2Vwcm9maWxlOiAnYmFzZVByb2ZpbGUnLFxuICBiYm94OiAnYmJveCcsXG4gIGJlZ2luOiAnYmVnaW4nLFxuICBiaWFzOiAnYmlhcycsXG4gIGJ5OiAnYnknLFxuICBjYWxjbW9kZTogJ2NhbGNNb2RlJyxcbiAgY2FwaGVpZ2h0OiAnY2FwSGVpZ2h0JyxcbiAgJ2NhcC1oZWlnaHQnOiAnY2FwSGVpZ2h0JyxcbiAgY2xpcDogJ2NsaXAnLFxuICBjbGlwcGF0aDogJ2NsaXBQYXRoJyxcbiAgJ2NsaXAtcGF0aCc6ICdjbGlwUGF0aCcsXG4gIGNsaXBwYXRodW5pdHM6ICdjbGlwUGF0aFVuaXRzJyxcbiAgY2xpcHJ1bGU6ICdjbGlwUnVsZScsXG4gICdjbGlwLXJ1bGUnOiAnY2xpcFJ1bGUnLFxuICBjb2xvcjogJ2NvbG9yJyxcbiAgY29sb3JpbnRlcnBvbGF0aW9uOiAnY29sb3JJbnRlcnBvbGF0aW9uJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24nOiAnY29sb3JJbnRlcnBvbGF0aW9uJyxcbiAgY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVyczogJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJzogJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLFxuICBjb2xvcnByb2ZpbGU6ICdjb2xvclByb2ZpbGUnLFxuICAnY29sb3ItcHJvZmlsZSc6ICdjb2xvclByb2ZpbGUnLFxuICBjb2xvcnJlbmRlcmluZzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgJ2NvbG9yLXJlbmRlcmluZyc6ICdjb2xvclJlbmRlcmluZycsXG4gIGNvbnRlbnRzY3JpcHR0eXBlOiAnY29udGVudFNjcmlwdFR5cGUnLFxuICBjb250ZW50c3R5bGV0eXBlOiAnY29udGVudFN0eWxlVHlwZScsXG4gIGN1cnNvcjogJ2N1cnNvcicsXG4gIGN4OiAnY3gnLFxuICBjeTogJ2N5JyxcbiAgZDogJ2QnLFxuICBkYXRhdHlwZTogJ2RhdGF0eXBlJyxcbiAgZGVjZWxlcmF0ZTogJ2RlY2VsZXJhdGUnLFxuICBkZXNjZW50OiAnZGVzY2VudCcsXG4gIGRpZmZ1c2Vjb25zdGFudDogJ2RpZmZ1c2VDb25zdGFudCcsXG4gIGRpcmVjdGlvbjogJ2RpcmVjdGlvbicsXG4gIGRpc3BsYXk6ICdkaXNwbGF5JyxcbiAgZGl2aXNvcjogJ2Rpdmlzb3InLFxuICBkb21pbmFudGJhc2VsaW5lOiAnZG9taW5hbnRCYXNlbGluZScsXG4gICdkb21pbmFudC1iYXNlbGluZSc6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgZHVyOiAnZHVyJyxcbiAgZHg6ICdkeCcsXG4gIGR5OiAnZHknLFxuICBlZGdlbW9kZTogJ2VkZ2VNb2RlJyxcbiAgZWxldmF0aW9uOiAnZWxldmF0aW9uJyxcbiAgZW5hYmxlYmFja2dyb3VuZDogJ2VuYWJsZUJhY2tncm91bmQnLFxuICAnZW5hYmxlLWJhY2tncm91bmQnOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gIGVuZDogJ2VuZCcsXG4gIGV4cG9uZW50OiAnZXhwb25lbnQnLFxuICBleHRlcm5hbHJlc291cmNlc3JlcXVpcmVkOiAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gIGZpbGw6ICdmaWxsJyxcbiAgZmlsbG9wYWNpdHk6ICdmaWxsT3BhY2l0eScsXG4gICdmaWxsLW9wYWNpdHknOiAnZmlsbE9wYWNpdHknLFxuICBmaWxscnVsZTogJ2ZpbGxSdWxlJyxcbiAgJ2ZpbGwtcnVsZSc6ICdmaWxsUnVsZScsXG4gIGZpbHRlcjogJ2ZpbHRlcicsXG4gIGZpbHRlcnJlczogJ2ZpbHRlclJlcycsXG4gIGZpbHRlcnVuaXRzOiAnZmlsdGVyVW5pdHMnLFxuICBmbG9vZG9wYWNpdHk6ICdmbG9vZE9wYWNpdHknLFxuICAnZmxvb2Qtb3BhY2l0eSc6ICdmbG9vZE9wYWNpdHknLFxuICBmbG9vZGNvbG9yOiAnZmxvb2RDb2xvcicsXG4gICdmbG9vZC1jb2xvcic6ICdmbG9vZENvbG9yJyxcbiAgZm9jdXNhYmxlOiAnZm9jdXNhYmxlJyxcbiAgZm9udGZhbWlseTogJ2ZvbnRGYW1pbHknLFxuICAnZm9udC1mYW1pbHknOiAnZm9udEZhbWlseScsXG4gIGZvbnRzaXplOiAnZm9udFNpemUnLFxuICAnZm9udC1zaXplJzogJ2ZvbnRTaXplJyxcbiAgZm9udHNpemVhZGp1c3Q6ICdmb250U2l6ZUFkanVzdCcsXG4gICdmb250LXNpemUtYWRqdXN0JzogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgZm9udHN0cmV0Y2g6ICdmb250U3RyZXRjaCcsXG4gICdmb250LXN0cmV0Y2gnOiAnZm9udFN0cmV0Y2gnLFxuICBmb250c3R5bGU6ICdmb250U3R5bGUnLFxuICAnZm9udC1zdHlsZSc6ICdmb250U3R5bGUnLFxuICBmb250dmFyaWFudDogJ2ZvbnRWYXJpYW50JyxcbiAgJ2ZvbnQtdmFyaWFudCc6ICdmb250VmFyaWFudCcsXG4gIGZvbnR3ZWlnaHQ6ICdmb250V2VpZ2h0JyxcbiAgJ2ZvbnQtd2VpZ2h0JzogJ2ZvbnRXZWlnaHQnLFxuICBmb3JtYXQ6ICdmb3JtYXQnLFxuICBmcm9tOiAnZnJvbScsXG4gIGZ4OiAnZngnLFxuICBmeTogJ2Z5JyxcbiAgZzE6ICdnMScsXG4gIGcyOiAnZzInLFxuICBnbHlwaG5hbWU6ICdnbHlwaE5hbWUnLFxuICAnZ2x5cGgtbmFtZSc6ICdnbHlwaE5hbWUnLFxuICBnbHlwaG9yaWVudGF0aW9uaG9yaXpvbnRhbDogJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICBnbHlwaG9yaWVudGF0aW9udmVydGljYWw6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnOiAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJyxcbiAgZ2x5cGhyZWY6ICdnbHlwaFJlZicsXG4gIGdyYWRpZW50dHJhbnNmb3JtOiAnZ3JhZGllbnRUcmFuc2Zvcm0nLFxuICBncmFkaWVudHVuaXRzOiAnZ3JhZGllbnRVbml0cycsXG4gIGhhbmdpbmc6ICdoYW5naW5nJyxcbiAgaG9yaXphZHZ4OiAnaG9yaXpBZHZYJyxcbiAgJ2hvcml6LWFkdi14JzogJ2hvcml6QWR2WCcsXG4gIGhvcml6b3JpZ2lueDogJ2hvcml6T3JpZ2luWCcsXG4gICdob3Jpei1vcmlnaW4teCc6ICdob3Jpek9yaWdpblgnLFxuICBpZGVvZ3JhcGhpYzogJ2lkZW9ncmFwaGljJyxcbiAgaW1hZ2VyZW5kZXJpbmc6ICdpbWFnZVJlbmRlcmluZycsXG4gICdpbWFnZS1yZW5kZXJpbmcnOiAnaW1hZ2VSZW5kZXJpbmcnLFxuICBpbjI6ICdpbjInLFxuICBpbjogJ2luJyxcbiAgaW5saXN0OiAnaW5saXN0JyxcbiAgaW50ZXJjZXB0OiAnaW50ZXJjZXB0JyxcbiAgazE6ICdrMScsXG4gIGsyOiAnazInLFxuICBrMzogJ2szJyxcbiAgazQ6ICdrNCcsXG4gIGs6ICdrJyxcbiAga2VybmVsbWF0cml4OiAna2VybmVsTWF0cml4JyxcbiAga2VybmVsdW5pdGxlbmd0aDogJ2tlcm5lbFVuaXRMZW5ndGgnLFxuICBrZXJuaW5nOiAna2VybmluZycsXG4gIGtleXBvaW50czogJ2tleVBvaW50cycsXG4gIGtleXNwbGluZXM6ICdrZXlTcGxpbmVzJyxcbiAga2V5dGltZXM6ICdrZXlUaW1lcycsXG4gIGxlbmd0aGFkanVzdDogJ2xlbmd0aEFkanVzdCcsXG4gIGxldHRlcnNwYWNpbmc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgJ2xldHRlci1zcGFjaW5nJzogJ2xldHRlclNwYWNpbmcnLFxuICBsaWdodGluZ2NvbG9yOiAnbGlnaHRpbmdDb2xvcicsXG4gICdsaWdodGluZy1jb2xvcic6ICdsaWdodGluZ0NvbG9yJyxcbiAgbGltaXRpbmdjb25lYW5nbGU6ICdsaW1pdGluZ0NvbmVBbmdsZScsXG4gIGxvY2FsOiAnbG9jYWwnLFxuICBtYXJrZXJlbmQ6ICdtYXJrZXJFbmQnLFxuICAnbWFya2VyLWVuZCc6ICdtYXJrZXJFbmQnLFxuICBtYXJrZXJoZWlnaHQ6ICdtYXJrZXJIZWlnaHQnLFxuICBtYXJrZXJtaWQ6ICdtYXJrZXJNaWQnLFxuICAnbWFya2VyLW1pZCc6ICdtYXJrZXJNaWQnLFxuICBtYXJrZXJzdGFydDogJ21hcmtlclN0YXJ0JyxcbiAgJ21hcmtlci1zdGFydCc6ICdtYXJrZXJTdGFydCcsXG4gIG1hcmtlcnVuaXRzOiAnbWFya2VyVW5pdHMnLFxuICBtYXJrZXJ3aWR0aDogJ21hcmtlcldpZHRoJyxcbiAgbWFzazogJ21hc2snLFxuICBtYXNrY29udGVudHVuaXRzOiAnbWFza0NvbnRlbnRVbml0cycsXG4gIG1hc2t1bml0czogJ21hc2tVbml0cycsXG4gIG1hdGhlbWF0aWNhbDogJ21hdGhlbWF0aWNhbCcsXG4gIG1vZGU6ICdtb2RlJyxcbiAgbnVtb2N0YXZlczogJ251bU9jdGF2ZXMnLFxuICBvZmZzZXQ6ICdvZmZzZXQnLFxuICBvcGFjaXR5OiAnb3BhY2l0eScsXG4gIG9wZXJhdG9yOiAnb3BlcmF0b3InLFxuICBvcmRlcjogJ29yZGVyJyxcbiAgb3JpZW50OiAnb3JpZW50JyxcbiAgb3JpZW50YXRpb246ICdvcmllbnRhdGlvbicsXG4gIG9yaWdpbjogJ29yaWdpbicsXG4gIG92ZXJmbG93OiAnb3ZlcmZsb3cnLFxuICBvdmVybGluZXBvc2l0aW9uOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gICdvdmVybGluZS1wb3NpdGlvbic6ICdvdmVybGluZVBvc2l0aW9uJyxcbiAgb3ZlcmxpbmV0aGlja25lc3M6ICdvdmVybGluZVRoaWNrbmVzcycsXG4gICdvdmVybGluZS10aGlja25lc3MnOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICBwYWludG9yZGVyOiAncGFpbnRPcmRlcicsXG4gICdwYWludC1vcmRlcic6ICdwYWludE9yZGVyJyxcbiAgcGFub3NlMTogJ3Bhbm9zZTEnLFxuICAncGFub3NlLTEnOiAncGFub3NlMScsXG4gIHBhdGhsZW5ndGg6ICdwYXRoTGVuZ3RoJyxcbiAgcGF0dGVybmNvbnRlbnR1bml0czogJ3BhdHRlcm5Db250ZW50VW5pdHMnLFxuICBwYXR0ZXJudHJhbnNmb3JtOiAncGF0dGVyblRyYW5zZm9ybScsXG4gIHBhdHRlcm51bml0czogJ3BhdHRlcm5Vbml0cycsXG4gIHBvaW50ZXJldmVudHM6ICdwb2ludGVyRXZlbnRzJyxcbiAgJ3BvaW50ZXItZXZlbnRzJzogJ3BvaW50ZXJFdmVudHMnLFxuICBwb2ludHM6ICdwb2ludHMnLFxuICBwb2ludHNhdHg6ICdwb2ludHNBdFgnLFxuICBwb2ludHNhdHk6ICdwb2ludHNBdFknLFxuICBwb2ludHNhdHo6ICdwb2ludHNBdFonLFxuICBwcmVmaXg6ICdwcmVmaXgnLFxuICBwcmVzZXJ2ZWFscGhhOiAncHJlc2VydmVBbHBoYScsXG4gIHByZXNlcnZlYXNwZWN0cmF0aW86ICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJyxcbiAgcHJpbWl0aXZldW5pdHM6ICdwcmltaXRpdmVVbml0cycsXG4gIHByb3BlcnR5OiAncHJvcGVydHknLFxuICByOiAncicsXG4gIHJhZGl1czogJ3JhZGl1cycsXG4gIHJlZng6ICdyZWZYJyxcbiAgcmVmeTogJ3JlZlknLFxuICByZW5kZXJpbmdpbnRlbnQ6ICdyZW5kZXJpbmdJbnRlbnQnLFxuICAncmVuZGVyaW5nLWludGVudCc6ICdyZW5kZXJpbmdJbnRlbnQnLFxuICByZXBlYXRjb3VudDogJ3JlcGVhdENvdW50JyxcbiAgcmVwZWF0ZHVyOiAncmVwZWF0RHVyJyxcbiAgcmVxdWlyZWRleHRlbnNpb25zOiAncmVxdWlyZWRFeHRlbnNpb25zJyxcbiAgcmVxdWlyZWRmZWF0dXJlczogJ3JlcXVpcmVkRmVhdHVyZXMnLFxuICByZXNvdXJjZTogJ3Jlc291cmNlJyxcbiAgcmVzdGFydDogJ3Jlc3RhcnQnLFxuICByZXN1bHQ6ICdyZXN1bHQnLFxuICByZXN1bHRzOiAncmVzdWx0cycsXG4gIHJvdGF0ZTogJ3JvdGF0ZScsXG4gIHJ4OiAncngnLFxuICByeTogJ3J5JyxcbiAgc2NhbGU6ICdzY2FsZScsXG4gIHNlY3VyaXR5OiAnc2VjdXJpdHknLFxuICBzZWVkOiAnc2VlZCcsXG4gIHNoYXBlcmVuZGVyaW5nOiAnc2hhcGVSZW5kZXJpbmcnLFxuICAnc2hhcGUtcmVuZGVyaW5nJzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgc2xvcGU6ICdzbG9wZScsXG4gIHNwYWNpbmc6ICdzcGFjaW5nJyxcbiAgc3BlY3VsYXJjb25zdGFudDogJ3NwZWN1bGFyQ29uc3RhbnQnLFxuICBzcGVjdWxhcmV4cG9uZW50OiAnc3BlY3VsYXJFeHBvbmVudCcsXG4gIHNwZWVkOiAnc3BlZWQnLFxuICBzcHJlYWRtZXRob2Q6ICdzcHJlYWRNZXRob2QnLFxuICBzdGFydG9mZnNldDogJ3N0YXJ0T2Zmc2V0JyxcbiAgc3RkZGV2aWF0aW9uOiAnc3RkRGV2aWF0aW9uJyxcbiAgc3RlbWg6ICdzdGVtaCcsXG4gIHN0ZW12OiAnc3RlbXYnLFxuICBzdGl0Y2h0aWxlczogJ3N0aXRjaFRpbGVzJyxcbiAgc3RvcGNvbG9yOiAnc3RvcENvbG9yJyxcbiAgJ3N0b3AtY29sb3InOiAnc3RvcENvbG9yJyxcbiAgc3RvcG9wYWNpdHk6ICdzdG9wT3BhY2l0eScsXG4gICdzdG9wLW9wYWNpdHknOiAnc3RvcE9wYWNpdHknLFxuICBzdHJpa2V0aHJvdWdocG9zaXRpb246ICdzdHJpa2V0aHJvdWdoUG9zaXRpb24nLFxuICAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbic6ICdzdHJpa2V0aHJvdWdoUG9zaXRpb24nLFxuICBzdHJpa2V0aHJvdWdodGhpY2tuZXNzOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyc6ICdzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJyxcbiAgc3RyaW5nOiAnc3RyaW5nJyxcbiAgc3Ryb2tlOiAnc3Ryb2tlJyxcbiAgc3Ryb2tlZGFzaGFycmF5OiAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgJ3N0cm9rZS1kYXNoYXJyYXknOiAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgc3Ryb2tlZGFzaG9mZnNldDogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gIHN0cm9rZWxpbmVjYXA6ICdzdHJva2VMaW5lY2FwJyxcbiAgJ3N0cm9rZS1saW5lY2FwJzogJ3N0cm9rZUxpbmVjYXAnLFxuICBzdHJva2VsaW5lam9pbjogJ3N0cm9rZUxpbmVqb2luJyxcbiAgJ3N0cm9rZS1saW5lam9pbic6ICdzdHJva2VMaW5lam9pbicsXG4gIHN0cm9rZW1pdGVybGltaXQ6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgJ3N0cm9rZS1taXRlcmxpbWl0JzogJ3N0cm9rZU1pdGVybGltaXQnLFxuICBzdHJva2V3aWR0aDogJ3N0cm9rZVdpZHRoJyxcbiAgJ3N0cm9rZS13aWR0aCc6ICdzdHJva2VXaWR0aCcsXG4gIHN0cm9rZW9wYWNpdHk6ICdzdHJva2VPcGFjaXR5JyxcbiAgJ3N0cm9rZS1vcGFjaXR5JzogJ3N0cm9rZU9wYWNpdHknLFxuICBzdXBwcmVzc2NvbnRlbnRlZGl0YWJsZXdhcm5pbmc6ICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnLFxuICBzdXBwcmVzc2h5ZHJhdGlvbndhcm5pbmc6ICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnLFxuICBzdXJmYWNlc2NhbGU6ICdzdXJmYWNlU2NhbGUnLFxuICBzeXN0ZW1sYW5ndWFnZTogJ3N5c3RlbUxhbmd1YWdlJyxcbiAgdGFibGV2YWx1ZXM6ICd0YWJsZVZhbHVlcycsXG4gIHRhcmdldHg6ICd0YXJnZXRYJyxcbiAgdGFyZ2V0eTogJ3RhcmdldFknLFxuICB0ZXh0YW5jaG9yOiAndGV4dEFuY2hvcicsXG4gICd0ZXh0LWFuY2hvcic6ICd0ZXh0QW5jaG9yJyxcbiAgdGV4dGRlY29yYXRpb246ICd0ZXh0RGVjb3JhdGlvbicsXG4gICd0ZXh0LWRlY29yYXRpb24nOiAndGV4dERlY29yYXRpb24nLFxuICB0ZXh0bGVuZ3RoOiAndGV4dExlbmd0aCcsXG4gIHRleHRyZW5kZXJpbmc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgJ3RleHQtcmVuZGVyaW5nJzogJ3RleHRSZW5kZXJpbmcnLFxuICB0bzogJ3RvJyxcbiAgdHJhbnNmb3JtOiAndHJhbnNmb3JtJyxcbiAgdHJhbnNmb3Jtb3JpZ2luOiAndHJhbnNmb3JtT3JpZ2luJyxcbiAgJ3RyYW5zZm9ybS1vcmlnaW4nOiAndHJhbnNmb3JtT3JpZ2luJyxcbiAgdHlwZW9mOiAndHlwZW9mJyxcbiAgdTE6ICd1MScsXG4gIHUyOiAndTInLFxuICB1bmRlcmxpbmVwb3NpdGlvbjogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgJ3VuZGVybGluZS1wb3NpdGlvbic6ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gIHVuZGVybGluZXRoaWNrbmVzczogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gICd1bmRlcmxpbmUtdGhpY2tuZXNzJzogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gIHVuaWNvZGU6ICd1bmljb2RlJyxcbiAgdW5pY29kZWJpZGk6ICd1bmljb2RlQmlkaScsXG4gICd1bmljb2RlLWJpZGknOiAndW5pY29kZUJpZGknLFxuICB1bmljb2RlcmFuZ2U6ICd1bmljb2RlUmFuZ2UnLFxuICAndW5pY29kZS1yYW5nZSc6ICd1bmljb2RlUmFuZ2UnLFxuICB1bml0c3BlcmVtOiAndW5pdHNQZXJFbScsXG4gICd1bml0cy1wZXItZW0nOiAndW5pdHNQZXJFbScsXG4gIHVuc2VsZWN0YWJsZTogJ3Vuc2VsZWN0YWJsZScsXG4gIHZhbHBoYWJldGljOiAndkFscGhhYmV0aWMnLFxuICAndi1hbHBoYWJldGljJzogJ3ZBbHBoYWJldGljJyxcbiAgdmFsdWVzOiAndmFsdWVzJyxcbiAgdmVjdG9yZWZmZWN0OiAndmVjdG9yRWZmZWN0JyxcbiAgJ3ZlY3Rvci1lZmZlY3QnOiAndmVjdG9yRWZmZWN0JyxcbiAgdmVyc2lvbjogJ3ZlcnNpb24nLFxuICB2ZXJ0YWR2eTogJ3ZlcnRBZHZZJyxcbiAgJ3ZlcnQtYWR2LXknOiAndmVydEFkdlknLFxuICB2ZXJ0b3JpZ2lueDogJ3ZlcnRPcmlnaW5YJyxcbiAgJ3ZlcnQtb3JpZ2luLXgnOiAndmVydE9yaWdpblgnLFxuICB2ZXJ0b3JpZ2lueTogJ3ZlcnRPcmlnaW5ZJyxcbiAgJ3ZlcnQtb3JpZ2luLXknOiAndmVydE9yaWdpblknLFxuICB2aGFuZ2luZzogJ3ZIYW5naW5nJyxcbiAgJ3YtaGFuZ2luZyc6ICd2SGFuZ2luZycsXG4gIHZpZGVvZ3JhcGhpYzogJ3ZJZGVvZ3JhcGhpYycsXG4gICd2LWlkZW9ncmFwaGljJzogJ3ZJZGVvZ3JhcGhpYycsXG4gIHZpZXdib3g6ICd2aWV3Qm94JyxcbiAgdmlld3RhcmdldDogJ3ZpZXdUYXJnZXQnLFxuICB2aXNpYmlsaXR5OiAndmlzaWJpbGl0eScsXG4gIHZtYXRoZW1hdGljYWw6ICd2TWF0aGVtYXRpY2FsJyxcbiAgJ3YtbWF0aGVtYXRpY2FsJzogJ3ZNYXRoZW1hdGljYWwnLFxuICB2b2NhYjogJ3ZvY2FiJyxcbiAgd2lkdGhzOiAnd2lkdGhzJyxcbiAgd29yZHNwYWNpbmc6ICd3b3JkU3BhY2luZycsXG4gICd3b3JkLXNwYWNpbmcnOiAnd29yZFNwYWNpbmcnLFxuICB3cml0aW5nbW9kZTogJ3dyaXRpbmdNb2RlJyxcbiAgJ3dyaXRpbmctbW9kZSc6ICd3cml0aW5nTW9kZScsXG4gIHgxOiAneDEnLFxuICB4MjogJ3gyJyxcbiAgeDogJ3gnLFxuICB4Y2hhbm5lbHNlbGVjdG9yOiAneENoYW5uZWxTZWxlY3RvcicsXG4gIHhoZWlnaHQ6ICd4SGVpZ2h0JyxcbiAgJ3gtaGVpZ2h0JzogJ3hIZWlnaHQnLFxuICB4bGlua2FjdHVhdGU6ICd4bGlua0FjdHVhdGUnLFxuICAneGxpbms6YWN0dWF0ZSc6ICd4bGlua0FjdHVhdGUnLFxuICB4bGlua2FyY3JvbGU6ICd4bGlua0FyY3JvbGUnLFxuICAneGxpbms6YXJjcm9sZSc6ICd4bGlua0FyY3JvbGUnLFxuICB4bGlua2hyZWY6ICd4bGlua0hyZWYnLFxuICAneGxpbms6aHJlZic6ICd4bGlua0hyZWYnLFxuICB4bGlua3JvbGU6ICd4bGlua1JvbGUnLFxuICAneGxpbms6cm9sZSc6ICd4bGlua1JvbGUnLFxuICB4bGlua3Nob3c6ICd4bGlua1Nob3cnLFxuICAneGxpbms6c2hvdyc6ICd4bGlua1Nob3cnLFxuICB4bGlua3RpdGxlOiAneGxpbmtUaXRsZScsXG4gICd4bGluazp0aXRsZSc6ICd4bGlua1RpdGxlJyxcbiAgeGxpbmt0eXBlOiAneGxpbmtUeXBlJyxcbiAgJ3hsaW5rOnR5cGUnOiAneGxpbmtUeXBlJyxcbiAgeG1sYmFzZTogJ3htbEJhc2UnLFxuICAneG1sOmJhc2UnOiAneG1sQmFzZScsXG4gIHhtbGxhbmc6ICd4bWxMYW5nJyxcbiAgJ3htbDpsYW5nJzogJ3htbExhbmcnLFxuICB4bWxuczogJ3htbG5zJyxcbiAgJ3htbDpzcGFjZSc6ICd4bWxTcGFjZScsXG4gIHhtbG5zeGxpbms6ICd4bWxuc1hsaW5rJyxcbiAgJ3htbG5zOnhsaW5rJzogJ3htbG5zWGxpbmsnLFxuICB4bWxzcGFjZTogJ3htbFNwYWNlJyxcbiAgeTE6ICd5MScsXG4gIHkyOiAneTInLFxuICB5OiAneScsXG4gIHljaGFubmVsc2VsZWN0b3I6ICd5Q2hhbm5lbFNlbGVjdG9yJyxcbiAgejogJ3onLFxuICB6b29tYW5kcGFuOiAnem9vbUFuZFBhbidcbn07XG5cbnZhciB3YXJuZWRQcm9wZXJ0aWVzID0ge307XG52YXIgRVZFTlRfTkFNRV9SRUdFWCA9IC9eb24uLztcbnZhciBJTlZBTElEX0VWRU5UX05BTUVfUkVHRVggPSAvXm9uW15BLVpdLztcbnZhciByQVJJQSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpIDtcbnZhciByQVJJQUNhbWVsID0gbmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpIDtcblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eSh0YWdOYW1lLCBuYW1lLCB2YWx1ZSwgZXZlbnRSZWdpc3RyeSkge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwod2FybmVkUHJvcGVydGllcywgbmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnb25mb2N1c2luJyB8fCBsb3dlckNhc2VkTmFtZSA9PT0gJ29uZm9jdXNvdXQnKSB7XG4gICAgICBlcnJvcignUmVhY3QgdXNlcyBvbkZvY3VzIGFuZCBvbkJsdXIgaW5zdGVhZCBvZiBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQuICcgKyAnQWxsIFJlYWN0IGV2ZW50cyBhcmUgbm9ybWFsaXplZCB0byBidWJibGUsIHNvIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dCAnICsgJ2FyZSBub3QgbmVlZGVkL3N1cHBvcnRlZCBieSBSZWFjdC4nKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblxuICAgIGlmIChldmVudFJlZ2lzdHJ5ICE9IG51bGwpIHtcbiAgICAgIHZhciByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzID0gZXZlbnRSZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLFxuICAgICAgICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgPSBldmVudFJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM7XG5cbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuXG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgcmVnaXN0cmF0aW9uTmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGVycm9yKCdVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gSXQgd2lsbCBiZSBpZ25vcmVkLicsIG5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgLy8gSWYgbm8gZXZlbnQgcGx1Z2lucyBoYXZlIGJlZW4gaW5qZWN0ZWQsIHdlIGFyZSBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgICAgIC8vIFNvIHdlIGNhbid0IHRlbGwgaWYgdGhlIGV2ZW50IG5hbWUgaXMgY29ycmVjdCBmb3Igc3VyZSwgYnV0IHdlIGNhbiBmaWx0ZXJcbiAgICAgIC8vIG91dCBrbm93biBiYWQgb25lcyBsaWtlIGBvbmNsaWNrYC4gV2UgY2FuJ3Qgc3VnZ2VzdCBhIHNwZWNpZmljIHJlcGxhY2VtZW50IHRob3VnaC5cbiAgICAgIGlmIChJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuICcgKyAnUmVhY3QgZXZlbnRzIHVzZSB0aGUgY2FtZWxDYXNlIG5hbWluZyBjb252ZW50aW9uLCBmb3IgZXhhbXBsZSBgb25DbGlja2AuJywgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBMZXQgdGhlIEFSSUEgYXR0cmlidXRlIGhvb2sgdmFsaWRhdGUgQVJJQSBhdHRyaWJ1dGVzXG5cblxuICAgIGlmIChyQVJJQS50ZXN0KG5hbWUpIHx8IHJBUklBQ2FtZWwudGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaW5uZXJodG1sJykge1xuICAgICAgZXJyb3IoJ0RpcmVjdGx5IHNldHRpbmcgcHJvcGVydHkgYGlubmVySFRNTGAgaXMgbm90IHBlcm1pdHRlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgbG9va3VwIGRvY3VtZW50YXRpb24gb24gYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdhcmlhJykge1xuICAgICAgZXJyb3IoJ1RoZSBgYXJpYWAgYXR0cmlidXRlIGlzIHJlc2VydmVkIGZvciBmdXR1cmUgdXNlIGluIFJlYWN0LiAnICsgJ1Bhc3MgaW5kaXZpZHVhbCBgYXJpYS1gIGF0dHJpYnV0ZXMgaW5zdGVhZC4nKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpcycgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYSBgJXNgIGZvciBhIHN0cmluZyBhdHRyaWJ1dGUgYGlzYC4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4nLCB0eXBlb2YgdmFsdWUpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIE5hTiBmb3IgdGhlIGAlc2AgYXR0cmlidXRlLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcgKyAndGhlIHZhbHVlIHRvIGEgc3RyaW5nLicsIG5hbWUpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gS25vd24gYXR0cmlidXRlcyBzaG91bGQgbWF0Y2ggdGhlIGNhc2luZyBzcGVjaWZpZWQgaW4gdGhlIHByb3BlcnR5IGNvbmZpZy5cblxuXG4gICAgaWYgKHBvc3NpYmxlU3RhbmRhcmROYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgIHZhciBzdGFuZGFyZE5hbWUgPSBwb3NzaWJsZVN0YW5kYXJkTmFtZXNbbG93ZXJDYXNlZE5hbWVdO1xuXG4gICAgICBpZiAoc3RhbmRhcmROYW1lICE9PSBuYW1lKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIERPTSBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBzdGFuZGFyZE5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5hbWUgIT09IGxvd2VyQ2FzZWROYW1lKSB7XG4gICAgICAvLyBVbmtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIGhhdmUgbG93ZXJjYXNlIGNhc2luZyBzaW5jZSB0aGF0J3MgaG93IHRoZXlcbiAgICAgIC8vIHdpbGwgYmUgY2FzZWQgYW55d2F5IHdpdGggc2VydmVyIHJlbmRlcmluZy5cbiAgICAgIGVycm9yKCdSZWFjdCBkb2VzIG5vdCByZWNvZ25pemUgdGhlIGAlc2AgcHJvcCBvbiBhIERPTSBlbGVtZW50LiBJZiB5b3UgJyArICdpbnRlbnRpb25hbGx5IHdhbnQgaXQgdG8gYXBwZWFyIGluIHRoZSBET00gYXMgYSBjdXN0b20gJyArICdhdHRyaWJ1dGUsIHNwZWxsIGl0IGFzIGxvd2VyY2FzZSBgJXNgIGluc3RlYWQuICcgKyAnSWYgeW91IGFjY2lkZW50YWxseSBwYXNzZWQgaXQgZnJvbSBhIHBhcmVudCBjb21wb25lbnQsIHJlbW92ZSAnICsgJ2l0IGZyb20gdGhlIERPTSBlbGVtZW50LicsIG5hbWUsIGxvd2VyQ2FzZWROYW1lKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIE5vdyB0aGF0IHdlJ3ZlIHZhbGlkYXRlZCBjYXNpbmcsIGRvIG5vdCB2YWxpZGF0ZVxuICAgIC8vIGRhdGEgdHlwZXMgZm9yIHJlc2VydmVkIHByb3BzXG5cblxuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgY2FzZSAnc3R5bGUnOlxuICAgICAgY2FzZSAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJzpcbiAgICAgIGNhc2UgJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZyc6XG4gICAgICBjYXNlICdkZWZhdWx0VmFsdWUnOiAvLyBSZXNlcnZlZFxuXG4gICAgICBjYXNlICdkZWZhdWx0Q2hlY2tlZCc6XG4gICAgICBjYXNlICdpbm5lckhUTUwnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAge1xuICAgICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgY2FzZSAnYXV0b0ZvY3VzJzpcbiAgICAgICAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuICAgICAgICAgICAgY2FzZSAnbXVsdGlwbGUnOlxuICAgICAgICAgICAgY2FzZSAnbXV0ZWQnOlxuICAgICAgICAgICAgY2FzZSAnc2VsZWN0ZWQnOlxuICAgICAgICAgICAgY2FzZSAnY29udGVudEVkaXRhYmxlJzpcbiAgICAgICAgICAgIGNhc2UgJ3NwZWxsQ2hlY2snOlxuICAgICAgICAgICAgY2FzZSAnZHJhZ2dhYmxlJzpcbiAgICAgICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICAgIGNhc2UgJ2F1dG9SZXZlcnNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnOlxuICAgICAgICAgICAgY2FzZSAnZm9jdXNhYmxlJzpcbiAgICAgICAgICAgIGNhc2UgJ3ByZXNlcnZlQWxwaGEnOlxuICAgICAgICAgICAgY2FzZSAnYWxsb3dGdWxsU2NyZWVuJzpcbiAgICAgICAgICAgIGNhc2UgJ2FzeW5jJzpcbiAgICAgICAgICAgIGNhc2UgJ2F1dG9QbGF5JzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbnRyb2xzJzpcbiAgICAgICAgICAgIGNhc2UgJ2RlZmF1bHQnOlxuICAgICAgICAgICAgY2FzZSAnZGVmZXInOlxuICAgICAgICAgICAgY2FzZSAnZGlzYWJsZWQnOlxuICAgICAgICAgICAgY2FzZSAnZGlzYWJsZVBpY3R1cmVJblBpY3R1cmUnOlxuICAgICAgICAgICAgY2FzZSAnZGlzYWJsZVJlbW90ZVBsYXliYWNrJzpcbiAgICAgICAgICAgIGNhc2UgJ2Zvcm1Ob1ZhbGlkYXRlJzpcbiAgICAgICAgICAgIGNhc2UgJ2hpZGRlbic6XG4gICAgICAgICAgICBjYXNlICdsb29wJzpcbiAgICAgICAgICAgIGNhc2UgJ25vTW9kdWxlJzpcbiAgICAgICAgICAgIGNhc2UgJ25vVmFsaWRhdGUnOlxuICAgICAgICAgICAgY2FzZSAnb3Blbic6XG4gICAgICAgICAgICBjYXNlICdwbGF5c0lubGluZSc6XG4gICAgICAgICAgICBjYXNlICdyZWFkT25seSc6XG4gICAgICAgICAgICBjYXNlICdyZXF1aXJlZCc6XG4gICAgICAgICAgICBjYXNlICdyZXZlcnNlZCc6XG4gICAgICAgICAgICBjYXNlICdzY29wZWQnOlxuICAgICAgICAgICAgY2FzZSAnc2VhbWxlc3MnOlxuICAgICAgICAgICAgY2FzZSAnaXRlbVNjb3BlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NhcHR1cmUnOlxuICAgICAgICAgICAgY2FzZSAnZG93bmxvYWQnOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gQm9vbGVhbiBwcm9wZXJ0aWVzIGNhbiBhY2NlcHQgYm9vbGVhbiB2YWx1ZXNcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHByZWZpeCA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgwLCA1KTtcblxuICAgICAgICAgICAgICAgIGlmIChwcmVmaXggPT09ICdkYXRhLScgfHwgcHJlZml4ID09PSAnYXJpYS0nKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uJywgdmFsdWUsIG5hbWUsIG5hbWUsIHZhbHVlLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuJyArICdJZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICcgKyAnJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS5cXG5cXG4nICsgJ0lmIHlvdSB1c2VkIHRvIGNvbmRpdGlvbmFsbHkgb21pdCBpdCB3aXRoICVzPXtjb25kaXRpb24gJiYgdmFsdWV9LCAnICsgJ3Bhc3MgJXM9e2NvbmRpdGlvbiA/IHZhbHVlIDogdW5kZWZpbmVkfSBpbnN0ZWFkLicsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSwgbmFtZSwgbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAvLyBXYXJuIHdoZW4gYSBrbm93biBhdHRyaWJ1dGUgaXMgYSBiYWQgdHlwZVxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gV2FybiB3aGVuIHBhc3NpbmcgdGhlIHN0cmluZ3MgJ2ZhbHNlJyBvciAndHJ1ZScgaW50byBhIGJvb2xlYW4gcHJvcFxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ2ZhbHNlJyB8fCB2YWx1ZSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnY2hlY2tlZCc6XG4gICAgICAgICAgICAgIGNhc2UgJ3NlbGVjdGVkJzpcbiAgICAgICAgICAgICAgY2FzZSAnbXVsdGlwbGUnOlxuICAgICAgICAgICAgICBjYXNlICdtdXRlZCc6XG4gICAgICAgICAgICAgIGNhc2UgJ2FsbG93RnVsbFNjcmVlbic6XG4gICAgICAgICAgICAgIGNhc2UgJ2FzeW5jJzpcbiAgICAgICAgICAgICAgY2FzZSAnYXV0b1BsYXknOlxuICAgICAgICAgICAgICBjYXNlICdjb250cm9scyc6XG4gICAgICAgICAgICAgIGNhc2UgJ2RlZmF1bHQnOlxuICAgICAgICAgICAgICBjYXNlICdkZWZlcic6XG4gICAgICAgICAgICAgIGNhc2UgJ2Rpc2FibGVkJzpcbiAgICAgICAgICAgICAgY2FzZSAnZGlzYWJsZVBpY3R1cmVJblBpY3R1cmUnOlxuICAgICAgICAgICAgICBjYXNlICdkaXNhYmxlUmVtb3RlUGxheWJhY2snOlxuICAgICAgICAgICAgICBjYXNlICdmb3JtTm9WYWxpZGF0ZSc6XG4gICAgICAgICAgICAgIGNhc2UgJ2hpZGRlbic6XG4gICAgICAgICAgICAgIGNhc2UgJ2xvb3AnOlxuICAgICAgICAgICAgICBjYXNlICdub01vZHVsZSc6XG4gICAgICAgICAgICAgIGNhc2UgJ25vVmFsaWRhdGUnOlxuICAgICAgICAgICAgICBjYXNlICdvcGVuJzpcbiAgICAgICAgICAgICAgY2FzZSAncGxheXNJbmxpbmUnOlxuICAgICAgICAgICAgICBjYXNlICdyZWFkT25seSc6XG4gICAgICAgICAgICAgIGNhc2UgJ3JlcXVpcmVkJzpcbiAgICAgICAgICAgICAgY2FzZSAncmV2ZXJzZWQnOlxuICAgICAgICAgICAgICBjYXNlICdzY29wZWQnOlxuICAgICAgICAgICAgICBjYXNlICdzZWFtbGVzcyc6XG4gICAgICAgICAgICAgIGNhc2UgJ2l0ZW1TY29wZSc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlcnJvcignUmVjZWl2ZWQgdGhlIHN0cmluZyBgJXNgIGZvciB0aGUgYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC4gJyArICclcyAnICsgJ0RpZCB5b3UgbWVhbiAlcz17JXN9PycsIHZhbHVlLCBuYW1lLCB2YWx1ZSA9PT0gJ2ZhbHNlJyA/ICdUaGUgYnJvd3NlciB3aWxsIGludGVycHJldCBpdCBhcyBhIHRydXRoeSB2YWx1ZS4nIDogJ0FsdGhvdWdoIHRoaXMgd29ya3MsIGl0IHdpbGwgbm90IHdvcmsgYXMgZXhwZWN0ZWQgaWYgeW91IHBhc3MgdGhlIHN0cmluZyBcImZhbHNlXCIuJywgbmFtZSwgdmFsdWUpO1xuXG4gICAgICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Vbmtub3duUHJvcGVydGllcyh0eXBlLCBwcm9wcywgZXZlbnRSZWdpc3RyeSkge1xuICB7XG4gICAgdmFyIHVua25vd25Qcm9wcyA9IFtdO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkodHlwZSwga2V5LCBwcm9wc1trZXldLCBldmVudFJlZ2lzdHJ5KTtcblxuICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgIHVua25vd25Qcm9wcy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gdW5rbm93blByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gICAgfSkuam9pbignLCAnKTtcblxuICAgIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBlcnJvcignSW52YWxpZCB2YWx1ZSBmb3IgcHJvcCAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSBpdCBmcm9tIHRoZSBlbGVtZW50LCAnICsgJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgaXQgaW4gdGhlIERPTS4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9hdHRyaWJ1dGUtYmVoYXZpb3IgJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUpO1xuICAgIH0gZWxzZSBpZiAodW5rbm93blByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIHZhbHVlcyBmb3IgcHJvcHMgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgdGhlbSBmcm9tIHRoZSBlbGVtZW50LCAnICsgJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgdGhlbSBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2F0dHJpYnV0ZS1iZWhhdmlvciAnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcywgZXZlbnRSZWdpc3RyeSkge1xuICBpZiAoaXNDdXN0b21FbGVtZW50KHR5cGUpIHx8IHR5cGVvZiBwcm9wcy5pcyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIGV2ZW50UmVnaXN0cnkpO1xufVxuXG4vLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG52YXIgYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuID0gL14oPzp3ZWJraXR8bW96fG8pW0EtWl0vO1xudmFyIG1zUGF0dGVybiQxID0gL14tbXMtLztcbnZhciBoeXBoZW5QYXR0ZXJuID0gLy0oLikvZzsgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXG5cbnZhciBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLztcbnZhciB3YXJuZWRTdHlsZU5hbWVzID0ge307XG52YXIgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fTtcbnZhciB3YXJuZWRGb3JOYU5WYWx1ZSA9IGZhbHNlO1xudmFyIHdhcm5lZEZvckluZmluaXR5VmFsdWUgPSBmYWxzZTtcblxuZnVuY3Rpb24gY2FtZWxpemUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShoeXBoZW5QYXR0ZXJuLCBmdW5jdGlvbiAoXywgY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUobmFtZSkge1xuICB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuXG4gICAgZXJyb3IoJ1Vuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgLy8gQXMgQW5kaSBTbWl0aCBzdWdnZXN0c1xuICAgIC8vIChodHRwOi8vd3d3LmFuZGlzbWl0aC5jb20vYmxvZy8yMDEyLzAyL21vZGVybml6ci1wcmVmaXhlZC8pLCBhbiBgLW1zYCBwcmVmaXhcbiAgICAvLyBpcyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGBtc2AuXG4gICAgY2FtZWxpemUobmFtZS5yZXBsYWNlKG1zUGF0dGVybiQxLCAnbXMtJykpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUobmFtZSkge1xuICB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuXG4gICAgZXJyb3IoJ1Vuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPycsIG5hbWUsIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24obmFtZSwgdmFsdWUpIHtcbiAge1xuICAgIGlmICh3YXJuZWRTdHlsZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgJiYgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdID0gdHJ1ZTtcblxuICAgIGVycm9yKFwiU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uLiBcIiArICdUcnkgXCIlczogJXNcIiBpbnN0ZWFkLicsIG5hbWUsIHZhbHVlLnJlcGxhY2UoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLCAnJykpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5TdHlsZVZhbHVlSXNOYU4obmFtZSwgdmFsdWUpIHtcbiAge1xuICAgIGlmICh3YXJuZWRGb3JOYU5WYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZEZvck5hTlZhbHVlID0gdHJ1ZTtcblxuICAgIGVycm9yKCdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJywgbmFtZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FyblN0eWxlVmFsdWVJc0luZmluaXR5KG5hbWUsIHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2FybmVkRm9ySW5maW5pdHlWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZEZvckluZmluaXR5VmFsdWUgPSB0cnVlO1xuXG4gICAgZXJyb3IoJ2BJbmZpbml0eWAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LicsIG5hbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5WYWxpZFN0eWxlKG5hbWUsIHZhbHVlKSB7XG4gIHtcbiAgICBpZiAobmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4udGVzdChuYW1lKSkge1xuICAgICAgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24obmFtZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNOYU4obmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5KG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBjb2RlIGNvcGllZCBhbmQgbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbFxudmFyIG1hdGNoSHRtbFJlZ0V4cCA9IC9bXCInJjw+XS87XG4vKipcbiAqIEVzY2FwZXMgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCBIVE1MIGVudGl0aWVzIGluIGEgZ2l2ZW4gaHRtbCBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJpbmcgSFRNTCBzdHJpbmcgdG8gZXNjYXBlIGZvciBsYXRlciBpbnNlcnRpb25cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xuICB7XG4gICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oc3RyaW5nKTtcbiAgfVxuXG4gIHZhciBzdHIgPSAnJyArIHN0cmluZztcbiAgdmFyIG1hdGNoID0gbWF0Y2hIdG1sUmVnRXhwLmV4ZWMoc3RyKTtcblxuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHZhciBlc2NhcGU7XG4gIHZhciBodG1sID0gJyc7XG4gIHZhciBpbmRleDtcbiAgdmFyIGxhc3RJbmRleCA9IDA7XG5cbiAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgY2FzZSAzNDpcbiAgICAgICAgLy8gXCJcbiAgICAgICAgZXNjYXBlID0gJyZxdW90Oyc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDM4OlxuICAgICAgICAvLyAmXG4gICAgICAgIGVzY2FwZSA9ICcmYW1wOyc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDM5OlxuICAgICAgICAvLyAnXG4gICAgICAgIGVzY2FwZSA9ICcmI3gyNzsnOyAvLyBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sOyB1c2VkIHRvIGJlICcmIzM5J1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDYwOlxuICAgICAgICAvLyA8XG4gICAgICAgIGVzY2FwZSA9ICcmbHQ7JztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNjI6XG4gICAgICAgIC8vID5cbiAgICAgICAgZXNjYXBlID0gJyZndDsnO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIGh0bWwgKz0gc3RyLnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpO1xuICAgIH1cblxuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcbiAgICBodG1sICs9IGVzY2FwZTtcbiAgfVxuXG4gIHJldHVybiBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHN0ci5zbGljZShsYXN0SW5kZXgsIGluZGV4KSA6IGh0bWw7XG59IC8vIGVuZCBjb2RlIGNvcGllZCBhbmQgbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbFxuXG4vKipcbiAqIEVzY2FwZXMgdGV4dCB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdGV4dCBUZXh0IHZhbHVlIHRvIGVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cblxuXG5mdW5jdGlvbiBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0ZXh0KSB7XG4gIGlmICh0eXBlb2YgdGV4dCA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiB0ZXh0ID09PSAnbnVtYmVyJykge1xuICAgIC8vIHRoaXMgc2hvcnRjaXJjdWl0IGhlbHBzIHBlcmYgZm9yIHR5cGVzIHRoYXQgd2Uga25vdyB3aWxsIG5ldmVyIGhhdmVcbiAgICAvLyBzcGVjaWFsIGNoYXJhY3RlcnMsIGVzcGVjaWFsbHkgZ2l2ZW4gdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgb2Z0ZW5cbiAgICAvLyBmb3IgbnVtZXJpYyBkb20gaWRzLlxuICAgIHJldHVybiAnJyArIHRleHQ7XG4gIH1cblxuICByZXR1cm4gZXNjYXBlSHRtbCh0ZXh0KTtcbn1cblxudmFyIHVwcGVyY2FzZVBhdHRlcm4gPSAvKFtBLVpdKS9nO1xudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ01velRyYW5zaXRpb24nKVxuICogICA8IFwiLW1vei10cmFuc2l0aW9uXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ21zVHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbXMtdHJhbnNpdGlvblwiXG4gKlxuICogQXMgTW9kZXJuaXpyIHN1Z2dlc3RzIChodHRwOi8vbW9kZXJuaXpyLmNvbS9kb2NzLyNwcmVmaXhlZCksIGFuIGBtc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gYC1tcy1gLlxuICovXG5cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShuYW1lKSB7XG4gIHJldHVybiBuYW1lLnJlcGxhY2UodXBwZXJjYXNlUGF0dGVybiwgJy0kMScpLnRvTG93ZXJDYXNlKCkucmVwbGFjZShtc1BhdHRlcm4sICctbXMtJyk7XG59XG5cbi8vIGFuZCBhbnkgbmV3bGluZSBvciB0YWIgYXJlIGZpbHRlcmVkIG91dCBhcyBpZiB0aGV5J3JlIG5vdCBwYXJ0IG9mIHRoZSBVUkwuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybC1wYXJzaW5nXG4vLyBUYWIgb3IgbmV3bGluZSBhcmUgZGVmaW5lZCBhcyBcXHJcXG5cXHQ6XG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jYXNjaWktdGFiLW9yLW5ld2xpbmVcbi8vIEEgQzAgY29udHJvbCBpcyBhIGNvZGUgcG9pbnQgaW4gdGhlIHJhbmdlIFxcdTAwMDAgTlVMTCB0byBcXHUwMDFGXG4vLyBJTkZPUk1BVElPTiBTRVBBUkFUT1IgT05FLCBpbmNsdXNpdmU6XG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jYzAtY29udHJvbC1vci1zcGFjZVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbnZhciBpc0phdmFTY3JpcHRQcm90b2NvbCA9IC9eW1xcdTAwMDAtXFx1MDAxRiBdKmpbXFxyXFxuXFx0XSphW1xcclxcblxcdF0qdltcXHJcXG5cXHRdKmFbXFxyXFxuXFx0XSpzW1xcclxcblxcdF0qY1tcXHJcXG5cXHRdKnJbXFxyXFxuXFx0XSppW1xcclxcblxcdF0qcFtcXHJcXG5cXHRdKnRbXFxyXFxuXFx0XSpcXDovaTtcbnZhciBkaWRXYXJuID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHNhbml0aXplVVJMKHVybCkge1xuICAvLyBXZSBzaG91bGQgbmV2ZXIgaGF2ZSBzeW1ib2xzIGhlcmUgYmVjYXVzZSB0aGV5IGdldCBmaWx0ZXJlZCBvdXQgZWxzZXdoZXJlLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgdmFyIHN0cmluZ2lmaWVkVVJMID0gJycgKyB1cmw7XG5cbiAge1xuICAgIGlmICghZGlkV2FybiAmJiBpc0phdmFTY3JpcHRQcm90b2NvbC50ZXN0KHN0cmluZ2lmaWVkVVJMKSkge1xuICAgICAgZGlkV2FybiA9IHRydWU7XG5cbiAgICAgIGVycm9yKCdBIGZ1dHVyZSB2ZXJzaW9uIG9mIFJlYWN0IHdpbGwgYmxvY2sgamF2YXNjcmlwdDogVVJMcyBhcyBhIHNlY3VyaXR5IHByZWNhdXRpb24uICcgKyAnVXNlIGV2ZW50IGhhbmRsZXJzIGluc3RlYWQgaWYgeW91IGNhbi4gSWYgeW91IG5lZWQgdG8gZ2VuZXJhdGUgdW5zYWZlIEhUTUwgdHJ5ICcgKyAndXNpbmcgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgaW5zdGVhZC4gUmVhY3Qgd2FzIHBhc3NlZCAlcy4nLCBKU09OLnN0cmluZ2lmeShzdHJpbmdpZmllZFVSTCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1cmw7XG59XG5cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcbn1cblxuLy8gVGhlIGJ1aWxkIHNjcmlwdCBpcyBhdCBzY3JpcHRzL3JvbGx1cC9nZW5lcmF0ZS1pbmxpbmUtZml6ei1ydW50aW1lLmpzLlxuLy8gUnVuIGB5YXJuIGdlbmVyYXRlLWlubGluZS1maXp6LXJ1bnRpbWVgIHRvIGdlbmVyYXRlLlxudmFyIGNsaWVudFJlbmRlckJvdW5kYXJ5ID0gJyRSWD1mdW5jdGlvbihiLGMsZCxlKXt2YXIgYT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChiKTthJiYoYj1hLnByZXZpb3VzU2libGluZyxiLmRhdGE9XCIkIVwiLGE9YS5kYXRhc2V0LGMmJihhLmRnc3Q9YyksZCYmKGEubXNnPWQpLGUmJihhLnN0Y2s9ZSksYi5fcmVhY3RSZXRyeSYmYi5fcmVhY3RSZXRyeSgpKX07JztcbnZhciBjb21wbGV0ZUJvdW5kYXJ5ID0gJyRSQz1mdW5jdGlvbihiLGMsZSl7Yz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChjKTtjLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYyk7dmFyIGE9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYik7aWYoYSl7Yj1hLnByZXZpb3VzU2libGluZztpZihlKWIuZGF0YT1cIiQhXCIsYS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWRnc3RcIixlKTtlbHNle2U9Yi5wYXJlbnROb2RlO2E9Yi5uZXh0U2libGluZzt2YXIgZj0wO2Rve2lmKGEmJjg9PT1hLm5vZGVUeXBlKXt2YXIgZD1hLmRhdGE7aWYoXCIvJFwiPT09ZClpZigwPT09ZilicmVhaztlbHNlIGYtLTtlbHNlXCIkXCIhPT1kJiZcIiQ/XCIhPT1kJiZcIiQhXCIhPT1kfHxmKyt9ZD1hLm5leHRTaWJsaW5nO2UucmVtb3ZlQ2hpbGQoYSk7YT1kfXdoaWxlKGEpO2Zvcig7Yy5maXJzdENoaWxkOyllLmluc2VydEJlZm9yZShjLmZpcnN0Q2hpbGQsYSk7Yi5kYXRhPVwiJFwifWIuX3JlYWN0UmV0cnkmJmIuX3JlYWN0UmV0cnkoKX19Oyc7XG52YXIgY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXMgPSAnJFJNPW5ldyBNYXA7XFxuJFJSPWZ1bmN0aW9uKHIsdCx3KXtmb3IodmFyIHU9JFJDLG49JFJNLHA9bmV3IE1hcCxxPWRvY3VtZW50LGcsYixoPXEucXVlcnlTZWxlY3RvckFsbChcImxpbmtbZGF0YS1wcmVjZWRlbmNlXSxzdHlsZVtkYXRhLXByZWNlZGVuY2VdXCIpLHY9W10saz0wO2I9aFtrKytdOylcIm5vdCBhbGxcIj09PWIuZ2V0QXR0cmlidXRlKFwibWVkaWFcIik/di5wdXNoKGIpOihcIkxJTktcIj09PWIudGFnTmFtZSYmbi5zZXQoYi5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLGIpLHAuc2V0KGIuZGF0YXNldC5wcmVjZWRlbmNlLGc9YikpO2I9MDtoPVtdO3ZhciBsLGE7Zm9yKGs9ITA7Oyl7aWYoayl7dmFyIGY9d1tiKytdO2lmKCFmKXtrPSExO2I9MDtjb250aW51ZX12YXIgYz0hMSxtPTA7dmFyIGQ9ZlttKytdO2lmKGE9bi5nZXQoZCkpe3ZhciBlPWEuX3A7Yz0hMH1lbHNle2E9cS5jcmVhdGVFbGVtZW50KFwibGlua1wiKTthLmhyZWY9ZDthLnJlbD1cInN0eWxlc2hlZXRcIjtmb3IoYS5kYXRhc2V0LnByZWNlZGVuY2U9XFxubD1mW20rK107ZT1mW20rK107KWEuc2V0QXR0cmlidXRlKGUsZlttKytdKTtlPWEuX3A9bmV3IFByb21pc2UoZnVuY3Rpb24oeCx5KXthLm9ubG9hZD14O2Eub25lcnJvcj15fSk7bi5zZXQoZCxhKX1kPWEuZ2V0QXR0cmlidXRlKFwibWVkaWFcIik7IWV8fFwibFwiPT09ZS5zfHxkJiYhbWF0Y2hNZWRpYShkKS5tYXRjaGVzfHxoLnB1c2goZSk7aWYoYyljb250aW51ZX1lbHNle2E9dltiKytdO2lmKCFhKWJyZWFrO2w9YS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXByZWNlZGVuY2VcIik7YS5yZW1vdmVBdHRyaWJ1dGUoXCJtZWRpYVwiKX1jPXAuZ2V0KGwpfHxnO2M9PT1nJiYoZz1hKTtwLnNldChsLGEpO2M/Yy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLGMubmV4dFNpYmxpbmcpOihjPXEuaGVhZCxjLmluc2VydEJlZm9yZShhLGMuZmlyc3RDaGlsZCkpfVByb21pc2UuYWxsKGgpLnRoZW4odS5iaW5kKG51bGwscix0LFwiXCIpLHUuYmluZChudWxsLHIsdCxcIlJlc291cmNlIGZhaWxlZCB0byBsb2FkXCIpKX07JztcbnZhciBjb21wbGV0ZVNlZ21lbnQgPSAnJFJTPWZ1bmN0aW9uKGEsYil7YT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChhKTtiPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGIpO2ZvcihhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSk7YS5maXJzdENoaWxkOyliLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEuZmlyc3RDaGlsZCxiKTtiLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYil9Oyc7XG5cbmZ1bmN0aW9uIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcodGhpbmcpIHtcbiAgcmV0dXJuIHRoaW5nID09PSBudWxsID8gJ2BudWxsYCcgOiB0aGluZyA9PT0gdW5kZWZpbmVkID8gJ2B1bmRlZmluZWRgJyA6IHRoaW5nID09PSAnJyA/ICdhbiBlbXB0eSBzdHJpbmcnIDogXCJzb21ldGhpbmcgd2l0aCB0eXBlIFxcXCJcIiArIHR5cGVvZiB0aGluZyArIFwiXFxcIlwiO1xufVxuZnVuY3Rpb24gZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcodGhpbmcpIHtcbiAgcmV0dXJuIHRoaW5nID09PSBudWxsID8gJ2BudWxsYCcgOiB0aGluZyA9PT0gdW5kZWZpbmVkID8gJ2B1bmRlZmluZWRgJyA6IHRoaW5nID09PSAnJyA/ICdhbiBlbXB0eSBzdHJpbmcnIDogdHlwZW9mIHRoaW5nID09PSAnc3RyaW5nJyA/IEpTT04uc3RyaW5naWZ5KHRoaW5nKSA6IFwic29tZXRoaW5nIHdpdGggdHlwZSBcXFwiXCIgKyB0eXBlb2YgdGhpbmcgKyBcIlxcXCJcIjtcbn1cblxuZnVuY3Rpb24gY29tcGFyZVJlc291cmNlUHJvcHNGb3JXYXJuaW5nKG5ld1Byb3BzLCBjdXJyZW50UHJvcHMpIHtcbiAge1xuICAgIHZhciBwcm9wRGlmZnMgPSBudWxsO1xuICAgIHZhciBhbGxQcm9wcyA9IEFycmF5LmZyb20obmV3IFNldChPYmplY3Qua2V5cyhjdXJyZW50UHJvcHMpLmNvbmNhdChPYmplY3Qua2V5cyhuZXdQcm9wcykpKSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbFByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcE5hbWUgPSBhbGxQcm9wc1tpXTtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IG5ld1Byb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBjdXJyZW50UHJvcHNbcHJvcE5hbWVdO1xuXG4gICAgICBpZiAobmV3VmFsdWUgIT09IGN1cnJlbnRWYWx1ZSAmJiAhKG5ld1ZhbHVlID09IG51bGwgJiYgY3VycmVudFZhbHVlID09IG51bGwpKSB7XG4gICAgICAgIGlmIChuZXdWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHByb3BEaWZmcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvcERpZmZzID0ge1xuICAgICAgICAgICAgICBtaXNzaW5nOiB7fSxcbiAgICAgICAgICAgICAgZXh0cmE6IHt9LFxuICAgICAgICAgICAgICBkaWZmZXJlbnQ6IHt9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHByb3BEaWZmcy5taXNzaW5nW3Byb3BOYW1lXSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChwcm9wRGlmZnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHByb3BEaWZmcyA9IHtcbiAgICAgICAgICAgICAgbWlzc2luZzoge30sXG4gICAgICAgICAgICAgIGV4dHJhOiB7fSxcbiAgICAgICAgICAgICAgZGlmZmVyZW50OiB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwcm9wRGlmZnMuZXh0cmFbcHJvcE5hbWVdID0gbmV3VmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHByb3BEaWZmcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvcERpZmZzID0ge1xuICAgICAgICAgICAgICBtaXNzaW5nOiB7fSxcbiAgICAgICAgICAgICAgZXh0cmE6IHt9LFxuICAgICAgICAgICAgICBkaWZmZXJlbnQ6IHt9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHByb3BEaWZmcy5kaWZmZXJlbnRbcHJvcE5hbWVdID0ge1xuICAgICAgICAgICAgb3JpZ2luYWw6IGN1cnJlbnRWYWx1ZSxcbiAgICAgICAgICAgIGxhdGVzdDogbmV3VmFsdWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3BEaWZmcztcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXNjcmliZURpZmZlcmVuY2VzRm9yU3R5bGVzaGVldHMobmV3UHJvcHMsIGN1cnJlbnRQcm9wcykge1xuICB2YXIgZGlmZiA9IGNvbXBhcmVSZXNvdXJjZVByb3BzRm9yV2FybmluZyhuZXdQcm9wcywgY3VycmVudFByb3BzKTtcbiAgaWYgKCFkaWZmKSByZXR1cm4gJyc7XG4gIHZhciBkZXNjcmlwdGlvbiA9ICcnO1xuXG4gIGZvciAodmFyIHByb3BOYW1lIGluIGRpZmYubWlzc2luZykge1xuICAgIHZhciBwcm9wVmFsdWUgPSBkaWZmLm1pc3NpbmdbcHJvcE5hbWVdO1xuXG4gICAgaWYgKHByb3BOYW1lID09PSAnbWVkaWEnKSB7XG4gICAgICBkZXNjcmlwdGlvbiArPSBcIlxcbiAgXFxcIlwiICsgcHJvcE5hbWUgKyBcIlxcXCIgbWlzc2luZyBmb3IgcHJvcHMsIG9yaWdpbmFsIHZhbHVlOiBcIiArIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKHByb3BWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX3Byb3BOYW1lIGluIGRpZmYuZXh0cmEpIHtcbiAgICB2YXIgX3Byb3BWYWx1ZSA9IGRpZmYuZXh0cmFbX3Byb3BOYW1lXTtcbiAgICBkZXNjcmlwdGlvbiArPSBcIlxcbiAgXFxcIlwiICsgX3Byb3BOYW1lICsgXCJcXFwiIHByb3AgdmFsdWU6IFwiICsgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcoX3Byb3BWYWx1ZSkgKyBcIiwgbWlzc2luZyBmcm9tIG9yaWdpbmFsIHByb3BzXCI7XG4gIH1cblxuICBmb3IgKHZhciBfcHJvcE5hbWUyIGluIGRpZmYuZGlmZmVyZW50KSB7XG4gICAgdmFyIGxhdGVzdFZhbHVlID0gZGlmZi5kaWZmZXJlbnRbX3Byb3BOYW1lMl0ubGF0ZXN0O1xuICAgIHZhciBvcmlnaW5hbFZhbHVlID0gZGlmZi5kaWZmZXJlbnRbX3Byb3BOYW1lMl0ub3JpZ2luYWw7XG4gICAgZGVzY3JpcHRpb24gKz0gXCJcXG4gIFxcXCJcIiArIF9wcm9wTmFtZTIgKyBcIlxcXCIgcHJvcCB2YWx1ZTogXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhsYXRlc3RWYWx1ZSkgKyBcIiwgb3JpZ2luYWwgdmFsdWU6IFwiICsgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcob3JpZ2luYWxWYWx1ZSk7XG4gIH1cblxuICByZXR1cm4gZGVzY3JpcHRpb247XG59XG5mdW5jdGlvbiBkZXNjcmliZURpZmZlcmVuY2VzRm9yU3R5bGVzaGVldE92ZXJQcmVpbml0KG5ld1Byb3BzLCBjdXJyZW50UHJvcHMpIHtcbiAgdmFyIGRpZmYgPSBjb21wYXJlUmVzb3VyY2VQcm9wc0Zvcldhcm5pbmcobmV3UHJvcHMsIGN1cnJlbnRQcm9wcyk7XG4gIGlmICghZGlmZikgcmV0dXJuICcnO1xuICB2YXIgZGVzY3JpcHRpb24gPSAnJztcblxuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBkaWZmLmV4dHJhKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IGRpZmYuZXh0cmFbcHJvcE5hbWVdO1xuXG4gICAgaWYgKHByb3BOYW1lID09PSAncHJlY2VkZW5jZScgfHwgcHJvcE5hbWUgPT09ICdjcm9zc09yaWdpbicgfHwgcHJvcE5hbWUgPT09ICdpbnRlZ3JpdHknKSB7XG4gICAgICBkZXNjcmlwdGlvbiArPSBcIlxcbiAgXFxcIlwiICsgcHJvcE5hbWUgKyBcIlxcXCIgcHJvcCB2YWx1ZTogXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhwcm9wVmFsdWUpICsgXCIsIG9wdGlvbiBtaXNzaW5nXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlc2NyaXB0aW9uICs9IFwiXFxuICBcXFwiXCIgKyBwcm9wTmFtZSArIFwiXFxcIiBwcm9wIHZhbHVlOiBcIiArIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKHByb3BWYWx1ZSkgKyBcIiwgb3B0aW9uIG5vdCBhdmFpbGFibGUgd2l0aCBSZWFjdERPTS5wcmVpbml0KClcIjtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBfcHJvcE5hbWUzIGluIGRpZmYuZGlmZmVyZW50KSB7XG4gICAgdmFyIGxhdGVzdFZhbHVlID0gZGlmZi5kaWZmZXJlbnRbX3Byb3BOYW1lM10ubGF0ZXN0O1xuICAgIHZhciBvcmlnaW5hbFZhbHVlID0gZGlmZi5kaWZmZXJlbnRbX3Byb3BOYW1lM10ub3JpZ2luYWw7XG5cbiAgICBpZiAoX3Byb3BOYW1lMyA9PT0gJ3ByZWNlZGVuY2UnICYmIG9yaWdpbmFsVmFsdWUgPT09ICdkZWZhdWx0Jykge1xuICAgICAgZGVzY3JpcHRpb24gKz0gXCJcXG4gIFxcXCJcIiArIF9wcm9wTmFtZTMgKyBcIlxcXCIgcHJvcCB2YWx1ZTogXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhsYXRlc3RWYWx1ZSkgKyBcIiwgbWlzc2luZyBmcm9tIG9wdGlvbnNcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVzY3JpcHRpb24gKz0gXCJcXG4gIFxcXCJcIiArIF9wcm9wTmFtZTMgKyBcIlxcXCIgcHJvcCB2YWx1ZTogXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhsYXRlc3RWYWx1ZSkgKyBcIiwgb3B0aW9uIHZhbHVlOiBcIiArIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKG9yaWdpbmFsVmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZXNjcmlwdGlvbjtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRGlmZmVyZW5jZXNGb3JQcmVpbml0T3ZlclN0eWxlc2hlZXQobmV3UHJvcHMsIGN1cnJlbnRQcm9wcykge1xuICB2YXIgZGlmZiA9IGNvbXBhcmVSZXNvdXJjZVByb3BzRm9yV2FybmluZyhuZXdQcm9wcywgY3VycmVudFByb3BzKTtcbiAgaWYgKCFkaWZmKSByZXR1cm4gJyc7XG4gIHZhciBkZXNjcmlwdGlvbiA9ICcnO1xuXG4gIGZvciAodmFyIHByb3BOYW1lIGluIGRpZmYubWlzc2luZykge1xuICAgIHZhciBwcm9wVmFsdWUgPSBkaWZmLm1pc3NpbmdbcHJvcE5hbWVdO1xuXG4gICAgaWYgKHByb3BOYW1lID09PSAncHJlY2VkZW5jZScgJiYgcHJvcFZhbHVlICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgIGRlc2NyaXB0aW9uICs9IFwiXFxuICBcXFwiXCIgKyBwcm9wTmFtZSArIFwiXFxcIiBtaXNzaW5nIGZyb20gb3B0aW9ucywgcHJvcCB2YWx1ZTogXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhwcm9wVmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9wcm9wTmFtZTQgaW4gZGlmZi5leHRyYSkge1xuICAgIHZhciBfcHJvcFZhbHVlMiA9IGRpZmYuZXh0cmFbX3Byb3BOYW1lNF07XG5cbiAgICBpZiAoX3Byb3BOYW1lNCA9PT0gJ3ByZWNlZGVuY2UnIHx8IF9wcm9wTmFtZTQgPT09ICdjcm9zc09yaWdpbicgfHwgX3Byb3BOYW1lNCA9PT0gJ2ludGVncml0eScpIHtcbiAgICAgIGRlc2NyaXB0aW9uICs9IFwiXFxuICBcXFwiXCIgKyBfcHJvcE5hbWU0ICsgXCJcXFwiIG9wdGlvbiB2YWx1ZTogXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhfcHJvcFZhbHVlMikgKyBcIiwgbWlzc2luZyBmcm9tIHByb3BzXCI7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX3Byb3BOYW1lNSBpbiBkaWZmLmRpZmZlcmVudCkge1xuICAgIHZhciBsYXRlc3RWYWx1ZSA9IGRpZmYuZGlmZmVyZW50W19wcm9wTmFtZTVdLmxhdGVzdDtcbiAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IGRpZmYuZGlmZmVyZW50W19wcm9wTmFtZTVdLm9yaWdpbmFsO1xuICAgIGRlc2NyaXB0aW9uICs9IFwiXFxuICBcXFwiXCIgKyBfcHJvcE5hbWU1ICsgXCJcXFwiIG9wdGlvbiB2YWx1ZTogXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhsYXRlc3RWYWx1ZSkgKyBcIiwgcHJvcCB2YWx1ZTogXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhvcmlnaW5hbFZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiBkZXNjcmlwdGlvbjtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRGlmZmVyZW5jZXNGb3JQcmVpbml0cyhuZXdQcm9wcywgY3VycmVudFByb3BzKSB7XG4gIHZhciBkaWZmID0gY29tcGFyZVJlc291cmNlUHJvcHNGb3JXYXJuaW5nKG5ld1Byb3BzLCBjdXJyZW50UHJvcHMpO1xuICBpZiAoIWRpZmYpIHJldHVybiAnJztcbiAgdmFyIGRlc2NyaXB0aW9uID0gJyc7XG5cbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gZGlmZi5taXNzaW5nKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IGRpZmYubWlzc2luZ1twcm9wTmFtZV07XG5cbiAgICBpZiAocHJvcE5hbWUgPT09ICdwcmVjZWRlbmNlJyAmJiBwcm9wVmFsdWUgIT09ICdkZWZhdWx0Jykge1xuICAgICAgZGVzY3JpcHRpb24gKz0gXCJcXG4gIFxcXCJcIiArIHByb3BOYW1lICsgXCJcXFwiIG1pc3NpbmcgZnJvbSBvcHRpb25zLCBvcmlnaW5hbCBvcHRpb24gdmFsdWU6IFwiICsgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcocHJvcFZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBfcHJvcE5hbWU2IGluIGRpZmYuZXh0cmEpIHtcbiAgICB2YXIgX3Byb3BWYWx1ZTMgPSBkaWZmLmV4dHJhW19wcm9wTmFtZTZdO1xuXG4gICAgaWYgKF9wcm9wTmFtZTYgPT09ICdwcmVjZWRlbmNlJyAmJiBfcHJvcFZhbHVlMyAhPT0gJ2RlZmF1bHQnIHx8IF9wcm9wTmFtZTYgPT09ICdjcm9zc09yaWdpbicgfHwgX3Byb3BOYW1lNiA9PT0gJ2ludGVncml0eScpIHtcbiAgICAgIGRlc2NyaXB0aW9uICs9IFwiXFxuICBcXFwiXCIgKyBfcHJvcE5hbWU2ICsgXCJcXFwiIG9wdGlvbiB2YWx1ZTogXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhfcHJvcFZhbHVlMykgKyBcIiwgbWlzc2luZyBmcm9tIG9yaWdpbmFsIG9wdGlvbnNcIjtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBfcHJvcE5hbWU3IGluIGRpZmYuZGlmZmVyZW50KSB7XG4gICAgdmFyIGxhdGVzdFZhbHVlID0gZGlmZi5kaWZmZXJlbnRbX3Byb3BOYW1lN10ubGF0ZXN0O1xuICAgIHZhciBvcmlnaW5hbFZhbHVlID0gZGlmZi5kaWZmZXJlbnRbX3Byb3BOYW1lN10ub3JpZ2luYWw7XG4gICAgZGVzY3JpcHRpb24gKz0gXCJcXG4gIFxcXCJcIiArIF9wcm9wTmFtZTcgKyBcIlxcXCIgb3B0aW9uIHZhbHVlOiBcIiArIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKGxhdGVzdFZhbHVlKSArIFwiLCBvcmlnaW5hbCBvcHRpb24gdmFsdWU6IFwiICsgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcob3JpZ2luYWxWYWx1ZSk7XG4gIH1cblxuICByZXR1cm4gZGVzY3JpcHRpb247XG59XG52YXIgcHJlbG9hZE9wdGlvbnNGb3JDb21wYXJpc29uID0gWydhcycsICdjcm9zc09yaWdpbicsICdpbnRlZ3JpdHknLCAnbWVkaWEnXTtcbmZ1bmN0aW9uIGRlc2NyaWJlRGlmZmVyZW5jZXNGb3JQcmVsb2FkcyhuZXdQcm9wcywgY3VycmVudFByb3BzKSB7XG4gIHZhciBkaWZmID0gY29tcGFyZVJlc291cmNlUHJvcHNGb3JXYXJuaW5nKG5ld1Byb3BzLCBjdXJyZW50UHJvcHMpO1xuICBpZiAoIWRpZmYpIHJldHVybiAnJztcbiAgdmFyIGRlc2NyaXB0aW9uID0gJyc7XG5cbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gZGlmZi5taXNzaW5nKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IGRpZmYubWlzc2luZ1twcm9wTmFtZV07XG5cbiAgICBpZiAocHJlbG9hZE9wdGlvbnNGb3JDb21wYXJpc29uLmluY2x1ZGVzKHByb3BOYW1lKSkge1xuICAgICAgZGVzY3JpcHRpb24gKz0gXCJcXG4gIFxcXCJcIiArIHByb3BOYW1lICsgXCJcXFwiIG1pc3NpbmcgZnJvbSBvcHRpb25zLCBvcmlnaW5hbCBvcHRpb24gdmFsdWU6IFwiICsgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcocHJvcFZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBfcHJvcE5hbWU4IGluIGRpZmYuZXh0cmEpIHtcbiAgICB2YXIgX3Byb3BWYWx1ZTQgPSBkaWZmLmV4dHJhW19wcm9wTmFtZThdO1xuXG4gICAgaWYgKHByZWxvYWRPcHRpb25zRm9yQ29tcGFyaXNvbi5pbmNsdWRlcyhfcHJvcE5hbWU4KSkge1xuICAgICAgZGVzY3JpcHRpb24gKz0gXCJcXG4gIFxcXCJcIiArIF9wcm9wTmFtZTggKyBcIlxcXCIgb3B0aW9uIHZhbHVlOiBcIiArIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKF9wcm9wVmFsdWU0KSArIFwiLCBtaXNzaW5nIGZyb20gb3JpZ2luYWwgb3B0aW9uc1wiO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9wcm9wTmFtZTkgaW4gZGlmZi5kaWZmZXJlbnQpIHtcbiAgICB2YXIgbGF0ZXN0VmFsdWUgPSBkaWZmLmRpZmZlcmVudFtfcHJvcE5hbWU5XS5sYXRlc3Q7XG4gICAgdmFyIG9yaWdpbmFsVmFsdWUgPSBkaWZmLmRpZmZlcmVudFtfcHJvcE5hbWU5XS5vcmlnaW5hbDtcblxuICAgIGlmIChwcmVsb2FkT3B0aW9uc0ZvckNvbXBhcmlzb24uaW5jbHVkZXMoX3Byb3BOYW1lOSkpIHtcbiAgICAgIGRlc2NyaXB0aW9uICs9IFwiXFxuICBcXFwiXCIgKyBfcHJvcE5hbWU5ICsgXCJcXFwiIG9wdGlvbiB2YWx1ZTogXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhsYXRlc3RWYWx1ZSkgKyBcIiwgb3JpZ2luYWwgb3B0aW9uIHZhbHVlOiBcIiArIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKG9yaWdpbmFsVmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZXNjcmlwdGlvbjtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRGlmZmVyZW5jZXNGb3JQcmVsb2FkT3ZlckltcGxpY2l0UHJlbG9hZChuZXdQcm9wcywgY3VycmVudFByb3BzKSB7XG4gIHZhciBkaWZmID0gY29tcGFyZVJlc291cmNlUHJvcHNGb3JXYXJuaW5nKG5ld1Byb3BzLCBjdXJyZW50UHJvcHMpO1xuICBpZiAoIWRpZmYpIHJldHVybiAnJztcbiAgdmFyIGRlc2NyaXB0aW9uID0gJyc7XG5cbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gZGlmZi5taXNzaW5nKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IGRpZmYubWlzc2luZ1twcm9wTmFtZV07XG5cbiAgICBpZiAocHJlbG9hZE9wdGlvbnNGb3JDb21wYXJpc29uLmluY2x1ZGVzKHByb3BOYW1lKSkge1xuICAgICAgZGVzY3JpcHRpb24gKz0gXCJcXG4gIFxcXCJcIiArIHByb3BOYW1lICsgXCJcXFwiIG1pc3NpbmcgZnJvbSBvcHRpb25zLCB1bmRlcmx5aW5nIHByb3AgdmFsdWU6IFwiICsgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcocHJvcFZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBfcHJvcE5hbWUxMCBpbiBkaWZmLmV4dHJhKSB7XG4gICAgdmFyIF9wcm9wVmFsdWU1ID0gZGlmZi5leHRyYVtfcHJvcE5hbWUxMF07XG5cbiAgICBpZiAocHJlbG9hZE9wdGlvbnNGb3JDb21wYXJpc29uLmluY2x1ZGVzKF9wcm9wTmFtZTEwKSkge1xuICAgICAgZGVzY3JpcHRpb24gKz0gXCJcXG4gIFxcXCJcIiArIF9wcm9wTmFtZTEwICsgXCJcXFwiIG9wdGlvbiB2YWx1ZTogXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhfcHJvcFZhbHVlNSkgKyBcIiwgbWlzc2luZyBmcm9tIHVuZGVybHlpbmcgcHJvcHNcIjtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBfcHJvcE5hbWUxMSBpbiBkaWZmLmRpZmZlcmVudCkge1xuICAgIHZhciBsYXRlc3RWYWx1ZSA9IGRpZmYuZGlmZmVyZW50W19wcm9wTmFtZTExXS5sYXRlc3Q7XG4gICAgdmFyIG9yaWdpbmFsVmFsdWUgPSBkaWZmLmRpZmZlcmVudFtfcHJvcE5hbWUxMV0ub3JpZ2luYWw7XG5cbiAgICBpZiAocHJlbG9hZE9wdGlvbnNGb3JDb21wYXJpc29uLmluY2x1ZGVzKF9wcm9wTmFtZTExKSkge1xuICAgICAgZGVzY3JpcHRpb24gKz0gXCJcXG4gIFxcXCJcIiArIF9wcm9wTmFtZTExICsgXCJcXFwiIG9wdGlvbiB2YWx1ZTogXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhsYXRlc3RWYWx1ZSkgKyBcIiwgdW5kZXJseWluZyBwcm9wIHZhbHVlOiBcIiArIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKG9yaWdpbmFsVmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZXNjcmlwdGlvbjtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRGlmZmVyZW5jZXNGb3JTY3JpcHRzKG5ld1Byb3BzLCBjdXJyZW50UHJvcHMpIHtcbiAgdmFyIGRpZmYgPSBjb21wYXJlUmVzb3VyY2VQcm9wc0Zvcldhcm5pbmcobmV3UHJvcHMsIGN1cnJlbnRQcm9wcyk7XG4gIGlmICghZGlmZikgcmV0dXJuICcnO1xuICB2YXIgZGVzY3JpcHRpb24gPSAnJztcblxuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBkaWZmLm1pc3NpbmcpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gZGlmZi5taXNzaW5nW3Byb3BOYW1lXTtcbiAgICBkZXNjcmlwdGlvbiArPSBcIlxcbiAgXFxcIlwiICsgcHJvcE5hbWUgKyBcIlxcXCIgbWlzc2luZyBmb3IgcHJvcHMsIG9yaWdpbmFsIHZhbHVlOiBcIiArIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKHByb3BWYWx1ZSk7XG4gIH1cblxuICBmb3IgKHZhciBfcHJvcE5hbWUxMiBpbiBkaWZmLmV4dHJhKSB7XG4gICAgdmFyIF9wcm9wVmFsdWU2ID0gZGlmZi5leHRyYVtfcHJvcE5hbWUxMl07XG4gICAgZGVzY3JpcHRpb24gKz0gXCJcXG4gIFxcXCJcIiArIF9wcm9wTmFtZTEyICsgXCJcXFwiIHByb3AgdmFsdWU6IFwiICsgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcoX3Byb3BWYWx1ZTYpICsgXCIsIG1pc3NpbmcgZnJvbSBvcmlnaW5hbCBwcm9wc1wiO1xuICB9XG5cbiAgZm9yICh2YXIgX3Byb3BOYW1lMTMgaW4gZGlmZi5kaWZmZXJlbnQpIHtcbiAgICB2YXIgbGF0ZXN0VmFsdWUgPSBkaWZmLmRpZmZlcmVudFtfcHJvcE5hbWUxM10ubGF0ZXN0O1xuICAgIHZhciBvcmlnaW5hbFZhbHVlID0gZGlmZi5kaWZmZXJlbnRbX3Byb3BOYW1lMTNdLm9yaWdpbmFsO1xuICAgIGRlc2NyaXB0aW9uICs9IFwiXFxuICBcXFwiXCIgKyBfcHJvcE5hbWUxMyArIFwiXFxcIiBwcm9wIHZhbHVlOiBcIiArIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKGxhdGVzdFZhbHVlKSArIFwiLCBvcmlnaW5hbCB2YWx1ZTogXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhvcmlnaW5hbFZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiBkZXNjcmlwdGlvbjtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRGlmZmVyZW5jZXNGb3JTY3JpcHRPdmVyUHJlaW5pdChuZXdQcm9wcywgY3VycmVudFByb3BzKSB7XG4gIHZhciBkaWZmID0gY29tcGFyZVJlc291cmNlUHJvcHNGb3JXYXJuaW5nKG5ld1Byb3BzLCBjdXJyZW50UHJvcHMpO1xuICBpZiAoIWRpZmYpIHJldHVybiAnJztcbiAgdmFyIGRlc2NyaXB0aW9uID0gJyc7XG5cbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gZGlmZi5leHRyYSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBkaWZmLmV4dHJhW3Byb3BOYW1lXTtcblxuICAgIGlmIChwcm9wTmFtZSA9PT0gJ2Nyb3NzT3JpZ2luJyB8fCBwcm9wTmFtZSA9PT0gJ2ludGVncml0eScpIHtcbiAgICAgIGRlc2NyaXB0aW9uICs9IFwiXFxuICBcXFwiXCIgKyBwcm9wTmFtZSArIFwiXFxcIiBwcm9wIHZhbHVlOiBcIiArIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKHByb3BWYWx1ZSkgKyBcIiwgb3B0aW9uIG1pc3NpbmdcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVzY3JpcHRpb24gKz0gXCJcXG4gIFxcXCJcIiArIHByb3BOYW1lICsgXCJcXFwiIHByb3AgdmFsdWU6IFwiICsgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcocHJvcFZhbHVlKSArIFwiLCBvcHRpb24gbm90IGF2YWlsYWJsZSB3aXRoIFJlYWN0RE9NLnByZWluaXQoKVwiO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9wcm9wTmFtZTE0IGluIGRpZmYuZGlmZmVyZW50KSB7XG4gICAgdmFyIGxhdGVzdFZhbHVlID0gZGlmZi5kaWZmZXJlbnRbX3Byb3BOYW1lMTRdLmxhdGVzdDtcbiAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IGRpZmYuZGlmZmVyZW50W19wcm9wTmFtZTE0XS5vcmlnaW5hbDtcbiAgICBkZXNjcmlwdGlvbiArPSBcIlxcbiAgXFxcIlwiICsgX3Byb3BOYW1lMTQgKyBcIlxcXCIgcHJvcCB2YWx1ZTogXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhsYXRlc3RWYWx1ZSkgKyBcIiwgb3B0aW9uIHZhbHVlOiBcIiArIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKG9yaWdpbmFsVmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIGRlc2NyaXB0aW9uO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVEaWZmZXJlbmNlc0ZvclByZWluaXRPdmVyU2NyaXB0KG5ld1Byb3BzLCBjdXJyZW50UHJvcHMpIHtcbiAgdmFyIGRpZmYgPSBjb21wYXJlUmVzb3VyY2VQcm9wc0Zvcldhcm5pbmcobmV3UHJvcHMsIGN1cnJlbnRQcm9wcyk7XG4gIGlmICghZGlmZikgcmV0dXJuICcnO1xuICB2YXIgZGVzY3JpcHRpb24gPSAnJztcblxuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBkaWZmLmV4dHJhKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IGRpZmYuZXh0cmFbcHJvcE5hbWVdO1xuXG4gICAgaWYgKHByb3BOYW1lID09PSAnY3Jvc3NPcmlnaW4nIHx8IHByb3BOYW1lID09PSAnaW50ZWdyaXR5Jykge1xuICAgICAgZGVzY3JpcHRpb24gKz0gXCJcXG4gIFxcXCJcIiArIHByb3BOYW1lICsgXCJcXFwiIG9wdGlvbiB2YWx1ZTogXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhwcm9wVmFsdWUpICsgXCIsIG1pc3NpbmcgZnJvbSBwcm9wc1wiO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9wcm9wTmFtZTE1IGluIGRpZmYuZGlmZmVyZW50KSB7XG4gICAgdmFyIGxhdGVzdFZhbHVlID0gZGlmZi5kaWZmZXJlbnRbX3Byb3BOYW1lMTVdLmxhdGVzdDtcbiAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IGRpZmYuZGlmZmVyZW50W19wcm9wTmFtZTE1XS5vcmlnaW5hbDtcbiAgICBkZXNjcmlwdGlvbiArPSBcIlxcbiAgXFxcIlwiICsgX3Byb3BOYW1lMTUgKyBcIlxcXCIgb3B0aW9uIHZhbHVlOiBcIiArIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKGxhdGVzdFZhbHVlKSArIFwiLCBwcm9wIHZhbHVlOiBcIiArIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKG9yaWdpbmFsVmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIGRlc2NyaXB0aW9uO1xufVxuXG52YXIgUmVhY3RET01TaGFyZWRJbnRlcm5hbHMgPSBSZWFjdERPTS5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxudmFyIFJlYWN0RE9NQ3VycmVudERpc3BhdGNoZXIgPSBSZWFjdERPTVNoYXJlZEludGVybmFscy5EaXNwYXRjaGVyO1xudmFyIFJlYWN0RE9NU2VydmVyRGlzcGF0Y2hlciA9IHtcbiAgcHJlZmV0Y2hETlM6IHByZWZldGNoRE5TLFxuICBwcmVjb25uZWN0OiBwcmVjb25uZWN0LFxuICBwcmVsb2FkOiBwcmVsb2FkLFxuICBwcmVpbml0OiBwcmVpbml0XG59O1xuZnVuY3Rpb24gcHJlcGFyZUhvc3REaXNwYXRjaGVyKCkge1xuICBSZWFjdERPTUN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBSZWFjdERPTVNlcnZlckRpc3BhdGNoZXI7XG59IC8vIFVzZWQgdG8gZGlzdGluZ3Vpc2ggdGhlc2UgY29udGV4dHMgZnJvbSBvbmVzIHVzZWQgaW4gb3RoZXIgcmVuZGVyZXJzLlxudmFyIFNjcmlwdFN0cmVhbWluZ0Zvcm1hdCA9IDA7XG52YXIgRGF0YVN0cmVhbWluZ0Zvcm1hdCA9IDE7XG52YXIgTm90aGluZ1NlbnRcbi8qICAgICAgICAgICAgICAgICAgICAgICovXG49IDA7XG52YXIgU2VudENvbXBsZXRlU2VnbWVudEZ1bmN0aW9uXG4vKiAgICAgICovXG49IDE7XG52YXIgU2VudENvbXBsZXRlQm91bmRhcnlGdW5jdGlvblxuLyogICAgICovXG49IDI7XG52YXIgU2VudENsaWVudFJlbmRlckZ1bmN0aW9uXG4vKiAgICAgICAgICovXG49IDQ7XG52YXIgU2VudFN0eWxlSW5zZXJ0aW9uRnVuY3Rpb25cbi8qICAgICAgICovXG49IDg7XG5cbnZhciBkYXRhRWxlbWVudFF1b3RlZEVuZCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+PC90ZW1wbGF0ZT4nKTtcbnZhciBzdGFydElubGluZVNjcmlwdCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHNjcmlwdD4nKTtcbnZhciBlbmRJbmxpbmVTY3JpcHQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvc2NyaXB0PicpO1xudmFyIHN0YXJ0U2NyaXB0U3JjID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8c2NyaXB0IHNyYz1cIicpO1xudmFyIHN0YXJ0TW9kdWxlU3JjID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8c2NyaXB0IHR5cGU9XCJtb2R1bGVcIiBzcmM9XCInKTtcbnZhciBzY3JpcHROb25jZSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgbm9uY2U9XCInKTtcbnZhciBzY3JpcHRJbnRlZ2lydHkgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGludGVncml0eT1cIicpO1xudmFyIHNjcmlwdENyb3NzT3JpZ2luID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBjcm9zc29yaWdpbj1cIicpO1xudmFyIGVuZEFzeW5jU2NyaXB0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBhc3luYz1cIlwiPjwvc2NyaXB0PicpO1xuLyoqXG4gKiBUaGlzIGVzY2FwaW5nIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIHdvcmsgd2l0aCBib290c3RyYXBTY3JpcHRDb250ZW50IG9ubHkuXG4gKiBiZWNhdXNlIHdlIGtub3cgd2UgYXJlIGVzY2FwaW5nIHRoZSBlbnRpcmUgc2NyaXB0LiBXZSBjYW4gYXZvaWQgZm9yIGluc3RhbmNlXG4gKiBlc2NhcGluZyBodG1sIGNvbW1lbnQgc3RyaW5nIHNlcXVlbmNlcyB0aGF0IGFyZSB2YWxpZCBqYXZhc2NyaXB0IGFzIHdlbGwgYmVjYXVzZVxuICogaWYgdGhlcmUgYXJlIG5vIHNlYnNlcXVlbnQgPHNjcmlwdCBzZXF1ZW5jZXMgdGhlIGh0bWwgcGFyc2VyIHdpbGwgbmV2ZXIgZW50ZXJcbiAqIHNjcmlwdCBkYXRhIGRvdWJsZSBlc2NhcGVkIHN0YXRlIChzZWU6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTMvc3ludGF4Lmh0bWwjc2NyaXB0LWRhdGEtZG91YmxlLWVzY2FwZWQtc3RhdGUpXG4gKlxuICogV2hpbGUgdW50cnVzdGVkIHNjcmlwdCBjb250ZW50IHNob3VsZCBiZSBtYWRlIHNhZmUgYmVmb3JlIHVzaW5nIHRoaXMgYXBpIGl0IHdpbGxcbiAqIGVuc3VyZSB0aGF0IHRoZSBzY3JpcHQgY2Fubm90IGJlIGVhcmx5IHRlcm1pbmF0ZWQgb3IgbmV2ZXIgdGVybWluYXRlZCBzdGF0ZVxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZUJvb3RzdHJhcFNjcmlwdENvbnRlbnQoc2NyaXB0VGV4dCkge1xuICB7XG4gICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oc2NyaXB0VGV4dCk7XG4gIH1cblxuICByZXR1cm4gKCcnICsgc2NyaXB0VGV4dCkucmVwbGFjZShzY3JpcHRSZWdleCwgc2NyaXB0UmVwbGFjZXIpO1xufVxuXG52YXIgc2NyaXB0UmVnZXggPSAvKDxcXC98PCkocykoY3JpcHQpL2dpO1xuXG52YXIgc2NyaXB0UmVwbGFjZXIgPSBmdW5jdGlvbiAobWF0Y2gsIHByZWZpeCwgcywgc3VmZml4KSB7XG4gIHJldHVybiBcIlwiICsgcHJlZml4ICsgKHMgPT09ICdzJyA/IFwiXFxcXHUwMDczXCIgOiBcIlxcXFx1MDA1M1wiKSArIHN1ZmZpeDtcbn07IC8vIEFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIHdoYXQgd2UndmUgYWxyZWFkeSB3cml0dGVuIHNvIHdlIGNhbiByZWZlciBiYWNrIHRvIGl0LlxuLy8gaWYgcGFzc2VkIGV4dGVybmFsUnVudGltZUNvbmZpZyBhbmQgdGhlIGVuYWJsZUZpenpFeHRlcm5hbFJ1bnRpbWUgZmVhdHVyZSBmbGFnXG4vLyBpcyBzZXQsIHRoZSBzZXJ2ZXIgd2lsbCBzZW5kIGluc3RydWN0aW9ucyB2aWEgZGF0YSBhdHRyaWJ1dGVzIChpbnN0ZWFkIG9mIGlubGluZSBzY3JpcHRzKVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlU3RhdGUkMShyZXNvdXJjZXMsIGlkZW50aWZpZXJQcmVmaXgsIG5vbmNlLCBib290c3RyYXBTY3JpcHRDb250ZW50LCBib290c3RyYXBTY3JpcHRzLCBib290c3RyYXBNb2R1bGVzLCBleHRlcm5hbFJ1bnRpbWVDb25maWcpIHtcbiAgdmFyIGlkUHJlZml4ID0gaWRlbnRpZmllclByZWZpeCA9PT0gdW5kZWZpbmVkID8gJycgOiBpZGVudGlmaWVyUHJlZml4O1xuICB2YXIgaW5saW5lU2NyaXB0V2l0aE5vbmNlID0gbm9uY2UgPT09IHVuZGVmaW5lZCA/IHN0YXJ0SW5saW5lU2NyaXB0IDogc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8c2NyaXB0IG5vbmNlPVwiJyArIGVzY2FwZVRleHRGb3JCcm93c2VyKG5vbmNlKSArICdcIj4nKTtcbiAgdmFyIGJvb3RzdHJhcENodW5rcyA9IFtdO1xuICB2YXIgZXh0ZXJuYWxSdW50aW1lU2NyaXB0ID0gbnVsbDtcbiAgdmFyIHN0cmVhbWluZ0Zvcm1hdCA9IFNjcmlwdFN0cmVhbWluZ0Zvcm1hdDtcblxuICBpZiAoYm9vdHN0cmFwU2NyaXB0Q29udGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goaW5saW5lU2NyaXB0V2l0aE5vbmNlLCBzdHJpbmdUb0NodW5rKGVzY2FwZUJvb3RzdHJhcFNjcmlwdENvbnRlbnQoYm9vdHN0cmFwU2NyaXB0Q29udGVudCkpLCBlbmRJbmxpbmVTY3JpcHQpO1xuICB9XG5cbiAge1xuXG4gICAgaWYgKGV4dGVybmFsUnVudGltZUNvbmZpZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdHJlYW1pbmdGb3JtYXQgPSBEYXRhU3RyZWFtaW5nRm9ybWF0O1xuXG4gICAgICBpZiAodHlwZW9mIGV4dGVybmFsUnVudGltZUNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZXh0ZXJuYWxSdW50aW1lU2NyaXB0ID0ge1xuICAgICAgICAgIHNyYzogZXh0ZXJuYWxSdW50aW1lQ29uZmlnLFxuICAgICAgICAgIGNodW5rczogW11cbiAgICAgICAgfTtcbiAgICAgICAgcHVzaFNjcmlwdEltcGwoZXh0ZXJuYWxSdW50aW1lU2NyaXB0LmNodW5rcywge1xuICAgICAgICAgIHNyYzogZXh0ZXJuYWxSdW50aW1lQ29uZmlnLFxuICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgIGludGVncml0eTogdW5kZWZpbmVkLFxuICAgICAgICAgIG5vbmNlOiBub25jZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4dGVybmFsUnVudGltZVNjcmlwdCA9IHtcbiAgICAgICAgICBzcmM6IGV4dGVybmFsUnVudGltZUNvbmZpZy5zcmMsXG4gICAgICAgICAgY2h1bmtzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBwdXNoU2NyaXB0SW1wbChleHRlcm5hbFJ1bnRpbWVTY3JpcHQuY2h1bmtzLCB7XG4gICAgICAgICAgc3JjOiBleHRlcm5hbFJ1bnRpbWVDb25maWcuc3JjLFxuICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgIGludGVncml0eTogZXh0ZXJuYWxSdW50aW1lQ29uZmlnLmludGVncml0eSxcbiAgICAgICAgICBub25jZTogbm9uY2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGJvb3RzdHJhcFNjcmlwdHMgIT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9vdHN0cmFwU2NyaXB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNjcmlwdENvbmZpZyA9IGJvb3RzdHJhcFNjcmlwdHNbaV07XG4gICAgICB2YXIgc3JjID0gdHlwZW9mIHNjcmlwdENvbmZpZyA9PT0gJ3N0cmluZycgPyBzY3JpcHRDb25maWcgOiBzY3JpcHRDb25maWcuc3JjO1xuICAgICAgdmFyIGludGVncml0eSA9IHR5cGVvZiBzY3JpcHRDb25maWcgPT09ICdzdHJpbmcnID8gdW5kZWZpbmVkIDogc2NyaXB0Q29uZmlnLmludGVncml0eTtcbiAgICAgIHZhciBjcm9zc09yaWdpbiA9IHR5cGVvZiBzY3JpcHRDb25maWcgPT09ICdzdHJpbmcnIHx8IHNjcmlwdENvbmZpZy5jcm9zc09yaWdpbiA9PSBudWxsID8gdW5kZWZpbmVkIDogc2NyaXB0Q29uZmlnLmNyb3NzT3JpZ2luID09PSAndXNlLWNyZWRlbnRpYWxzJyA/ICd1c2UtY3JlZGVudGlhbHMnIDogJyc7XG4gICAgICBwcmVsb2FkQm9vdHN0cmFwU2NyaXB0KHJlc291cmNlcywgc3JjLCBub25jZSwgaW50ZWdyaXR5LCBjcm9zc09yaWdpbik7XG4gICAgICBib290c3RyYXBDaHVua3MucHVzaChzdGFydFNjcmlwdFNyYywgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihzcmMpKSk7XG5cbiAgICAgIGlmIChub25jZSkge1xuICAgICAgICBib290c3RyYXBDaHVua3MucHVzaChzY3JpcHROb25jZSwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcihub25jZSkpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGludGVncml0eSkge1xuICAgICAgICBib290c3RyYXBDaHVua3MucHVzaChzY3JpcHRJbnRlZ2lydHksIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoaW50ZWdyaXR5KSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNyb3NzT3JpZ2luID09PSAnc3RyaW5nJykge1xuICAgICAgICBib290c3RyYXBDaHVua3MucHVzaChzY3JpcHRDcm9zc09yaWdpbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcihjcm9zc09yaWdpbikpKTtcbiAgICAgIH1cblxuICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goZW5kQXN5bmNTY3JpcHQpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChib290c3RyYXBNb2R1bGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYm9vdHN0cmFwTW9kdWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfc2NyaXB0Q29uZmlnID0gYm9vdHN0cmFwTW9kdWxlc1tfaV07XG5cbiAgICAgIHZhciBfc3JjID0gdHlwZW9mIF9zY3JpcHRDb25maWcgPT09ICdzdHJpbmcnID8gX3NjcmlwdENvbmZpZyA6IF9zY3JpcHRDb25maWcuc3JjO1xuXG4gICAgICB2YXIgX2ludGVncml0eSA9IHR5cGVvZiBfc2NyaXB0Q29uZmlnID09PSAnc3RyaW5nJyA/IHVuZGVmaW5lZCA6IF9zY3JpcHRDb25maWcuaW50ZWdyaXR5O1xuXG4gICAgICB2YXIgX2Nyb3NzT3JpZ2luID0gdHlwZW9mIF9zY3JpcHRDb25maWcgPT09ICdzdHJpbmcnIHx8IF9zY3JpcHRDb25maWcuY3Jvc3NPcmlnaW4gPT0gbnVsbCA/IHVuZGVmaW5lZCA6IF9zY3JpcHRDb25maWcuY3Jvc3NPcmlnaW4gPT09ICd1c2UtY3JlZGVudGlhbHMnID8gJ3VzZS1jcmVkZW50aWFscycgOiAnJztcblxuICAgICAgcHJlbG9hZEJvb3RzdHJhcE1vZHVsZShyZXNvdXJjZXMsIF9zcmMsIG5vbmNlLCBfaW50ZWdyaXR5LCBfY3Jvc3NPcmlnaW4pO1xuICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goc3RhcnRNb2R1bGVTcmMsIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoX3NyYykpKTtcblxuICAgICAgaWYgKG5vbmNlKSB7XG4gICAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKHNjcmlwdE5vbmNlLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKG5vbmNlKSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX2ludGVncml0eSkge1xuICAgICAgICBib290c3RyYXBDaHVua3MucHVzaChzY3JpcHRJbnRlZ2lydHksIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoX2ludGVncml0eSkpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBfY3Jvc3NPcmlnaW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKHNjcmlwdENyb3NzT3JpZ2luLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKF9jcm9zc09yaWdpbikpKTtcbiAgICAgIH1cblxuICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goZW5kQXN5bmNTY3JpcHQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYm9vdHN0cmFwQ2h1bmtzOiBib290c3RyYXBDaHVua3MsXG4gICAgcGxhY2Vob2xkZXJQcmVmaXg6IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhpZFByZWZpeCArICdQOicpLFxuICAgIHNlZ21lbnRQcmVmaXg6IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhpZFByZWZpeCArICdTOicpLFxuICAgIGJvdW5kYXJ5UHJlZml4OiBpZFByZWZpeCArICdCOicsXG4gICAgaWRQcmVmaXg6IGlkUHJlZml4LFxuICAgIG5leHRTdXNwZW5zZUlEOiAwLFxuICAgIHN0cmVhbWluZ0Zvcm1hdDogc3RyZWFtaW5nRm9ybWF0LFxuICAgIHN0YXJ0SW5saW5lU2NyaXB0OiBpbmxpbmVTY3JpcHRXaXRoTm9uY2UsXG4gICAgaW5zdHJ1Y3Rpb25zOiBOb3RoaW5nU2VudCxcbiAgICBleHRlcm5hbFJ1bnRpbWVTY3JpcHQ6IGV4dGVybmFsUnVudGltZVNjcmlwdCxcbiAgICBodG1sQ2h1bmtzOiBudWxsLFxuICAgIGhlYWRDaHVua3M6IG51bGwsXG4gICAgaGFzQm9keTogZmFsc2UsXG4gICAgY2hhcnNldENodW5rczogW10sXG4gICAgcHJlY29ubmVjdENodW5rczogW10sXG4gICAgcHJlbG9hZENodW5rczogW10sXG4gICAgaG9pc3RhYmxlQ2h1bmtzOiBbXSxcbiAgICBzdHlsZXNUb0hvaXN0OiBmYWxzZSxcbiAgICBub25jZTogbm9uY2VcbiAgfTtcbn0gLy8gQ29uc3RhbnRzIGZvciB0aGUgaW5zZXJ0aW9uIG1vZGUgd2UncmUgY3VycmVudGx5IHdyaXRpbmcgaW4uIFdlIGRvbid0IGVuY29kZSBhbGwgSFRNTDUgaW5zZXJ0aW9uXG4vLyBtb2Rlcy4gV2Ugb25seSBpbmNsdWRlIHRoZSB2YXJpYW50cyBhcyB0aGV5IG1hdHRlciBmb3IgdGhlIHNha2Ugb2Ygb3VyIHB1cnBvc2VzLlxuLy8gV2UgZG9uJ3QgYWN0dWFsbHkgcHJvdmlkZSB0aGUgbmFtZXNwYWNlIHRoZXJlZm9yZSB3ZSB1c2UgY29uc3RhbnRzIGluc3RlYWQgb2YgdGhlIHN0cmluZy5cblxudmFyIFJPT1RfSFRNTF9NT0RFID0gMDsgLy8gVXNlZCBmb3IgdGhlIHJvb3QgbW9zdCBlbGVtZW50IHRhZy5cbi8vIFdlIGhhdmUgYSBsZXNzIHRoYW4gSFRNTF9IVE1MX01PREUgY2hlY2sgZWxzZXdoZXJlLiBJZiB5b3UgYWRkIG1vcmUgY2FzZXMgaGVyZSwgbWFrZSBzdXJlIGl0XG4vLyBzdGlsbCBtYWtlcyBzZW5zZVxuXG52YXIgSFRNTF9IVE1MX01PREUgPSAxOyAvLyBVc2VkIGZvciB0aGUgPGh0bWw+IGlmIGl0IGlzIGF0IHRoZSB0b3AgbGV2ZWwuXG5cbnZhciBIVE1MX01PREUgPSAyO1xudmFyIFNWR19NT0RFID0gMztcbnZhciBNQVRITUxfTU9ERSA9IDQ7XG52YXIgSFRNTF9UQUJMRV9NT0RFID0gNTtcbnZhciBIVE1MX1RBQkxFX0JPRFlfTU9ERSA9IDY7XG52YXIgSFRNTF9UQUJMRV9ST1dfTU9ERSA9IDc7XG52YXIgSFRNTF9DT0xHUk9VUF9NT0RFID0gODsgLy8gV2UgaGF2ZSBhIGdyZWF0ZXIgdGhhbiBIVE1MX1RBQkxFX01PREUgY2hlY2sgZWxzZXdoZXJlLiBJZiB5b3UgYWRkIG1vcmUgY2FzZXMgaGVyZSwgbWFrZSBzdXJlIGl0XG4vLyBzdGlsbCBtYWtlcyBzZW5zZVxuLy8gTGV0cyB1cyBrZWVwIHRyYWNrIG9mIGNvbnRleHR1YWwgc3RhdGUgYW5kIHBpY2sgaXQgYmFjayB1cCBhZnRlciBzdXNwZW5kaW5nLlxuXG5mdW5jdGlvbiBjcmVhdGVGb3JtYXRDb250ZXh0KGluc2VydGlvbk1vZGUsIHNlbGVjdGVkVmFsdWUsIG5vc2NyaXB0VGFnSW5TY29wZSkge1xuICByZXR1cm4ge1xuICAgIGluc2VydGlvbk1vZGU6IGluc2VydGlvbk1vZGUsXG4gICAgc2VsZWN0ZWRWYWx1ZTogc2VsZWN0ZWRWYWx1ZSxcbiAgICBub3NjcmlwdFRhZ0luU2NvcGU6IG5vc2NyaXB0VGFnSW5TY29wZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q2hpbGRGb3JtYXRDb250ZXh0KHBhcmVudENvbnRleHQsIHR5cGUsIHByb3BzKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ25vc2NyaXB0JzpcbiAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfTU9ERSwgbnVsbCwgdHJ1ZSk7XG5cbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9NT0RFLCBwcm9wcy52YWx1ZSAhPSBudWxsID8gcHJvcHMudmFsdWUgOiBwcm9wcy5kZWZhdWx0VmFsdWUsIHBhcmVudENvbnRleHQubm9zY3JpcHRUYWdJblNjb3BlKTtcblxuICAgIGNhc2UgJ3N2Zyc6XG4gICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChTVkdfTU9ERSwgbnVsbCwgcGFyZW50Q29udGV4dC5ub3NjcmlwdFRhZ0luU2NvcGUpO1xuXG4gICAgY2FzZSAnbWF0aCc6XG4gICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChNQVRITUxfTU9ERSwgbnVsbCwgcGFyZW50Q29udGV4dC5ub3NjcmlwdFRhZ0luU2NvcGUpO1xuXG4gICAgY2FzZSAnZm9yZWlnbk9iamVjdCc6XG4gICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX01PREUsIG51bGwsIHBhcmVudENvbnRleHQubm9zY3JpcHRUYWdJblNjb3BlKTtcbiAgICAvLyBUYWJsZSBwYXJlbnRzIGFyZSBzcGVjaWFsIGluIHRoYXQgdGhlaXIgY2hpbGRyZW4gY2FuIG9ubHkgYmUgY3JlYXRlZCBhdCBhbGwgaWYgdGhleSdyZVxuICAgIC8vIHdyYXBwZWQgaW4gYSB0YWJsZSBwYXJlbnQuIFNvIHdlIG5lZWQgdG8gZW5jb2RlIHRoYXQgd2UncmUgZW50ZXJpbmcgdGhpcyBtb2RlLlxuXG4gICAgY2FzZSAndGFibGUnOlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9UQUJMRV9NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0Lm5vc2NyaXB0VGFnSW5TY29wZSk7XG5cbiAgICBjYXNlICd0aGVhZCc6XG4gICAgY2FzZSAndGJvZHknOlxuICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfVEFCTEVfQk9EWV9NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0Lm5vc2NyaXB0VGFnSW5TY29wZSk7XG5cbiAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX0NPTEdST1VQX01PREUsIG51bGwsIHBhcmVudENvbnRleHQubm9zY3JpcHRUYWdJblNjb3BlKTtcblxuICAgIGNhc2UgJ3RyJzpcbiAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfVEFCTEVfUk9XX01PREUsIG51bGwsIHBhcmVudENvbnRleHQubm9zY3JpcHRUYWdJblNjb3BlKTtcbiAgfVxuXG4gIGlmIChwYXJlbnRDb250ZXh0Lmluc2VydGlvbk1vZGUgPj0gSFRNTF9UQUJMRV9NT0RFKSB7XG4gICAgLy8gV2hhdGV2ZXIgdGFnIHRoaXMgd2FzLCBpdCB3YXNuJ3QgYSB0YWJsZSBwYXJlbnQgb3Igb3RoZXIgc3BlY2lhbCBwYXJlbnQsIHNvIHdlIG11c3QgaGF2ZVxuICAgIC8vIGVudGVyZWQgcGxhaW4gSFRNTCBhZ2Fpbi5cbiAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX01PREUsIG51bGwsIHBhcmVudENvbnRleHQubm9zY3JpcHRUYWdJblNjb3BlKTtcbiAgfVxuXG4gIGlmIChwYXJlbnRDb250ZXh0Lmluc2VydGlvbk1vZGUgPT09IFJPT1RfSFRNTF9NT0RFKSB7XG4gICAgaWYgKHR5cGUgPT09ICdodG1sJykge1xuICAgICAgLy8gV2UndmUgZW1pdHRlZCB0aGUgcm9vdCBhbmQgaXMgbm93IGluIDxodG1sPiBtb2RlLlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9IVE1MX01PREUsIG51bGwsIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2UndmUgZW1pdHRlZCB0aGUgcm9vdCBhbmQgaXMgbm93IGluIHBsYWluIEhUTUwgbW9kZS5cbiAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfTU9ERSwgbnVsbCwgZmFsc2UpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChwYXJlbnRDb250ZXh0Lmluc2VydGlvbk1vZGUgPT09IEhUTUxfSFRNTF9NT0RFKSB7XG4gICAgLy8gV2UndmUgZW1pdHRlZCB0aGUgZG9jdW1lbnQgZWxlbWVudCBhbmQgaXMgbm93IGluIHBsYWluIEhUTUwgbW9kZS5cbiAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX01PREUsIG51bGwsIGZhbHNlKTtcbiAgfVxuXG4gIHJldHVybiBwYXJlbnRDb250ZXh0O1xufVxudmFyIFVOSU5JVElBTElaRURfU1VTUEVOU0VfQk9VTkRBUllfSUQgPSBudWxsO1xuZnVuY3Rpb24gYXNzaWduU3VzcGVuc2VCb3VuZGFyeUlEKHJlc3BvbnNlU3RhdGUpIHtcbiAgdmFyIGdlbmVyYXRlZElEID0gcmVzcG9uc2VTdGF0ZS5uZXh0U3VzcGVuc2VJRCsrO1xuICByZXR1cm4gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKHJlc3BvbnNlU3RhdGUuYm91bmRhcnlQcmVmaXggKyBnZW5lcmF0ZWRJRC50b1N0cmluZygxNikpO1xufVxuZnVuY3Rpb24gbWFrZUlkKHJlc3BvbnNlU3RhdGUsIHRyZWVJZCwgbG9jYWxJZCkge1xuICB2YXIgaWRQcmVmaXggPSByZXNwb25zZVN0YXRlLmlkUHJlZml4O1xuICB2YXIgaWQgPSAnOicgKyBpZFByZWZpeCArICdSJyArIHRyZWVJZDsgLy8gVW5sZXNzIHRoaXMgaXMgdGhlIGZpcnN0IGlkIGF0IHRoaXMgbGV2ZWwsIGFwcGVuZCBhIG51bWJlciBhdCB0aGUgZW5kXG4gIC8vIHRoYXQgcmVwcmVzZW50cyB0aGUgcG9zaXRpb24gb2YgdGhpcyB1c2VJZCBob29rIGFtb25nIGFsbCB0aGUgdXNlSWRcbiAgLy8gaG9va3MgZm9yIHRoaXMgZmliZXIuXG5cbiAgaWYgKGxvY2FsSWQgPiAwKSB7XG4gICAgaWQgKz0gJ0gnICsgbG9jYWxJZC50b1N0cmluZygzMik7XG4gIH1cblxuICByZXR1cm4gaWQgKyAnOic7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUhUTUxUZXh0Tm9kZSh0ZXh0KSB7XG4gIHJldHVybiBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0ZXh0KTtcbn1cblxudmFyIHRleHRTZXBhcmF0b3IgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwhLS0gLS0+Jyk7XG5mdW5jdGlvbiBwdXNoVGV4dEluc3RhbmNlJDEodGFyZ2V0LCB0ZXh0LCByZXNwb25zZVN0YXRlLCB0ZXh0RW1iZWRkZWQpIHtcbiAgaWYgKHRleHQgPT09ICcnKSB7XG4gICAgLy8gRW1wdHkgdGV4dCBkb2Vzbid0IGhhdmUgYSBET00gbm9kZSByZXByZXNlbnRhdGlvbiBhbmQgdGhlIGh5ZHJhdGlvbiBpcyBhd2FyZSBvZiB0aGlzLlxuICAgIHJldHVybiB0ZXh0RW1iZWRkZWQ7XG4gIH1cblxuICBpZiAodGV4dEVtYmVkZGVkKSB7XG4gICAgdGFyZ2V0LnB1c2godGV4dFNlcGFyYXRvcik7XG4gIH1cblxuICB0YXJnZXQucHVzaChzdHJpbmdUb0NodW5rKGVuY29kZUhUTUxUZXh0Tm9kZSh0ZXh0KSkpO1xuICByZXR1cm4gdHJ1ZTtcbn0gLy8gQ2FsbGVkIHdoZW4gRml6eiBpcyBkb25lIHdpdGggYSBTZWdtZW50LiBDdXJyZW50bHkgdGhlIG9ubHkgcHVycG9zZSBpcyB0byBjb25kaXRpb25hbGx5XG4vLyBlbWl0IGEgdGV4dCBzZXBhcmF0b3Igd2hlbiB3ZSBkb24ndCBrbm93IGZvciBzdXJlIGl0IGlzIHNhZmUgdG8gb21pdFxuXG5mdW5jdGlvbiBwdXNoU2VnbWVudEZpbmFsZSQxKHRhcmdldCwgcmVzcG9uc2VTdGF0ZSwgbGFzdFB1c2hlZFRleHQsIHRleHRFbWJlZGRlZCkge1xuICBpZiAobGFzdFB1c2hlZFRleHQgJiYgdGV4dEVtYmVkZGVkKSB7XG4gICAgdGFyZ2V0LnB1c2godGV4dFNlcGFyYXRvcik7XG4gIH1cbn1cbnZhciBzdHlsZU5hbWVDYWNoZSA9IG5ldyBNYXAoKTtcblxuZnVuY3Rpb24gcHJvY2Vzc1N0eWxlTmFtZShzdHlsZU5hbWUpIHtcbiAgdmFyIGNodW5rID0gc3R5bGVOYW1lQ2FjaGUuZ2V0KHN0eWxlTmFtZSk7XG5cbiAgaWYgKGNodW5rICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY2h1bms7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGh5cGhlbmF0ZVN0eWxlTmFtZShzdHlsZU5hbWUpKSk7XG4gIHN0eWxlTmFtZUNhY2hlLnNldChzdHlsZU5hbWUsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBzdHlsZUF0dHJpYnV0ZVN0YXJ0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgc3R5bGU9XCInKTtcbnZhciBzdHlsZUFzc2lnbiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnOicpO1xudmFyIHN0eWxlU2VwYXJhdG9yID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc7Jyk7XG5cbmZ1bmN0aW9uIHB1c2hTdHlsZUF0dHJpYnV0ZSh0YXJnZXQsIHN0eWxlKSB7XG4gIGlmICh0eXBlb2Ygc3R5bGUgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsICcgKyBcIm5vdCBhIHN0cmluZy4gRm9yIGV4YW1wbGUsIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IHNwYWNpbmcgKyAnZW0nfX0gd2hlbiBcIiArICd1c2luZyBKU1guJyk7XG4gIH1cblxuICB2YXIgaXNGaXJzdCA9IHRydWU7XG5cbiAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHN0eWxlLCBzdHlsZU5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIElmIHlvdSBwcm92aWRlIHVuc2FmZSB1c2VyIGRhdGEgaGVyZSB0aGV5IGNhbiBpbmplY3QgYXJiaXRyYXJ5IENTU1xuICAgIC8vIHdoaWNoIG1heSBiZSBwcm9ibGVtYXRpYyAoSSBjb3VsZG4ndCByZXBybyB0aGlzKTpcbiAgICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldFxuICAgIC8vIGh0dHA6Ly93d3cudGhlc3Bhbm5lci5jby51ay8yMDA3LzExLzI2L3VsdGltYXRlLXhzcy1jc3MtaW5qZWN0aW9uL1xuICAgIC8vIFRoaXMgaXMgbm90IGFuIFhTUyBob2xlIGJ1dCBpbnN0ZWFkIGEgcG90ZW50aWFsIENTUyBpbmplY3Rpb24gaXNzdWVcbiAgICAvLyB3aGljaCBoYXMgbGVhZCB0byBhIGdyZWF0ZXIgZGlzY3Vzc2lvbiBhYm91dCBob3cgd2UncmUgZ29pbmcgdG9cbiAgICAvLyB0cnVzdCBVUkxzIG1vdmluZyBmb3J3YXJkLiBTZWUgIzIxMTU5MDFcblxuXG4gICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZVtzdHlsZU5hbWVdO1xuXG4gICAgaWYgKHN0eWxlVmFsdWUgPT0gbnVsbCB8fCB0eXBlb2Ygc3R5bGVWYWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHN0eWxlVmFsdWUgPT09ICcnKSB7XG4gICAgICAvLyBUT0RPOiBXZSB1c2VkIHRvIHNldCBlbXB0eSBzdHJpbmcgYXMgYSBzdHlsZSB3aXRoIGFuIGVtcHR5IHZhbHVlLiBEb2VzIHRoYXQgZXZlciBtYWtlIHNlbnNlP1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIG5hbWVDaHVuayA9IHZvaWQgMDtcbiAgICB2YXIgdmFsdWVDaHVuayA9IHZvaWQgMDtcbiAgICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuXG4gICAgaWYgKGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgIG5hbWVDaHVuayA9IHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoc3R5bGVOYW1lKSk7XG5cbiAgICAgIHtcbiAgICAgICAgY2hlY2tDU1NQcm9wZXJ0eVN0cmluZ0NvZXJjaW9uKHN0eWxlVmFsdWUsIHN0eWxlTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlQ2h1bmsgPSBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKCgnJyArIHN0eWxlVmFsdWUpLnRyaW0oKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5WYWxpZFN0eWxlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIG5hbWVDaHVuayA9IHByb2Nlc3NTdHlsZU5hbWUoc3R5bGVOYW1lKTtcblxuICAgICAgaWYgKHR5cGVvZiBzdHlsZVZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoc3R5bGVWYWx1ZSAhPT0gMCAmJiAhaXNVbml0bGVzc051bWJlcihzdHlsZU5hbWUpKSB7XG4gICAgICAgICAgdmFsdWVDaHVuayA9IHN0cmluZ1RvQ2h1bmsoc3R5bGVWYWx1ZSArICdweCcpOyAvLyBQcmVzdW1lcyBpbXBsaWNpdCAncHgnIHN1ZmZpeCBmb3IgdW5pdGxlc3MgbnVtYmVyc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlQ2h1bmsgPSBzdHJpbmdUb0NodW5rKCcnICsgc3R5bGVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24oc3R5bGVWYWx1ZSwgc3R5bGVOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlQ2h1bmsgPSBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKCgnJyArIHN0eWxlVmFsdWUpLnRyaW0oKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICBpc0ZpcnN0ID0gZmFsc2U7IC8vIElmIGl0J3MgZmlyc3QsIHdlIGRvbid0IG5lZWQgYW55IHNlcGFyYXRvcnMgcHJlZml4ZWQuXG5cbiAgICAgIHRhcmdldC5wdXNoKHN0eWxlQXR0cmlidXRlU3RhcnQsIG5hbWVDaHVuaywgc3R5bGVBc3NpZ24sIHZhbHVlQ2h1bmspO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQucHVzaChzdHlsZVNlcGFyYXRvciwgbmFtZUNodW5rLCBzdHlsZUFzc2lnbiwgdmFsdWVDaHVuayk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFpc0ZpcnN0KSB7XG4gICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlRW5kKTtcbiAgfVxufVxuXG52YXIgYXR0cmlidXRlU2VwYXJhdG9yID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgJyk7XG52YXIgYXR0cmlidXRlQXNzaWduID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc9XCInKTtcbnZhciBhdHRyaWJ1dGVFbmQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiJyk7XG52YXIgYXR0cmlidXRlRW1wdHlTdHJpbmcgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJz1cIlwiJyk7XG5cbmZ1bmN0aW9uIHB1c2hCb29sZWFuQXR0cmlidXRlKHRhcmdldCwgbmFtZSwgdmFsdWUpIC8vIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxue1xuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N5bWJvbCcpIHtcbiAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIHN0cmluZ1RvQ2h1bmsobmFtZSksIGF0dHJpYnV0ZUVtcHR5U3RyaW5nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgbmFtZSwgdmFsdWUpIC8vIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxue1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N5bWJvbCcgJiYgdHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHtcbiAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIHN0cmluZ1RvQ2h1bmsobmFtZSksIGF0dHJpYnV0ZUFzc2lnbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSkpLCBhdHRyaWJ1dGVFbmQpO1xuICB9XG59XG4vLyB0aGFuIG9uIHRoZSBjbGllbnQgYW5kIGhvcGVmdWxseSBpdCdzIGdvb2dsZWFibGUuXG5cblxuc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2NyaXB0LXVybFxuXCJqYXZhc2NyaXB0OnRocm93IG5ldyBFcnJvcignQSBSZWFjdCBmb3JtIHdhcyB1bmV4cGVjdGVkbHkgc3VibWl0dGVkLicpXCIpKTtcbnZhciBzdGFydEhpZGRlbklucHV0Q2h1bmsgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxpbnB1dCB0eXBlPVwiaGlkZGVuXCInKTtcblxuZnVuY3Rpb24gcHVzaEFkZGl0aW9uYWxGb3JtRmllbGQodmFsdWUsIGtleSkge1xuICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgdGFyZ2V0LnB1c2goc3RhcnRIaWRkZW5JbnB1dENodW5rKTtcblxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRmlsZS9CbG9iIGZpZWxkcyBhcmUgbm90IHlldCBzdXBwb3J0ZWQgaW4gcHJvZ3Jlc3NpdmUgZm9ybXMuICcgKyAnSXQgcHJvYmFibHkgbWVhbnMgeW91IGFyZSBjbG9zaW5nIG92ZXIgYmluYXJ5IGRhdGEgb3IgRm9ybURhdGEgaW4gYSBTZXJ2ZXIgQWN0aW9uLicpO1xuICB9XG5cbiAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsICduYW1lJywga2V5KTtcbiAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsICd2YWx1ZScsIHZhbHVlKTtcbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nKTtcbn1cblxuZnVuY3Rpb24gcHVzaEFkZGl0aW9uYWxGb3JtRmllbGRzKHRhcmdldCwgZm9ybURhdGEpIHtcbiAgaWYgKGZvcm1EYXRhICE9PSBudWxsKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddOiBGb3JtRGF0YSBoYXMgZm9yRWFjaC5cbiAgICBmb3JtRGF0YS5mb3JFYWNoKHB1c2hBZGRpdGlvbmFsRm9ybUZpZWxkLCB0YXJnZXQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hGb3JtQWN0aW9uQXR0cmlidXRlKHRhcmdldCwgcmVzcG9uc2VTdGF0ZSwgZm9ybUFjdGlvbiwgZm9ybUVuY1R5cGUsIGZvcm1NZXRob2QsIGZvcm1UYXJnZXQsIG5hbWUpIHtcbiAgdmFyIGZvcm1EYXRhID0gbnVsbDtcblxuICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsICduYW1lJywgbmFtZSk7XG4gIH1cblxuICBpZiAoZm9ybUFjdGlvbiAhPSBudWxsKSB7XG4gICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsICdmb3JtQWN0aW9uJywgZm9ybUFjdGlvbik7XG4gIH1cblxuICBpZiAoZm9ybUVuY1R5cGUgIT0gbnVsbCkge1xuICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCAnZm9ybUVuY1R5cGUnLCBmb3JtRW5jVHlwZSk7XG4gIH1cblxuICBpZiAoZm9ybU1ldGhvZCAhPSBudWxsKSB7XG4gICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsICdmb3JtTWV0aG9kJywgZm9ybU1ldGhvZCk7XG4gIH1cblxuICBpZiAoZm9ybVRhcmdldCAhPSBudWxsKSB7XG4gICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsICdmb3JtVGFyZ2V0JywgZm9ybVRhcmdldCk7XG4gIH1cblxuICByZXR1cm4gZm9ybURhdGE7XG59XG5cbmZ1bmN0aW9uIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBuYW1lLCB2YWx1ZSkgLy8gbm90IG51bGwgb3IgdW5kZWZpbmVkXG57XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIC8vIFRoZXNlIGFyZSB2ZXJ5IGNvbW1vbiBwcm9wcyBhbmQgdGhlcmVmb3JlIGFyZSBpbiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzd2l0Y2guXG4gICAgLy8gVE9ETzogYXJpYS1sYWJlbCBpcyBhIHZlcnkgY29tbW9uIHByb3AgYnV0IGFsbG93cyBib29sZWFucyBzbyBpcyBub3QgbGlrZSB0aGUgb3RoZXJzXG4gICAgLy8gYnV0IHNob3VsZCBpZGVhbGx5IGdvIGluIHRoaXMgbGlzdCB0b28uXG4gICAgY2FzZSAnY2xhc3NOYW1lJzpcbiAgICAgIHtcbiAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsICdjbGFzcycsIHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICd0YWJJbmRleCc6XG4gICAgICB7XG4gICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAndGFiaW5kZXgnLCB2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZGlyJzpcbiAgICBjYXNlICdyb2xlJzpcbiAgICBjYXNlICd2aWV3Qm94JzpcbiAgICBjYXNlICd3aWR0aCc6XG4gICAgY2FzZSAnaGVpZ2h0JzpcbiAgICAgIHtcbiAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdzdHlsZSc6XG4gICAgICB7XG4gICAgICAgIHB1c2hTdHlsZUF0dHJpYnV0ZSh0YXJnZXQsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSAnc3JjJzpcbiAgICBjYXNlICdocmVmJzpcbiAgICAvLyBGYWxsIHRocm91Z2ggdG8gdGhlIGxhc3QgY2FzZSB3aGljaCBzaG91bGRuJ3QgcmVtb3ZlIGVtcHR5IHN0cmluZ3MuXG5cbiAgICBjYXNlICdhY3Rpb24nOlxuICAgIGNhc2UgJ2Zvcm1BY3Rpb24nOlxuICAgICAge1xuICAgICAgICAvLyBUT0RPOiBDb25zaWRlciBvbmx5IHNwZWNpYWwgY2FzaW5nIHRoZXNlIGZvciBlYWNoIHRhZy5cbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgbmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2FuaXRpemVkVmFsdWUgPSBzYW5pdGl6ZVVSTCgnJyArIHZhbHVlKTtcbiAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBzdHJpbmdUb0NodW5rKG5hbWUpLCBhdHRyaWJ1dGVBc3NpZ24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoc2FuaXRpemVkVmFsdWUpKSwgYXR0cmlidXRlRW5kKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZGVmYXVsdFZhbHVlJzpcbiAgICBjYXNlICdkZWZhdWx0Q2hlY2tlZCc6IC8vIFRoZXNlIHNob3VsZG4ndCBiZSBzZXQgYXMgYXR0cmlidXRlcyBvbiBnZW5lcmljIEhUTUwgZWxlbWVudHMuXG5cbiAgICBjYXNlICdpbm5lckhUTUwnOiAvLyBNdXN0IHVzZSBkYW5nZXJvdXNseVNldElubmVySFRNTCBpbnN0ZWFkLlxuXG4gICAgY2FzZSAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJzpcbiAgICBjYXNlICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnOlxuICAgICAgLy8gSWdub3JlZC4gVGhlc2UgYXJlIGJ1aWx0LWluIHRvIFJlYWN0IG9uIHRoZSBjbGllbnQuXG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICdhdXRvRm9jdXMnOlxuICAgIGNhc2UgJ211bHRpcGxlJzpcbiAgICBjYXNlICdtdXRlZCc6XG4gICAgICB7XG4gICAgICAgIHB1c2hCb29sZWFuQXR0cmlidXRlKHRhcmdldCwgbmFtZS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3hsaW5rSHJlZic6XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfc2FuaXRpemVkVmFsdWUgPSBzYW5pdGl6ZVVSTCgnJyArIHZhbHVlKTtcblxuICAgICAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIHN0cmluZ1RvQ2h1bmsoJ3hsaW5rOmhyZWYnKSwgYXR0cmlidXRlQXNzaWduLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKF9zYW5pdGl6ZWRWYWx1ZSkpLCBhdHRyaWJ1dGVFbmQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlICdjb250ZW50RWRpdGFibGUnOlxuICAgIGNhc2UgJ3NwZWxsQ2hlY2snOlxuICAgIGNhc2UgJ2RyYWdnYWJsZSc6XG4gICAgY2FzZSAndmFsdWUnOlxuICAgIGNhc2UgJ2F1dG9SZXZlcnNlJzpcbiAgICBjYXNlICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJzpcbiAgICBjYXNlICdmb2N1c2FibGUnOlxuICAgIGNhc2UgJ3ByZXNlcnZlQWxwaGEnOlxuICAgICAge1xuICAgICAgICAvLyBCb29sZWFuaXNoIFN0cmluZ1xuICAgICAgICAvLyBUaGVzZSBhcmUgXCJlbnVtZXJhdGVkXCIgYXR0cmlidXRlcyB0aGF0IGFjY2VwdCBcInRydWVcIiBhbmQgXCJmYWxzZVwiLlxuICAgICAgICAvLyBJbiBSZWFjdCwgd2UgbGV0IHVzZXJzIHBhc3MgYHRydWVgIGFuZCBgZmFsc2VgIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5XG4gICAgICAgIC8vIHRoZXNlIGFyZW4ndCBib29sZWFuIGF0dHJpYnV0ZXMgKHRoZXkgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncykuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3ltYm9sJykge1xuICAgICAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuayhuYW1lKSwgYXR0cmlidXRlQXNzaWduLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSksIGF0dHJpYnV0ZUVuZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlICdhbGxvd0Z1bGxTY3JlZW4nOlxuICAgIGNhc2UgJ2FzeW5jJzpcbiAgICBjYXNlICdhdXRvUGxheSc6XG4gICAgY2FzZSAnY29udHJvbHMnOlxuICAgIGNhc2UgJ2RlZmF1bHQnOlxuICAgIGNhc2UgJ2RlZmVyJzpcbiAgICBjYXNlICdkaXNhYmxlZCc6XG4gICAgY2FzZSAnZGlzYWJsZVBpY3R1cmVJblBpY3R1cmUnOlxuICAgIGNhc2UgJ2Rpc2FibGVSZW1vdGVQbGF5YmFjayc6XG4gICAgY2FzZSAnZm9ybU5vVmFsaWRhdGUnOlxuICAgIGNhc2UgJ2hpZGRlbic6XG4gICAgY2FzZSAnbG9vcCc6XG4gICAgY2FzZSAnbm9Nb2R1bGUnOlxuICAgIGNhc2UgJ25vVmFsaWRhdGUnOlxuICAgIGNhc2UgJ29wZW4nOlxuICAgIGNhc2UgJ3BsYXlzSW5saW5lJzpcbiAgICBjYXNlICdyZWFkT25seSc6XG4gICAgY2FzZSAncmVxdWlyZWQnOlxuICAgIGNhc2UgJ3JldmVyc2VkJzpcbiAgICBjYXNlICdzY29wZWQnOlxuICAgIGNhc2UgJ3NlYW1sZXNzJzpcbiAgICBjYXNlICdpdGVtU2NvcGUnOlxuICAgICAge1xuICAgICAgICAvLyBCb29sZWFuXG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3ltYm9sJykge1xuICAgICAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuayhuYW1lKSwgYXR0cmlidXRlRW1wdHlTdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSAnY2FwdHVyZSc6XG4gICAgY2FzZSAnZG93bmxvYWQnOlxuICAgICAge1xuICAgICAgICAvLyBPdmVybG9hZGVkIEJvb2xlYW5cbiAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBzdHJpbmdUb0NodW5rKG5hbWUpLCBhdHRyaWJ1dGVFbXB0eVN0cmluZyk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IGZhbHNlKSA7IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBzdHJpbmdUb0NodW5rKG5hbWUpLCBhdHRyaWJ1dGVBc3NpZ24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpKSwgYXR0cmlidXRlRW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgJ2NvbHMnOlxuICAgIGNhc2UgJ3Jvd3MnOlxuICAgIGNhc2UgJ3NpemUnOlxuICAgIGNhc2UgJ3NwYW4nOlxuICAgICAge1xuICAgICAgICAvLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgbXVzdCBiZSBwb3NpdGl2ZSBudW1iZXJzLlxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N5bWJvbCcgJiYgIWlzTmFOKHZhbHVlKSAmJiB2YWx1ZSA+PSAxKSB7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBzdHJpbmdUb0NodW5rKG5hbWUpLCBhdHRyaWJ1dGVBc3NpZ24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpKSwgYXR0cmlidXRlRW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3Jvd1NwYW4nOlxuICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgIHtcbiAgICAgICAgLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IG11c3QgYmUgbnVtYmVycy5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdzeW1ib2wnICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIHN0cmluZ1RvQ2h1bmsobmFtZSksIGF0dHJpYnV0ZUFzc2lnbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSkpLCBhdHRyaWJ1dGVFbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSAneGxpbmtBY3R1YXRlJzpcbiAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAneGxpbms6YWN0dWF0ZScsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcblxuICAgIGNhc2UgJ3hsaW5rQXJjcm9sZSc6XG4gICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgJ3hsaW5rOmFyY3JvbGUnLCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICd4bGlua1JvbGUnOlxuICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsICd4bGluazpyb2xlJywgdmFsdWUpO1xuICAgICAgcmV0dXJuO1xuXG4gICAgY2FzZSAneGxpbmtTaG93JzpcbiAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAneGxpbms6c2hvdycsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcblxuICAgIGNhc2UgJ3hsaW5rVGl0bGUnOlxuICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsICd4bGluazp0aXRsZScsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcblxuICAgIGNhc2UgJ3hsaW5rVHlwZSc6XG4gICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgJ3hsaW5rOnR5cGUnLCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICd4bWxCYXNlJzpcbiAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAneG1sOmJhc2UnLCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICd4bWxMYW5nJzpcbiAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAneG1sOmxhbmcnLCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICd4bWxTcGFjZSc6XG4gICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgJ3htbDpzcGFjZScsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoIC8vIHNob3VsZElnbm9yZUF0dHJpYnV0ZVxuICAgICAgLy8gV2UgaGF2ZSBhbHJlYWR5IGZpbHRlcmVkIG91dCBudWxsL3VuZGVmaW5lZCBhbmQgcmVzZXJ2ZWQgd29yZHMuXG4gICAgICBuYW1lLmxlbmd0aCA+IDIgJiYgKG5hbWVbMF0gPT09ICdvJyB8fCBuYW1lWzBdID09PSAnTycpICYmIChuYW1lWzFdID09PSAnbicgfHwgbmFtZVsxXSA9PT0gJ04nKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gZ2V0QXR0cmlidXRlQWxpYXMobmFtZSk7XG5cbiAgICAgIGlmIChpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgIC8vIHNob3VsZFJlbW92ZUF0dHJpYnV0ZVxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBwcmVmaXggPSBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG5cbiAgICAgICAgICAgICAgaWYgKHByZWZpeCAhPT0gJ2RhdGEtJyAmJiBwcmVmaXggIT09ICdhcmlhLScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuayhhdHRyaWJ1dGVOYW1lKSwgYXR0cmlidXRlQXNzaWduLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSksIGF0dHJpYnV0ZUVuZCk7XG4gICAgICB9XG5cbiAgfVxufVxuXG52YXIgZW5kT2ZTdGFydFRhZyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPicpO1xudmFyIGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnLz4nKTtcblxuZnVuY3Rpb24gcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pIHtcbiAgaWYgKGlubmVySFRNTCAhPSBudWxsKSB7XG4gICAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbm5lckhUTUwgIT09ICdvYmplY3QnIHx8ICEoJ19faHRtbCcgaW4gaW5uZXJIVE1MKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiAnICsgJ1BsZWFzZSB2aXNpdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgJyArICdmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICB9XG5cbiAgICB2YXIgaHRtbCA9IGlubmVySFRNTC5fX2h0bWw7XG5cbiAgICBpZiAoaHRtbCAhPT0gbnVsbCAmJiBodG1sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oaHRtbCk7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoJycgKyBodG1sKSk7XG4gICAgfVxuICB9XG59IC8vIFRPRE86IE1vdmUgdGhlc2UgdG8gUmVzcG9uc2VTdGF0ZSBzbyB0aGF0IHdlIHdhcm4gZm9yIGV2ZXJ5IHJlcXVlc3QuXG4vLyBJdCB3b3VsZCBoZWxwIGRlYnVnZ2luZyBpbiBzdGF0ZWZ1bCBzZXJ2ZXJzIChlLmcuIHNlcnZpY2Ugd29ya2VyKS5cblxuXG52YXIgZGlkV2FybkRlZmF1bHRJbnB1dFZhbHVlID0gZmFsc2U7XG52YXIgZGlkV2FybkRlZmF1bHRDaGVja2VkID0gZmFsc2U7XG52YXIgZGlkV2FybkRlZmF1bHRTZWxlY3RWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gPSBmYWxzZTtcbnZhciBkaWRXYXJuSW52YWxpZE9wdGlvbklubmVySFRNTCA9IGZhbHNlO1xudmFyIGRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uID0gZmFsc2U7XG52YXIgZGlkV2FybkZvcm1BY3Rpb25UeXBlID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGNoZWNrU2VsZWN0UHJvcChwcm9wcywgcHJvcE5hbWUpIHtcbiAge1xuICAgIHZhciB2YWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcblxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICB2YXIgYXJyYXkgPSBpc0FycmF5KHZhbHVlKTtcblxuICAgICAgaWYgKHByb3BzLm11bHRpcGxlICYmICFhcnJheSkge1xuICAgICAgICBlcnJvcignVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGFuIGFycmF5IGlmICcgKyAnYG11bHRpcGxlYCBpcyB0cnVlLicsIHByb3BOYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoIXByb3BzLm11bHRpcGxlICYmIGFycmF5KSB7XG4gICAgICAgIGVycm9yKCdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYSBzY2FsYXIgJyArICd2YWx1ZSBpZiBgbXVsdGlwbGVgIGlzIGZhbHNlLicsIHByb3BOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaFN0YXJ0U2VsZWN0KHRhcmdldCwgcHJvcHMpIHtcbiAge1xuICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoJ3NlbGVjdCcsIHByb3BzKTtcbiAgICBjaGVja1NlbGVjdFByb3AocHJvcHMsICd2YWx1ZScpO1xuICAgIGNoZWNrU2VsZWN0UHJvcChwcm9wcywgJ2RlZmF1bHRWYWx1ZScpO1xuXG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUpIHtcbiAgICAgIGVycm9yKCdTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHNlbGVjdCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG5cbiAgICAgIGRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoJ3NlbGVjdCcpKTtcbiAgdmFyIGNoaWxkcmVuID0gbnVsbDtcbiAgdmFyIGlubmVySFRNTCA9IG51bGw7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIC8vIFRPRE86IFRoaXMgZG9lc24ndCByZWFsbHkgbWFrZSBzZW5zZSBmb3Igc2VsZWN0IHNpbmNlIGl0IGNhbid0IHVzZSB0aGUgY29udHJvbGxlZFxuICAgICAgICAgIC8vIHZhbHVlIGluIHRoZSBpbm5lckhUTUwuXG4gICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2RlZmF1bHRWYWx1ZSc6XG4gICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICAvLyBUaGVzZSBhcmUgc2V0IG9uIHRoZSBDb250ZXh0IGluc3RlYWQgYW5kIGFwcGxpZWQgdG8gdGhlIG5lc3RlZCBvcHRpb25zLlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuT3B0aW9uQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIGNvbnRlbnQgPSAnJzsgLy8gRmxhdHRlbiBjaGlsZHJlbiBhbmQgd2FybiBpZiB0aGV5IGFyZW4ndCBzdHJpbmdzIG9yIG51bWJlcnM7XG4gIC8vIGludmFsaWQgdHlwZXMgYXJlIGlnbm9yZWQuXG5cbiAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb250ZW50ICs9IGNoaWxkO1xuXG4gICAge1xuICAgICAgaWYgKCFkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuICYmIHR5cGVvZiBjaGlsZCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGNoaWxkICE9PSAnbnVtYmVyJykge1xuICAgICAgICBkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignQ2Fubm90IGluZmVyIHRoZSBvcHRpb24gdmFsdWUgb2YgY29tcGxleCBjaGlsZHJlbi4gJyArICdQYXNzIGEgYHZhbHVlYCBwcm9wIG9yIHVzZSBhIHBsYWluIHN0cmluZyBhcyBjaGlsZHJlbiB0byA8b3B0aW9uPi4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY29udGVudDtcbn1cblxudmFyIHNlbGVjdGVkTWFya2VyQXR0cmlidXRlID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgc2VsZWN0ZWQ9XCJcIicpO1xuXG5mdW5jdGlvbiBwdXNoU3RhcnRPcHRpb24odGFyZ2V0LCBwcm9wcywgZm9ybWF0Q29udGV4dCkge1xuICB2YXIgc2VsZWN0ZWRWYWx1ZSA9IGZvcm1hdENvbnRleHQuc2VsZWN0ZWRWYWx1ZTtcbiAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZygnb3B0aW9uJykpO1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICB2YXIgdmFsdWUgPSBudWxsO1xuICB2YXIgc2VsZWN0ZWQgPSBudWxsO1xuICB2YXIgaW5uZXJIVE1MID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzZWxlY3RlZCc6XG4gICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgICAgc2VsZWN0ZWQgPSBwcm9wVmFsdWU7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgc3VwcG9ydCBmb3IgYHNlbGVjdGVkYCBpbiA8b3B0aW9uPi5cbiAgICAgICAgICAgIGlmICghZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24pIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mICcgKyAnc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LicpO1xuXG4gICAgICAgICAgICAgIGRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICB2YWx1ZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgLy8gV2UgaW50ZW50aW9uYWxseSBmYWxsdGhyb3VnaCB0byBhbHNvIHNldCB0aGUgYXR0cmlidXRlIG9uIHRoZSBub2RlLlxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHNlbGVjdGVkVmFsdWUgIT0gbnVsbCkge1xuICAgIHZhciBzdHJpbmdWYWx1ZTtcblxuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCAndmFsdWUnKTtcbiAgICAgIH1cblxuICAgICAgc3RyaW5nVmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIGlmIChpbm5lckhUTUwgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoIWRpZFdhcm5JbnZhbGlkT3B0aW9uSW5uZXJIVE1MKSB7XG4gICAgICAgICAgICBkaWRXYXJuSW52YWxpZE9wdGlvbklubmVySFRNTCA9IHRydWU7XG5cbiAgICAgICAgICAgIGVycm9yKCdQYXNzIGEgYHZhbHVlYCBwcm9wIGlmIHlvdSBzZXQgZGFuZ2Vyb3VzbHlJbm5lckhUTUwgc28gUmVhY3Qga25vd3MgJyArICd3aGljaCB2YWx1ZSBzaG91bGQgYmUgc2VsZWN0ZWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0cmluZ1ZhbHVlID0gZmxhdHRlbk9wdGlvbkNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShzZWxlY3RlZFZhbHVlKSkge1xuICAgICAgLy8gbXVsdGlwbGVcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWRWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihzZWxlY3RlZFZhbHVlW2ldLCAndmFsdWUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2ID0gJycgKyBzZWxlY3RlZFZhbHVlW2ldO1xuXG4gICAgICAgIGlmICh2ID09PSBzdHJpbmdWYWx1ZSkge1xuICAgICAgICAgIHRhcmdldC5wdXNoKHNlbGVjdGVkTWFya2VyQXR0cmlidXRlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24oc2VsZWN0ZWRWYWx1ZSwgJ3NlbGVjdC52YWx1ZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoJycgKyBzZWxlY3RlZFZhbHVlID09PSBzdHJpbmdWYWx1ZSkge1xuICAgICAgICB0YXJnZXQucHVzaChzZWxlY3RlZE1hcmtlckF0dHJpYnV0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHNlbGVjdGVkKSB7XG4gICAgdGFyZ2V0LnB1c2goc2VsZWN0ZWRNYXJrZXJBdHRyaWJ1dGUpO1xuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBwdXNoU3RhcnRGb3JtKHRhcmdldCwgcHJvcHMsIHJlc3BvbnNlU3RhdGUpIHtcbiAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZygnZm9ybScpKTtcbiAgdmFyIGNoaWxkcmVuID0gbnVsbDtcbiAgdmFyIGlubmVySFRNTCA9IG51bGw7XG4gIHZhciBmb3JtQWN0aW9uID0gbnVsbDtcbiAgdmFyIGZvcm1FbmNUeXBlID0gbnVsbDtcbiAgdmFyIGZvcm1NZXRob2QgPSBudWxsO1xuICB2YXIgZm9ybVRhcmdldCA9IG51bGw7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdhY3Rpb24nOlxuICAgICAgICAgIGZvcm1BY3Rpb24gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZW5jVHlwZSc6XG4gICAgICAgICAgZm9ybUVuY1R5cGUgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbWV0aG9kJzpcbiAgICAgICAgICBmb3JtTWV0aG9kID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RhcmdldCc6XG4gICAgICAgICAgZm9ybVRhcmdldCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChmb3JtQWN0aW9uICE9IG51bGwpIHtcbiAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgJ2FjdGlvbicsIGZvcm1BY3Rpb24pO1xuICB9XG5cbiAgaWYgKGZvcm1FbmNUeXBlICE9IG51bGwpIHtcbiAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgJ2VuY1R5cGUnLCBmb3JtRW5jVHlwZSk7XG4gIH1cblxuICBpZiAoZm9ybU1ldGhvZCAhPSBudWxsKSB7XG4gICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsICdtZXRob2QnLCBmb3JtTWV0aG9kKTtcbiAgfVxuXG4gIGlmIChmb3JtVGFyZ2V0ICE9IG51bGwpIHtcbiAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgJ3RhcmdldCcsIGZvcm1UYXJnZXQpO1xuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG5cbiAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuXG4gIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlIGNoaWxkcmVuIGFzIGEgc3RyaW5nIHRvIGF2b2lkIHRoZSB1bm5lY2Vzc2FyeSBjb21tZW50LlxuICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIHNwZWNpYWwgY2FzZSBhZnRlciB0aGUgZ2VuZXJhbCBvcHRpbWl6YXRpb24gaXMgaW4gcGxhY2UuXG4gICAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlbmNvZGVIVE1MVGV4dE5vZGUoY2hpbGRyZW4pKSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIHB1c2hJbnB1dCh0YXJnZXQsIHByb3BzLCByZXNwb25zZVN0YXRlKSB7XG4gIHtcbiAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKCdpbnB1dCcsIHByb3BzKTtcbiAgfVxuXG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoJ2lucHV0JykpO1xuICB2YXIgbmFtZSA9IG51bGw7XG4gIHZhciBmb3JtQWN0aW9uID0gbnVsbDtcbiAgdmFyIGZvcm1FbmNUeXBlID0gbnVsbDtcbiAgdmFyIGZvcm1NZXRob2QgPSBudWxsO1xuICB2YXIgZm9ybVRhcmdldCA9IG51bGw7XG4gIHZhciB2YWx1ZSA9IG51bGw7XG4gIHZhciBkZWZhdWx0VmFsdWUgPSBudWxsO1xuICB2YXIgY2hlY2tlZCA9IG51bGw7XG4gIHZhciBkZWZhdWx0Q2hlY2tlZCA9IG51bGw7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0JyArIFwiIGlzIGEgc2VsZi1jbG9zaW5nIHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgXCIgKyAndXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG5cbiAgICAgICAgY2FzZSAnbmFtZSc6XG4gICAgICAgICAgbmFtZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmb3JtQWN0aW9uJzpcbiAgICAgICAgICBmb3JtQWN0aW9uID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Zvcm1FbmNUeXBlJzpcbiAgICAgICAgICBmb3JtRW5jVHlwZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmb3JtTWV0aG9kJzpcbiAgICAgICAgICBmb3JtTWV0aG9kID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Zvcm1UYXJnZXQnOlxuICAgICAgICAgIGZvcm1UYXJnZXQgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGVmYXVsdENoZWNrZWQnOlxuICAgICAgICAgIGRlZmF1bHRDaGVja2VkID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2RlZmF1bHRWYWx1ZSc6XG4gICAgICAgICAgZGVmYXVsdFZhbHVlID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuICAgICAgICAgIGNoZWNrZWQgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgIHZhbHVlID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmIChmb3JtQWN0aW9uICE9PSBudWxsICYmIHByb3BzLnR5cGUgIT09ICdpbWFnZScgJiYgcHJvcHMudHlwZSAhPT0gJ3N1Ym1pdCcgJiYgIWRpZFdhcm5Gb3JtQWN0aW9uVHlwZSkge1xuICAgICAgZGlkV2FybkZvcm1BY3Rpb25UeXBlID0gdHJ1ZTtcblxuICAgICAgZXJyb3IoJ0FuIGlucHV0IGNhbiBvbmx5IHNwZWNpZnkgYSBmb3JtQWN0aW9uIGFsb25nIHdpdGggdHlwZT1cInN1Ym1pdFwiIG9yIHR5cGU9XCJpbWFnZVwiLicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmb3JtRGF0YSA9IHB1c2hGb3JtQWN0aW9uQXR0cmlidXRlKHRhcmdldCwgcmVzcG9uc2VTdGF0ZSwgZm9ybUFjdGlvbiwgZm9ybUVuY1R5cGUsIGZvcm1NZXRob2QsIGZvcm1UYXJnZXQsIG5hbWUpO1xuXG4gIHtcbiAgICBpZiAoY2hlY2tlZCAhPT0gbnVsbCAmJiBkZWZhdWx0Q2hlY2tlZCAhPT0gbnVsbCAmJiAhZGlkV2FybkRlZmF1bHRDaGVja2VkKSB7XG4gICAgICBlcnJvcignJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggY2hlY2tlZCBhbmQgZGVmYXVsdENoZWNrZWQgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIGNoZWNrZWQgcHJvcCwgb3IgdGhlIGRlZmF1bHRDaGVja2VkIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJywgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG5cbiAgICAgIGRpZFdhcm5EZWZhdWx0Q2hlY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmIGRlZmF1bHRWYWx1ZSAhPT0gbnVsbCAmJiAhZGlkV2FybkRlZmF1bHRJbnB1dFZhbHVlKSB7XG4gICAgICBlcnJvcignJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggdmFsdWUgYW5kIGRlZmF1bHRWYWx1ZSBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycsICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpO1xuXG4gICAgICBkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjaGVja2VkICE9PSBudWxsKSB7XG4gICAgcHVzaEJvb2xlYW5BdHRyaWJ1dGUodGFyZ2V0LCAnY2hlY2tlZCcsIGNoZWNrZWQpO1xuICB9IGVsc2UgaWYgKGRlZmF1bHRDaGVja2VkICE9PSBudWxsKSB7XG4gICAgcHVzaEJvb2xlYW5BdHRyaWJ1dGUodGFyZ2V0LCAnY2hlY2tlZCcsIGRlZmF1bHRDaGVja2VkKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCAndmFsdWUnLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZGVmYXVsdFZhbHVlICE9PSBudWxsKSB7XG4gICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsICd2YWx1ZScsIGRlZmF1bHRWYWx1ZSk7XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmcpOyAvLyBXZSBwbGFjZSBhbnkgYWRkaXRpb25hbCBoaWRkZW4gZm9ybSBmaWVsZHMgYWZ0ZXIgdGhlIGlucHV0LlxuXG4gIHB1c2hBZGRpdGlvbmFsRm9ybUZpZWxkcyh0YXJnZXQsIGZvcm1EYXRhKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHB1c2hTdGFydEJ1dHRvbih0YXJnZXQsIHByb3BzLCByZXNwb25zZVN0YXRlKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoJ2J1dHRvbicpKTtcbiAgdmFyIGNoaWxkcmVuID0gbnVsbDtcbiAgdmFyIGlubmVySFRNTCA9IG51bGw7XG4gIHZhciBuYW1lID0gbnVsbDtcbiAgdmFyIGZvcm1BY3Rpb24gPSBudWxsO1xuICB2YXIgZm9ybUVuY1R5cGUgPSBudWxsO1xuICB2YXIgZm9ybU1ldGhvZCA9IG51bGw7XG4gIHZhciBmb3JtVGFyZ2V0ID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ25hbWUnOlxuICAgICAgICAgIG5hbWUgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZm9ybUFjdGlvbic6XG4gICAgICAgICAgZm9ybUFjdGlvbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmb3JtRW5jVHlwZSc6XG4gICAgICAgICAgZm9ybUVuY1R5cGUgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZm9ybU1ldGhvZCc6XG4gICAgICAgICAgZm9ybU1ldGhvZCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmb3JtVGFyZ2V0JzpcbiAgICAgICAgICBmb3JtVGFyZ2V0ID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmIChmb3JtQWN0aW9uICE9PSBudWxsICYmIHByb3BzLnR5cGUgIT0gbnVsbCAmJiBwcm9wcy50eXBlICE9PSAnc3VibWl0JyAmJiAhZGlkV2FybkZvcm1BY3Rpb25UeXBlKSB7XG4gICAgICBkaWRXYXJuRm9ybUFjdGlvblR5cGUgPSB0cnVlO1xuXG4gICAgICBlcnJvcignQSBidXR0b24gY2FuIG9ubHkgc3BlY2lmeSBhIGZvcm1BY3Rpb24gYWxvbmcgd2l0aCB0eXBlPVwic3VibWl0XCIgb3Igbm8gdHlwZS4nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZm9ybURhdGEgPSBwdXNoRm9ybUFjdGlvbkF0dHJpYnV0ZSh0YXJnZXQsIHJlc3BvbnNlU3RhdGUsIGZvcm1BY3Rpb24sIGZvcm1FbmNUeXBlLCBmb3JtTWV0aG9kLCBmb3JtVGFyZ2V0LCBuYW1lKTtcbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7IC8vIFdlIHBsYWNlIGFueSBhZGRpdGlvbmFsIGhpZGRlbiBmb3JtIGZpZWxkcyB3ZSBuZWVkIHRvIGluY2x1ZGUgaW5zaWRlIHRoZSBidXR0b24gaXRzZWxmLlxuXG4gIHB1c2hBZGRpdGlvbmFsRm9ybUZpZWxkcyh0YXJnZXQsIGZvcm1EYXRhKTtcbiAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuXG4gIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlIGNoaWxkcmVuIGFzIGEgc3RyaW5nIHRvIGF2b2lkIHRoZSB1bm5lY2Vzc2FyeSBjb21tZW50LlxuICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIHNwZWNpYWwgY2FzZSBhZnRlciB0aGUgZ2VuZXJhbCBvcHRpbWl6YXRpb24gaXMgaW4gcGxhY2UuXG4gICAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlbmNvZGVIVE1MVGV4dE5vZGUoY2hpbGRyZW4pKSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIHB1c2hTdGFydFRleHRBcmVhKHRhcmdldCwgcHJvcHMpIHtcbiAge1xuICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoJ3RleHRhcmVhJywgcHJvcHMpO1xuXG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSkge1xuICAgICAgZXJyb3IoJ1RleHRhcmVhIGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCB0ZXh0YXJlYSAnICsgJ2FuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuXG4gICAgICBkaWRXYXJuRGVmYXVsdFRleHRhcmVhVmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoJ3RleHRhcmVhJykpO1xuICB2YXIgdmFsdWUgPSBudWxsO1xuICB2YXIgZGVmYXVsdFZhbHVlID0gbnVsbDtcbiAgdmFyIGNoaWxkcmVuID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgICAgdmFsdWUgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGVmYXVsdFZhbHVlJzpcbiAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBkb2VzIG5vdCBtYWtlIHNlbnNlIG9uIDx0ZXh0YXJlYT4uJyk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodmFsdWUgPT09IG51bGwgJiYgZGVmYXVsdFZhbHVlICE9PSBudWxsKSB7XG4gICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTsgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cblxuICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgIHtcbiAgICAgIGVycm9yKCdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgaW5zdGVhZCBvZiBzZXR0aW5nICcgKyAnY2hpbGRyZW4gb24gPHRleHRhcmVhPi4nKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJZiB5b3Ugc3VwcGx5IGBkZWZhdWx0VmFsdWVgIG9uIGEgPHRleHRhcmVhPiwgZG8gbm90IHBhc3MgY2hpbGRyZW4uJyk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJzx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC4nKTtcbiAgICAgIH0gLy8gVE9ETzogcmVtb3ZlIHRoZSBjb2VyY2lvbiBhbmQgdGhlIERFViBjaGVjayBiZWxvdyBiZWNhdXNlIGl0IHdpbGxcbiAgICAgIC8vIGFsd2F5cyBiZSBvdmVyd3JpdHRlbiBieSB0aGUgY29lcmNpb24gc2V2ZXJhbCBsaW5lcyBiZWxvdyBpdC4gIzIyMzA5XG5cblxuICAgICAge1xuICAgICAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihjaGlsZHJlblswXSk7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gJycgKyBjaGlsZHJlblswXTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihjaGlsZHJlbik7XG4gICAgfVxuXG4gICAgdmFsdWUgPSAnJyArIGNoaWxkcmVuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWVbMF0gPT09ICdcXG4nKSB7XG4gICAgLy8gdGV4dC9odG1sIGlnbm9yZXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGVzZSB0YWdzIGlmIGl0J3MgYSBuZXdsaW5lXG4gICAgLy8gUHJlZmVyIHRvIGJyZWFrIGFwcGxpY2F0aW9uL3htbCBvdmVyIHRleHQvaHRtbCAoZm9yIG5vdykgYnkgYWRkaW5nXG4gICAgLy8gYSBuZXdsaW5lIHNwZWNpZmljYWxseSB0byBnZXQgZWF0ZW4gYnkgdGhlIHBhcnNlci4gKEFsdGVybmF0ZWx5IGZvclxuICAgIC8vIHRleHRhcmVhcywgcmVwbGFjaW5nIFwiXlxcblwiIHdpdGggXCJcXHJcXG5cIiBkb2Vzbid0IGdldCBlYXRlbiwgYW5kIHRoZSBmaXJzdFxuICAgIC8vIFxcciBpcyBub3JtYWxpemVkIG91dCBieSBIVE1MVGV4dEFyZWFFbGVtZW50I3ZhbHVlLilcbiAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sLXBvbHlnbG90LyNuZXdsaW5lcy1pbi10ZXh0YXJlYS1hbmQtcHJlPlxuICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI2VsZW1lbnQtcmVzdHJpY3Rpb25zPlxuICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI25ld2xpbmVzPlxuICAgIC8vIFNlZTogUGFyc2luZyBvZiBcInRleHRhcmVhXCIgXCJsaXN0aW5nXCIgYW5kIFwicHJlXCIgZWxlbWVudHNcbiAgICAvLyAgZnJvbSA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keT5cbiAgICB0YXJnZXQucHVzaChsZWFkaW5nTmV3bGluZSk7XG4gIH0gLy8gVG9TdHJpbmcgYW5kIHB1c2ggZGlyZWN0bHkgaW5zdGVhZCBvZiByZWN1cnNlIG92ZXIgY2hpbGRyZW4uXG4gIC8vIFdlIGRvbid0IHJlYWxseSBzdXBwb3J0IGNvbXBsZXggY2hpbGRyZW4gaW4gdGhlIHZhbHVlIGFueXdheS5cbiAgLy8gVGhpcyBhbHNvIGN1cnJlbnRseSBhdm9pZHMgYSB0cmFpbGluZyBjb21tZW50IG5vZGUgd2hpY2ggYnJlYWtzIHRleHRhcmVhLlxuXG5cbiAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAge1xuICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgJ3ZhbHVlJyk7XG4gICAgfVxuXG4gICAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlbmNvZGVIVE1MVGV4dE5vZGUoJycgKyB2YWx1ZSkpKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwdXNoTWV0YSh0YXJnZXQsIHByb3BzLCByZXNwb25zZVN0YXRlLCB0ZXh0RW1iZWRkZWQsIGluc2VydGlvbk1vZGUsIG5vc2NyaXB0VGFnSW5TY29wZSkge1xuICB7XG4gICAgaWYgKGluc2VydGlvbk1vZGUgPT09IFNWR19NT0RFIHx8IG5vc2NyaXB0VGFnSW5TY29wZSB8fCBwcm9wcy5pdGVtUHJvcCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gcHVzaFNlbGZDbG9zaW5nKHRhcmdldCwgcHJvcHMsICdtZXRhJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0ZXh0RW1iZWRkZWQpIHtcbiAgICAgICAgLy8gVGhpcyBsaW5rIGZvbGxvd3MgdGV4dCBidXQgd2UgYXJlbid0IHdyaXRpbmcgYSB0YWcuIHdoaWxlIG5vdCBhcyBlZmZpY2llbnQgYXMgcG9zc2libGUgd2UgbmVlZFxuICAgICAgICAvLyB0byBiZSBzYWZlIGFuZCBhc3N1bWUgdGV4dCB3aWxsIGZvbGxvdyBieSBpbnNlcnRpbmcgYSB0ZXh0U2VwYXJhdG9yXG4gICAgICAgIHRhcmdldC5wdXNoKHRleHRTZXBhcmF0b3IpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHByb3BzLmNoYXJTZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBwdXNoU2VsZkNsb3NpbmcocmVzcG9uc2VTdGF0ZS5jaGFyc2V0Q2h1bmtzLCBwcm9wcywgJ21ldGEnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcHMubmFtZSA9PT0gJ3ZpZXdwb3J0Jykge1xuICAgICAgICAvLyBcInZpZXdwb3J0XCIgaXNuJ3QgcmVsYXRlZCB0byBwcmVjb25uZWN0IGJ1dCBpdCBoYXMgdGhlIHJpZ2h0IHByaW9yaXR5XG4gICAgICAgIHJldHVybiBwdXNoU2VsZkNsb3NpbmcocmVzcG9uc2VTdGF0ZS5wcmVjb25uZWN0Q2h1bmtzLCBwcm9wcywgJ21ldGEnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwdXNoU2VsZkNsb3NpbmcocmVzcG9uc2VTdGF0ZS5ob2lzdGFibGVDaHVua3MsIHByb3BzLCAnbWV0YScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoTGluayh0YXJnZXQsIHByb3BzLCByZXNwb25zZVN0YXRlLCByZXNvdXJjZXMsIHRleHRFbWJlZGRlZCwgaW5zZXJ0aW9uTW9kZSwgbm9zY3JpcHRUYWdJblNjb3BlKSB7XG4gIHtcbiAgICB2YXIgcmVsID0gcHJvcHMucmVsO1xuICAgIHZhciBocmVmID0gcHJvcHMuaHJlZjtcbiAgICB2YXIgcHJlY2VkZW5jZSA9IHByb3BzLnByZWNlZGVuY2U7XG5cbiAgICBpZiAoaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHwgbm9zY3JpcHRUYWdJblNjb3BlIHx8IHByb3BzLml0ZW1Qcm9wICE9IG51bGwgfHwgdHlwZW9mIHJlbCAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGhyZWYgIT09ICdzdHJpbmcnIHx8IGhyZWYgPT09ICcnKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChyZWwgPT09ICdzdHlsZXNoZWV0JyAmJiB0eXBlb2YgcHJvcHMucHJlY2VkZW5jZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGhyZWYgIT09ICdzdHJpbmcnIHx8ICFocmVmKSB7XG4gICAgICAgICAgICBlcnJvcignUmVhY3QgZW5jb3VudGVyZWQgYSBgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIC4uLi8+YCB3aXRoIGEgYHByZWNlZGVuY2VgIHByb3AgYW5kIGV4cGVjdGVkIHRoZSBgaHJlZmAgcHJvcCB0byBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgYnV0IGVjb3VudGVyZWQgJXMgaW5zdGVhZC4gSWYgeW91ciBpbnRlbnQgd2FzIHRvIGhhdmUgUmVhY3QgaG9pc3QgYW5kIGRlZHVwbGNpYXRlIHRoaXMgc3R5bGVzaGVldCB1c2luZyB0aGUgYHByZWNlZGVuY2VgIHByb3AgZW5zdXJlIHRoZXJlIGlzIGEgbm9uLWVtcHR5IHN0cmluZyBgaHJlZmAgcHJvcCBhcyB3ZWxsLCBvdGhlcndpc2UgcmVtb3ZlIHRoZSBgcHJlY2VkZW5jZWAgcHJvcC4nLCBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdPYmplY3RGb3JXYXJuaW5nKGhyZWYpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHVzaExpbmtJbXBsKHRhcmdldCwgcHJvcHMpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHByb3BzLnJlbCA9PT0gJ3N0eWxlc2hlZXQnKSB7XG4gICAgICAvLyBUaGlzIDxsaW5rPiBtYXkgaG9pc3RhYmxlIGFzIGEgU3R5bGVzaGVldCBSZXNvdXJjZSwgb3RoZXJ3aXNlIGl0IHdpbGwgZW1pdCBpbiBwbGFjZVxuICAgICAgdmFyIGtleSA9IGdldFJlc291cmNlS2V5KCdzdHlsZScsIGhyZWYpO1xuXG4gICAgICBpZiAodHlwZW9mIHByZWNlZGVuY2UgIT09ICdzdHJpbmcnIHx8IHByb3BzLmRpc2FibGVkICE9IG51bGwgfHwgcHJvcHMub25Mb2FkIHx8IHByb3BzLm9uRXJyb3IpIHtcbiAgICAgICAgLy8gVGhpcyBzdHlsZXNoZWV0IGlzIGVpdGhlciBub3Qgb3B0ZWQgaW50byBSZXNvdXJjZSBzZW1hbnRpY3Mgb3IgaGFzIGNvbmZsaWN0aW5nIHByb3BlcnRpZXMgd2hpY2hcbiAgICAgICAgLy8gZGlzcXVhbGlmeSBpdCBmb3Igc3VjaC4gV2UgY2FuIHN0aWxsIGNyZWF0ZSBhIHByZWxvYWQgcmVzb3VyY2UgdG8gaGVscCBpdCBsb2FkIGZhc3RlciBvbiB0aGVcbiAgICAgICAgLy8gY2xpZW50XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHByZWNlZGVuY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMuZGlzYWJsZWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBlcnJvcignUmVhY3QgZW5jb3VudGVyZWQgYSBgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIC4uLi8+YCB3aXRoIGEgYHByZWNlZGVuY2VgIHByb3AgYW5kIGEgYGRpc2FibGVkYCBwcm9wLiBUaGUgcHJlc2VuY2Ugb2YgdGhlIGBkaXNhYmxlZGAgcHJvcCBpbmRpY2F0ZXMgYW4gaW50ZW50IHRvIG1hbmFnZSB0aGUgc3R5bGVzaGVldCBhY3RpdmUgc3RhdGUgZnJvbSB5b3VyIGZyb20geW91ciBDb21wb25lbnQgY29kZSBhbmQgUmVhY3Qgd2lsbCBub3QgaG9pc3Qgb3IgZGVkdXBsaWNhdGUgdGhpcyBzdHlsZXNoZWV0LiBJZiB5b3VyIGludGVudCB3YXMgdG8gaGF2ZSBSZWFjdCBob2lzdCBhbmQgZGVkdXBsY2lhdGUgdGhpcyBzdHlsZXNoZWV0IHVzaW5nIHRoZSBgcHJlY2VkZW5jZWAgcHJvcCByZW1vdmUgdGhlIGBkaXNhYmxlZGAgcHJvcCwgb3RoZXJ3aXNlIHJlbW92ZSB0aGUgYHByZWNlZGVuY2VgIHByb3AuJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BzLm9uTG9hZCB8fCBwcm9wcy5vbkVycm9yKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wRGVzY3JpcHRpb24gPSBwcm9wcy5vbkxvYWQgJiYgcHJvcHMub25FcnJvciA/ICdgb25Mb2FkYCBhbmQgYG9uRXJyb3JgIHByb3BzJyA6IHByb3BzLm9uTG9hZCA/ICdgb25Mb2FkYCBwcm9wJyA6ICdgb25FcnJvcmAgcHJvcCc7XG5cbiAgICAgICAgICAgICAgZXJyb3IoJ1JlYWN0IGVuY291bnRlcmVkIGEgYDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiAuLi4vPmAgd2l0aCBhIGBwcmVjZWRlbmNlYCBwcm9wIGFuZCAlcy4gVGhlIHByZXNlbmNlIG9mIGxvYWRpbmcgYW5kIGVycm9yIGhhbmRsZXJzIGluZGljYXRlcyBhbiBpbnRlbnQgdG8gbWFuYWdlIHRoZSBzdHlsZXNoZWV0IGxvYWRpbmcgc3RhdGUgZnJvbSB5b3VyIGZyb20geW91ciBDb21wb25lbnQgY29kZSBhbmQgUmVhY3Qgd2lsbCBub3QgaG9pc3Qgb3IgZGVkdXBsaWNhdGUgdGhpcyBzdHlsZXNoZWV0LiBJZiB5b3VyIGludGVudCB3YXMgdG8gaGF2ZSBSZWFjdCBob2lzdCBhbmQgZGVkdXBsY2lhdGUgdGhpcyBzdHlsZXNoZWV0IHVzaW5nIHRoZSBgcHJlY2VkZW5jZWAgcHJvcCByZW1vdmUgdGhlICVzLCBvdGhlcndpc2UgcmVtb3ZlIHRoZSBgcHJlY2VkZW5jZWAgcHJvcC4nLCBwcm9wRGVzY3JpcHRpb24sIHByb3BEZXNjcmlwdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHB1c2hMaW5rSW1wbCh0YXJnZXQsIHByb3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgc3R5bGVzaGVldCByZWZlcnMgdG8gYSBSZXNvdXJjZSBhbmQgd2UgY3JlYXRlIGEgbmV3IG9uZSBpZiBuZWNlc3NhcnlcbiAgICAgICAgdmFyIHJlc291cmNlID0gcmVzb3VyY2VzLnN0eWxlc01hcC5nZXQoa2V5KTtcblxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGRldlJlc291cmNlID0gZ2V0QXNSZXNvdXJjZURFVihyZXNvdXJjZSk7XG5cbiAgICAgICAgICBpZiAoZGV2UmVzb3VyY2UpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZGV2UmVzb3VyY2UuX19wcm92ZW5hbmNlKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ3JlbmRlcmVkJzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB2YXIgZGlmZmVyZW5jZURlc2NyaXB0aW9uID0gZGVzY3JpYmVEaWZmZXJlbmNlc0ZvclN0eWxlc2hlZXRzKCAvLyBEaWZmIHRoZSBwcm9wcyBmcm9tIHRoZSBKU1ggZWxlbWVudCwgbm90IHRoZSBkZXJpdmVkIHJlc291cmNlIHByb3BzXG4gICAgICAgICAgICAgICAgICBwcm9wcywgZGV2UmVzb3VyY2UuX19vcmlnaW5hbFByb3BzKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGRpZmZlcmVuY2VEZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcignUmVhY3QgZW5jb3VudGVyZWQgYSA8bGluayByZWw9XCJzdHlsZXNoZWV0XCIgaHJlZj1cIiVzXCIgLi4uLz4gd2l0aCBhIGBwcmVjZWRlbmNlYCBwcm9wIHRoYXQgaGFzIHByb3BzIHRoYXQgY29uZmxpY3QnICsgJyB3aXRoIGFub3RoZXIgaG9pc3RhYmxlIHN0eWxlc2hlZXQgd2l0aCB0aGUgc2FtZSBgaHJlZmAuIFdoZW4gdXNpbmcgYHByZWNlZGVuY2VgIHdpdGggPGxpbmsgcmVsPVwic3R5bHNoZWV0XCIgLi4uLz4nICsgJyB0aGUgcHJvcHMgZnJvbSB0aGUgZmlyc3QgZW5jb3VudGVyZWQgaW5zdGFuY2Ugd2lsbCBiZSB1c2VkIGFuZCBwcm9wcyBmcm9tIGxhdGVyIGluc3RhbmNlcyB3aWxsIGJlIGlnbm9yZWQuJyArICcgVXBkYXRlIHRoZSBwcm9wcyBvbiBlaXRoZXIgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIC4uLi8+IGluc3RhbmNlIHNvIHRoZXkgYWdyZWUuJXMnLCBocmVmLCBkaWZmZXJlbmNlRGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY2FzZSAncHJlaW5pdCc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdmFyIF9kaWZmZXJlbmNlRGVzY3JpcHRpb24gPSBkZXNjcmliZURpZmZlcmVuY2VzRm9yU3R5bGVzaGVldE92ZXJQcmVpbml0KCAvLyBEaWZmIHRoZSBwcm9wcyBmcm9tIHRoZSBKU1ggZWxlbWVudCwgbm90IHRoZSBkZXJpdmVkIHJlc291cmNlIHByb3BzXG4gICAgICAgICAgICAgICAgICBwcm9wcywgZGV2UmVzb3VyY2UuX19wcm9wc0VxdWl2YWxlbnQpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoX2RpZmZlcmVuY2VEZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcignUmVhY3QgZW5jb3VudGVyZWQgYSA8bGluayByZWw9XCJzdHlsZXNoZWV0XCIgcHJlY2VkZW5jZT1cIiVzXCIgaHJlZj1cIiVzXCIgLi4uLz4gd2l0aCBwcm9wcyB0aGF0IGNvbmZsaWN0JyArICcgd2l0aCB0aGUgb3B0aW9ucyBwcm92aWRlZCB0byBgUmVhY3RET00ucHJlaW5pdChcIiVzXCIsIHsgYXM6IFwic3R5bGVcIiwgLi4uIH0pYC4gUmVhY3Qgd2lsbCB1c2UgdGhlIGZpcnN0IHByb3BzIG9yIHByZWluaXRpYWxpemF0aW9uJyArICcgb3B0aW9ucyBlbmNvdW50ZXJlZCB3aGVuIHJlbmRlcmluZyBhIGhvaXN0YWJsZSBzdHlsZXNoZWV0IHdpdGggYSBwYXJ0aWN1bGFyIGBocmVmYCBhbmQgd2lsbCBpZ25vcmUgYW55IG5ld2VyIHByb3BzIG9yJyArICcgb3B0aW9ucy4gVGhlIGZpcnN0IGluc3RhbmNlIG9mIHRoaXMgc3R5bGVzaGVldCByZXNvdXJjZSB3YXMgY3JlYXRlZCB1c2luZyB0aGUgYFJlYWN0RE9NLnByZWluaXQoKWAgZnVuY3Rpb24uJyArICcgUGxlYXNlIG5vdGUsIGBSZWFjdERPTS5wcmVpbml0KClgIGlzIG1vZGVsZWQgb2ZmIG9mIG1vZHVsZSBpbXBvcnQgYXNzZXJ0aW9ucyBjYXBhYmlsaXRpZXMgYW5kIGRvZXMgbm90IHN1cHBvcnQnICsgJyBhcmJpdHJhcnkgcHJvcHMuIElmIHlvdSBuZWVkIHRvIGhhdmUgcHJvcHMgbm90IGluY2x1ZGVkIHdpdGggdGhlIHByZWluaXQgb3B0aW9ucyB5b3Ugd2lsbCBuZWVkIHRvIHJlbHkgb24gcmVuZGVyaW5nJyArICcgPGxpbms+IHRhZ3Mgb25seS4lcycsIHByZWNlZGVuY2UsIGhyZWYsIGhyZWYsIF9kaWZmZXJlbmNlRGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZXNvdXJjZSkge1xuICAgICAgICAgIHZhciByZXNvdXJjZVByb3BzID0gc3R5bGVzaGVldFByb3BzRnJvbVJhd1Byb3BzKHByb3BzKTtcbiAgICAgICAgICB2YXIgcHJlbG9hZFJlc291cmNlID0gcmVzb3VyY2VzLnByZWxvYWRzTWFwLmdldChrZXkpO1xuICAgICAgICAgIHZhciBzdGF0ZSA9IE5vU3RhdGU7XG5cbiAgICAgICAgICBpZiAocHJlbG9hZFJlc291cmNlKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhbHJlYWR5IGhhZCBhIHByZWxvYWQgd2UgZG9uJ3Qgd2FudCB0aGF0IHJlc291cmNlIHRvIGZsdXNoIGRpcmVjdGx5LlxuICAgICAgICAgICAgLy8gV2UgbGV0IHRoZSBuZXdseSBjcmVhdGVkIHJlc291cmNlIGdvdmVybiBmbHVzaGluZy5cbiAgICAgICAgICAgIHByZWxvYWRSZXNvdXJjZS5zdGF0ZSB8PSBCbG9ja2VkO1xuICAgICAgICAgICAgYWRvcHRQcmVsb2FkUHJvcHNGb3JTdHlsZXNoZWV0UHJvcHMocmVzb3VyY2VQcm9wcywgcHJlbG9hZFJlc291cmNlLnByb3BzKTtcblxuICAgICAgICAgICAgaWYgKHByZWxvYWRSZXNvdXJjZS5zdGF0ZSAmIEZsdXNoZWQpIHtcbiAgICAgICAgICAgICAgc3RhdGUgPSBQcmVsb2FkRmx1c2hlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXNvdXJjZSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHlsZXNoZWV0JyxcbiAgICAgICAgICAgIGNodW5rczogW10sXG4gICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICBwcm9wczogcmVzb3VyY2VQcm9wc1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmVzb3VyY2VzLnN0eWxlc01hcC5zZXQoa2V5LCByZXNvdXJjZSk7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBtYXJrQXNSZW5kZXJlZFJlc291cmNlREVWKHJlc291cmNlLCBwcm9wcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHByZWNlZGVuY2VTZXQgPSByZXNvdXJjZXMucHJlY2VkZW5jZXMuZ2V0KHByZWNlZGVuY2UpO1xuXG4gICAgICAgICAgaWYgKCFwcmVjZWRlbmNlU2V0KSB7XG4gICAgICAgICAgICBwcmVjZWRlbmNlU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgcmVzb3VyY2VzLnByZWNlZGVuY2VzLnNldChwcmVjZWRlbmNlLCBwcmVjZWRlbmNlU2V0KTtcbiAgICAgICAgICAgIHZhciBlbXB0eVN0eWxlUmVzb3VyY2UgPSB7XG4gICAgICAgICAgICAgIHR5cGU6ICdzdHlsZScsXG4gICAgICAgICAgICAgIGNodW5rczogW10sXG4gICAgICAgICAgICAgIHN0YXRlOiBOb1N0YXRlLFxuICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IHByZWNlZGVuY2UsXG4gICAgICAgICAgICAgICAgaHJlZnM6IFtdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwcmVjZWRlbmNlU2V0LmFkZChlbXB0eVN0eWxlUmVzb3VyY2UpO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChyZXNvdXJjZXMuc3R5bGVQcmVjZWRlbmNlcy5oYXMocHJlY2VkZW5jZSkpIHtcbiAgICAgICAgICAgICAgICBlcnJvcignUmVhY3QgY29uc3RydWN0ZWQgYW4gZW1wdHkgc3R5bGUgcmVzb3VyY2Ugd2hlbiBhIHN0eWxlIHJlc291cmNlIGFscmVhZHkgZXhpc3RzIGZvciB0aGlzIHByZWNlZGVuY2U6IFwiJXNcIi4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nLCBwcmVjZWRlbmNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXNvdXJjZXMuc3R5bGVQcmVjZWRlbmNlcy5zZXQocHJlY2VkZW5jZSwgZW1wdHlTdHlsZVJlc291cmNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwcmVjZWRlbmNlU2V0LmFkZChyZXNvdXJjZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzb3VyY2VzLmJvdW5kYXJ5UmVzb3VyY2VzKSB7XG4gICAgICAgICAgcmVzb3VyY2VzLmJvdW5kYXJ5UmVzb3VyY2VzLmFkZChyZXNvdXJjZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dEVtYmVkZGVkKSB7XG4gICAgICAgICAgLy8gVGhpcyBsaW5rIGZvbGxvd3MgdGV4dCBidXQgd2UgYXJlbid0IHdyaXRpbmcgYSB0YWcuIHdoaWxlIG5vdCBhcyBlZmZpY2llbnQgYXMgcG9zc2libGUgd2UgbmVlZFxuICAgICAgICAgIC8vIHRvIGJlIHNhZmUgYW5kIGFzc3VtZSB0ZXh0IHdpbGwgZm9sbG93IGJ5IGluc2VydGluZyBhIHRleHRTZXBhcmF0b3JcbiAgICAgICAgICB0YXJnZXQucHVzaCh0ZXh0U2VwYXJhdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcHMub25Mb2FkIHx8IHByb3BzLm9uRXJyb3IpIHtcbiAgICAgIC8vIFdoZW4gdXNpbmcgbG9hZCBoYW5kbGVycyB3ZSBjYW5ub3QgaG9pc3QgYW5kIG5lZWQgdG8gZW1pdCBsaW5rcyBpbiBwbGFjZVxuICAgICAgcmV0dXJuIHB1c2hMaW5rSW1wbCh0YXJnZXQsIHByb3BzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2UgY2FuIGhvaXN0IHRoaXMgbGluayBzbyB3ZSBtYXkgbmVlZCB0byBlbWl0IGEgdGV4dCBzZXBhcmF0b3IuXG4gICAgICAvLyBAVE9ETyByZWZhY3RvciB0ZXh0IHNlcGFyYXRvcnMgc28gd2UgZG9uJ3QgaGF2ZSB0byBkZWZlbnNpdmVseSBhZGRcbiAgICAgIC8vIHRoZW0gd2hlbiB3ZSBkb24ndCBlbmQgdXAgZW1pdHRpbmcgYSB0YWcgYXMgYSByZXN1bHQgb2YgcHVzaFN0YXJ0SW5zdGFuY2VcbiAgICAgIGlmICh0ZXh0RW1iZWRkZWQpIHtcbiAgICAgICAgLy8gVGhpcyBsaW5rIGZvbGxvd3MgdGV4dCBidXQgd2UgYXJlbid0IHdyaXRpbmcgYSB0YWcuIHdoaWxlIG5vdCBhcyBlZmZpY2llbnQgYXMgcG9zc2libGUgd2UgbmVlZFxuICAgICAgICAvLyB0byBiZSBzYWZlIGFuZCBhc3N1bWUgdGV4dCB3aWxsIGZvbGxvdyBieSBpbnNlcnRpbmcgYSB0ZXh0U2VwYXJhdG9yXG4gICAgICAgIHRhcmdldC5wdXNoKHRleHRTZXBhcmF0b3IpO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BzLnJlbCkge1xuICAgICAgICBjYXNlICdwcmVjb25uZWN0JzpcbiAgICAgICAgY2FzZSAnZG5zLXByZWZldGNoJzpcbiAgICAgICAgICByZXR1cm4gcHVzaExpbmtJbXBsKHJlc3BvbnNlU3RhdGUucHJlY29ubmVjdENodW5rcywgcHJvcHMpO1xuXG4gICAgICAgIGNhc2UgJ3ByZWxvYWQnOlxuICAgICAgICAgIHJldHVybiBwdXNoTGlua0ltcGwocmVzcG9uc2VTdGF0ZS5wcmVsb2FkQ2h1bmtzLCBwcm9wcyk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gcHVzaExpbmtJbXBsKHJlc3BvbnNlU3RhdGUuaG9pc3RhYmxlQ2h1bmtzLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hMaW5rSW1wbCh0YXJnZXQsIHByb3BzKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoJ2xpbmsnKSk7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xpbmsnICsgXCIgaXMgYSBzZWxmLWNsb3NpbmcgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciBcIiArICd1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyk7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwdXNoU3R5bGUodGFyZ2V0LCBwcm9wcywgcmVzb3VyY2VzLCB0ZXh0RW1iZWRkZWQsIGluc2VydGlvbk1vZGUsIG5vc2NyaXB0VGFnSW5TY29wZSkge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsICdjaGlsZHJlbicpKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIHZhciBjaGlsZCA9IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4ubGVuZ3RoIDwgMiA/IGNoaWxkcmVuWzBdIDogbnVsbCA6IGNoaWxkcmVuO1xuXG4gICAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ3N5bWJvbCcgfHwgQXJyYXkuaXNBcnJheShjaGlsZCkpIHtcbiAgICAgICAgdmFyIGNoaWxkVHlwZSA9IHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJyA/ICdhIEZ1bmN0aW9uJyA6IHR5cGVvZiBjaGlsZCA9PT0gJ3N5bWJvbCcgPyAnYSBTeWJtb2wnIDogJ2FuIEFycmF5JztcblxuICAgICAgICBlcnJvcignUmVhY3QgZXhwZWN0IGNoaWxkcmVuIG9mIDxzdHlsZT4gdGFncyB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBvciBvYmplY3Qgd2l0aCBhIGB0b1N0cmluZ2AgbWV0aG9kIGJ1dCBmb3VuZCAlcyBpbnN0ZWFkLiAnICsgJ0luIGJyb3dzZXJzIHN0eWxlIEVsZW1lbnRzIGNhbiBvbmx5IGhhdmUgYFRleHRgIE5vZGVzIGFzIGNoaWxkcmVuLicsIGNoaWxkVHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIHZhciBwcmVjZWRlbmNlID0gcHJvcHMucHJlY2VkZW5jZTtcbiAgICB2YXIgaHJlZiA9IHByb3BzLmhyZWY7XG5cbiAgICBpZiAoaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHwgbm9zY3JpcHRUYWdJblNjb3BlIHx8IHByb3BzLml0ZW1Qcm9wICE9IG51bGwgfHwgdHlwZW9mIHByZWNlZGVuY2UgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBocmVmICE9PSAnc3RyaW5nJyB8fCBocmVmID09PSAnJykge1xuICAgICAgLy8gVGhpcyBzdHlsZSB0YWcgaXMgbm90IGFibGUgdG8gYmUgdHVybmVkIGludG8gYSBTdHlsZSBSZXNvdXJjZVxuICAgICAgcmV0dXJuIHB1c2hTdHlsZUltcGwodGFyZ2V0LCBwcm9wcyk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGhyZWYuaW5jbHVkZXMoJyAnKSkge1xuICAgICAgICBlcnJvcignUmVhY3QgZXhwZWN0ZWQgdGhlIGBocmVmYCBwcm9wIGZvciBhIDxzdHlsZT4gdGFnIG9wdGluZyBpbnRvIGhvaXN0aW5nIHNlbWFudGljcyB1c2luZyB0aGUgYHByZWNlZGVuY2VgIHByb3AgdG8gbm90IGhhdmUgYW55IHNwYWNlcyBidXQgZWNvdW50ZXJlZCBzcGFjZXMgaW5zdGVhZC4gdXNpbmcgc3BhY2VzIGluIHRoaXMgcHJvcCB3aWxsIGNhdXNlIGh5ZHJhdGlvbiBvZiB0aGlzIHN0eWxlIHRvIGZhaWwgb24gdGhlIGNsaWVudC4gVGhlIGhyZWYgZm9yIHRoZSA8c3R5bGU+IHdoZXJlIHRoaXMgb2N1cnJlZCBpcyBcIiVzXCIuJywgaHJlZik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGtleSA9IGdldFJlc291cmNlS2V5KCdzdHlsZScsIGhyZWYpO1xuICAgIHZhciByZXNvdXJjZSA9IHJlc291cmNlcy5zdHlsZXNNYXAuZ2V0KGtleSk7XG5cbiAgICBpZiAoIXJlc291cmNlKSB7XG4gICAgICByZXNvdXJjZSA9IHJlc291cmNlcy5zdHlsZVByZWNlZGVuY2VzLmdldChwcmVjZWRlbmNlKTtcblxuICAgICAgaWYgKCFyZXNvdXJjZSkge1xuICAgICAgICByZXNvdXJjZSA9IHtcbiAgICAgICAgICB0eXBlOiAnc3R5bGUnLFxuICAgICAgICAgIGNodW5rczogW10sXG4gICAgICAgICAgc3RhdGU6IE5vU3RhdGUsXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IHByZWNlZGVuY2UsXG4gICAgICAgICAgICBocmVmczogW2hyZWZdXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXNvdXJjZXMuc3R5bGVQcmVjZWRlbmNlcy5zZXQocHJlY2VkZW5jZSwgcmVzb3VyY2UpO1xuICAgICAgICB2YXIgcHJlY2VkZW5jZVNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgcHJlY2VkZW5jZVNldC5hZGQocmVzb3VyY2UpO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAocmVzb3VyY2VzLnByZWNlZGVuY2VzLmhhcyhwcmVjZWRlbmNlKSkge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0IGNvbnN0cnVjdGVkIGEgbmV3IHN0eWxlIHByZWNlZGVuY2Ugc2V0IHdoZW4gb25lIGFscmVhZHkgZXhpc3RzIGZvciB0aGlzIHByZWNlZGVuY2U6IFwiJXNcIi4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nLCBwcmVjZWRlbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXNvdXJjZXMucHJlY2VkZW5jZXMuc2V0KHByZWNlZGVuY2UsIHByZWNlZGVuY2VTZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb3VyY2UucHJvcHMuaHJlZnMucHVzaChocmVmKTtcbiAgICAgIH1cblxuICAgICAgcmVzb3VyY2VzLnN0eWxlc01hcC5zZXQoa2V5LCByZXNvdXJjZSk7XG5cbiAgICAgIGlmIChyZXNvdXJjZXMuYm91bmRhcnlSZXNvdXJjZXMpIHtcbiAgICAgICAgcmVzb3VyY2VzLmJvdW5kYXJ5UmVzb3VyY2VzLmFkZChyZXNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIHB1c2hTdHlsZUNvbnRlbnRzKHJlc291cmNlLmNodW5rcywgcHJvcHMpO1xuICAgIH1cblxuICAgIGlmICh0ZXh0RW1iZWRkZWQpIHtcbiAgICAgIC8vIFRoaXMgbGluayBmb2xsb3dzIHRleHQgYnV0IHdlIGFyZW4ndCB3cml0aW5nIGEgdGFnLiB3aGlsZSBub3QgYXMgZWZmaWNpZW50IGFzIHBvc3NpYmxlIHdlIG5lZWRcbiAgICAgIC8vIHRvIGJlIHNhZmUgYW5kIGFzc3VtZSB0ZXh0IHdpbGwgZm9sbG93IGJ5IGluc2VydGluZyBhIHRleHRTZXBhcmF0b3JcbiAgICAgIHRhcmdldC5wdXNoKHRleHRTZXBhcmF0b3IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoU3R5bGVJbXBsKHRhcmdldCwgcHJvcHMpIHtcbiAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZygnc3R5bGUnKSk7XG4gIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gIHZhciBpbm5lckhUTUwgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgdmFyIGNoaWxkID0gQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbi5sZW5ndGggPCAyID8gY2hpbGRyZW5bMF0gOiBudWxsIDogY2hpbGRyZW47XG5cbiAgaWYgKHR5cGVvZiBjaGlsZCAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY2hpbGQgIT09ICdzeW1ib2wnICYmIGNoaWxkICE9PSBudWxsICYmIGNoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgICB0YXJnZXQucHVzaChzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKCcnICsgY2hpbGQpKSk7XG4gIH1cblxuICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MLCBjaGlsZHJlbik7XG4gIHRhcmdldC5wdXNoKGVuZFRhZzEsIHN0cmluZ1RvQ2h1bmsoJ3N0eWxlJyksIGVuZFRhZzIpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHVzaFN0eWxlQ29udGVudHModGFyZ2V0LCBwcm9wcykge1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICB2YXIgaW5uZXJIVE1MID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBjaGlsZCA9IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4ubGVuZ3RoIDwgMiA/IGNoaWxkcmVuWzBdIDogbnVsbCA6IGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlb2YgY2hpbGQgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGNoaWxkICE9PSAnc3ltYm9sJyAmJiBjaGlsZCAhPT0gbnVsbCAmJiBjaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gICAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcignJyArIGNoaWxkKSkpO1xuICB9XG5cbiAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuICByZXR1cm47XG59XG5cbmZ1bmN0aW9uIGdldEltYWdlUHJlbG9hZEtleShocmVmLCBpbWFnZVNyY1NldCwgaW1hZ2VTaXplcykge1xuICB2YXIgdW5pcXVlUGFydCA9ICcnO1xuXG4gIGlmICh0eXBlb2YgaW1hZ2VTcmNTZXQgPT09ICdzdHJpbmcnICYmIGltYWdlU3JjU2V0ICE9PSAnJykge1xuICAgIHVuaXF1ZVBhcnQgKz0gJ1snICsgaW1hZ2VTcmNTZXQgKyAnXSc7XG5cbiAgICBpZiAodHlwZW9mIGltYWdlU2l6ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICB1bmlxdWVQYXJ0ICs9ICdbJyArIGltYWdlU2l6ZXMgKyAnXSc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHVuaXF1ZVBhcnQgKz0gJ1tdW10nICsgaHJlZjtcbiAgfVxuXG4gIHJldHVybiBnZXRSZXNvdXJjZUtleSgnaW1hZ2UnLCB1bmlxdWVQYXJ0KTtcbn1cblxuZnVuY3Rpb24gcHVzaEltZyh0YXJnZXQsIHByb3BzLCByZXNvdXJjZXMpIHtcbiAgdmFyIHNyYyA9IHByb3BzLnNyYyxcbiAgICAgIHNyY1NldCA9IHByb3BzLnNyY1NldDtcblxuICBpZiAocHJvcHMubG9hZGluZyAhPT0gJ2xhenknICYmICh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygc3JjU2V0ID09PSAnc3RyaW5nJykgJiYgcHJvcHMuZmV0Y2hQcmlvcml0eSAhPT0gJ2xvdycgJiYgLy8gV2UgZXhjbHVkZSBkYXRhIFVSSXMgaW4gc3JjIGFuZCBzcmNTZXQgc2luY2UgdGhlc2Ugc2hvdWxkIG5vdCBiZSBwcmVsb2FkZWRcbiAgISh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJyAmJiBzcmNbNF0gPT09ICc6JyAmJiAoc3JjWzBdID09PSAnZCcgfHwgc3JjWzBdID09PSAnRCcpICYmIChzcmNbMV0gPT09ICdhJyB8fCBzcmNbMV0gPT09ICdBJykgJiYgKHNyY1syXSA9PT0gJ3QnIHx8IHNyY1syXSA9PT0gJ1QnKSAmJiAoc3JjWzNdID09PSAnYScgfHwgc3JjWzNdID09PSAnQScpKSAmJiAhKHR5cGVvZiBzcmNTZXQgPT09ICdzdHJpbmcnICYmIHNyY1NldFs0XSA9PT0gJzonICYmIChzcmNTZXRbMF0gPT09ICdkJyB8fCBzcmNTZXRbMF0gPT09ICdEJykgJiYgKHNyY1NldFsxXSA9PT0gJ2EnIHx8IHNyY1NldFsxXSA9PT0gJ0EnKSAmJiAoc3JjU2V0WzJdID09PSAndCcgfHwgc3JjU2V0WzJdID09PSAnVCcpICYmIChzcmNTZXRbM10gPT09ICdhJyB8fCBzcmNTZXRbM10gPT09ICdBJykpKSB7XG4gICAgLy8gV2UgaGF2ZSBhIHN1c3BlbnNleSBpbWFnZSBhbmQgb3VnaHQgdG8gcHJlbG9hZCBpdCB0byBvcHRpbWl6ZSB0aGUgbG9hZGluZyBvZiBkaXNwbGF5IGJsb2NraW5nXG4gICAgLy8gcmVzb3VyY2VzLlxuICAgIHZhciBzaXplcyA9IHByb3BzLnNpemVzO1xuICAgIHZhciBrZXkgPSBnZXRJbWFnZVByZWxvYWRLZXkoc3JjLCBzcmNTZXQsIHNpemVzKTtcbiAgICB2YXIgcmVzb3VyY2UgPSByZXNvdXJjZXMucHJlbG9hZHNNYXAuZ2V0KGtleSk7XG5cbiAgICBpZiAoIXJlc291cmNlKSB7XG4gICAgICByZXNvdXJjZSA9IHtcbiAgICAgICAgdHlwZTogJ3ByZWxvYWQnLFxuICAgICAgICBjaHVua3M6IFtdLFxuICAgICAgICBzdGF0ZTogTm9TdGF0ZSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICByZWw6ICdwcmVsb2FkJyxcbiAgICAgICAgICBhczogJ2ltYWdlJyxcbiAgICAgICAgICAvLyBUaGVyZSBpcyBhIGJ1ZyBpbiBTYWZhcmkgd2hlcmUgaW1hZ2VTcmNTZXQgaXMgbm90IHJlc3BlY3RlZCBvbiBwcmVsb2FkIGxpbmtzXG4gICAgICAgICAgLy8gc28gd2Ugb21pdCB0aGUgaHJlZiBoZXJlIGlmIHdlIGhhdmUgaW1hZ2VTcmNTZXQgYi9jIHNhZmFyaSB3aWxsIGxvYWQgdGhlIHdyb25nIGltYWdlLlxuICAgICAgICAgIC8vIFRoaXMgaGFybXMgb2xkZXIgYnJvd2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IGltYWdlU3JjU2V0IGJ5IG1ha2luZyB0aGVpciBwcmVsb2FkcyBub3Qgd29ya1xuICAgICAgICAgIC8vIGJ1dCB0aGlzIHBvcHVsYXRpb24gaXMgc2hyaW5raW5nIGZhc3QgYW5kIGlzIGFscmVhZHkgc21hbGwgc28gd2UgYWNjZXB0IHRoaXMgdHJhZGVvZmYuXG4gICAgICAgICAgaHJlZjogc3JjU2V0ID8gdW5kZWZpbmVkIDogc3JjLFxuICAgICAgICAgIGltYWdlU3JjU2V0OiBzcmNTZXQsXG4gICAgICAgICAgaW1hZ2VTaXplczogc2l6ZXMsXG4gICAgICAgICAgY3Jvc3NPcmlnaW46IHByb3BzLmNyb3NzT3JpZ2luLFxuICAgICAgICAgIGludGVncml0eTogcHJvcHMuaW50ZWdyaXR5LFxuICAgICAgICAgIHR5cGU6IHByb3BzLnR5cGUsXG4gICAgICAgICAgZmV0Y2hQcmlvcml0eTogcHJvcHMuZmV0Y2hQcmlvcml0eSxcbiAgICAgICAgICByZWZlcnJlclBvbGljeTogcHJvcHMucmVmZXJyZXJQb2xpY3lcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlc291cmNlcy5wcmVsb2Fkc01hcC5zZXQoa2V5LCByZXNvdXJjZSk7XG5cbiAgICAgIHtcbiAgICAgICAgbWFya0FzUmVuZGVyZWRSZXNvdXJjZURFVihyZXNvdXJjZSwgcHJvcHMpO1xuICAgICAgfVxuXG4gICAgICBwdXNoTGlua0ltcGwocmVzb3VyY2UuY2h1bmtzLCByZXNvdXJjZS5wcm9wcyk7XG4gICAgfVxuXG4gICAgaWYgKHByb3BzLmZldGNoUHJpb3JpdHkgPT09ICdoaWdoJyB8fCByZXNvdXJjZXMuaGlnaEltYWdlUHJlbG9hZHMuc2l6ZSA8IDEwKSB7XG4gICAgICByZXNvdXJjZXMuaGlnaEltYWdlUHJlbG9hZHMuYWRkKHJlc291cmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb3VyY2VzLmJ1bGtQcmVsb2Fkcy5hZGQocmVzb3VyY2UpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwdXNoU2VsZkNsb3NpbmcodGFyZ2V0LCBwcm9wcywgJ2ltZycpO1xufVxuXG5mdW5jdGlvbiBwdXNoU2VsZkNsb3NpbmcodGFyZ2V0LCBwcm9wcywgdGFnKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcodGFnKSk7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGFnICsgXCIgaXMgYSBzZWxmLWNsb3NpbmcgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciBcIiArICd1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyk7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwdXNoU3RhcnRNZW51SXRlbSh0YXJnZXQsIHByb3BzKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoJ21lbnVpdGVtJykpO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZW51aXRlbXMgY2Fubm90IGhhdmUgYGNoaWxkcmVuYCBub3IgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHVzaFRpdGxlKHRhcmdldCwgcHJvcHMsIHJlc3BvbnNlU3RhdGUsIGluc2VydGlvbk1vZGUsIG5vc2NyaXB0VGFnSW5TY29wZSkge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsICdjaGlsZHJlbicpKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIHZhciBjaGlsZCA9IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4ubGVuZ3RoIDwgMiA/IGNoaWxkcmVuWzBdIDogbnVsbCA6IGNoaWxkcmVuO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICBlcnJvcignUmVhY3QgZXhwZWN0cyB0aGUgYGNoaWxkcmVuYCBwcm9wIG9mIDx0aXRsZT4gdGFncyB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBvciBvYmplY3Qgd2l0aCBhIG5vdmVsIGB0b1N0cmluZ2AgbWV0aG9kIGJ1dCBmb3VuZCBhbiBBcnJheSB3aXRoIGxlbmd0aCAlcyBpbnN0ZWFkLicgKyAnIEJyb3dzZXJzIHRyZWF0IGFsbCBjaGlsZCBOb2RlcyBvZiA8dGl0bGU+IHRhZ3MgYXMgVGV4dCBjb250ZW50IGFuZCBSZWFjdCBleHBlY3RzIHRvIGJlIGFibGUgdG8gY29udmVydCBgY2hpbGRyZW5gIG9mIDx0aXRsZT4gdGFncyB0byBhIHNpbmdsZSBzdHJpbmcgdmFsdWUnICsgJyB3aGljaCBpcyB3aHkgQXJyYXlzIG9mIGxlbmd0aCBncmVhdGVyIHRoYW4gMSBhcmUgbm90IHN1cHBvcnRlZC4gV2hlbiB1c2luZyBKU1ggaXQgY2FuIGJlIGNvbW1vbmcgdG8gY29tYmluZSB0ZXh0IG5vZGVzIGFuZCB2YWx1ZSBub2Rlcy4nICsgJyBGb3IgZXhhbXBsZTogPHRpdGxlPmhlbGxvIHtuYW1lT2ZVc2VyfTwvdGl0bGU+LiBXaGlsZSBub3QgaW1tZWRpYXRlbHkgYXBwYXJlbnQsIGBjaGlsZHJlbmAgaW4gdGhpcyBjYXNlIGlzIGFuIEFycmF5IHdpdGggbGVuZ3RoIDIuIElmIHlvdXIgYGNoaWxkcmVuYCBwcm9wJyArICcgaXMgdXNpbmcgdGhpcyBmb3JtIHRyeSByZXdyaXRpbmcgaXQgdXNpbmcgYSB0ZW1wbGF0ZSBzdHJpbmc6IDx0aXRsZT57YGhlbGxvICR7bmFtZU9mVXNlcn1gfTwvdGl0bGU+LicsIGNoaWxkcmVuLmxlbmd0aCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIHZhciBjaGlsZFR5cGUgPSB0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicgPyAnYSBGdW5jdGlvbicgOiAnYSBTeWJtb2wnO1xuXG4gICAgICAgIGVycm9yKCdSZWFjdCBleHBlY3QgY2hpbGRyZW4gb2YgPHRpdGxlPiB0YWdzIHRvIGJlIGEgc3RyaW5nLCBudW1iZXIsIG9yIG9iamVjdCB3aXRoIGEgbm92ZWwgYHRvU3RyaW5nYCBtZXRob2QgYnV0IGZvdW5kICVzIGluc3RlYWQuJyArICcgQnJvd3NlcnMgdHJlYXQgYWxsIGNoaWxkIE5vZGVzIG9mIDx0aXRsZT4gdGFncyBhcyBUZXh0IGNvbnRlbnQgYW5kIFJlYWN0IGV4cGVjdHMgdG8gYmUgYWJsZSB0byBjb252ZXJ0IGNoaWxkcmVuIG9mIDx0aXRsZT4nICsgJyB0YWdzIHRvIGEgc2luZ2xlIHN0cmluZyB2YWx1ZS4nLCBjaGlsZFR5cGUpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZCAmJiBjaGlsZC50b1N0cmluZyA9PT0ge30udG9TdHJpbmcpIHtcbiAgICAgICAgaWYgKGNoaWxkLiQkdHlwZW9mICE9IG51bGwpIHtcbiAgICAgICAgICBlcnJvcignUmVhY3QgZXhwZWN0cyB0aGUgYGNoaWxkcmVuYCBwcm9wIG9mIDx0aXRsZT4gdGFncyB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBvciBvYmplY3Qgd2l0aCBhIG5vdmVsIGB0b1N0cmluZ2AgbWV0aG9kIGJ1dCBmb3VuZCBhbiBvYmplY3QgdGhhdCBhcHBlYXJzIHRvIGJlJyArICcgYSBSZWFjdCBlbGVtZW50IHdoaWNoIG5ldmVyIGltcGxlbWVudHMgYSBzdWl0YWJsZSBgdG9TdHJpbmdgIG1ldGhvZC4gQnJvd3NlcnMgdHJlYXQgYWxsIGNoaWxkIE5vZGVzIG9mIDx0aXRsZT4gdGFncyBhcyBUZXh0IGNvbnRlbnQgYW5kIFJlYWN0IGV4cGVjdHMgdG8nICsgJyBiZSBhYmxlIHRvIGNvbnZlcnQgY2hpbGRyZW4gb2YgPHRpdGxlPiB0YWdzIHRvIGEgc2luZ2xlIHN0cmluZyB2YWx1ZSB3aGljaCBpcyB3aHkgcmVuZGVyaW5nIFJlYWN0IGVsZW1lbnRzIGlzIG5vdCBzdXBwb3J0ZWQuIElmIHRoZSBgY2hpbGRyZW5gIG9mIDx0aXRsZT4gaXMnICsgJyBhIFJlYWN0IENvbXBvbmVudCB0cnkgbW92aW5nIHRoZSA8dGl0bGU+IHRhZyBpbnRvIHRoYXQgY29tcG9uZW50LiBJZiB0aGUgYGNoaWxkcmVuYCBvZiA8dGl0bGU+IGlzIHNvbWUgSFRNTCBtYXJrdXAgY2hhbmdlIGl0IHRvIGJlIFRleHQgb25seSB0byBiZSB2YWxpZCBIVE1MLicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9yKCdSZWFjdCBleHBlY3RzIHRoZSBgY2hpbGRyZW5gIHByb3Agb2YgPHRpdGxlPiB0YWdzIHRvIGJlIGEgc3RyaW5nLCBudW1iZXIsIG9yIG9iamVjdCB3aXRoIGEgbm92ZWwgYHRvU3RyaW5nYCBtZXRob2QgYnV0IGZvdW5kIGFuIG9iamVjdCB0aGF0IGRvZXMgbm90IGltcGxlbWVudCcgKyAnIGEgc3VpdGFibGUgYHRvU3RyaW5nYCBtZXRob2QuIEJyb3dzZXJzIHRyZWF0IGFsbCBjaGlsZCBOb2RlcyBvZiA8dGl0bGU+IHRhZ3MgYXMgVGV4dCBjb250ZW50IGFuZCBSZWFjdCBleHBlY3RzIHRvIGJlIGFibGUgdG8gY29udmVydCBjaGlsZHJlbiBvZiA8dGl0bGU+IHRhZ3MnICsgJyB0byBhIHNpbmdsZSBzdHJpbmcgdmFsdWUuIFVzaW5nIHRoZSBkZWZhdWx0IGB0b1N0cmluZ2AgbWV0aG9kIGF2YWlsYWJsZSBvbiBldmVyeSBvYmplY3QgaXMgYWxtb3N0IGNlcnRhaW5seSBhbiBlcnJvci4gQ29uc2lkZXIgd2hldGhlciB0aGUgYGNoaWxkcmVuYCBvZiB0aGlzIDx0aXRsZT4nICsgJyBpcyBhbiBvYmplY3QgaW4gZXJyb3IgYW5kIGNoYW5nZSBpdCB0byBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgaWYgc28uIE90aGVyd2lzZSBpbXBsZW1lbnQgYSBgdG9TdHJpbmdgIG1ldGhvZCB0aGF0IFJlYWN0IGNhbiB1c2UgdG8gcHJvZHVjZSBhIHZhbGlkIDx0aXRsZT4uJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKGluc2VydGlvbk1vZGUgIT09IFNWR19NT0RFICYmICFub3NjcmlwdFRhZ0luU2NvcGUgJiYgcHJvcHMuaXRlbVByb3AgPT0gbnVsbCkge1xuICAgICAgcHVzaFRpdGxlSW1wbChyZXNwb25zZVN0YXRlLmhvaXN0YWJsZUNodW5rcywgcHJvcHMpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwdXNoVGl0bGVJbXBsKHRhcmdldCwgcHJvcHMpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoVGl0bGVJbXBsKHRhcmdldCwgcHJvcHMpIHtcbiAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZygndGl0bGUnKSk7XG4gIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gIHZhciBpbm5lckhUTUwgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgdmFyIGNoaWxkID0gQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbi5sZW5ndGggPCAyID8gY2hpbGRyZW5bMF0gOiBudWxsIDogY2hpbGRyZW47XG5cbiAgaWYgKHR5cGVvZiBjaGlsZCAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY2hpbGQgIT09ICdzeW1ib2wnICYmIGNoaWxkICE9PSBudWxsICYmIGNoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgICB0YXJnZXQucHVzaChzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKCcnICsgY2hpbGQpKSk7XG4gIH1cblxuICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MLCBjaGlsZHJlbik7XG4gIHRhcmdldC5wdXNoKGVuZFRhZzEsIHN0cmluZ1RvQ2h1bmsoJ3RpdGxlJyksIGVuZFRhZzIpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHVzaFN0YXJ0SGVhZCh0YXJnZXQsIHByb3BzLCByZXNwb25zZVN0YXRlLCBpbnNlcnRpb25Nb2RlKSB7XG4gIHtcbiAgICBpZiAoaW5zZXJ0aW9uTW9kZSA8IEhUTUxfTU9ERSAmJiByZXNwb25zZVN0YXRlLmhlYWRDaHVua3MgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgPGhlYWQ+IGlzIHRoZSBEb2N1bWVudC5oZWFkIGFuZCBzaG91bGQgYmUgcGFydCBvZiB0aGUgcHJlYW1ibGVcbiAgICAgIHJlc3BvbnNlU3RhdGUuaGVhZENodW5rcyA9IFtdO1xuICAgICAgcmV0dXJuIHB1c2hTdGFydEdlbmVyaWNFbGVtZW50KHJlc3BvbnNlU3RhdGUuaGVhZENodW5rcywgcHJvcHMsICdoZWFkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgPGhlYWQ+IGlzIGRlZXAgYW5kIGlzIGxpa2VseSBqdXN0IGFuIGVycm9yLiB3ZSBlbWl0IGl0IGlubGluZSB0aG91Z2guXG4gICAgICAvLyBWYWxpZGF0aW9uIHNob3VsZCB3YXJuIHRoYXQgdGhpcyB0YWcgaXMgdGhlIHRoZSB3cm9uZyBzcG90LlxuICAgICAgcmV0dXJuIHB1c2hTdGFydEdlbmVyaWNFbGVtZW50KHRhcmdldCwgcHJvcHMsICdoZWFkJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hTdGFydEh0bWwodGFyZ2V0LCBwcm9wcywgcmVzcG9uc2VTdGF0ZSwgaW5zZXJ0aW9uTW9kZSkge1xuICB7XG4gICAgaWYgKGluc2VydGlvbk1vZGUgPT09IFJPT1RfSFRNTF9NT0RFICYmIHJlc3BvbnNlU3RhdGUuaHRtbENodW5rcyA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyA8aHRtbD4gaXMgdGhlIERvY3VtZW50LmRvY3VtZW50RWxlbWVudCBhbmQgc2hvdWxkIGJlIHBhcnQgb2YgdGhlIHByZWFtYmxlXG4gICAgICByZXNwb25zZVN0YXRlLmh0bWxDaHVua3MgPSBbRE9DVFlQRV07XG4gICAgICByZXR1cm4gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQocmVzcG9uc2VTdGF0ZS5odG1sQ2h1bmtzLCBwcm9wcywgJ2h0bWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyA8aHRtbD4gaXMgZGVlcCBhbmQgaXMgbGlrZWx5IGp1c3QgYW4gZXJyb3IuIHdlIGVtaXQgaXQgaW5saW5lIHRob3VnaC5cbiAgICAgIC8vIFZhbGlkYXRpb24gc2hvdWxkIHdhcm4gdGhhdCB0aGlzIHRhZyBpcyB0aGUgdGhlIHdyb25nIHNwb3QuXG4gICAgICByZXR1cm4gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQodGFyZ2V0LCBwcm9wcywgJ2h0bWwnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaFNjcmlwdCh0YXJnZXQsIHByb3BzLCByZXNvdXJjZXMsIHRleHRFbWJlZGRlZCwgaW5zZXJ0aW9uTW9kZSwgbm9zY3JpcHRUYWdJblNjb3BlKSB7XG4gIHtcbiAgICB2YXIgYXN5bmNQcm9wID0gcHJvcHMuYXN5bmM7XG5cbiAgICBpZiAodHlwZW9mIHByb3BzLnNyYyAhPT0gJ3N0cmluZycgfHwgIXByb3BzLnNyYyB8fCAhKGFzeW5jUHJvcCAmJiB0eXBlb2YgYXN5bmNQcm9wICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBhc3luY1Byb3AgIT09ICdzeW1ib2wnKSB8fCBwcm9wcy5vbkxvYWQgfHwgcHJvcHMub25FcnJvciB8fCBpbnNlcnRpb25Nb2RlID09PSBTVkdfTU9ERSB8fCBub3NjcmlwdFRhZ0luU2NvcGUgfHwgcHJvcHMuaXRlbVByb3AgIT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBzY3JpcHQgd2lsbCBub3QgYmUgYSByZXNvdXJjZSwgd2UgYmFpbG91dCBlYXJseSBhbmQgZW1pdCBpdCBpbiBwbGFjZS5cbiAgICAgIHJldHVybiBwdXNoU2NyaXB0SW1wbCh0YXJnZXQsIHByb3BzKTtcbiAgICB9XG5cbiAgICB2YXIgc3JjID0gcHJvcHMuc3JjO1xuICAgIHZhciBrZXkgPSBnZXRSZXNvdXJjZUtleSgnc2NyaXB0Jywgc3JjKTsgLy8gV2UgY2FuIG1ha2UgdGhpcyA8c2NyaXB0PiBpbnRvIGEgU2NyaXB0UmVzb3VyY2VcblxuICAgIHZhciByZXNvdXJjZSA9IHJlc291cmNlcy5zY3JpcHRzTWFwLmdldChrZXkpO1xuXG4gICAge1xuICAgICAgdmFyIGRldlJlc291cmNlID0gZ2V0QXNSZXNvdXJjZURFVihyZXNvdXJjZSk7XG5cbiAgICAgIGlmIChkZXZSZXNvdXJjZSkge1xuICAgICAgICBzd2l0Y2ggKGRldlJlc291cmNlLl9fcHJvdmVuYW5jZSkge1xuICAgICAgICAgIGNhc2UgJ3JlbmRlcmVkJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGRpZmZlcmVuY2VEZXNjcmlwdGlvbiA9IGRlc2NyaWJlRGlmZmVyZW5jZXNGb3JTY3JpcHRzKCAvLyBEaWZmIHRoZSBwcm9wcyBmcm9tIHRoZSBKU1ggZWxlbWVudCwgbm90IHRoZSBkZXJpdmVkIHJlc291cmNlIHByb3BzXG4gICAgICAgICAgICAgIHByb3BzLCBkZXZSZXNvdXJjZS5fX29yaWdpbmFsUHJvcHMpO1xuXG4gICAgICAgICAgICAgIGlmIChkaWZmZXJlbmNlRGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICBlcnJvcignUmVhY3QgZW5jb3VudGVyZWQgYSA8c2NyaXB0IGFzeW5jPXt0cnVlfSBzcmM9XCIlc1wiIC4uLi8+IHRoYXQgaGFzIHByb3BzIHRoYXQgY29uZmxpY3QnICsgJyB3aXRoIGFub3RoZXIgaG9pc3RhYmxlIHNjcmlwdCB3aXRoIHRoZSBzYW1lIGBzcmNgLiBXaGVuIHJlbmRlcmluZyBob2lzdGFibGUgc2NyaXB0cyAoYXN5bmMgc2NyaXB0cyB3aXRob3V0IGFueSBsb2FkaW5nIGhhbmRsZXJzKScgKyAnIHRoZSBwcm9wcyBmcm9tIHRoZSBmaXJzdCBlbmNvdW50ZXJlZCBpbnN0YW5jZSB3aWxsIGJlIHVzZWQgYW5kIHByb3BzIGZyb20gbGF0ZXIgaW5zdGFuY2VzIHdpbGwgYmUgaWdub3JlZC4nICsgJyBVcGRhdGUgdGhlIHByb3BzIG9uIGJvdGggPHNjcmlwdCBhc3luYz17dHJ1ZX0gLi4uLz4gaW5zdGFuY2Ugc28gdGhleSBhZ3JlZS4lcycsIHNyYywgZGlmZmVyZW5jZURlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAncHJlaW5pdCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBfZGlmZmVyZW5jZURlc2NyaXB0aW9uMiA9IGRlc2NyaWJlRGlmZmVyZW5jZXNGb3JTY3JpcHRPdmVyUHJlaW5pdCggLy8gRGlmZiB0aGUgcHJvcHMgZnJvbSB0aGUgSlNYIGVsZW1lbnQsIG5vdCB0aGUgZGVyaXZlZCByZXNvdXJjZSBwcm9wc1xuICAgICAgICAgICAgICBwcm9wcywgZGV2UmVzb3VyY2UuX19wcm9wc0VxdWl2YWxlbnQpO1xuXG4gICAgICAgICAgICAgIGlmIChfZGlmZmVyZW5jZURlc2NyaXB0aW9uMikge1xuICAgICAgICAgICAgICAgIGVycm9yKCdSZWFjdCBlbmNvdW50ZXJlZCBhIDxzY3JpcHQgYXN5bmM9e3RydWV9IHNyYz1cIiVzXCIgLi4uLz4gd2l0aCBwcm9wcyB0aGF0IGNvbmZsaWN0JyArICcgd2l0aCB0aGUgb3B0aW9ucyBwcm92aWRlZCB0byBgUmVhY3RET00ucHJlaW5pdChcIiVzXCIsIHsgYXM6IFwic2NyaXB0XCIsIC4uLiB9KWAuIFJlYWN0IHdpbGwgdXNlIHRoZSBmaXJzdCBwcm9wcyBvciBwcmVpbml0aWFsaXphdGlvbicgKyAnIG9wdGlvbnMgZW5jb3VudGVyZWQgd2hlbiByZW5kZXJpbmcgYSBob2lzdGFibGUgc2NyaXB0IHdpdGggYSBwYXJ0aWN1bGFyIGBzcmNgIGFuZCB3aWxsIGlnbm9yZSBhbnkgbmV3ZXIgcHJvcHMgb3InICsgJyBvcHRpb25zLiBUaGUgZmlyc3QgaW5zdGFuY2Ugb2YgdGhpcyBzY3JpcHQgcmVzb3VyY2Ugd2FzIGNyZWF0ZWQgdXNpbmcgdGhlIGBSZWFjdERPTS5wcmVpbml0KClgIGZ1bmN0aW9uLicgKyAnIFBsZWFzZSBub3RlLCBgUmVhY3RET00ucHJlaW5pdCgpYCBpcyBtb2RlbGVkIG9mZiBvZiBtb2R1bGUgaW1wb3J0IGFzc2VydGlvbnMgY2FwYWJpbGl0aWVzIGFuZCBkb2VzIG5vdCBzdXBwb3J0JyArICcgYXJiaXRyYXJ5IHByb3BzLiBJZiB5b3UgbmVlZCB0byBoYXZlIHByb3BzIG5vdCBpbmNsdWRlZCB3aXRoIHRoZSBwcmVpbml0IG9wdGlvbnMgeW91IHdpbGwgbmVlZCB0byByZWx5IG9uIHJlbmRlcmluZycgKyAnIDxzY3JpcHQ+IHRhZ3Mgb25seS4lcycsIHNyYywgc3JjLCBfZGlmZmVyZW5jZURlc2NyaXB0aW9uMik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcmVzb3VyY2UpIHtcbiAgICAgIHJlc291cmNlID0ge1xuICAgICAgICB0eXBlOiAnc2NyaXB0JyxcbiAgICAgICAgY2h1bmtzOiBbXSxcbiAgICAgICAgc3RhdGU6IE5vU3RhdGUsXG4gICAgICAgIHByb3BzOiBudWxsXG4gICAgICB9O1xuICAgICAgcmVzb3VyY2VzLnNjcmlwdHNNYXAuc2V0KGtleSwgcmVzb3VyY2UpO1xuXG4gICAgICB7XG4gICAgICAgIG1hcmtBc1JlbmRlcmVkUmVzb3VyY2VERVYocmVzb3VyY2UsIHByb3BzKTtcbiAgICAgIH0gLy8gQWRkIHRvIHRoZSBzY3JpcHQgZmx1c2hpbmcgcXVldWVcblxuXG4gICAgICByZXNvdXJjZXMuc2NyaXB0cy5hZGQocmVzb3VyY2UpO1xuICAgICAgdmFyIHNjcmlwdFByb3BzID0gcHJvcHM7XG4gICAgICB2YXIgcHJlbG9hZFJlc291cmNlID0gcmVzb3VyY2VzLnByZWxvYWRzTWFwLmdldChrZXkpO1xuXG4gICAgICBpZiAocHJlbG9hZFJlc291cmNlKSB7XG4gICAgICAgIC8vIElmIHdlIGFscmVhZHkgaGFkIGEgcHJlbG9hZCB3ZSBkb24ndCB3YW50IHRoYXQgcmVzb3VyY2UgdG8gZmx1c2ggZGlyZWN0bHkuXG4gICAgICAgIC8vIFdlIGxldCB0aGUgbmV3bHkgY3JlYXRlZCByZXNvdXJjZSBnb3Zlcm4gZmx1c2hpbmcuXG4gICAgICAgIHByZWxvYWRSZXNvdXJjZS5zdGF0ZSB8PSBCbG9ja2VkO1xuICAgICAgICBzY3JpcHRQcm9wcyA9IGFzc2lnbih7fSwgcHJvcHMpO1xuICAgICAgICBhZG9wdFByZWxvYWRQcm9wc0ZvclNjcmlwdFByb3BzKHNjcmlwdFByb3BzLCBwcmVsb2FkUmVzb3VyY2UucHJvcHMpO1xuICAgICAgfSAvLyBlbmNvZGUgdGhlIHRhZyBhcyBDaHVua3NcblxuXG4gICAgICBwdXNoU2NyaXB0SW1wbChyZXNvdXJjZS5jaHVua3MsIHNjcmlwdFByb3BzKTtcbiAgICB9XG5cbiAgICBpZiAodGV4dEVtYmVkZGVkKSB7XG4gICAgICAvLyBUaGlzIHNjcmlwdCBmb2xsb3dzIHRleHQgYnV0IHdlIGFyZW4ndCB3cml0aW5nIGEgdGFnLiB3aGlsZSBub3QgYXMgZWZmaWNpZW50IGFzIHBvc3NpYmxlIHdlIG5lZWRcbiAgICAgIC8vIHRvIGJlIHNhZmUgYW5kIGFzc3VtZSB0ZXh0IHdpbGwgZm9sbG93IGJ5IGluc2VydGluZyBhIHRleHRTZXBhcmF0b3JcbiAgICAgIHRhcmdldC5wdXNoKHRleHRTZXBhcmF0b3IpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hTY3JpcHRJbXBsKHRhcmdldCwgcHJvcHMpIHtcbiAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZygnc2NyaXB0JykpO1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICB2YXIgaW5uZXJIVE1MID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG5cbiAge1xuICAgIGlmIChjaGlsZHJlbiAhPSBudWxsICYmIHR5cGVvZiBjaGlsZHJlbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBkZXNjcmlwdGl2ZVN0YXRlbWVudCA9IHR5cGVvZiBjaGlsZHJlbiA9PT0gJ251bWJlcicgPyAnYSBudW1iZXIgZm9yIGNoaWxkcmVuJyA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gJ2FuIGFycmF5IGZvciBjaGlsZHJlbicgOiAnc29tZXRoaW5nIHVuZXhwZWN0ZWQgZm9yIGNoaWxkcmVuJztcblxuICAgICAgZXJyb3IoJ0Egc2NyaXB0IGVsZW1lbnQgd2FzIHJlbmRlcmVkIHdpdGggJXMuIElmIHNjcmlwdCBlbGVtZW50IGhhcyBjaGlsZHJlbiBpdCBtdXN0IGJlIGEgc2luZ2xlIHN0cmluZy4nICsgJyBDb25zaWRlciB1c2luZyBkYW5nZXJvdXNseVNldElubmVySFRNTCBvciBwYXNzaW5nIGEgcGxhaW4gc3RyaW5nIGFzIGNoaWxkcmVuLicsIGRlc2NyaXB0aXZlU3RhdGVtZW50KTtcbiAgICB9XG4gIH1cblxuICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MLCBjaGlsZHJlbik7XG5cbiAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZycpIHtcbiAgICB0YXJnZXQucHVzaChzdHJpbmdUb0NodW5rKGVuY29kZUhUTUxUZXh0Tm9kZShjaGlsZHJlbikpKTtcbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZFRhZzEsIHN0cmluZ1RvQ2h1bmsoJ3NjcmlwdCcpLCBlbmRUYWcyKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHB1c2hTdGFydEdlbmVyaWNFbGVtZW50KHRhcmdldCwgcHJvcHMsIHRhZykge1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKHRhZykpO1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICB2YXIgaW5uZXJIVE1MID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcblxuICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJykge1xuICAgIC8vIFNwZWNpYWwgY2FzZSBjaGlsZHJlbiBhcyBhIHN0cmluZyB0byBhdm9pZCB0aGUgdW5uZWNlc3NhcnkgY29tbWVudC5cbiAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBzcGVjaWFsIGNhc2UgYWZ0ZXIgdGhlIGdlbmVyYWwgb3B0aW1pemF0aW9uIGlzIGluIHBsYWNlLlxuICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoZW5jb2RlSFRNTFRleHROb2RlKGNoaWxkcmVuKSkpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBwdXNoU3RhcnRDdXN0b21FbGVtZW50KHRhcmdldCwgcHJvcHMsIHRhZykge1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKHRhZykpO1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICB2YXIgaW5uZXJIVE1MID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3N0eWxlJzpcbiAgICAgICAgICBwdXNoU3R5bGVBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyc6XG4gICAgICAgIGNhc2UgJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZyc6XG4gICAgICAgICAgLy8gSWdub3JlZC4gVGhlc2UgYXJlIGJ1aWx0LWluIHRvIFJlYWN0IG9uIHRoZSBjbGllbnQuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoaXNBdHRyaWJ1dGVOYW1lU2FmZShwcm9wS2V5KSAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIHN0cmluZ1RvQ2h1bmsocHJvcEtleSksIGF0dHJpYnV0ZUFzc2lnbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcihwcm9wVmFsdWUpKSwgYXR0cmlidXRlRW5kKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbnZhciBsZWFkaW5nTmV3bGluZSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXFxuJyk7XG5cbmZ1bmN0aW9uIHB1c2hTdGFydFByZWZvcm1hdHRlZEVsZW1lbnQodGFyZ2V0LCBwcm9wcywgdGFnKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcodGFnKSk7XG4gIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gIHZhciBpbm5lckhUTUwgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTsgLy8gdGV4dC9odG1sIGlnbm9yZXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGVzZSB0YWdzIGlmIGl0J3MgYSBuZXdsaW5lXG4gIC8vIFByZWZlciB0byBicmVhayBhcHBsaWNhdGlvbi94bWwgb3ZlciB0ZXh0L2h0bWwgKGZvciBub3cpIGJ5IGFkZGluZ1xuICAvLyBhIG5ld2xpbmUgc3BlY2lmaWNhbGx5IHRvIGdldCBlYXRlbiBieSB0aGUgcGFyc2VyLiAoQWx0ZXJuYXRlbHkgZm9yXG4gIC8vIHRleHRhcmVhcywgcmVwbGFjaW5nIFwiXlxcblwiIHdpdGggXCJcXHJcXG5cIiBkb2Vzbid0IGdldCBlYXRlbiwgYW5kIHRoZSBmaXJzdFxuICAvLyBcXHIgaXMgbm9ybWFsaXplZCBvdXQgYnkgSFRNTFRleHRBcmVhRWxlbWVudCN2YWx1ZS4pXG4gIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWwtcG9seWdsb3QvI25ld2xpbmVzLWluLXRleHRhcmVhLWFuZC1wcmU+XG4gIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI2VsZW1lbnQtcmVzdHJpY3Rpb25zPlxuICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNuZXdsaW5lcz5cbiAgLy8gU2VlOiBQYXJzaW5nIG9mIFwidGV4dGFyZWFcIiBcImxpc3RpbmdcIiBhbmQgXCJwcmVcIiBlbGVtZW50c1xuICAvLyAgZnJvbSA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keT5cbiAgLy8gVE9ETzogVGhpcyBkb2Vzbid0IGRlYWwgd2l0aCB0aGUgY2FzZSB3aGVyZSB0aGUgY2hpbGQgaXMgYW4gYXJyYXlcbiAgLy8gb3IgY29tcG9uZW50IHRoYXQgcmV0dXJucyBhIHN0cmluZy5cblxuICBpZiAoaW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGlubmVySFRNTCAhPT0gJ29iamVjdCcgfHwgISgnX19odG1sJyBpbiBpbm5lckhUTUwpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Bwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuICcgKyAnUGxlYXNlIHZpc2l0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9kYW5nZXJvdXNseS1zZXQtaW5uZXItaHRtbCAnICsgJ2ZvciBtb3JlIGluZm9ybWF0aW9uLicpO1xuICAgIH1cblxuICAgIHZhciBodG1sID0gaW5uZXJIVE1MLl9faHRtbDtcblxuICAgIGlmIChodG1sICE9PSBudWxsICYmIGh0bWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBodG1sID09PSAnc3RyaW5nJyAmJiBodG1sLmxlbmd0aCA+IDAgJiYgaHRtbFswXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgdGFyZ2V0LnB1c2gobGVhZGluZ05ld2xpbmUsIHN0cmluZ1RvQ2h1bmsoaHRtbCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKGh0bWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuaygnJyArIGh0bWwpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJyAmJiBjaGlsZHJlblswXSA9PT0gJ1xcbicpIHtcbiAgICB0YXJnZXQucHVzaChsZWFkaW5nTmV3bGluZSk7XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59IC8vIFdlIGFjY2VwdCBhbnkgdGFnIHRvIGJlIHJlbmRlcmVkIGJ1dCBzaW5jZSB0aGlzIGdldHMgaW5qZWN0ZWQgaW50byBhcmJpdHJhcnlcbi8vIEhUTUwsIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgaXQncyBhIHNhZmUgdGFnLlxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC8jTlQtTmFtZVxuXG5cbnZhciBWQUxJRF9UQUdfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWjpfXFwuXFwtXFxkXSokLzsgLy8gU2ltcGxpZmllZCBzdWJzZXRcblxudmFyIHZhbGlkYXRlZFRhZ0NhY2hlID0gbmV3IE1hcCgpO1xuXG5mdW5jdGlvbiBzdGFydENodW5rRm9yVGFnKHRhZykge1xuICB2YXIgdGFnU3RhcnRDaHVuayA9IHZhbGlkYXRlZFRhZ0NhY2hlLmdldCh0YWcpO1xuXG4gIGlmICh0YWdTdGFydENodW5rID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoIVZBTElEX1RBR19SRUdFWC50ZXN0KHRhZykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdGFnOiBcIiArIHRhZyk7XG4gICAgfVxuXG4gICAgdGFnU3RhcnRDaHVuayA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPCcgKyB0YWcpO1xuICAgIHZhbGlkYXRlZFRhZ0NhY2hlLnNldCh0YWcsIHRhZ1N0YXJ0Q2h1bmspO1xuICB9XG5cbiAgcmV0dXJuIHRhZ1N0YXJ0Q2h1bms7XG59XG5cbnZhciBET0NUWVBFID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8IURPQ1RZUEUgaHRtbD4nKTtcbmZ1bmN0aW9uIHB1c2hTdGFydEluc3RhbmNlKHRhcmdldCwgdHlwZSwgcHJvcHMsIHJlc291cmNlcywgcmVzcG9uc2VTdGF0ZSwgZm9ybWF0Q29udGV4dCwgdGV4dEVtYmVkZGVkKSB7XG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcywgbnVsbCk7XG5cbiAgICBpZiAoIXByb3BzLnN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyAmJiBwcm9wcy5jb250ZW50RWRpdGFibGUgJiYgcHJvcHMuY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ0EgY29tcG9uZW50IGlzIGBjb250ZW50RWRpdGFibGVgIGFuZCBjb250YWlucyBgY2hpbGRyZW5gIG1hbmFnZWQgYnkgJyArICdSZWFjdC4gSXQgaXMgbm93IHlvdXIgcmVzcG9uc2liaWxpdHkgdG8gZ3VhcmFudGVlIHRoYXQgbm9uZSBvZiAnICsgJ3Rob3NlIG5vZGVzIGFyZSB1bmV4cGVjdGVkbHkgbW9kaWZpZWQgb3IgZHVwbGljYXRlZC4gVGhpcyBpcyAnICsgJ3Byb2JhYmx5IG5vdCBpbnRlbnRpb25hbC4nKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlICE9PSBTVkdfTU9ERSAmJiBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgIT09IE1BVEhNTF9NT0RFKSB7XG4gICAgICBpZiAodHlwZS5pbmRleE9mKCctJykgPT09IC0xICYmIHR5cGUudG9Mb3dlckNhc2UoKSAhPT0gdHlwZSkge1xuICAgICAgICBlcnJvcignPCVzIC8+IGlzIHVzaW5nIGluY29ycmVjdCBjYXNpbmcuICcgKyAnVXNlIFBhc2NhbENhc2UgZm9yIFJlYWN0IGNvbXBvbmVudHMsICcgKyAnb3IgbG93ZXJjYXNlIGZvciBIVE1MIGVsZW1lbnRzLicsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2Rpdic6XG4gICAgY2FzZSAnc3Bhbic6XG4gICAgY2FzZSAnc3ZnJzpcbiAgICBjYXNlICdwYXRoJzpcbiAgICBjYXNlICdhJzpcbiAgICBjYXNlICdnJzpcbiAgICBjYXNlICdwJzpcbiAgICBjYXNlICdsaSc6XG4gICAgICAvLyBGYXN0IHRyYWNrIHZlcnkgY29tbW9uIHRhZ3NcbiAgICAgIGJyZWFrO1xuICAgIC8vIFNwZWNpYWwgdGFnc1xuXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHJldHVybiBwdXNoU3RhcnRTZWxlY3QodGFyZ2V0LCBwcm9wcyk7XG5cbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgcmV0dXJuIHB1c2hTdGFydE9wdGlvbih0YXJnZXQsIHByb3BzLCBmb3JtYXRDb250ZXh0KTtcblxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHJldHVybiBwdXNoU3RhcnRUZXh0QXJlYSh0YXJnZXQsIHByb3BzKTtcblxuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIHJldHVybiBwdXNoSW5wdXQodGFyZ2V0LCBwcm9wcywgcmVzcG9uc2VTdGF0ZSk7XG5cbiAgICBjYXNlICdidXR0b24nOlxuICAgICAgcmV0dXJuIHB1c2hTdGFydEJ1dHRvbih0YXJnZXQsIHByb3BzLCByZXNwb25zZVN0YXRlKTtcblxuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgcmV0dXJuIHB1c2hTdGFydEZvcm0odGFyZ2V0LCBwcm9wcyk7XG5cbiAgICBjYXNlICdtZW51aXRlbSc6XG4gICAgICByZXR1cm4gcHVzaFN0YXJ0TWVudUl0ZW0odGFyZ2V0LCBwcm9wcyk7XG5cbiAgICBjYXNlICd0aXRsZSc6XG4gICAgICByZXR1cm4gcHVzaFRpdGxlKHRhcmdldCwgcHJvcHMsIHJlc3BvbnNlU3RhdGUsIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSwgZm9ybWF0Q29udGV4dC5ub3NjcmlwdFRhZ0luU2NvcGUpIDtcblxuICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgcmV0dXJuIHB1c2hMaW5rKHRhcmdldCwgcHJvcHMsIHJlc3BvbnNlU3RhdGUsIHJlc291cmNlcywgdGV4dEVtYmVkZGVkLCBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUsIGZvcm1hdENvbnRleHQubm9zY3JpcHRUYWdJblNjb3BlKTtcblxuICAgIGNhc2UgJ3NjcmlwdCc6XG4gICAgICByZXR1cm4gcHVzaFNjcmlwdCh0YXJnZXQsIHByb3BzLCByZXNvdXJjZXMsIHRleHRFbWJlZGRlZCwgZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlLCBmb3JtYXRDb250ZXh0Lm5vc2NyaXB0VGFnSW5TY29wZSkgO1xuXG4gICAgY2FzZSAnc3R5bGUnOlxuICAgICAgcmV0dXJuIHB1c2hTdHlsZSh0YXJnZXQsIHByb3BzLCByZXNvdXJjZXMsIHRleHRFbWJlZGRlZCwgZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlLCBmb3JtYXRDb250ZXh0Lm5vc2NyaXB0VGFnSW5TY29wZSk7XG5cbiAgICBjYXNlICdtZXRhJzpcbiAgICAgIHJldHVybiBwdXNoTWV0YSh0YXJnZXQsIHByb3BzLCByZXNwb25zZVN0YXRlLCB0ZXh0RW1iZWRkZWQsIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSwgZm9ybWF0Q29udGV4dC5ub3NjcmlwdFRhZ0luU2NvcGUpO1xuICAgIC8vIE5ld2xpbmUgZWF0aW5nIHRhZ3NcblxuICAgIGNhc2UgJ2xpc3RpbmcnOlxuICAgIGNhc2UgJ3ByZSc6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBwdXNoU3RhcnRQcmVmb3JtYXR0ZWRFbGVtZW50KHRhcmdldCwgcHJvcHMsIHR5cGUpO1xuICAgICAgfVxuXG4gICAgY2FzZSAnaW1nJzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHB1c2hJbWcodGFyZ2V0LCBwcm9wcywgcmVzb3VyY2VzKSA7XG4gICAgICB9XG4gICAgLy8gT21pdHRlZCBjbG9zZSB0YWdzXG5cbiAgICBjYXNlICdiYXNlJzpcbiAgICBjYXNlICdhcmVhJzpcbiAgICBjYXNlICdicic6XG4gICAgY2FzZSAnY29sJzpcbiAgICBjYXNlICdlbWJlZCc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2tleWdlbic6XG4gICAgY2FzZSAncGFyYW0nOlxuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgY2FzZSAndHJhY2snOlxuICAgIGNhc2UgJ3dicic6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBwdXNoU2VsZkNsb3NpbmcodGFyZ2V0LCBwcm9wcywgdHlwZSk7XG4gICAgICB9XG4gICAgLy8gVGhlc2UgYXJlIHJlc2VydmVkIFNWRyBhbmQgTWF0aE1MIGVsZW1lbnRzLCB0aGF0IGFyZSBuZXZlciBjdXN0b20gZWxlbWVudHMuXG4gICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9jdXN0b20vI2N1c3RvbS1lbGVtZW50cy1jb3JlLWNvbmNlcHRzXG5cbiAgICBjYXNlICdhbm5vdGF0aW9uLXhtbCc6XG4gICAgY2FzZSAnY29sb3ItcHJvZmlsZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlJzpcbiAgICBjYXNlICdmb250LWZhY2Utc3JjJzpcbiAgICBjYXNlICdmb250LWZhY2UtdXJpJzpcbiAgICBjYXNlICdmb250LWZhY2UtZm9ybWF0JzpcbiAgICBjYXNlICdmb250LWZhY2UtbmFtZSc6XG4gICAgY2FzZSAnbWlzc2luZy1nbHlwaCc6XG4gICAgICB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIC8vIFByZWFtYmxlIHN0YXJ0IHRhZ3NcblxuICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgcmV0dXJuIHB1c2hTdGFydEhlYWQodGFyZ2V0LCBwcm9wcywgcmVzcG9uc2VTdGF0ZSwgZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlKTtcblxuICAgIGNhc2UgJ2h0bWwnOlxuICAgICAge1xuICAgICAgICByZXR1cm4gcHVzaFN0YXJ0SHRtbCh0YXJnZXQsIHByb3BzLCByZXNwb25zZVN0YXRlLCBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUpO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGUuaW5kZXhPZignLScpICE9PSAtMSkge1xuICAgICAgICAgIC8vIEN1c3RvbSBlbGVtZW50XG4gICAgICAgICAgcmV0dXJuIHB1c2hTdGFydEN1c3RvbUVsZW1lbnQodGFyZ2V0LCBwcm9wcywgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfSAvLyBHZW5lcmljIGVsZW1lbnRcblxuXG4gIHJldHVybiBwdXNoU3RhcnRHZW5lcmljRWxlbWVudCh0YXJnZXQsIHByb3BzLCB0eXBlKTtcbn1cbnZhciBlbmRUYWcxID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8LycpO1xudmFyIGVuZFRhZzIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJz4nKTtcbmZ1bmN0aW9uIHB1c2hFbmRJbnN0YW5jZSh0YXJnZXQsIHR5cGUsIHByb3BzLCByZXNwb25zZVN0YXRlLCBmb3JtYXRDb250ZXh0KSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIC8vIFdoZW4gZmxvYXQgaXMgb24gd2UgZXhwZWN0IHRpdGxlIGFuZCBzY3JpcHQgdGFncyB0byBhbHdheXMgYmUgcHVzaGVkIGluXG4gICAgLy8gYSB1bml0IGFuZCBuZXZlciByZXR1cm4gY2hpbGRyZW4uIHdoZW4gd2UgZW5kIHVwIHB1c2hpbmcgdGhlIGVuZCB0YWcgd2VcbiAgICAvLyB3YW50IHRvIGVuc3VyZSB0aGVyZSBpcyBubyBleHRyYSBjbG9zaW5nIHRhZyBwdXNoZWRcbiAgICBjYXNlICd0aXRsZSc6XG4gICAgY2FzZSAnc3R5bGUnOlxuICAgIGNhc2UgJ3NjcmlwdCc6XG4gICAgLy8gT21pdHRlZCBjbG9zZSB0YWdzXG4gICAgLy8gVE9ETzogSW5zdGVhZCBvZiByZXBlYXRpbmcgdGhpcyBzd2l0Y2ggd2UgY291bGQgdHJ5IHRvIHBhc3MgYSBmbGFnIGZyb20gYWJvdmUuXG4gICAgLy8gVGhhdCB3b3VsZCByZXF1aXJlIHJldHVybmluZyBhIHR1cGxlLiBXaGljaCBtaWdodCBiZSBvayBpZiBpdCBnZXRzIGlubGluZWQuXG5cbiAgICBjYXNlICdhcmVhJzpcbiAgICBjYXNlICdiYXNlJzpcbiAgICBjYXNlICdicic6XG4gICAgY2FzZSAnY29sJzpcbiAgICBjYXNlICdlbWJlZCc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2ltZyc6XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgIGNhc2UgJ2tleWdlbic6XG4gICAgY2FzZSAnbGluayc6XG4gICAgY2FzZSAnbWV0YSc6XG4gICAgY2FzZSAncGFyYW0nOlxuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgY2FzZSAndHJhY2snOlxuICAgIGNhc2UgJ3dicic6XG4gICAgICB7XG4gICAgICAgIC8vIE5vIGNsb3NlIHRhZyBuZWVkZWQuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAvLyBQb3N0YW1ibGUgZW5kIHRhZ3NcbiAgICAvLyBXaGVuIGZsb2F0IGlzIGVuYWJsZWQgd2Ugb21pdCB0aGUgZW5kIHRhZ3MgZm9yIGJvZHkgYW5kIGh0bWwgd2hlblxuICAgIC8vIHRoZXkgcmVwcmVzZW50IHRoZSBEb2N1bWVudC5ib2R5IGFuZCBEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgTm9kZXMuXG4gICAgLy8gVGhpcyBpcyBzbyB3ZSBjYW4gd2l0aGhvbGQgdGhlbSB1bnRpbCB0aGUgcG9zdGFtYmxlIHdoZW4gd2Uga25vd1xuICAgIC8vIHdlIHdvbid0IGVtaXQgYW55IG1vcmUgdGFnc1xuXG4gICAgY2FzZSAnYm9keSc6XG4gICAgICB7XG4gICAgICAgIGlmIChmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgPD0gSFRNTF9IVE1MX01PREUpIHtcbiAgICAgICAgICByZXNwb25zZVN0YXRlLmhhc0JvZHkgPSB0cnVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnaHRtbCc6XG4gICAgICBpZiAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlID09PSBST09UX0hUTUxfTU9ERSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kVGFnMSwgc3RyaW5nVG9DaHVuayh0eXBlKSwgZW5kVGFnMik7XG59XG5cbmZ1bmN0aW9uIHdyaXRlQm9vdHN0cmFwKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlKSB7XG4gIHZhciBib290c3RyYXBDaHVua3MgPSByZXNwb25zZVN0YXRlLmJvb3RzdHJhcENodW5rcztcbiAgdmFyIGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgYm9vdHN0cmFwQ2h1bmtzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGJvb3RzdHJhcENodW5rc1tpXSk7XG4gIH1cblxuICBpZiAoaSA8IGJvb3RzdHJhcENodW5rcy5sZW5ndGgpIHtcbiAgICB2YXIgbGFzdENodW5rID0gYm9vdHN0cmFwQ2h1bmtzW2ldO1xuICAgIGJvb3RzdHJhcENodW5rcy5sZW5ndGggPSAwO1xuICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBsYXN0Q2h1bmspO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdyaXRlQ29tcGxldGVkUm9vdChkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZSkge1xuICByZXR1cm4gd3JpdGVCb290c3RyYXAoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUpO1xufSAvLyBTdHJ1Y3R1cmFsIE5vZGVzXG4vLyBBIHBsYWNlaG9sZGVyIGlzIGEgbm9kZSBpbnNpZGUgYSBoaWRkZW4gcGFydGlhbCB0cmVlIHRoYXQgY2FuIGJlIGZpbGxlZCBpbiBsYXRlciwgYnV0IGJlZm9yZVxuLy8gZGlzcGxheS4gSXQncyBuZXZlciB2aXNpYmxlIHRvIHVzZXJzLiBXZSB1c2UgdGhlIHRlbXBsYXRlIHRhZyBiZWNhdXNlIGl0IGNhbiBiZSB1c2VkIGluIGV2ZXJ5XG4vLyB0eXBlIG9mIHBhcmVudC4gPHNjcmlwdD4gdGFncyBhbHNvIHdvcmsgaW4gZXZlcnkgb3RoZXIgdGFnIGV4Y2VwdCA8Y29sZ3JvdXA+LlxuXG52YXIgcGxhY2Vob2xkZXIxID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGVtcGxhdGUgaWQ9XCInKTtcbnZhciBwbGFjZWhvbGRlcjIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPjwvdGVtcGxhdGU+Jyk7XG5mdW5jdGlvbiB3cml0ZVBsYWNlaG9sZGVyKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlLCBpZCkge1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBwbGFjZWhvbGRlcjEpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlLnBsYWNlaG9sZGVyUHJlZml4KTtcbiAgdmFyIGZvcm1hdHRlZElEID0gc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBmb3JtYXR0ZWRJRCk7XG4gIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBwbGFjZWhvbGRlcjIpO1xufSAvLyBTdXNwZW5zZSBib3VuZGFyaWVzIGFyZSBlbmNvZGVkIGFzIGNvbW1lbnRzLlxuXG52YXIgc3RhcnRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8IS0tJC0tPicpO1xudmFyIHN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkxID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8IS0tJD8tLT48dGVtcGxhdGUgaWQ9XCInKTtcbnZhciBzdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5MiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+PC90ZW1wbGF0ZT4nKTtcbnZhciBzdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPCEtLSQhLS0+Jyk7XG52YXIgZW5kU3VzcGVuc2VCb3VuZGFyeSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPCEtLS8kLS0+Jyk7XG52YXIgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGVtcGxhdGUnKTtcbnZhciBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiJyk7XG52YXIgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnIGRhdGEtZGdzdD1cIicpO1xudmFyIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyBkYXRhLW1zZz1cIicpO1xudmFyIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUMgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyBkYXRhLXN0Y2s9XCInKTtcbnZhciBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJz48L3RlbXBsYXRlPicpO1xuZnVuY3Rpb24gd3JpdGVTdGFydENvbXBsZXRlZFN1c3BlbnNlQm91bmRhcnkkMShkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZSkge1xuICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5KTtcbn1cbmZ1bmN0aW9uIHdyaXRlU3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZSwgaWQpIHtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTEpO1xuXG4gIGlmIChpZCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQW4gSUQgbXVzdCBoYXZlIGJlZW4gYXNzaWduZWQgYmVmb3JlIHdlIGNhbiBjb21wbGV0ZSB0aGUgYm91bmRhcnkuJyk7XG4gIH1cblxuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBpZCk7XG4gIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5Mik7XG59XG5mdW5jdGlvbiB3cml0ZVN0YXJ0Q2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5JDEoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUsIGVycm9yRGlnZXN0LCBlcnJvck1lc3NzYWdlLCBlcnJvckNvbXBvbmVudFN0YWNrKSB7XG4gIHZhciByZXN1bHQ7XG4gIHJlc3VsdCA9IHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0Q2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5KTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxKTtcblxuICBpZiAoZXJyb3JEaWdlc3QpIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFBKTtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGVycm9yRGlnZXN0KSkpO1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yQXR0ckludGVyc3RpdGlhbCk7XG4gIH1cblxuICB7XG4gICAgaWYgKGVycm9yTWVzc3NhZ2UpIHtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUIpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihlcnJvck1lc3NzYWdlKSkpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3JBdHRySW50ZXJzdGl0aWFsKTtcbiAgICB9XG5cbiAgICBpZiAoZXJyb3JDb21wb25lbnRTdGFjaykge1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQyk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGVycm9yQ29tcG9uZW50U3RhY2spKSk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWwpO1xuICAgIH1cbiAgfVxuXG4gIHJlc3VsdCA9IHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB3cml0ZUVuZENvbXBsZXRlZFN1c3BlbnNlQm91bmRhcnkkMShkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZSkge1xuICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU3VzcGVuc2VCb3VuZGFyeSk7XG59XG5mdW5jdGlvbiB3cml0ZUVuZFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlKSB7XG4gIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTdXNwZW5zZUJvdW5kYXJ5KTtcbn1cbmZ1bmN0aW9uIHdyaXRlRW5kQ2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5JDEoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUpIHtcbiAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFN1c3BlbnNlQm91bmRhcnkpO1xufVxudmFyIHN0YXJ0U2VnbWVudEhUTUwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxkaXYgaGlkZGVuIGlkPVwiJyk7XG52YXIgc3RhcnRTZWdtZW50SFRNTDIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpO1xudmFyIGVuZFNlZ21lbnRIVE1MID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L2Rpdj4nKTtcbnZhciBzdGFydFNlZ21lbnRTVkcgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmVcIiBpZD1cIicpO1xudmFyIHN0YXJ0U2VnbWVudFNWRzIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpO1xudmFyIGVuZFNlZ21lbnRTVkcgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvc3ZnPicpO1xudmFyIHN0YXJ0U2VnbWVudE1hdGhNTCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPG1hdGggYXJpYS1oaWRkZW49XCJ0cnVlXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmVcIiBpZD1cIicpO1xudmFyIHN0YXJ0U2VnbWVudE1hdGhNTDIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpO1xudmFyIGVuZFNlZ21lbnRNYXRoTUwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvbWF0aD4nKTtcbnZhciBzdGFydFNlZ21lbnRUYWJsZSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRhYmxlIGhpZGRlbiBpZD1cIicpO1xudmFyIHN0YXJ0U2VnbWVudFRhYmxlMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+Jyk7XG52YXIgZW5kU2VnbWVudFRhYmxlID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L3RhYmxlPicpO1xudmFyIHN0YXJ0U2VnbWVudFRhYmxlQm9keSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRhYmxlIGhpZGRlbj48dGJvZHkgaWQ9XCInKTtcbnZhciBzdGFydFNlZ21lbnRUYWJsZUJvZHkyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj4nKTtcbnZhciBlbmRTZWdtZW50VGFibGVCb2R5ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L3Rib2R5PjwvdGFibGU+Jyk7XG52YXIgc3RhcnRTZWdtZW50VGFibGVSb3cgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0YWJsZSBoaWRkZW4+PHRyIGlkPVwiJyk7XG52YXIgc3RhcnRTZWdtZW50VGFibGVSb3cyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj4nKTtcbnZhciBlbmRTZWdtZW50VGFibGVSb3cgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvdHI+PC90YWJsZT4nKTtcbnZhciBzdGFydFNlZ21lbnRDb2xHcm91cCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRhYmxlIGhpZGRlbj48Y29sZ3JvdXAgaWQ9XCInKTtcbnZhciBzdGFydFNlZ21lbnRDb2xHcm91cDIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpO1xudmFyIGVuZFNlZ21lbnRDb2xHcm91cCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPC9jb2xncm91cD48L3RhYmxlPicpO1xuZnVuY3Rpb24gd3JpdGVTdGFydFNlZ21lbnQoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUsIGZvcm1hdENvbnRleHQsIGlkKSB7XG4gIHN3aXRjaCAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlKSB7XG4gICAgY2FzZSBST09UX0hUTUxfTU9ERTpcbiAgICBjYXNlIEhUTUxfSFRNTF9NT0RFOlxuICAgIGNhc2UgSFRNTF9NT0RFOlxuICAgICAge1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRIVE1MKTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZS5zZWdtZW50UHJlZml4KTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudEhUTUwyKTtcbiAgICAgIH1cblxuICAgIGNhc2UgU1ZHX01PREU6XG4gICAgICB7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudFNWRyk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUuc2VnbWVudFByZWZpeCk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSk7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRTVkcyKTtcbiAgICAgIH1cblxuICAgIGNhc2UgTUFUSE1MX01PREU6XG4gICAgICB7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudE1hdGhNTCk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUuc2VnbWVudFByZWZpeCk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSk7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRNYXRoTUwyKTtcbiAgICAgIH1cblxuICAgIGNhc2UgSFRNTF9UQUJMRV9NT0RFOlxuICAgICAge1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRUYWJsZSk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUuc2VnbWVudFByZWZpeCk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSk7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRUYWJsZTIpO1xuICAgICAgfVxuICAgIC8vIFRPRE86IEZvciB0aGUgcmVzdCBvZiB0aGVzZSwgdGhlcmUgd2lsbCBiZSBleHRyYSB3cmFwcGVyIG5vZGVzIHRoYXQgbmV2ZXJcbiAgICAvLyBnZXQgZGVsZXRlZCBmcm9tIHRoZSBkb2N1bWVudC4gV2UgbmVlZCB0byBkZWxldGUgdGhlIHRhYmxlIHRvbyBhcyBwYXJ0XG4gICAgLy8gb2YgdGhlIGluamVjdGVkIHNjcmlwdHMuIFRoZXkgYXJlIGludmlzaWJsZSB0aG91Z2ggc28gaXQncyBub3QgdG9vIHRlcnJpYmxlXG4gICAgLy8gYW5kIGl0J3Mga2luZCBvZiBhbiBlZGdlIGNhc2UgdG8gc3VzcGVuZCBpbiBhIHRhYmxlLiBUb3RhbGx5IHN1cHBvcnRlZCB0aG91Z2guXG5cbiAgICBjYXNlIEhUTUxfVEFCTEVfQk9EWV9NT0RFOlxuICAgICAge1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRUYWJsZUJvZHkpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlLnNlZ21lbnRQcmVmaXgpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSkpO1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50VGFibGVCb2R5Mik7XG4gICAgICB9XG5cbiAgICBjYXNlIEhUTUxfVEFCTEVfUk9XX01PREU6XG4gICAgICB7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudFRhYmxlUm93KTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZS5zZWdtZW50UHJlZml4KTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudFRhYmxlUm93Mik7XG4gICAgICB9XG5cbiAgICBjYXNlIEhUTUxfQ09MR1JPVVBfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50Q29sR3JvdXApO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlLnNlZ21lbnRQcmVmaXgpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSkpO1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50Q29sR3JvdXAyKTtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBpbnNlcnRpb24gbW9kZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gd3JpdGVFbmRTZWdtZW50KGRlc3RpbmF0aW9uLCBmb3JtYXRDb250ZXh0KSB7XG4gIHN3aXRjaCAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlKSB7XG4gICAgY2FzZSBST09UX0hUTUxfTU9ERTpcbiAgICBjYXNlIEhUTUxfSFRNTF9NT0RFOlxuICAgIGNhc2UgSFRNTF9NT0RFOlxuICAgICAge1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU2VnbWVudEhUTUwpO1xuICAgICAgfVxuXG4gICAgY2FzZSBTVkdfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRTVkcpO1xuICAgICAgfVxuXG4gICAgY2FzZSBNQVRITUxfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRNYXRoTUwpO1xuICAgICAgfVxuXG4gICAgY2FzZSBIVE1MX1RBQkxFX01PREU6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTZWdtZW50VGFibGUpO1xuICAgICAgfVxuXG4gICAgY2FzZSBIVE1MX1RBQkxFX0JPRFlfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRUYWJsZUJvZHkpO1xuICAgICAgfVxuXG4gICAgY2FzZSBIVE1MX1RBQkxFX1JPV19NT0RFOlxuICAgICAge1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU2VnbWVudFRhYmxlUm93KTtcbiAgICAgIH1cblxuICAgIGNhc2UgSFRNTF9DT0xHUk9VUF9NT0RFOlxuICAgICAge1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU2VnbWVudENvbEdyb3VwKTtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBpbnNlcnRpb24gbW9kZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cbiAgfVxufVxudmFyIGNvbXBsZXRlU2VnbWVudFNjcmlwdDFGdWxsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGNvbXBsZXRlU2VnbWVudCArICc7JFJTKFwiJyk7XG52YXIgY29tcGxldGVTZWdtZW50U2NyaXB0MVBhcnRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyRSUyhcIicpO1xudmFyIGNvbXBsZXRlU2VnbWVudFNjcmlwdDIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiLFwiJyk7XG52YXIgY29tcGxldGVTZWdtZW50U2NyaXB0RW5kID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIik8L3NjcmlwdD4nKTtcbnZhciBjb21wbGV0ZVNlZ21lbnREYXRhMSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRlbXBsYXRlIGRhdGEtcnNpPVwiXCIgZGF0YS1zaWQ9XCInKTtcbnZhciBjb21wbGV0ZVNlZ21lbnREYXRhMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1waWQ9XCInKTtcbnZhciBjb21wbGV0ZVNlZ21lbnREYXRhRW5kID0gZGF0YUVsZW1lbnRRdW90ZWRFbmQ7XG5mdW5jdGlvbiB3cml0ZUNvbXBsZXRlZFNlZ21lbnRJbnN0cnVjdGlvbihkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZSwgY29udGVudFNlZ21lbnRJRCkge1xuICB2YXIgc2NyaXB0Rm9ybWF0ID0gcmVzcG9uc2VTdGF0ZS5zdHJlYW1pbmdGb3JtYXQgPT09IFNjcmlwdFN0cmVhbWluZ0Zvcm1hdDtcblxuICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZS5zdGFydElubGluZVNjcmlwdCk7XG5cbiAgICBpZiAoKHJlc3BvbnNlU3RhdGUuaW5zdHJ1Y3Rpb25zICYgU2VudENvbXBsZXRlU2VnbWVudEZ1bmN0aW9uKSA9PT0gTm90aGluZ1NlbnQpIHtcbiAgICAgIC8vIFRoZSBmaXJzdCB0aW1lIHdlIHdyaXRlIHRoaXMsIHdlJ2xsIG5lZWQgdG8gaW5jbHVkZSB0aGUgZnVsbCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHJlc3BvbnNlU3RhdGUuaW5zdHJ1Y3Rpb25zIHw9IFNlbnRDb21wbGV0ZVNlZ21lbnRGdW5jdGlvbjtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlU2VnbWVudFNjcmlwdDFGdWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRnV0dXJlIGNhbGxzIGNhbiBqdXN0IHJldXNlIHRoZSBzYW1lIGZ1bmN0aW9uLlxuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVTZWdtZW50U2NyaXB0MVBhcnRpYWwpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZVNlZ21lbnREYXRhMSk7XG4gIH0gLy8gV3JpdGUgZnVuY3Rpb24gYXJndW1lbnRzLCB3aGljaCBhcmUgc3RyaW5nIGxpdGVyYWxzXG5cblxuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlLnNlZ21lbnRQcmVmaXgpO1xuICB2YXIgZm9ybWF0dGVkSUQgPSBzdHJpbmdUb0NodW5rKGNvbnRlbnRTZWdtZW50SUQudG9TdHJpbmcoMTYpKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgZm9ybWF0dGVkSUQpO1xuXG4gIGlmIChzY3JpcHRGb3JtYXQpIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZVNlZ21lbnRTY3JpcHQyKTtcbiAgfSBlbHNlIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZVNlZ21lbnREYXRhMik7XG4gIH1cblxuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlLnBsYWNlaG9sZGVyUHJlZml4KTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgZm9ybWF0dGVkSUQpO1xuXG4gIGlmIChzY3JpcHRGb3JtYXQpIHtcbiAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY29tcGxldGVTZWdtZW50U2NyaXB0RW5kKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY29tcGxldGVTZWdtZW50RGF0YUVuZCk7XG4gIH1cbn1cbnZhciBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MUZ1bGwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoY29tcGxldGVCb3VuZGFyeSArICckUkMoXCInKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MVBhcnRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyRSQyhcIicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MUZ1bGxCb3RoID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGNvbXBsZXRlQm91bmRhcnkgKyBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlcyArICckUlIoXCInKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFGdWxsUGFydGlhbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlcyArICckUlIoXCInKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFQYXJ0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCckUlIoXCInKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIsXCInKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0M2EgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiLCcpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQzYiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCInKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0RW5kID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcpPC9zY3JpcHQ+Jyk7XG52YXIgY29tcGxldGVCb3VuZGFyeURhdGExID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGVtcGxhdGUgZGF0YS1yY2k9XCJcIiBkYXRhLWJpZD1cIicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzRGF0YTEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0ZW1wbGF0ZSBkYXRhLXJyaT1cIlwiIGRhdGEtYmlkPVwiJyk7XG52YXIgY29tcGxldGVCb3VuZGFyeURhdGEyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBkYXRhLXNpZD1cIicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlEYXRhM2EgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGRhdGEtc3R5PVwiJyk7XG52YXIgY29tcGxldGVCb3VuZGFyeURhdGFFbmQgPSBkYXRhRWxlbWVudFF1b3RlZEVuZDtcbmZ1bmN0aW9uIHdyaXRlQ29tcGxldGVkQm91bmRhcnlJbnN0cnVjdGlvbihkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZSwgYm91bmRhcnlJRCwgY29udGVudFNlZ21lbnRJRCwgYm91bmRhcnlSZXNvdXJjZXMpIHtcbiAgdmFyIHJlcXVpcmVzU3R5bGVJbnNlcnRpb247XG5cbiAge1xuICAgIHJlcXVpcmVzU3R5bGVJbnNlcnRpb24gPSByZXNwb25zZVN0YXRlLnN0eWxlc1RvSG9pc3Q7IC8vIElmIG5lY2Vzc2FyeSBzdHlsZXNoZWV0cyB3aWxsIGJlIGZsdXNoZWQgd2l0aCB0aGlzIGluc3RydWN0aW9uLlxuICAgIC8vIEFueSBzdHlsZSB0YWdzIG5vdCB5ZXQgaG9pc3RlZCBpbiB0aGUgRG9jdW1lbnQgd2lsbCBhbHNvIGJlIGhvaXN0ZWQuXG4gICAgLy8gV2UgcmVzZXQgdGhpcyBzdGF0ZSBzaW5jZSBhZnRlciB0aGlzIGluc3RydWN0aW9uIGV4ZWN1dGVzIGFsbCBzdHlsZXNcbiAgICAvLyB1cCB0byB0aGlzIHBvaW50IHdpbGwgaGF2ZSBiZWVuIGhvaXN0ZWRcblxuICAgIHJlc3BvbnNlU3RhdGUuc3R5bGVzVG9Ib2lzdCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIHNjcmlwdEZvcm1hdCA9IHJlc3BvbnNlU3RhdGUuc3RyZWFtaW5nRm9ybWF0ID09PSBTY3JpcHRTdHJlYW1pbmdGb3JtYXQ7XG5cbiAgaWYgKHNjcmlwdEZvcm1hdCkge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUuc3RhcnRJbmxpbmVTY3JpcHQpO1xuXG4gICAgaWYgKHJlcXVpcmVzU3R5bGVJbnNlcnRpb24pIHtcbiAgICAgIGlmICgocmVzcG9uc2VTdGF0ZS5pbnN0cnVjdGlvbnMgJiBTZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uKSA9PT0gTm90aGluZ1NlbnQpIHtcbiAgICAgICAgcmVzcG9uc2VTdGF0ZS5pbnN0cnVjdGlvbnMgfD0gU2VudFN0eWxlSW5zZXJ0aW9uRnVuY3Rpb24gfCBTZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbG9uZVByZWNvbXB1dGVkQ2h1bmsoY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNTY3JpcHQxRnVsbEJvdGgpKTtcbiAgICAgIH0gZWxzZSBpZiAoKHJlc3BvbnNlU3RhdGUuaW5zdHJ1Y3Rpb25zICYgU2VudFN0eWxlSW5zZXJ0aW9uRnVuY3Rpb24pID09PSBOb3RoaW5nU2VudCkge1xuICAgICAgICByZXNwb25zZVN0YXRlLmluc3RydWN0aW9ucyB8PSBTZW50U3R5bGVJbnNlcnRpb25GdW5jdGlvbjtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNTY3JpcHQxRnVsbFBhcnRpYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNTY3JpcHQxUGFydGlhbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgocmVzcG9uc2VTdGF0ZS5pbnN0cnVjdGlvbnMgJiBTZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uKSA9PT0gTm90aGluZ1NlbnQpIHtcbiAgICAgICAgcmVzcG9uc2VTdGF0ZS5pbnN0cnVjdGlvbnMgfD0gU2VudENvbXBsZXRlQm91bmRhcnlGdW5jdGlvbjtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVNjcmlwdDFGdWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQxUGFydGlhbCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChyZXF1aXJlc1N0eWxlSW5zZXJ0aW9uKSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc0RhdGExKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeURhdGExKTtcbiAgICB9XG4gIH1cblxuICBpZiAoYm91bmRhcnlJRCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQW4gSUQgbXVzdCBoYXZlIGJlZW4gYXNzaWduZWQgYmVmb3JlIHdlIGNhbiBjb21wbGV0ZSB0aGUgYm91bmRhcnkuJyk7XG4gIH0gLy8gV3JpdGUgZnVuY3Rpb24gYXJndW1lbnRzLCB3aGljaCBhcmUgc3RyaW5nIGFuZCBhcnJheSBsaXRlcmFsc1xuXG5cbiAgdmFyIGZvcm1hdHRlZENvbnRlbnRJRCA9IHN0cmluZ1RvQ2h1bmsoY29udGVudFNlZ21lbnRJRC50b1N0cmluZygxNikpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBib3VuZGFyeUlEKTtcblxuICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVNjcmlwdDIpO1xuICB9IGVsc2Uge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlEYXRhMik7XG4gIH1cblxuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlLnNlZ21lbnRQcmVmaXgpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBmb3JtYXR0ZWRDb250ZW50SUQpO1xuXG4gIGlmIChyZXF1aXJlc1N0eWxlSW5zZXJ0aW9uKSB7XG4gICAgLy8gU2NyaXB0IGFuZCBkYXRhIHdyaXRlcnMgbXVzdCBmb3JtYXQgdGhpcyBkaWZmZXJlbnRseTpcbiAgICAvLyAgLSBzY3JpcHQgd3JpdGVyIGVtaXRzIGFuIGFycmF5IGxpdGVyYWwsIHdob3NlIHN0cmluZyBlbGVtZW50cyBhcmVcbiAgICAvLyAgICBlc2NhcGVkIGZvciBqYXZhc2NyaXB0ICBlLmcuIFtcIkFcIiwgXCJCXCJdXG4gICAgLy8gIC0gZGF0YSB3cml0ZXIgZW1pdHMgYSBzdHJpbmcgbGl0ZXJhbCwgd2hpY2ggaXMgZXNjYXBlZCBhcyBodG1sXG4gICAgLy8gICAgZS5nLiBbJiMzNDtBJiMzNDssICYjMzQ7QiYjMzQ7XVxuICAgIGlmIChzY3JpcHRGb3JtYXQpIHtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQzYSk7IC8vIGJvdW5kYXJ5UmVzb3VyY2VzIGVuY29kZXMgYW4gYXJyYXkgbGl0ZXJhbFxuXG4gICAgICB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmNpZXNJbkpTKGRlc3RpbmF0aW9uLCBib3VuZGFyeVJlc291cmNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlEYXRhM2EpO1xuICAgICAgd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jaWVzSW5BdHRyKGRlc3RpbmF0aW9uLCBib3VuZGFyeVJlc291cmNlcyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChzY3JpcHRGb3JtYXQpIHtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQzYik7XG4gICAgfVxuICB9XG5cbiAgdmFyIHdyaXRlTW9yZTtcblxuICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgd3JpdGVNb3JlID0gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVNjcmlwdEVuZCk7XG4gIH0gZWxzZSB7XG4gICAgd3JpdGVNb3JlID0gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeURhdGFFbmQpO1xuICB9XG5cbiAgcmV0dXJuIHdyaXRlQm9vdHN0cmFwKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlKSAmJiB3cml0ZU1vcmU7XG59XG52YXIgY2xpZW50UmVuZGVyU2NyaXB0MUZ1bGwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoY2xpZW50UmVuZGVyQm91bmRhcnkgKyAnOyRSWChcIicpO1xudmFyIGNsaWVudFJlbmRlclNjcmlwdDFQYXJ0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCckUlgoXCInKTtcbnZhciBjbGllbnRSZW5kZXJTY3JpcHQxQSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCInKTtcbnZhciBjbGllbnRSZW5kZXJFcnJvclNjcmlwdEFyZ0ludGVyc3RpdGlhbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnLCcpO1xudmFyIGNsaWVudFJlbmRlclNjcmlwdEVuZCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnKTwvc2NyaXB0PicpO1xudmFyIGNsaWVudFJlbmRlckRhdGExID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGVtcGxhdGUgZGF0YS1yeGk9XCJcIiBkYXRhLWJpZD1cIicpO1xudmFyIGNsaWVudFJlbmRlckRhdGEyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBkYXRhLWRnc3Q9XCInKTtcbnZhciBjbGllbnRSZW5kZXJEYXRhMyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1tc2c9XCInKTtcbnZhciBjbGllbnRSZW5kZXJEYXRhNCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1zdGNrPVwiJyk7XG52YXIgY2xpZW50UmVuZGVyRGF0YUVuZCA9IGRhdGFFbGVtZW50UXVvdGVkRW5kO1xuZnVuY3Rpb24gd3JpdGVDbGllbnRSZW5kZXJCb3VuZGFyeUluc3RydWN0aW9uKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlLCBib3VuZGFyeUlELCBlcnJvckRpZ2VzdCwgZXJyb3JNZXNzYWdlLCBlcnJvckNvbXBvbmVudFN0YWNrKSB7XG4gIHZhciBzY3JpcHRGb3JtYXQgPSByZXNwb25zZVN0YXRlLnN0cmVhbWluZ0Zvcm1hdCA9PT0gU2NyaXB0U3RyZWFtaW5nRm9ybWF0O1xuXG4gIGlmIChzY3JpcHRGb3JtYXQpIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlLnN0YXJ0SW5saW5lU2NyaXB0KTtcblxuICAgIGlmICgocmVzcG9uc2VTdGF0ZS5pbnN0cnVjdGlvbnMgJiBTZW50Q2xpZW50UmVuZGVyRnVuY3Rpb24pID09PSBOb3RoaW5nU2VudCkge1xuICAgICAgLy8gVGhlIGZpcnN0IHRpbWUgd2Ugd3JpdGUgdGhpcywgd2UnbGwgbmVlZCB0byBpbmNsdWRlIHRoZSBmdWxsIGltcGxlbWVudGF0aW9uLlxuICAgICAgcmVzcG9uc2VTdGF0ZS5pbnN0cnVjdGlvbnMgfD0gU2VudENsaWVudFJlbmRlckZ1bmN0aW9uO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyU2NyaXB0MUZ1bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGdXR1cmUgY2FsbHMgY2FuIGp1c3QgcmV1c2UgdGhlIHNhbWUgZnVuY3Rpb24uXG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJTY3JpcHQxUGFydGlhbCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIDx0ZW1wbGF0ZSBkYXRhLXJ4aT1cIlwiIGRhdGEtYmlkPVwiXG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyRGF0YTEpO1xuICB9XG5cbiAgaWYgKGJvdW5kYXJ5SUQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIElEIG11c3QgaGF2ZSBiZWVuIGFzc2lnbmVkIGJlZm9yZSB3ZSBjYW4gY29tcGxldGUgdGhlIGJvdW5kYXJ5LicpO1xuICB9XG5cbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYm91bmRhcnlJRCk7XG5cbiAgaWYgKHNjcmlwdEZvcm1hdCkge1xuICAgIC8vIFwiIG5lZWRzIHRvIGJlIGluc2VydGVkIGZvciBzY3JpcHRzLCBzaW5jZSBBcmdJbnRlcnN0aXR1YWwgZG9lcyBub3QgY29udGFpblxuICAgIC8vIGxlYWRpbmcgb3IgdHJhaWxpbmcgcXVvdGVzXG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyU2NyaXB0MUEpO1xuICB9XG5cbiAgaWYgKGVycm9yRGlnZXN0IHx8IGVycm9yTWVzc2FnZSB8fCBlcnJvckNvbXBvbmVudFN0YWNrKSB7XG4gICAgaWYgKHNjcmlwdEZvcm1hdCkge1xuICAgICAgLy8gLFwiSlNPTlN0cmluZ1wiXG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJFcnJvclNjcmlwdEFyZ0ludGVyc3RpdGlhbCk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyhlcnJvckRpZ2VzdCB8fCAnJykpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gXCIgZGF0YS1kZ3N0PVwiSFRNTFN0cmluZ1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyRGF0YTIpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihlcnJvckRpZ2VzdCB8fCAnJykpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZXJyb3JNZXNzYWdlIHx8IGVycm9yQ29tcG9uZW50U3RhY2spIHtcbiAgICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgICAvLyAsXCJKU09OU3RyaW5nXCJcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGVycm9yTWVzc2FnZSB8fCAnJykpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gXCIgZGF0YS1tc2c9XCJIVE1MU3RyaW5nXG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJEYXRhMyk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGVycm9yTWVzc2FnZSB8fCAnJykpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZXJyb3JDb21wb25lbnRTdGFjaykge1xuICAgIC8vICxcIkpTT05TdHJpbmdcIlxuICAgIGlmIChzY3JpcHRGb3JtYXQpIHtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGVycm9yQ29tcG9uZW50U3RhY2spKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFwiIGRhdGEtc3Rjaz1cIkhUTUxTdHJpbmdcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlckRhdGE0KTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoZXJyb3JDb21wb25lbnRTdGFjaykpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgLy8gPjwvc2NyaXB0PlxuICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJTY3JpcHRFbmQpO1xuICB9IGVsc2Uge1xuICAgIC8vIFwiPjwvdGVtcGxhdGU+XG4gICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGNsaWVudFJlbmRlckRhdGFFbmQpO1xuICB9XG59XG52YXIgcmVnZXhGb3JKU1N0cmluZ3NJbkluc3RydWN0aW9uU2NyaXB0cyA9IC9bPFxcdTIwMjhcXHUyMDI5XS9nO1xuXG5mdW5jdGlvbiBlc2NhcGVKU1N0cmluZ3NGb3JJbnN0cnVjdGlvblNjcmlwdHMoaW5wdXQpIHtcbiAgdmFyIGVzY2FwZWQgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gIHJldHVybiBlc2NhcGVkLnJlcGxhY2UocmVnZXhGb3JKU1N0cmluZ3NJbkluc3RydWN0aW9uU2NyaXB0cywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgc3dpdGNoIChtYXRjaCkge1xuICAgICAgLy8gc2FudGl6aW5nIGJyZWFraW5nIG91dCBvZiBzdHJpbmdzIGFuZCBzY3JpcHQgdGFnc1xuICAgICAgY2FzZSAnPCc6XG4gICAgICAgIHJldHVybiBcIlxcXFx1MDAzY1wiO1xuXG4gICAgICBjYXNlIFwiXFx1MjAyOFwiOlxuICAgICAgICByZXR1cm4gXCJcXFxcdTIwMjhcIjtcblxuICAgICAgY2FzZSBcIlxcdTIwMjlcIjpcbiAgICAgICAgcmV0dXJuIFwiXFxcXHUyMDI5XCI7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzIGVuY291bnRlcmVkIGEgbWF0Y2ggaXQgZG9lcyBub3Qga25vdyBob3cgdG8gcmVwbGFjZS4gdGhpcyBtZWFucyB0aGUgbWF0Y2ggcmVnZXggYW5kIHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGFyZSBubyBsb25nZXIgaW4gc3luYy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdCcpO1xuICAgICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxudmFyIHJlZ2V4Rm9ySlNTdHJpbmdzSW5TY3JpcHRzID0gL1smPjxcXHUyMDI4XFx1MjAyOV0vZztcblxuZnVuY3Rpb24gZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMoaW5wdXQpIHtcbiAgdmFyIGVzY2FwZWQgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gIHJldHVybiBlc2NhcGVkLnJlcGxhY2UocmVnZXhGb3JKU1N0cmluZ3NJblNjcmlwdHMsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHN3aXRjaCAobWF0Y2gpIHtcbiAgICAgIC8vIHNhbnRpemluZyBicmVha2luZyBvdXQgb2Ygc3RyaW5ncyBhbmQgc2NyaXB0IHRhZ3NcbiAgICAgIGNhc2UgJyYnOlxuICAgICAgICByZXR1cm4gXCJcXFxcdTAwMjZcIjtcblxuICAgICAgY2FzZSAnPic6XG4gICAgICAgIHJldHVybiBcIlxcXFx1MDAzZVwiO1xuXG4gICAgICBjYXNlICc8JzpcbiAgICAgICAgcmV0dXJuIFwiXFxcXHUwMDNjXCI7XG5cbiAgICAgIGNhc2UgXCJcXHUyMDI4XCI6XG4gICAgICAgIHJldHVybiBcIlxcXFx1MjAyOFwiO1xuXG4gICAgICBjYXNlIFwiXFx1MjAyOVwiOlxuICAgICAgICByZXR1cm4gXCJcXFxcdTIwMjlcIjtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyBlbmNvdW50ZXJlZCBhIG1hdGNoIGl0IGRvZXMgbm90IGtub3cgaG93IHRvIHJlcGxhY2UuIHRoaXMgbWVhbnMgdGhlIG1hdGNoIHJlZ2V4IGFuZCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBhcmUgbm8gbG9uZ2VyIGluIHN5bmMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbnZhciBsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4xID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8c3R5bGUgbWVkaWE9XCJub3QgYWxsXCIgZGF0YS1wcmVjZWRlbmNlPVwiJyk7XG52YXIgbGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1ocmVmPVwiJyk7XG52YXIgbGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+Jyk7XG52YXIgbGF0ZVN0eWxlVGFnVGVtcGxhdGVDbG9zZSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPC9zdHlsZT4nKTsgLy8gVHJhY2tzIHdoZXRoZXIgdGhlIGJvdW5kYXJ5IGN1cnJlbnRseSBmbHVzaGluZyBpcyBmbHVzaGlnbiBzdHlsZSB0YWdzIG9yIGhhcyBhbnlcbi8vIHN0eWxlc2hlZXQgZGVwZW5kZW5jaWVzIG5vdCBmbHVzaGVkIGluIHRoZSBQcmVhbWJsZS5cblxudmFyIGN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5SGFzU3R5bGVzVG9Ib2lzdCA9IGZhbHNlOyAvLyBBY3RzIGFzIGEgcmV0dXJuIHZhbHVlIGZvciB0aGUgZm9yRWFjaCBleGVjdXRpb24gb2Ygc3R5bGUgdGFnIGZsdXNoaW5nLlxuXG52YXIgZGVzdGluYXRpb25IYXNDYXBhY2l0eSA9IHRydWU7XG5cbmZ1bmN0aW9uIGZsdXNoU3R5bGVUYWdzTGF0ZUZvckJvdW5kYXJ5KHJlc291cmNlKSB7XG4gIGlmIChyZXNvdXJjZS50eXBlID09PSAnc3R5bGVzaGVldCcgJiYgKHJlc291cmNlLnN0YXRlICYgRmx1c2hlZEluUHJlYW1ibGUpID09PSBOb1N0YXRlKSB7XG4gICAgY3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlIYXNTdHlsZXNUb0hvaXN0ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChyZXNvdXJjZS50eXBlID09PSAnc3R5bGUnKSB7XG4gICAgdmFyIGNodW5rcyA9IHJlc291cmNlLmNodW5rcztcbiAgICB2YXIgaHJlZnMgPSByZXNvdXJjZS5wcm9wcy5ocmVmcztcbiAgICB2YXIgaSA9IDA7XG5cbiAgICBpZiAoY2h1bmtzLmxlbmd0aCkge1xuICAgICAgd3JpdGVDaHVuayh0aGlzLCBsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4xKTtcbiAgICAgIHdyaXRlQ2h1bmsodGhpcywgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihyZXNvdXJjZS5wcm9wcy5wcmVjZWRlbmNlKSkpO1xuXG4gICAgICBpZiAoaHJlZnMubGVuZ3RoKSB7XG4gICAgICAgIHdyaXRlQ2h1bmsodGhpcywgbGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMik7XG5cbiAgICAgICAgZm9yICg7IGkgPCBocmVmcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICB3cml0ZUNodW5rKHRoaXMsIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoaHJlZnNbaV0pKSk7XG4gICAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBzcGFjZVNlcGFyYXRvcik7XG4gICAgICAgIH1cblxuICAgICAgICB3cml0ZUNodW5rKHRoaXMsIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoaHJlZnNbaV0pKSk7XG4gICAgICB9XG5cbiAgICAgIHdyaXRlQ2h1bmsodGhpcywgbGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMyk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBjaHVua3NbaV0pO1xuICAgICAgfVxuXG4gICAgICBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5ID0gd3JpdGVDaHVua0FuZFJldHVybih0aGlzLCBsYXRlU3R5bGVUYWdUZW1wbGF0ZUNsb3NlKTsgLy8gV2Ugd3JvdGUgc3R5bGUgdGFncyBmb3IgdGhpcyBib3VuZGFyeSBhbmQgd2UgbWF5IG5lZWQgdG8gZW1pdCBhIHNjcmlwdFxuICAgICAgLy8gdG8gaG9pc3QgdGhlbS5cblxuICAgICAgY3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlIYXNTdHlsZXNUb0hvaXN0ID0gdHJ1ZTsgLy8gc3R5bGUgcmVzb3VyY2VzIGNhbiBmbHVzaCBjb250aW51b3VzbHkgc2luY2UgbW9yZSBydWxlcyBtYXkgYmUgd3JpdHRlbiBpbnRvXG4gICAgICAvLyB0aGVtIHdpdGggbmV3IGhyZWZzLiBJbnN0ZWFkIG9mIG1hcmtpbmcgaXQgZmx1c2hlZCwgd2Ugc2ltcGx5IHJlc2V0IHRoZSBjaHVua3NcbiAgICAgIC8vIGFuZCBocmVmc1xuXG4gICAgICBjaHVua3MubGVuZ3RoID0gMDtcbiAgICAgIGhyZWZzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdyaXRlUmVzb3VyY2VzRm9yQm91bmRhcnkoZGVzdGluYXRpb24sIGJvdW5kYXJ5UmVzb3VyY2VzLCByZXNwb25zZVN0YXRlKSB7XG4gIC8vIFJlc2V0IHRoZXNlIG9uIGVhY2ggaW52b2NhdGlvbiwgdGhleSBhcmUgb25seSBzYWZlIHRvIHJlYWQgaW4gdGhpcyBmdW5jdGlvblxuICBjdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeUhhc1N0eWxlc1RvSG9pc3QgPSBmYWxzZTtcbiAgZGVzdGluYXRpb25IYXNDYXBhY2l0eSA9IHRydWU7IC8vIEZsdXNoIGVhY2ggQm91bmRhcnkgcmVzb3VyY2VcblxuICBib3VuZGFyeVJlc291cmNlcy5mb3JFYWNoKGZsdXNoU3R5bGVUYWdzTGF0ZUZvckJvdW5kYXJ5LCBkZXN0aW5hdGlvbik7XG5cbiAgaWYgKGN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5SGFzU3R5bGVzVG9Ib2lzdCkge1xuICAgIHJlc3BvbnNlU3RhdGUuc3R5bGVzVG9Ib2lzdCA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gZGVzdGluYXRpb25IYXNDYXBhY2l0eTtcbn1cblxuZnVuY3Rpb24gZmx1c2hSZXNvdXJjZUluUHJlYW1ibGUocmVzb3VyY2UpIHtcbiAgaWYgKChyZXNvdXJjZS5zdGF0ZSAmIChGbHVzaGVkIHwgQmxvY2tlZCkpID09PSBOb1N0YXRlKSB7XG4gICAgdmFyIGNodW5rcyA9IHJlc291cmNlLmNodW5rcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3cml0ZUNodW5rKHRoaXMsIGNodW5rc1tpXSk7XG4gICAgfVxuXG4gICAgcmVzb3VyY2Uuc3RhdGUgfD0gRmx1c2hlZEluUHJlYW1ibGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hSZXNvdXJjZUxhdGUocmVzb3VyY2UpIHtcbiAgaWYgKChyZXNvdXJjZS5zdGF0ZSAmIChGbHVzaGVkIHwgQmxvY2tlZCkpID09PSBOb1N0YXRlKSB7XG4gICAgdmFyIGNodW5rcyA9IHJlc291cmNlLmNodW5rcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3cml0ZUNodW5rKHRoaXMsIGNodW5rc1tpXSk7XG4gICAgfVxuXG4gICAgcmVzb3VyY2Uuc3RhdGUgfD0gRmx1c2hlZExhdGU7XG4gIH1cbn0gLy8gVGhpcyBtdXN0IGFsd2F5cyBiZSByZWFkIGFmdGVyIGZsdXNoaW5nIHN0eWxlc2hlZXQgc3R5bGVzLiB3ZSBrbm93IHdlIHdpbGwgZW5jb3VudGVyIGEgc3R5bGUgcmVzb3VyY2Vcbi8vIHBlciBwcmVjZWRlbmNlIGFuZCBpdCB3aWxsIGJlIHNldCBiZWZvcmUgcmVhZHkgc28gd2UgY2FzdCB0aGlzIHRvIGF2b2lkIGFuIGV4dHJhIGNoZWNrIGF0IHJ1bnRpbWVcblxuXG52YXIgcHJlY2VkZW5jZVN0eWxlVGFnUmVzb3VyY2UgPSBudWxsOyAvLyBUaGlzIGZsYWdzIGxldCdzIHVzIG9wdCBvdXQgb2YgZmx1c2hpbmcgYSBwbGFjZWhvbGRlciBzdHlsZSB0YWcgdG8gZW1pdCB0aGUgcHJlY2VkZW5jZSBpbiB0aGUgcmlnaHQgb3JkZXIuXG4vLyBJZiBhIHN0eWxlc2hlZXQgd2FzIGZsdXNoZWQgdGhlbiB3ZSBoYXZlIHRoZSBwcmVjZWRlbmNlIG9yZGVyIHByZXNlcnZlZCBhbmQgb25seSBuZWVkIHRvIGVtaXQgPHN0eWxlPiB0YWdzXG4vLyBpZiB0aGVyZSBhcmUgYWN0dWFsIGNodW5rcyB0byBmbHVzaFxuXG52YXIgZGlkRmx1c2hQcmVjZWRlbmNlID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZsdXNoU3R5bGVJblByZWFtYmxlKHJlc291cmNlLCBrZXksIHNldCkge1xuICB2YXIgY2h1bmtzID0gcmVzb3VyY2UuY2h1bmtzO1xuXG4gIGlmIChyZXNvdXJjZS5zdGF0ZSAmIEZsdXNoZWQpIHtcbiAgICAvLyBJbiB0aGVvcnkgdGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuIGJlY2F1c2Ugd2UgY2xlYXIgZnJvbSB0aGVcbiAgICAvLyBTZXQgb24gZmx1c2ggYnV0IHRvIGVuc3VyZSBjb3JyZWN0IHNlbWFudGljcyB3ZSBkb24ndCBlbWl0XG4gICAgLy8gYW55dGhpbmcgaWYgd2UgYXJlIGluIHRoaXMgc3RhdGUuXG4gICAgc2V0LmRlbGV0ZShyZXNvdXJjZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgY2FuIGVtaXQgdGhpcyBzdHlsZSBvciBzdHlsZXNoZWV0IGFzIGlzLlxuICAgIGlmIChyZXNvdXJjZS50eXBlID09PSAnc3R5bGUnKSB7XG4gICAgICBwcmVjZWRlbmNlU3R5bGVUYWdSZXNvdXJjZSA9IHJlc291cmNlO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gV2Ugc3RpbGwgbmVlZCB0byBlbmNvZGUgc3R5bGVzaGVldCBjaHVua3NcbiAgICAvLyBiZWNhdXNlIHVubGlrZSBtb3N0IEhvaXN0YWJsZXMgYW5kIFJlc291cmNlcyB3ZSBkbyBub3QgZWFnZXJseSBlbmNvZGVcbiAgICAvLyB0aGVtIGR1cmluZyByZW5kZXIuIFRoaXMgaXMgYmVjYXVzZSBpZiB3ZSBmbHVzaCBsYXRlIHdlIGhhdmUgdG8gc2VuZCBhXG4gICAgLy8gZGlmZmVyZW50IGVuY29kaW5nIGFuZCB3ZSBkb24ndCB3YW50IHRvIGVuY29kZSBtdWx0aXBsZSB0aW1lc1xuXG5cbiAgICBwdXNoTGlua0ltcGwoY2h1bmtzLCByZXNvdXJjZS5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgd3JpdGVDaHVuayh0aGlzLCBjaHVua3NbaV0pO1xuICAgIH1cblxuICAgIHJlc291cmNlLnN0YXRlIHw9IEZsdXNoZWRJblByZWFtYmxlO1xuICAgIGRpZEZsdXNoUHJlY2VkZW5jZSA9IHRydWU7XG4gIH1cbn1cblxudmFyIHN0eWxlVGFnUmVzb3VyY2VPcGVuMSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHN0eWxlIGRhdGEtcHJlY2VkZW5jZT1cIicpO1xudmFyIHN0eWxlVGFnUmVzb3VyY2VPcGVuMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1ocmVmPVwiJyk7XG52YXIgc3BhY2VTZXBhcmF0b3IgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyAnKTtcbnZhciBzdHlsZVRhZ1Jlc291cmNlT3BlbjMgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpO1xudmFyIHN0eWxlVGFnUmVzb3VyY2VDbG9zZSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPC9zdHlsZT4nKTtcblxuZnVuY3Rpb24gZmx1c2hBbGxTdHlsZXNJblByZWFtYmxlKHNldCwgcHJlY2VkZW5jZSkge1xuICBkaWRGbHVzaFByZWNlZGVuY2UgPSBmYWxzZTtcbiAgc2V0LmZvckVhY2goZmx1c2hTdHlsZUluUHJlYW1ibGUsIHRoaXMpO1xuICBzZXQuY2xlYXIoKTtcbiAgdmFyIGNodW5rcyA9IHByZWNlZGVuY2VTdHlsZVRhZ1Jlc291cmNlLmNodW5rcztcbiAgdmFyIGhyZWZzID0gcHJlY2VkZW5jZVN0eWxlVGFnUmVzb3VyY2UucHJvcHMuaHJlZnM7XG5cbiAgaWYgKGRpZEZsdXNoUHJlY2VkZW5jZSA9PT0gZmFsc2UgfHwgY2h1bmtzLmxlbmd0aCkge1xuICAgIHdyaXRlQ2h1bmsodGhpcywgc3R5bGVUYWdSZXNvdXJjZU9wZW4xKTtcbiAgICB3cml0ZUNodW5rKHRoaXMsIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIocHJlY2VkZW5jZSkpKTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICBpZiAoaHJlZnMubGVuZ3RoKSB7XG4gICAgICB3cml0ZUNodW5rKHRoaXMsIHN0eWxlVGFnUmVzb3VyY2VPcGVuMik7XG5cbiAgICAgIGZvciAoOyBpIDwgaHJlZnMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHdyaXRlQ2h1bmsodGhpcywgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihocmVmc1tpXSkpKTtcbiAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBzcGFjZVNlcGFyYXRvcik7XG4gICAgICB9XG5cbiAgICAgIHdyaXRlQ2h1bmsodGhpcywgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihocmVmc1tpXSkpKTtcbiAgICB9XG5cbiAgICB3cml0ZUNodW5rKHRoaXMsIHN0eWxlVGFnUmVzb3VyY2VPcGVuMyk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3cml0ZUNodW5rKHRoaXMsIGNodW5rc1tpXSk7XG4gICAgfVxuXG4gICAgd3JpdGVDaHVuayh0aGlzLCBzdHlsZVRhZ1Jlc291cmNlQ2xvc2UpOyAvLyBzdHlsZSByZXNvdXJjZXMgY2FuIGZsdXNoIGNvbnRpbnVvdXNseSBzaW5jZSBtb3JlIHJ1bGVzIG1heSBiZSB3cml0dGVuIGludG9cbiAgICAvLyB0aGVtIHdpdGggbmV3IGhyZWZzLiBJbnN0ZWFkIG9mIG1hcmtpbmcgaXQgZmx1c2hlZCwgd2Ugc2ltcGx5IHJlc2V0IHRoZSBjaHVua3NcbiAgICAvLyBhbmQgaHJlZnNcblxuICAgIGNodW5rcy5sZW5ndGggPSAwO1xuICAgIGhyZWZzLmxlbmd0aCA9IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlbG9hZExhdGVTdHlsZShyZXNvdXJjZSkge1xuICBpZiAocmVzb3VyY2Uuc3RhdGUgJiBQcmVsb2FkRmx1c2hlZCkge1xuICAgIC8vIFRoaXMgcmVzb3VyY2UgaGFzIGFscmVhZHkgaGFkIGEgcHJlbG9hZCBmbHVzaGVkXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHJlc291cmNlLnR5cGUgPT09ICdzdHlsZScpIHtcbiAgICAvLyA8c3R5bGU+IHRhZ3MgZG8gbm90IG5lZWQgdG8gYmUgcHJlbG9hZGVkXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNodW5rcyA9IHJlc291cmNlLmNodW5rcztcbiAgdmFyIHByZWxvYWRQcm9wcyA9IHByZWxvYWRBc1N0eWxlUHJvcHNGcm9tUHJvcHMocmVzb3VyY2UucHJvcHMuaHJlZiwgcmVzb3VyY2UucHJvcHMpO1xuICBwdXNoTGlua0ltcGwoY2h1bmtzLCBwcmVsb2FkUHJvcHMpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgd3JpdGVDaHVuayh0aGlzLCBjaHVua3NbaV0pO1xuICB9XG5cbiAgcmVzb3VyY2Uuc3RhdGUgfD0gUHJlbG9hZEZsdXNoZWQ7XG4gIGNodW5rcy5sZW5ndGggPSAwO1xufVxuXG5mdW5jdGlvbiBwcmVsb2FkTGF0ZVN0eWxlcyhzZXQsIHByZWNlZGVuY2UpIHtcbiAgc2V0LmZvckVhY2gocHJlbG9hZExhdGVTdHlsZSwgdGhpcyk7XG4gIHNldC5jbGVhcigpO1xufSAvLyBXZSBkb24ndCBib3RoZXIgcmVwb3J0aW5nIGJhY2twcmVzc3VyZSBhdCB0aGUgbW9tZW50IGJlY2F1c2Ugd2UgZXhwZWN0IHRvXG4vLyBmbHVzaCB0aGUgZW50aXJlIHByZWFtYmxlIGluIGEgc2luZ2xlIHBhc3MuIFRoaXMgcHJvYmFibHkgc2hvdWxkIGJlIG1vZGlmaWVkXG4vLyBpbiB0aGUgZnV0dXJlIHRvIGJlIGJhY2twcmVzc3VyZSBzZW5zaXRpdmUgYnV0IHRoYXQgcmVxdWlyZXMgYSBsYXJnZXIgcmVmYWN0b3Jcbi8vIG9mIHRoZSBmbHVzaGluZyBjb2RlIGluIEZpenouXG5cblxuZnVuY3Rpb24gd3JpdGVQcmVhbWJsZShkZXN0aW5hdGlvbiwgcmVzb3VyY2VzLCByZXNwb25zZVN0YXRlLCB3aWxsRmx1c2hBbGxTZWdtZW50cykge1xuICAvLyBUaGlzIGZ1bmN0aW9uIG11c3QgYmUgY2FsbGVkIGV4YWN0bHkgb25jZSBvbiBldmVyeSByZXF1ZXN0XG4gIGlmICghd2lsbEZsdXNoQWxsU2VnbWVudHMgJiYgcmVzcG9uc2VTdGF0ZS5leHRlcm5hbFJ1bnRpbWVTY3JpcHQpIHtcbiAgICAvLyBJZiB0aGUgcm9vdCBzZWdtZW50IGlzIGluY29tcGxldGUgZHVlIHRvIHN1c3BlbmRlZCB0YXNrc1xuICAgIC8vIChlLmcuIHdpbGxGbHVzaEFsbFNlZ21lbnRzID0gZmFsc2UpIGFuZCB3ZSBhcmUgdXNpbmcgZGF0YVxuICAgIC8vIHN0cmVhbWluZyBmb3JtYXQsIGVuc3VyZSB0aGUgZXh0ZXJuYWwgcnVudGltZSBpcyBzZW50LlxuICAgIC8vIChVc2VyIGNvZGUgY291bGQgY2hvb3NlIHRvIHNlbmQgdGhpcyBldmVuIGVhcmxpZXIgYnkgY2FsbGluZ1xuICAgIC8vICBwcmVpbml0KC4uLiksIGlmIHRoZXkga25vdyB0aGV5IHdpbGwgc3VzcGVuZCkuXG4gICAgdmFyIF9yZXNwb25zZVN0YXRlJGV4dGVybiA9IHJlc3BvbnNlU3RhdGUuZXh0ZXJuYWxSdW50aW1lU2NyaXB0LFxuICAgICAgICBzcmMgPSBfcmVzcG9uc2VTdGF0ZSRleHRlcm4uc3JjLFxuICAgICAgICBjaHVua3MgPSBfcmVzcG9uc2VTdGF0ZSRleHRlcm4uY2h1bmtzO1xuICAgIGludGVybmFsUHJlaW5pdFNjcmlwdChyZXNvdXJjZXMsIHNyYywgY2h1bmtzKTtcbiAgfVxuXG4gIHZhciBodG1sQ2h1bmtzID0gcmVzcG9uc2VTdGF0ZS5odG1sQ2h1bmtzO1xuICB2YXIgaGVhZENodW5rcyA9IHJlc3BvbnNlU3RhdGUuaGVhZENodW5rcztcbiAgdmFyIGkgPSAwOyAvLyBFbWl0IG9wZW4gdGFncyBiZWZvcmUgSG9pc3RhYmxlcyBhbmQgUmVzb3VyY2VzXG5cbiAgaWYgKGh0bWxDaHVua3MpIHtcbiAgICAvLyBXZSBoYXZlIGFuIDxodG1sPiB0byBlbWl0IGFzIHBhcnQgb2YgdGhlIHByZWFtYmxlXG4gICAgZm9yIChpID0gMDsgaSA8IGh0bWxDaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGh0bWxDaHVua3NbaV0pO1xuICAgIH1cblxuICAgIGlmIChoZWFkQ2h1bmtzKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaGVhZENodW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBoZWFkQ2h1bmtzW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2UgZGlkIG5vdCByZW5kZXIgYSBoZWFkIGJ1dCB3ZSBlbWl0dGVkIGFuIDxodG1sPiBzbyB3ZSBlbWl0IG9uZSBub3dcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0Q2h1bmtGb3JUYWcoJ2hlYWQnKSk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBlbmRPZlN0YXJ0VGFnKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaGVhZENodW5rcykge1xuICAgIC8vIFdlIGRvIG5vdCBoYXZlIGFuIDxodG1sPiBidXQgd2UgZG8gaGF2ZSBhIDxoZWFkPlxuICAgIGZvciAoaSA9IDA7IGkgPCBoZWFkQ2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBoZWFkQ2h1bmtzW2ldKTtcbiAgICB9XG4gIH0gLy8gRW1pdCBoaWdoIHByaW9yaXR5IEhvaXN0YWJsZXNcblxuXG4gIHZhciBjaGFyc2V0Q2h1bmtzID0gcmVzcG9uc2VTdGF0ZS5jaGFyc2V0Q2h1bmtzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBjaGFyc2V0Q2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2hhcnNldENodW5rc1tpXSk7XG4gIH1cblxuICBjaGFyc2V0Q2h1bmtzLmxlbmd0aCA9IDA7IC8vIGVtaXQgcHJlY29ubmVjdCByZXNvdXJjZXNcblxuICByZXNvdXJjZXMucHJlY29ubmVjdHMuZm9yRWFjaChmbHVzaFJlc291cmNlSW5QcmVhbWJsZSwgZGVzdGluYXRpb24pO1xuICByZXNvdXJjZXMucHJlY29ubmVjdHMuY2xlYXIoKTtcbiAgdmFyIHByZWNvbm5lY3RDaHVua3MgPSByZXNwb25zZVN0YXRlLnByZWNvbm5lY3RDaHVua3M7XG5cbiAgZm9yIChpID0gMDsgaSA8IHByZWNvbm5lY3RDaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBwcmVjb25uZWN0Q2h1bmtzW2ldKTtcbiAgfVxuXG4gIHByZWNvbm5lY3RDaHVua3MubGVuZ3RoID0gMDtcbiAgcmVzb3VyY2VzLmZvbnRQcmVsb2Fkcy5mb3JFYWNoKGZsdXNoUmVzb3VyY2VJblByZWFtYmxlLCBkZXN0aW5hdGlvbik7XG4gIHJlc291cmNlcy5mb250UHJlbG9hZHMuY2xlYXIoKTtcbiAgcmVzb3VyY2VzLmhpZ2hJbWFnZVByZWxvYWRzLmZvckVhY2goZmx1c2hSZXNvdXJjZUluUHJlYW1ibGUsIGRlc3RpbmF0aW9uKTtcbiAgcmVzb3VyY2VzLmhpZ2hJbWFnZVByZWxvYWRzLmNsZWFyKCk7IC8vIEZsdXNoIHVuYmxvY2tlZCBzdHlsZXNoZWV0cyBieSBwcmVjZWRlbmNlXG5cbiAgcmVzb3VyY2VzLnByZWNlZGVuY2VzLmZvckVhY2goZmx1c2hBbGxTdHlsZXNJblByZWFtYmxlLCBkZXN0aW5hdGlvbik7XG4gIHJlc291cmNlcy5ib290c3RyYXBTY3JpcHRzLmZvckVhY2goZmx1c2hSZXNvdXJjZUluUHJlYW1ibGUsIGRlc3RpbmF0aW9uKTtcbiAgcmVzb3VyY2VzLnNjcmlwdHMuZm9yRWFjaChmbHVzaFJlc291cmNlSW5QcmVhbWJsZSwgZGVzdGluYXRpb24pO1xuICByZXNvdXJjZXMuc2NyaXB0cy5jbGVhcigpO1xuICByZXNvdXJjZXMuYnVsa1ByZWxvYWRzLmZvckVhY2goZmx1c2hSZXNvdXJjZUluUHJlYW1ibGUsIGRlc3RpbmF0aW9uKTtcbiAgcmVzb3VyY2VzLmJ1bGtQcmVsb2Fkcy5jbGVhcigpOyAvLyBXcml0ZSBlbWJlZGRpbmcgcHJlbG9hZENodW5rc1xuXG4gIHZhciBwcmVsb2FkQ2h1bmtzID0gcmVzcG9uc2VTdGF0ZS5wcmVsb2FkQ2h1bmtzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBwcmVsb2FkQ2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcHJlbG9hZENodW5rc1tpXSk7XG4gIH1cblxuICBwcmVsb2FkQ2h1bmtzLmxlbmd0aCA9IDA7IC8vIFdyaXRlIGVtYmVkZGluZyBob2lzdGFibGVDaHVua3NcblxuICB2YXIgaG9pc3RhYmxlQ2h1bmtzID0gcmVzcG9uc2VTdGF0ZS5ob2lzdGFibGVDaHVua3M7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvaXN0YWJsZUNodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGhvaXN0YWJsZUNodW5rc1tpXSk7XG4gIH1cblxuICBob2lzdGFibGVDaHVua3MubGVuZ3RoID0gMDsgLy8gRmx1c2ggY2xvc2luZyBoZWFkIGlmIG5lY2Vzc2FyeVxuXG4gIGlmIChodG1sQ2h1bmtzICYmIGhlYWRDaHVua3MgPT09IG51bGwpIHtcbiAgICAvLyBXZSBoYXZlIGFuIDxodG1sPiByZW5kZXJlZCBidXQgbm8gPGhlYWQ+IHJlbmRlcmVkLiBXZSBob3dldmVyIGluc2VydGVkXG4gICAgLy8gYSA8aGVhZD4gdXAgYWJvdmUgc28gd2UgbmVlZCB0byBlbWl0IHRoZSA8L2hlYWQ+IG5vdy4gVGhpcyBpcyBzYWZlIGJlY2F1c2VcbiAgICAvLyBpZiB0aGUgbWFpbiBjb250ZW50IGNvbnRhaW5lZCB0aGUgPC9oZWFkPiBpdCB3b3VsZCBhbHNvIGhhdmUgcHJvdmlkZWQgYVxuICAgIC8vIDxoZWFkPi4gVGhpcyBtZWFucyB0aGF0IGFsbCB0aGUgY29udGVudCBpbnNpZGUgPGh0bWw+IGlzIGVpdGhlciA8Ym9keT4gb3JcbiAgICAvLyBpbnZhbGlkIEhUTUxcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBlbmRUYWcxKTtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKCdoZWFkJykpO1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGVuZFRhZzIpO1xuICB9XG59IC8vIFdlIGRvbid0IGJvdGhlciByZXBvcnRpbmcgYmFja3ByZXNzdXJlIGF0IHRoZSBtb21lbnQgYmVjYXVzZSB3ZSBleHBlY3QgdG9cbi8vIGZsdXNoIHRoZSBlbnRpcmUgcHJlYW1ibGUgaW4gYSBzaW5nbGUgcGFzcy4gVGhpcyBwcm9iYWJseSBzaG91bGQgYmUgbW9kaWZpZWRcbi8vIGluIHRoZSBmdXR1cmUgdG8gYmUgYmFja3ByZXNzdXJlIHNlbnNpdGl2ZSBidXQgdGhhdCByZXF1aXJlcyBhIGxhcmdlciByZWZhY3RvclxuLy8gb2YgdGhlIGZsdXNoaW5nIGNvZGUgaW4gRml6ei5cblxuZnVuY3Rpb24gd3JpdGVIb2lzdGFibGVzKGRlc3RpbmF0aW9uLCByZXNvdXJjZXMsIHJlc3BvbnNlU3RhdGUpIHtcbiAgdmFyIGkgPSAwOyAvLyBFbWl0IGhpZ2ggcHJpb3JpdHkgSG9pc3RhYmxlc1xuICAvLyBXZSBvbWl0IGNoYXJzZXRDaHVua3MgYmVjYXVzZSB3ZSBoYXZlIGFscmVhZHkgc2VudCB0aGUgc2hlbGwgYW5kIGlmIGl0IHdhc24ndFxuICAvLyBhbHJlYWR5IHNlbnQgaXQgaXMgdG9vIGxhdGUgbm93LlxuXG4gIHJlc291cmNlcy5wcmVjb25uZWN0cy5mb3JFYWNoKGZsdXNoUmVzb3VyY2VMYXRlLCBkZXN0aW5hdGlvbik7XG4gIHJlc291cmNlcy5wcmVjb25uZWN0cy5jbGVhcigpO1xuICB2YXIgcHJlY29ubmVjdENodW5rcyA9IHJlc3BvbnNlU3RhdGUucHJlY29ubmVjdENodW5rcztcblxuICBmb3IgKGkgPSAwOyBpIDwgcHJlY29ubmVjdENodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHByZWNvbm5lY3RDaHVua3NbaV0pO1xuICB9XG5cbiAgcHJlY29ubmVjdENodW5rcy5sZW5ndGggPSAwO1xuICByZXNvdXJjZXMuZm9udFByZWxvYWRzLmZvckVhY2goZmx1c2hSZXNvdXJjZUxhdGUsIGRlc3RpbmF0aW9uKTtcbiAgcmVzb3VyY2VzLmZvbnRQcmVsb2Fkcy5jbGVhcigpO1xuICByZXNvdXJjZXMuaGlnaEltYWdlUHJlbG9hZHMuZm9yRWFjaChmbHVzaFJlc291cmNlSW5QcmVhbWJsZSwgZGVzdGluYXRpb24pO1xuICByZXNvdXJjZXMuaGlnaEltYWdlUHJlbG9hZHMuY2xlYXIoKTsgLy8gUHJlbG9hZCBhbnkgc3R5bGVzaGVldHMuIHRoZXNlIHdpbGwgZW1pdCBpbiBhIHJlbmRlciBpbnN0cnVjdGlvbiB0aGF0IGZvbGxvd3MgdGhpc1xuICAvLyBidXQgd2Ugd2FudCB0byBraWNrIG9mZiBwcmVsb2FkaW5nIGFzIHNvb24gYXMgcG9zc2libGVcblxuICByZXNvdXJjZXMucHJlY2VkZW5jZXMuZm9yRWFjaChwcmVsb2FkTGF0ZVN0eWxlcywgZGVzdGluYXRpb24pOyAvLyBib290c3RyYXAgc2NyaXB0cyBzaG91bGQgZmx1c2ggYWJvdmUgc2NyaXB0IHByaW9yaXR5IGJ1dCB0aGVzZSBjYW4gb25seSBmbHVzaCBpbiB0aGUgcHJlYW1ibGVcbiAgLy8gc28gd2UgZWxpZGUgdGhlIGNvZGUgaGVyZSBmb3IgcGVyZm9ybWFuY2VcblxuICByZXNvdXJjZXMuc2NyaXB0cy5mb3JFYWNoKGZsdXNoUmVzb3VyY2VMYXRlLCBkZXN0aW5hdGlvbik7XG4gIHJlc291cmNlcy5zY3JpcHRzLmNsZWFyKCk7XG4gIHJlc291cmNlcy5idWxrUHJlbG9hZHMuZm9yRWFjaChmbHVzaFJlc291cmNlTGF0ZSwgZGVzdGluYXRpb24pO1xuICByZXNvdXJjZXMuYnVsa1ByZWxvYWRzLmNsZWFyKCk7IC8vIFdyaXRlIGVtYmVkZGluZyBwcmVsb2FkQ2h1bmtzXG5cbiAgdmFyIHByZWxvYWRDaHVua3MgPSByZXNwb25zZVN0YXRlLnByZWxvYWRDaHVua3M7XG5cbiAgZm9yIChpID0gMDsgaSA8IHByZWxvYWRDaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBwcmVsb2FkQ2h1bmtzW2ldKTtcbiAgfVxuXG4gIHByZWxvYWRDaHVua3MubGVuZ3RoID0gMDsgLy8gV3JpdGUgZW1iZWRkaW5nIGhvaXN0YWJsZUNodW5rc1xuXG4gIHZhciBob2lzdGFibGVDaHVua3MgPSByZXNwb25zZVN0YXRlLmhvaXN0YWJsZUNodW5rcztcblxuICBmb3IgKGkgPSAwOyBpIDwgaG9pc3RhYmxlQ2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgaG9pc3RhYmxlQ2h1bmtzW2ldKTtcbiAgfVxuXG4gIGhvaXN0YWJsZUNodW5rcy5sZW5ndGggPSAwO1xufVxuZnVuY3Rpb24gd3JpdGVQb3N0YW1ibGUoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUpIHtcbiAgaWYgKHJlc3BvbnNlU3RhdGUuaGFzQm9keSkge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGVuZFRhZzEpO1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoJ2JvZHknKSk7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgZW5kVGFnMik7XG4gIH1cblxuICBpZiAocmVzcG9uc2VTdGF0ZS5odG1sQ2h1bmtzKSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgZW5kVGFnMSk7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuaygnaHRtbCcpKTtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBlbmRUYWcyKTtcbiAgfVxufVxudmFyIGFycmF5Rmlyc3RPcGVuQnJhY2tldCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnWycpO1xudmFyIGFycmF5U3Vic2VxdWVudE9wZW5CcmFja2V0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcsWycpO1xudmFyIGFycmF5SW50ZXJzdGl0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcsJyk7XG52YXIgYXJyYXlDbG9zZUJyYWNrZXQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ10nKTsgLy8gVGhpcyBmdW5jdGlvbiB3cml0ZXMgYSAyRCBhcnJheSBvZiBzdHJpbmdzIHRvIGJlIGVtYmVkZGVkIGluIGphdmFzY3JpcHQuXG4vLyBFLmcuXG4vLyAgW1tcIkpTX2VzY2FwZWRfc3RyaW5nMVwiLCBcIkpTX2VzY2FwZWRfc3RyaW5nMlwiXV1cblxuZnVuY3Rpb24gd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jaWVzSW5KUyhkZXN0aW5hdGlvbiwgYm91bmRhcnlSZXNvdXJjZXMpIHtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlGaXJzdE9wZW5CcmFja2V0KTtcbiAgdmFyIG5leHRBcnJheU9wZW5CcmFja0NodW5rID0gYXJyYXlGaXJzdE9wZW5CcmFja2V0O1xuICBib3VuZGFyeVJlc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChyZXNvdXJjZSkge1xuICAgIGlmIChyZXNvdXJjZS50eXBlID09PSAnc3R5bGUnKSA7IGVsc2UgaWYgKHJlc291cmNlLnN0YXRlICYgRmx1c2hlZEluUHJlYW1ibGUpIDsgZWxzZSBpZiAocmVzb3VyY2Uuc3RhdGUgJiBGbHVzaGVkKSB7XG4gICAgICAvLyBXZSBvbmx5IG5lZWQgdG8gZW1pdCB0aGUgaHJlZiBiZWNhdXNlIHRoaXMgcmVzb3VyY2UgZmx1c2hlZCBpbiBhbiBlYXJsaWVyXG4gICAgICAvLyBib3VuZGFyeSBhbHJlYWR5IHdoaWNoIGVuY29kZWQgdGhlIGF0dHJpYnV0ZXMgbmVjZXNzYXJ5IHRvIGNvbnN0cnVjdFxuICAgICAgLy8gdGhlIHJlc291cmNlIGluc3RhbmNlIG9uIHRoZSBjbGllbnQuXG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayk7XG4gICAgICB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmN5SHJlZk9ubHlJbkpTKGRlc3RpbmF0aW9uLCByZXNvdXJjZS5wcm9wcy5ocmVmKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGFycmF5Q2xvc2VCcmFja2V0KTtcbiAgICAgIG5leHRBcnJheU9wZW5CcmFja0NodW5rID0gYXJyYXlTdWJzZXF1ZW50T3BlbkJyYWNrZXQ7XG4gICAgfSBlbHNlIGlmIChyZXNvdXJjZS50eXBlID09PSAnc3R5bGVzaGVldCcpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gZW1pdCB0aGUgd2hvbGUgcmVzb3VyY2UgZm9yIGluc2VydGlvbiBvbiB0aGUgY2xpZW50XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayk7XG4gICAgICB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmN5SW5KUyhkZXN0aW5hdGlvbiwgcmVzb3VyY2UucHJvcHMuaHJlZiwgcmVzb3VyY2UucHJvcHNbJ2RhdGEtcHJlY2VkZW5jZSddLCByZXNvdXJjZS5wcm9wcyk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUNsb3NlQnJhY2tldCk7XG4gICAgICBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayA9IGFycmF5U3Vic2VxdWVudE9wZW5CcmFja2V0O1xuICAgICAgcmVzb3VyY2Uuc3RhdGUgfD0gRmx1c2hlZExhdGU7XG4gICAgfVxuICB9KTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlDbG9zZUJyYWNrZXQpO1xufVxuLyogSGVscGVyIGZ1bmN0aW9ucyAqL1xuXG5cbmZ1bmN0aW9uIHdyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY3lIcmVmT25seUluSlMoZGVzdGluYXRpb24sIGhyZWYpIHtcbiAgLy8gV2Ugc2hvdWxkIGFjdHVhbGx5IGVuZm9yY2UgdGhpcyBlYXJsaWVyIHdoZW4gdGhlIHJlc291cmNlIGlzIGNyZWF0ZWQgYnV0IGZvclxuICAvLyBub3cgd2UgbWFrZSBzdXJlIHdlIGFyZSBhY3R1YWxseSBkZWFsaW5nIHdpdGggYSBzdHJpbmcgaGVyZS5cbiAge1xuICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24oaHJlZiwgJ2hyZWYnKTtcbiAgfVxuXG4gIHZhciBjb2VyY2VkSHJlZiA9ICcnICsgaHJlZjtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyhjb2VyY2VkSHJlZikpKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jeUluSlMoZGVzdGluYXRpb24sIGhyZWYsIHByZWNlZGVuY2UsIHByb3BzKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICB2YXIgY29lcmNlZEhyZWYgPSBzYW5pdGl6ZVVSTCgnJyArIGhyZWYpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGNvZXJjZWRIcmVmKSkpO1xuXG4gIHtcbiAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHByZWNlZGVuY2UsICdwcmVjZWRlbmNlJyk7XG4gIH1cblxuICB2YXIgY29lcmNlZFByZWNlZGVuY2UgPSAnJyArIHByZWNlZGVuY2U7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGFycmF5SW50ZXJzdGl0aWFsKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyhjb2VyY2VkUHJlY2VkZW5jZSkpKTtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2hyZWYnOlxuICAgICAgICBjYXNlICdyZWwnOlxuICAgICAgICBjYXNlICdwcmVjZWRlbmNlJzpcbiAgICAgICAgY2FzZSAnZGF0YS1wcmVjZWRlbmNlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsaW5rJyArIFwiIGlzIGEgc2VsZi1jbG9zaW5nIHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgXCIgKyAndXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB3cml0ZVN0eWxlUmVzb3VyY2VBdHRyaWJ1dGVJbkpTKGRlc3RpbmF0aW9uLCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiB3cml0ZVN0eWxlUmVzb3VyY2VBdHRyaWJ1dGVJbkpTKGRlc3RpbmF0aW9uLCBuYW1lLCB2YWx1ZSkgLy8gbm90IG51bGwgb3IgdW5kZWZpbmVkXG57XG4gIHZhciBhdHRyaWJ1dGVOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICB2YXIgYXR0cmlidXRlVmFsdWU7XG5cbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAobmFtZSkge1xuICAgIC8vIFJlc2VydmVkIG5hbWVzXG4gICAgY2FzZSAnaW5uZXJIVE1MJzpcbiAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgY2FzZSAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJzpcbiAgICBjYXNlICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnOlxuICAgIGNhc2UgJ3N0eWxlJzpcbiAgICAgIC8vIElnbm9yZWRcbiAgICAgIHJldHVybjtcbiAgICAvLyBBdHRyaWJ1dGUgcmVuYW1lc1xuXG4gICAgY2FzZSAnY2xhc3NOYW1lJzpcbiAgICAgIHtcbiAgICAgICAgYXR0cmlidXRlTmFtZSA9ICdjbGFzcyc7XG5cbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAvLyBCb29sZWFuc1xuXG4gICAgY2FzZSAnaGlkZGVuJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJpYnV0ZVZhbHVlID0gJyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIC8vIFNhbnRpemVkIFVSTHNcblxuICAgIGNhc2UgJ3NyYyc6XG4gICAgY2FzZSAnaHJlZic6XG4gICAgICB7XG4gICAgICAgIHZhbHVlID0gc2FuaXRpemVVUkwodmFsdWUpO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJpYnV0ZVZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBpZiAoIC8vIHVucmVjb2duaXplZCBldmVudCBoYW5kbGVycyBhcmUgbm90IFNTUidkIGFuZCB3ZSAoYXBwYXJlbnRseSlcbiAgICAgICAgLy8gdXNlIG9uKiBhcyBodWVyaXN0aWMgZm9yIHRoZXNlIGhhbmRsZXIgcHJvcHNcbiAgICAgICAgbmFtZS5sZW5ndGggPiAyICYmIChuYW1lWzBdID09PSAnbycgfHwgbmFtZVswXSA9PT0gJ08nKSAmJiAobmFtZVsxXSA9PT0gJ24nIHx8IG5hbWVbMV0gPT09ICdOJykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWJ1dGVWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICB9XG4gIH1cblxuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUludGVyc3RpdGlhbCk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMoYXR0cmlidXRlTmFtZSkpKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlJbnRlcnN0aXRpYWwpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGF0dHJpYnV0ZVZhbHVlKSkpO1xufSAvLyBUaGlzIGZ1bmN0aW9uIHdyaXRlcyBhIDJEIGFycmF5IG9mIHN0cmluZ3MgdG8gYmUgZW1iZWRkZWQgaW4gYW4gYXR0cmlidXRlXG4vLyB2YWx1ZSBhbmQgcmVhZCB3aXRoIEpTT04ucGFyc2UgaW4gUmVhY3RET01TZXJ2ZXJFeHRlcm5hbFJ1bnRpbWUuanNcbi8vIEUuZy5cbi8vICBbWyZxdW90O0pTT05fZXNjYXBlZF9zdHJpbmcxJnF1b3Q7LCAmcXVvdDtKU09OX2VzY2FwZWRfc3RyaW5nMiZxdW90O11dXG5cblxuZnVuY3Rpb24gd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jaWVzSW5BdHRyKGRlc3RpbmF0aW9uLCBib3VuZGFyeVJlc291cmNlcykge1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUZpcnN0T3BlbkJyYWNrZXQpO1xuICB2YXIgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmsgPSBhcnJheUZpcnN0T3BlbkJyYWNrZXQ7XG4gIGJvdW5kYXJ5UmVzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHJlc291cmNlKSB7XG4gICAgaWYgKHJlc291cmNlLnR5cGUgPT09ICdzdHlsZScpIDsgZWxzZSBpZiAocmVzb3VyY2Uuc3RhdGUgJiBGbHVzaGVkSW5QcmVhbWJsZSkgOyBlbHNlIGlmIChyZXNvdXJjZS5zdGF0ZSAmIEZsdXNoZWQpIHtcbiAgICAgIC8vIFdlIG9ubHkgbmVlZCB0byBlbWl0IHRoZSBocmVmIGJlY2F1c2UgdGhpcyByZXNvdXJjZSBmbHVzaGVkIGluIGFuIGVhcmxpZXJcbiAgICAgIC8vIGJvdW5kYXJ5IGFscmVhZHkgd2hpY2ggZW5jb2RlZCB0aGUgYXR0cmlidXRlcyBuZWNlc3NhcnkgdG8gY29uc3RydWN0XG4gICAgICAvLyB0aGUgcmVzb3VyY2UgaW5zdGFuY2Ugb24gdGhlIGNsaWVudC5cbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIG5leHRBcnJheU9wZW5CcmFja0NodW5rKTtcbiAgICAgIHdyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY3lIcmVmT25seUluQXR0cihkZXN0aW5hdGlvbiwgcmVzb3VyY2UucHJvcHMuaHJlZik7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUNsb3NlQnJhY2tldCk7XG4gICAgICBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayA9IGFycmF5U3Vic2VxdWVudE9wZW5CcmFja2V0O1xuICAgIH0gZWxzZSBpZiAocmVzb3VyY2UudHlwZSA9PT0gJ3N0eWxlc2hlZXQnKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGVtaXQgdGhlIHdob2xlIHJlc291cmNlIGZvciBpbnNlcnRpb24gb24gdGhlIGNsaWVudFxuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmspO1xuICAgICAgd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jeUluQXR0cihkZXN0aW5hdGlvbiwgcmVzb3VyY2UucHJvcHMuaHJlZiwgcmVzb3VyY2UucHJvcHNbJ2RhdGEtcHJlY2VkZW5jZSddLCByZXNvdXJjZS5wcm9wcyk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUNsb3NlQnJhY2tldCk7XG4gICAgICBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayA9IGFycmF5U3Vic2VxdWVudE9wZW5CcmFja2V0O1xuICAgICAgcmVzb3VyY2Uuc3RhdGUgfD0gRmx1c2hlZExhdGU7XG4gICAgfVxuICB9KTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlDbG9zZUJyYWNrZXQpO1xufVxuLyogSGVscGVyIGZ1bmN0aW9ucyAqL1xuXG5cbmZ1bmN0aW9uIHdyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY3lIcmVmT25seUluQXR0cihkZXN0aW5hdGlvbiwgaHJlZikge1xuICAvLyBXZSBzaG91bGQgYWN0dWFsbHkgZW5mb3JjZSB0aGlzIGVhcmxpZXIgd2hlbiB0aGUgcmVzb3VyY2UgaXMgY3JlYXRlZCBidXQgZm9yXG4gIC8vIG5vdyB3ZSBtYWtlIHN1cmUgd2UgYXJlIGFjdHVhbGx5IGRlYWxpbmcgd2l0aCBhIHN0cmluZyBoZXJlLlxuICB7XG4gICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihocmVmLCAnaHJlZicpO1xuICB9XG5cbiAgdmFyIGNvZXJjZWRIcmVmID0gJycgKyBocmVmO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKEpTT04uc3RyaW5naWZ5KGNvZXJjZWRIcmVmKSkpKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jeUluQXR0cihkZXN0aW5hdGlvbiwgaHJlZiwgcHJlY2VkZW5jZSwgcHJvcHMpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHZhciBjb2VyY2VkSHJlZiA9IHNhbml0aXplVVJMKCcnICsgaHJlZik7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoSlNPTi5zdHJpbmdpZnkoY29lcmNlZEhyZWYpKSkpO1xuXG4gIHtcbiAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHByZWNlZGVuY2UsICdwcmVjZWRlbmNlJyk7XG4gIH1cblxuICB2YXIgY29lcmNlZFByZWNlZGVuY2UgPSAnJyArIHByZWNlZGVuY2U7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGFycmF5SW50ZXJzdGl0aWFsKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihKU09OLnN0cmluZ2lmeShjb2VyY2VkUHJlY2VkZW5jZSkpKSk7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdocmVmJzpcbiAgICAgICAgY2FzZSAncmVsJzpcbiAgICAgICAgY2FzZSAncHJlY2VkZW5jZSc6XG4gICAgICAgIGNhc2UgJ2RhdGEtcHJlY2VkZW5jZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbGluaycgKyBcIiBpcyBhIHNlbGYtY2xvc2luZyB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIFwiICsgJ3VzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgd3JpdGVTdHlsZVJlc291cmNlQXR0cmlidXRlSW5BdHRyKGRlc3RpbmF0aW9uLCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiB3cml0ZVN0eWxlUmVzb3VyY2VBdHRyaWJ1dGVJbkF0dHIoZGVzdGluYXRpb24sIG5hbWUsIHZhbHVlKSAvLyBub3QgbnVsbCBvciB1bmRlZmluZWRcbntcbiAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBhdHRyaWJ1dGVWYWx1ZTtcblxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgLy8gUmVzZXJ2ZWQgbmFtZXNcbiAgICBjYXNlICdpbm5lckhUTUwnOlxuICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICBjYXNlICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnOlxuICAgIGNhc2UgJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZyc6XG4gICAgY2FzZSAnc3R5bGUnOlxuICAgICAgLy8gSWdub3JlZFxuICAgICAgcmV0dXJuO1xuICAgIC8vIEF0dHJpYnV0ZSByZW5hbWVzXG5cbiAgICBjYXNlICdjbGFzc05hbWUnOlxuICAgICAge1xuICAgICAgICBhdHRyaWJ1dGVOYW1lID0gJ2NsYXNzJztcblxuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWJ1dGVWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIC8vIEJvb2xlYW5zXG5cbiAgICBjYXNlICdoaWRkZW4nOlxuICAgICAge1xuICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgLy8gU2FudGl6ZWQgVVJMc1xuXG4gICAgY2FzZSAnc3JjJzpcbiAgICBjYXNlICdocmVmJzpcbiAgICAgIHtcbiAgICAgICAgdmFsdWUgPSBzYW5pdGl6ZVVSTCh2YWx1ZSk7XG5cbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIGlmICggLy8gdW5yZWNvZ25pemVkIGV2ZW50IGhhbmRsZXJzIGFyZSBub3QgU1NSJ2QgYW5kIHdlIChhcHBhcmVudGx5KVxuICAgICAgICAvLyB1c2Ugb24qIGFzIGh1ZXJpc3RpYyBmb3IgdGhlc2UgaGFuZGxlciBwcm9wc1xuICAgICAgICBuYW1lLmxlbmd0aCA+IDIgJiYgKG5hbWVbMF0gPT09ICdvJyB8fCBuYW1lWzBdID09PSAnTycpICYmIChuYW1lWzFdID09PSAnbicgfHwgbmFtZVsxXSA9PT0gJ04nKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJpYnV0ZVZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgIH1cbiAgfVxuXG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGFycmF5SW50ZXJzdGl0aWFsKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihKU09OLnN0cmluZ2lmeShhdHRyaWJ1dGVOYW1lKSkpKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlJbnRlcnN0aXRpYWwpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKEpTT04uc3RyaW5naWZ5KGF0dHJpYnV0ZVZhbHVlKSkpKTtcbn1cbi8qKlxuICogUmVzb3VyY2VzXG4gKi9cblxuXG52YXIgTm9TdGF0ZVxuLyogICAgICAgICAgICAqL1xuPSAwOyAvLyBUaGVzZSB0YWdzIGluZGljYXRlIHdoZXRoZXIgdGhlIFJlc291cmNlIHdhcyBmbHVzaGVkIGFuZCBpbiB3aGljaCBwaGFzZVxuXG52YXIgRmx1c2hlZEluUHJlYW1ibGVcbi8qICAqL1xuPSAxO1xudmFyIEZsdXNoZWRMYXRlXG4vKiAgICAgICAgKi9cbj0gMjtcbnZhciBGbHVzaGVkXG4vKiAgICAgICAgICAgICovXG49IDM7IC8vIFRoaXMgdGFnIGluZGljYXRlcyB3aGV0aGVyIHRoaXMgUmVzb3VyY2UgaXMgYmxvY2tlZCBmcm9tIGZsdXNoaW5nLlxuLy8gVGhpcyBjdXJyZW50bHkgaXMgb25seSB1c2VkIHdpdGggc3R5bGVzaGVldHMgdGhhdCBhcmUgYmxvY2tlZCBieSBhIEJvdW5kYXJ5XG5cbnZhciBCbG9ja2VkXG4vKiAgICAgICAgICAgICovXG49IDQ7IC8vIFRoaXMgdGFnIGluZGljYXRlcyB3aGV0aGVyIHRoaXMgUmVzb3VyY2UgaGFzIGJlZW4gcHJlbG9hZGVkLlxuLy8gVGhpcyBnZW5lcmFsbHkgb25seSBtYWtlcyBzZW5zZSBmb3IgUmVzb3VyY2VzIG90aGVyIHRoYW4gUHJlbG9hZFJlc291cmNlXG5cbnZhciBQcmVsb2FkRmx1c2hlZFxuLyogICAgICovXG49IDg7IC8vIERldiBleHRlbnNpb25zLlxuLy8gU3R5bGVzaGVldHMgYW5kIFNjcmlwdHMgcmVuZGVyZWQgd2l0aCBqc3hcbi8vIFByZWxvYWRzLCBTdHlsZXNoZWV0cywgYW5kIFNjcmlwdHMgZnJvbSBSZWFjdERPTS5wcmVsb2FkIG9yIFJlYWN0RE9NLnByZWluaXRcbi8vIFByZWxvYWRzIGNyZWF0ZWQgZm9yIG5vcm1hbCBjb21wb25lbnRzIHdlIHJlbmRlcmVkIGJ1dCBrbm93IHdlIGNhbiBwcmVsb2FkIGVhcmx5IHN1Y2ggYXNcbi8vIHN5bmMgU2NyaXB0cyBhbmQgc3R5bGVzaGVldHMgd2l0aG91dCBwcmVjZWRlbmNlIG9yIHdpdGggb25Mb2FkL29uRXJyb3IgaGFuZGxlcnNcbi8vIEBUT0RPIGFkZCBib290c3RyYXAgc2NyaXB0IHRvIGltcGxpY2l0IHByZWxvYWRzXG5cbmZ1bmN0aW9uIGNyZWF0ZVJlc291cmNlcygpIHtcbiAgcmV0dXJuIHtcbiAgICAvLyBwZXJzaXN0ZW50XG4gICAgcHJlbG9hZHNNYXA6IG5ldyBNYXAoKSxcbiAgICBwcmVjb25uZWN0c01hcDogbmV3IE1hcCgpLFxuICAgIHN0eWxlc01hcDogbmV3IE1hcCgpLFxuICAgIHNjcmlwdHNNYXA6IG5ldyBNYXAoKSxcbiAgICAvLyBjbGVhcmVkIG9uIGZsdXNoXG4gICAgcHJlY29ubmVjdHM6IG5ldyBTZXQoKSxcbiAgICBmb250UHJlbG9hZHM6IG5ldyBTZXQoKSxcbiAgICBoaWdoSW1hZ2VQcmVsb2FkczogbmV3IFNldCgpLFxuICAgIC8vIHVzZWRJbWFnZVByZWxvYWRzOiBuZXcgU2V0KCksXG4gICAgcHJlY2VkZW5jZXM6IG5ldyBNYXAoKSxcbiAgICBzdHlsZVByZWNlZGVuY2VzOiBuZXcgTWFwKCksXG4gICAgYm9vdHN0cmFwU2NyaXB0czogbmV3IFNldCgpLFxuICAgIHNjcmlwdHM6IG5ldyBTZXQoKSxcbiAgICBidWxrUHJlbG9hZHM6IG5ldyBTZXQoKSxcbiAgICAvLyBsaWtlIGEgbW9kdWxlIGdsb2JhbCBmb3IgY3VycmVudGx5IHJlbmRlcmluZyBib3VuZGFyeVxuICAgIGJvdW5kYXJ5UmVzb3VyY2VzOiBudWxsXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVCb3VuZGFyeVJlc291cmNlcygpIHtcbiAgcmV0dXJuIG5ldyBTZXQoKTtcbn1cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5UmVzb3VyY2VzVGFyZ2V0KHJlc291cmNlcywgYm91bmRhcnlSZXNvdXJjZXMpIHtcbiAgcmVzb3VyY2VzLmJvdW5kYXJ5UmVzb3VyY2VzID0gYm91bmRhcnlSZXNvdXJjZXM7XG59XG5cbmZ1bmN0aW9uIGdldFJlc291cmNlS2V5KGFzLCBocmVmKSB7XG4gIHJldHVybiBcIltcIiArIGFzICsgXCJdXCIgKyBocmVmO1xufVxuXG5mdW5jdGlvbiBwcmVmZXRjaEROUyhocmVmLCBvcHRpb25zKSB7XG5cbiAgdmFyIHJlcXVlc3QgPSByZXNvbHZlUmVxdWVzdCgpO1xuXG4gIGlmICghcmVxdWVzdCkge1xuICAgIC8vIEluIGFzeW5jIGNvbnRleHRzIHdlIGNhbiBzb21ldGltZXMgcmVzb2x2ZSByZXNvdXJjZXMgZnJvbSBBc3luY0xvY2FsU3RvcmFnZS4gSWYgd2UgY2FuJ3Qgd2UgY2FuIGFsc29cbiAgICAvLyBwb3NzaWJseSBnZXQgdGhlbSBmcm9tIHRoZSBzdGFjayBpZiB3ZSBhcmUgbm90IGluIGFuIGFzeW5jIGNvbnRleHQuIFNpbmNlIHdlIHdlcmUgbm90IGFibGUgdG8gcmVzb2x2ZVxuICAgIC8vIHRoZSByZXNvdXJjZXMgZm9yIHRoaXMgY2FsbCBpbiBlaXRoZXIgY2FzZSB3ZSBvcHQgdG8gZG8gbm90aGluZy4gV2UgY2FuIGNvbnNpZGVyIG1ha2luZyB0aGlzIGEgd2FybmluZ1xuICAgIC8vIGJ1dCB0aGVyZSBtYXkgYmUgdGltZXMgd2hlcmUgY2FsbGluZyBhIGZ1bmN0aW9uIG91dHNpZGUgb2YgcmVuZGVyIGlzIGludGVudGlvbmFsIChpLmUuIHRvIHdhcm0gdXAgZGF0YVxuICAgIC8vIGZldGNoaW5nKSBhbmQgd2UgZG9uJ3Qgd2FudCB0byB3YXJuIGluIHRob3NlIGNhc2VzLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByZXNvdXJjZXMgPSBnZXRSZXNvdXJjZXMocmVxdWVzdCk7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgaHJlZiAhPT0gJ3N0cmluZycgfHwgIWhyZWYpIHtcbiAgICAgIGVycm9yKCdSZWFjdERPTS5wcmVmZXRjaEROUygpOiBFeHBlY3RlZCB0aGUgYGhyZWZgIGFyZ3VtZW50IChmaXJzdCkgdG8gYmUgYSBub24tZW1wdHkgc3RyaW5nIGJ1dCBlbmNvdW50ZXJlZCAlcyBpbnN0ZWFkLicsIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcoaHJlZikpO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2Nyb3NzT3JpZ2luJykpIHtcbiAgICAgICAgZXJyb3IoJ1JlYWN0RE9NLnByZWZldGNoRE5TKCk6IEV4cGVjdGVkIG9ubHkgb25lIGFyZ3VtZW50LCBgaHJlZmAsIGJ1dCBlbmNvdW50ZXJlZCAlcyBhcyBhIHNlY29uZCBhcmd1bWVudCBpbnN0ZWFkLiBUaGlzIGFyZ3VtZW50IGlzIHJlc2VydmVkIGZvciBmdXR1cmUgb3B0aW9ucyBhbmQgaXMgY3VycmVudGx5IGRpc2FsbG93ZWQuIEl0IGxvb2tzIGxpa2UgdGhlIHlvdSBhcmUgYXR0ZW1wdGluZyB0byBzZXQgYSBjcm9zc09yaWdpbiBwcm9wZXJ0eSBmb3IgdGhpcyBETlMgbG9va3VwIGhpbnQuIEJyb3dzZXJzIGRvIG5vdCBwZXJmb3JtIEROUyBxdWVyaWVzIHVzaW5nIENPUlMgYW5kIHNldHRpbmcgdGhpcyBhdHRyaWJ1dGUgb24gdGhlIHJlc291cmNlIGhpbnQgaGFzIG5vIGVmZmVjdC4gVHJ5IGNhbGxpbmcgUmVhY3RET00ucHJlZmV0Y2hETlMoKSB3aXRoIGp1c3QgYSBzaW5nbGUgc3RyaW5nIGFyZ3VtZW50LCBgaHJlZmAuJywgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcob3B0aW9ucykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IoJ1JlYWN0RE9NLnByZWZldGNoRE5TKCk6IEV4cGVjdGVkIG9ubHkgb25lIGFyZ3VtZW50LCBgaHJlZmAsIGJ1dCBlbmNvdW50ZXJlZCAlcyBhcyBhIHNlY29uZCBhcmd1bWVudCBpbnN0ZWFkLiBUaGlzIGFyZ3VtZW50IGlzIHJlc2VydmVkIGZvciBmdXR1cmUgb3B0aW9ucyBhbmQgaXMgY3VycmVudGx5IGRpc2FsbG93ZWQuIFRyeSBjYWxsaW5nIFJlYWN0RE9NLnByZWZldGNoRE5TKCkgd2l0aCBqdXN0IGEgc2luZ2xlIHN0cmluZyBhcmd1bWVudCwgYGhyZWZgLicsIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKG9wdGlvbnMpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGhyZWYgPT09ICdzdHJpbmcnICYmIGhyZWYpIHtcbiAgICB2YXIga2V5ID0gZ2V0UmVzb3VyY2VLZXkoJ3ByZWZldGNoRE5TJywgaHJlZik7XG4gICAgdmFyIHJlc291cmNlID0gcmVzb3VyY2VzLnByZWNvbm5lY3RzTWFwLmdldChrZXkpO1xuXG4gICAgaWYgKCFyZXNvdXJjZSkge1xuICAgICAgcmVzb3VyY2UgPSB7XG4gICAgICAgIHR5cGU6ICdwcmVjb25uZWN0JyxcbiAgICAgICAgY2h1bmtzOiBbXSxcbiAgICAgICAgc3RhdGU6IE5vU3RhdGUsXG4gICAgICAgIHByb3BzOiBudWxsXG4gICAgICB9O1xuICAgICAgcmVzb3VyY2VzLnByZWNvbm5lY3RzTWFwLnNldChrZXksIHJlc291cmNlKTtcbiAgICAgIHB1c2hMaW5rSW1wbChyZXNvdXJjZS5jaHVua3MsIHtcbiAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgcmVsOiAnZG5zLXByZWZldGNoJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVzb3VyY2VzLnByZWNvbm5lY3RzLmFkZChyZXNvdXJjZSk7XG4gICAgZmx1c2hSZXNvdXJjZXMocmVxdWVzdCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHByZWNvbm5lY3QoaHJlZiwgb3B0aW9ucykge1xuXG4gIHZhciByZXF1ZXN0ID0gcmVzb2x2ZVJlcXVlc3QoKTtcblxuICBpZiAoIXJlcXVlc3QpIHtcbiAgICAvLyBJbiBhc3luYyBjb250ZXh0cyB3ZSBjYW4gc29tZXRpbWVzIHJlc29sdmUgcmVzb3VyY2VzIGZyb20gQXN5bmNMb2NhbFN0b3JhZ2UuIElmIHdlIGNhbid0IHdlIGNhbiBhbHNvXG4gICAgLy8gcG9zc2libHkgZ2V0IHRoZW0gZnJvbSB0aGUgc3RhY2sgaWYgd2UgYXJlIG5vdCBpbiBhbiBhc3luYyBjb250ZXh0LiBTaW5jZSB3ZSB3ZXJlIG5vdCBhYmxlIHRvIHJlc29sdmVcbiAgICAvLyB0aGUgcmVzb3VyY2VzIGZvciB0aGlzIGNhbGwgaW4gZWl0aGVyIGNhc2Ugd2Ugb3B0IHRvIGRvIG5vdGhpbmcuIFdlIGNhbiBjb25zaWRlciBtYWtpbmcgdGhpcyBhIHdhcm5pbmdcbiAgICAvLyBidXQgdGhlcmUgbWF5IGJlIHRpbWVzIHdoZXJlIGNhbGxpbmcgYSBmdW5jdGlvbiBvdXRzaWRlIG9mIHJlbmRlciBpcyBpbnRlbnRpb25hbCAoaS5lLiB0byB3YXJtIHVwIGRhdGFcbiAgICAvLyBmZXRjaGluZykgYW5kIHdlIGRvbid0IHdhbnQgdG8gd2FybiBpbiB0aG9zZSBjYXNlcy5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVzb3VyY2VzID0gZ2V0UmVzb3VyY2VzKHJlcXVlc3QpO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGhyZWYgIT09ICdzdHJpbmcnIHx8ICFocmVmKSB7XG4gICAgICBlcnJvcignUmVhY3RET00ucHJlY29ubmVjdCgpOiBFeHBlY3RlZCB0aGUgYGhyZWZgIGFyZ3VtZW50IChmaXJzdCkgdG8gYmUgYSBub24tZW1wdHkgc3RyaW5nIGJ1dCBlbmNvdW50ZXJlZCAlcyBpbnN0ZWFkLicsIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcoaHJlZikpO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucyAhPSBudWxsICYmIHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgZXJyb3IoJ1JlYWN0RE9NLnByZWNvbm5lY3QoKTogRXhwZWN0ZWQgdGhlIGBvcHRpb25zYCBhcmd1bWVudCAoc2Vjb25kKSB0byBiZSBhbiBvYmplY3QgYnV0IGVuY291bnRlcmVkICVzIGluc3RlYWQuIFRoZSBvbmx5IHN1cHBvcnRlZCBvcHRpb24gYXQgdGhpcyB0aW1lIGlzIGBjcm9zc09yaWdpbmAgd2hpY2ggYWNjZXB0cyBhIHN0cmluZy4nLCBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhvcHRpb25zKSk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zICE9IG51bGwgJiYgdHlwZW9mIG9wdGlvbnMuY3Jvc3NPcmlnaW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJvcignUmVhY3RET00ucHJlY29ubmVjdCgpOiBFeHBlY3RlZCB0aGUgYGNyb3NzT3JpZ2luYCBvcHRpb24gKHNlY29uZCBhcmd1bWVudCkgdG8gYmUgYSBzdHJpbmcgYnV0IGVuY291bnRlcmVkICVzIGluc3RlYWQuIFRyeSByZW1vdmluZyB0aGlzIG9wdGlvbiBvciBwYXNzaW5nIGEgc3RyaW5nIHZhbHVlIGluc3RlYWQuJywgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nT2JqZWN0Rm9yV2FybmluZyhvcHRpb25zLmNyb3NzT3JpZ2luKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBocmVmID09PSAnc3RyaW5nJyAmJiBocmVmKSB7XG4gICAgdmFyIGNyb3NzT3JpZ2luID0gb3B0aW9ucyA9PSBudWxsIHx8IHR5cGVvZiBvcHRpb25zLmNyb3NzT3JpZ2luICE9PSAnc3RyaW5nJyA/IG51bGwgOiBvcHRpb25zLmNyb3NzT3JpZ2luID09PSAndXNlLWNyZWRlbnRpYWxzJyA/ICd1c2UtY3JlZGVudGlhbHMnIDogJyc7XG4gICAgdmFyIGtleSA9IFwiW3ByZWNvbm5lY3RdW1wiICsgKGNyb3NzT3JpZ2luID09PSBudWxsID8gJ251bGwnIDogY3Jvc3NPcmlnaW4pICsgXCJdXCIgKyBocmVmO1xuICAgIHZhciByZXNvdXJjZSA9IHJlc291cmNlcy5wcmVjb25uZWN0c01hcC5nZXQoa2V5KTtcblxuICAgIGlmICghcmVzb3VyY2UpIHtcbiAgICAgIHJlc291cmNlID0ge1xuICAgICAgICB0eXBlOiAncHJlY29ubmVjdCcsXG4gICAgICAgIGNodW5rczogW10sXG4gICAgICAgIHN0YXRlOiBOb1N0YXRlLFxuICAgICAgICBwcm9wczogbnVsbFxuICAgICAgfTtcbiAgICAgIHJlc291cmNlcy5wcmVjb25uZWN0c01hcC5zZXQoa2V5LCByZXNvdXJjZSk7XG4gICAgICBwdXNoTGlua0ltcGwocmVzb3VyY2UuY2h1bmtzLCB7XG4gICAgICAgIHJlbDogJ3ByZWNvbm5lY3QnLFxuICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW5cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlc291cmNlcy5wcmVjb25uZWN0cy5hZGQocmVzb3VyY2UpO1xuICAgIGZsdXNoUmVzb3VyY2VzKHJlcXVlc3QpO1xuICB9XG59XG5mdW5jdGlvbiBwcmVsb2FkKGhyZWYsIG9wdGlvbnMpIHtcblxuICB2YXIgcmVxdWVzdCA9IHJlc29sdmVSZXF1ZXN0KCk7XG5cbiAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgLy8gSW4gYXN5bmMgY29udGV4dHMgd2UgY2FuIHNvbWV0aW1lcyByZXNvbHZlIHJlc291cmNlcyBmcm9tIEFzeW5jTG9jYWxTdG9yYWdlLiBJZiB3ZSBjYW4ndCB3ZSBjYW4gYWxzb1xuICAgIC8vIHBvc3NpYmx5IGdldCB0aGVtIGZyb20gdGhlIHN0YWNrIGlmIHdlIGFyZSBub3QgaW4gYW4gYXN5bmMgY29udGV4dC4gU2luY2Ugd2Ugd2VyZSBub3QgYWJsZSB0byByZXNvbHZlXG4gICAgLy8gdGhlIHJlc291cmNlcyBmb3IgdGhpcyBjYWxsIGluIGVpdGhlciBjYXNlIHdlIG9wdCB0byBkbyBub3RoaW5nLiBXZSBjYW4gY29uc2lkZXIgbWFraW5nIHRoaXMgYSB3YXJuaW5nXG4gICAgLy8gYnV0IHRoZXJlIG1heSBiZSB0aW1lcyB3aGVyZSBjYWxsaW5nIGEgZnVuY3Rpb24gb3V0c2lkZSBvZiByZW5kZXIgaXMgaW50ZW50aW9uYWwgKGkuZS4gdG8gd2FybSB1cCBkYXRhXG4gICAgLy8gZmV0Y2hpbmcpIGFuZCB3ZSBkb24ndCB3YW50IHRvIHdhcm4gaW4gdGhvc2UgY2FzZXMuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJlc291cmNlcyA9IGdldFJlc291cmNlcyhyZXF1ZXN0KTtcblxuICB7XG4gICAgdmFyIGVuY291bnRlcmVkID0gJyc7XG5cbiAgICBpZiAodHlwZW9mIGhyZWYgIT09ICdzdHJpbmcnIHx8ICFocmVmKSB7XG4gICAgICBlbmNvdW50ZXJlZCArPSBcIiBUaGUgYGhyZWZgIGFyZ3VtZW50IGVuY291bnRlcmVkIHdhcyBcIiArIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcoaHJlZikgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucyA9PSBudWxsIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgZW5jb3VudGVyZWQgKz0gXCIgVGhlIGBvcHRpb25zYCBhcmd1bWVudCBlbmNvdW50ZXJlZCB3YXMgXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdPYmplY3RGb3JXYXJuaW5nKG9wdGlvbnMpICsgXCIuXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5hcyAhPT0gJ3N0cmluZycgfHwgIW9wdGlvbnMuYXMpIHtcbiAgICAgIGVuY291bnRlcmVkICs9IFwiIFRoZSBgYXNgIG9wdGlvbiBlbmNvdW50ZXJlZCB3YXMgXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdPYmplY3RGb3JXYXJuaW5nKG9wdGlvbnMuYXMpICsgXCIuXCI7XG4gICAgfVxuXG4gICAgaWYgKGVuY291bnRlcmVkKSB7XG4gICAgICBlcnJvcignUmVhY3RET00ucHJlbG9hZCgpOiBFeHBlY3RlZCB0d28gYXJndW1lbnRzLCBhIG5vbi1lbXB0eSBgaHJlZmAgc3RyaW5nIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0IHdpdGggYW4gYGFzYCBwcm9wZXJ0eSB2YWxpZCBmb3IgYSBgPGxpbmsgcmVsPVwicHJlbG9hZFwiIGFzPVwiLi4uXCIgLz5gIHRhZy4lcycsIGVuY291bnRlcmVkKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGhyZWYgPT09ICdzdHJpbmcnICYmIGhyZWYgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgIT09IG51bGwgJiYgdHlwZW9mIG9wdGlvbnMuYXMgPT09ICdzdHJpbmcnICYmIG9wdGlvbnMuYXMpIHtcbiAgICB2YXIgYXMgPSBvcHRpb25zLmFzO1xuICAgIHZhciBrZXk7XG5cbiAgICBpZiAoYXMgPT09ICdpbWFnZScpIHtcbiAgICAgIC8vIEZvciBpbWFnZSBwcmVsb2FkcyB0aGUga2V5IGNvbnRhaW5zIGVpdGhlciB0aGUgaW1hZ2VTcmNTZXQgKyBpbWFnZVNpemVzIG9yIHRoZSBocmVmIGJ1dCBub3RcbiAgICAgIC8vIGJvdGguIFRoaXMgaXMgdG8gcHJldmVudCBpZGVudGljYWwgY2FsbHMgd2l0aCB0aGUgc2FtZSBzcmNTZXQgYW5kIHNpemVzIHRvIGJlIGR1cGxpY2F0ZWRcbiAgICAgIC8vIGJ5IHZhcnlpbmcgdGhlIGhyZWYuIHRoaXMgaXMgYW4gZWRnZSBjYXNlIGJ1dCBpdCBpcyB0aGUgbW9zdCBjb3JyZWN0IGJlaGF2aW9yLlxuICAgICAgdmFyIGltYWdlU3JjU2V0ID0gb3B0aW9ucy5pbWFnZVNyY1NldCxcbiAgICAgICAgICBpbWFnZVNpemVzID0gb3B0aW9ucy5pbWFnZVNpemVzO1xuICAgICAga2V5ID0gZ2V0SW1hZ2VQcmVsb2FkS2V5KGhyZWYsIGltYWdlU3JjU2V0LCBpbWFnZVNpemVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5ID0gZ2V0UmVzb3VyY2VLZXkoYXMsIGhyZWYpO1xuICAgIH1cblxuICAgIHZhciByZXNvdXJjZSA9IHJlc291cmNlcy5wcmVsb2Fkc01hcC5nZXQoa2V5KTtcblxuICAgIHtcbiAgICAgIHZhciBkZXZSZXNvdXJjZSA9IGdldEFzUmVzb3VyY2VERVYocmVzb3VyY2UpO1xuXG4gICAgICBpZiAoZGV2UmVzb3VyY2UpIHtcbiAgICAgICAgc3dpdGNoIChkZXZSZXNvdXJjZS5fX3Byb3ZlbmFuY2UpIHtcbiAgICAgICAgICBjYXNlICdwcmVsb2FkJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGRpZmZlcmVuY2VEZXNjcmlwdGlvbiA9IGRlc2NyaWJlRGlmZmVyZW5jZXNGb3JQcmVsb2FkcyhvcHRpb25zLCBkZXZSZXNvdXJjZS5fX29yaWdpbmFsT3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgaWYgKGRpZmZlcmVuY2VEZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIGVycm9yKCdSZWFjdERPTS5wcmVsb2FkKCk6IFRoZSBvcHRpb25zIHByb3ZpZGVkIGNvbmZsaWN0IHdpdGggYW5vdGhlciBjYWxsIHRvIGBSZWFjdERPTS5wcmVsb2FkKFwiJXNcIiwgeyBhczogXCIlc1wiLCAuLi59KWAuJyArICcgUmVhY3Qgd2lsbCBhbHdheXMgdXNlIHRoZSBvcHRpb25zIGl0IGZpcnN0IGVuY291bnRlcnMgd2hlbiBwcmVsb2FkaW5nIGEgcmVzb3VyY2UgZm9yIGEgZ2l2ZW4gYGhyZWZgIGFuZCBgYXNgIHR5cGUsIGFuZCBhbnkgbGF0ZXIgb3B0aW9ucyB3aWxsIGJlIGlnbm9yZWQgaWYgZGlmZmVyZW50LicgKyAnIFRyeSB1cGRhdGluZyBhbGwgY2FsbHMgdG8gYFJlYWN0RE9NLnByZWxvYWQoKWAgd2l0aCB0aGUgc2FtZSBgaHJlZmAgYW5kIGBhc2AgdHlwZSB0byB1c2UgdGhlIHNhbWUgb3B0aW9ucywgb3IgZWxpbWluYXRlIG9uZSBvZiB0aGUgY2FsbHMuJXMnLCBocmVmLCBhcywgZGlmZmVyZW5jZURlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnaW1wbGljaXQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgX2RpZmZlcmVuY2VEZXNjcmlwdGlvbjMgPSBkZXNjcmliZURpZmZlcmVuY2VzRm9yUHJlbG9hZE92ZXJJbXBsaWNpdFByZWxvYWQob3B0aW9ucywgZGV2UmVzb3VyY2UuX19pbXBsaWVkUHJvcHMpO1xuXG4gICAgICAgICAgICAgIGlmIChfZGlmZmVyZW5jZURlc2NyaXB0aW9uMykge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50RGVzY3JpcHRpb24gPSBhcyA9PT0gJ3N0eWxlJyA/ICc8bGluayByZWw9XCJzdHlsZXNoZWV0XCIgLi4uIC8+JyA6IGFzID09PSAnc2NyaXB0JyA/ICc8c2NyaXB0IC4uLiAvPicgOiBudWxsO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnREZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ1JlYWN0RE9NLnByZWxvYWQoKTogRm9yIGBocmVmYCBcIiVzXCIsIFRoZSBvcHRpb25zIHByb3ZpZGVkIGNvbmZsaWN0IHdpdGggcHJvcHMgb24gYSBtYXRjaGluZyAlcyBlbGVtZW50LiBXaGVuIHRoZSBwcmVsb2FkJyArICcgb3B0aW9ucyBkaXNhZ3JlZSB3aXRoIHRoZSB1bmRlcmx5aW5nIHJlc291cmNlIGl0IHVzdWFsbHkgbWVhbnMgdGhlIGJyb3dzZXIgd2lsbCBub3QgYmUgYWJsZSB0byB1c2UgdGhlIHByZWxvYWQgd2hlbiB0aGUgcmVzb3VyY2UnICsgJyBpcyBmZXRjaGVkLCBuZWdhdGluZyBhbnkgYmVuZWZpdCB0aGUgcHJlbG9hZCB3b3VsZCBwcm92aWRlLiBSZWFjdCB3aWxsIHByZWxvYWQgdGhlIHJlc291cmNlIHVzaW5nIHByb3BzIGRlcml2ZWQgZnJvbSB0aGUgcmVzb3VyY2UgaW5zdGVhZCcgKyAnIGFuZCBpZ25vcmUgdGhlIG9wdGlvbnMgcHJvdmlkZWQgdG8gdGhlIGBSZWFjdERPTS5wcmVsb2FkKClgIGNhbGwuIEluIGdlbmVyYWwsIHByZWxvYWRpbmcgaXMgdXNlZnVsIHdoZW4geW91IGV4cGVjdCB0bycgKyAnIHJlbmRlciBhIHJlc291cmNlIHNvb24gYnV0IGhhdmUgbm90IHlldCBkb25lIHNvLiBJbiB0aGlzIGNhc2Ugc2luY2UgdGhlIHVuZGVybHlpbmcgcmVzb3VyY2Ugd2FzIGFscmVhZHkgcmVuZGVyZWQgdGhlIHByZWxvYWQgY2FsbCcgKyAnIG1heSBiZSBleHRyYW5lb3VzLiBUcnkgcmVtb3ZpbmcgdGhlIGNhbGwsIG90aGVyd2lzZSB0cnkgYWRqdXN0aW5nIGJvdGggdGhlIHByb3BzIG9uIHRoZSAlcyBhbmQgdGhlIG9wdGlvbnMnICsgJyBwYXNzZWQgdG8gYFJlYWN0RE9NLnByZWxvYWQoKWAgdG8gYWdyZWUuJXMnLCBocmVmLCBlbGVtZW50RGVzY3JpcHRpb24sIGVsZW1lbnREZXNjcmlwdGlvbiwgX2RpZmZlcmVuY2VEZXNjcmlwdGlvbjMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFyZXNvdXJjZSkge1xuICAgICAgcmVzb3VyY2UgPSB7XG4gICAgICAgIHR5cGU6ICdwcmVsb2FkJyxcbiAgICAgICAgY2h1bmtzOiBbXSxcbiAgICAgICAgc3RhdGU6IE5vU3RhdGUsXG4gICAgICAgIHByb3BzOiBwcmVsb2FkUHJvcHNGcm9tUHJlbG9hZE9wdGlvbnMoaHJlZiwgYXMsIG9wdGlvbnMpXG4gICAgICB9O1xuICAgICAgcmVzb3VyY2VzLnByZWxvYWRzTWFwLnNldChrZXksIHJlc291cmNlKTtcblxuICAgICAge1xuICAgICAgICBtYXJrQXNJbXBlcmF0aXZlUmVzb3VyY2VERVYocmVzb3VyY2UsICdwcmVsb2FkJywgaHJlZiwgb3B0aW9ucywgcmVzb3VyY2UucHJvcHMpO1xuICAgICAgfVxuXG4gICAgICBwdXNoTGlua0ltcGwocmVzb3VyY2UuY2h1bmtzLCByZXNvdXJjZS5wcm9wcyk7XG4gICAgfVxuXG4gICAgaWYgKGFzID09PSAnZm9udCcpIHtcbiAgICAgIHJlc291cmNlcy5mb250UHJlbG9hZHMuYWRkKHJlc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKGFzID09PSAnaW1hZ2UnICYmIG9wdGlvbnMuZmV0Y2hQcmlvcml0eSA9PT0gJ2hpZ2gnKSB7XG4gICAgICByZXNvdXJjZXMuaGlnaEltYWdlUHJlbG9hZHMuYWRkKHJlc291cmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb3VyY2VzLmJ1bGtQcmVsb2Fkcy5hZGQocmVzb3VyY2UpO1xuICAgIH1cblxuICAgIGZsdXNoUmVzb3VyY2VzKHJlcXVlc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZWluaXQoaHJlZiwgb3B0aW9ucykge1xuXG4gIHZhciByZXF1ZXN0ID0gcmVzb2x2ZVJlcXVlc3QoKTtcblxuICBpZiAoIXJlcXVlc3QpIHtcbiAgICAvLyBJbiBhc3luYyBjb250ZXh0cyB3ZSBjYW4gc29tZXRpbWVzIHJlc29sdmUgcmVzb3VyY2VzIGZyb20gQXN5bmNMb2NhbFN0b3JhZ2UuIElmIHdlIGNhbid0IHdlIGNhbiBhbHNvXG4gICAgLy8gcG9zc2libHkgZ2V0IHRoZW0gZnJvbSB0aGUgc3RhY2sgaWYgd2UgYXJlIG5vdCBpbiBhbiBhc3luYyBjb250ZXh0LiBTaW5jZSB3ZSB3ZXJlIG5vdCBhYmxlIHRvIHJlc29sdmVcbiAgICAvLyB0aGUgcmVzb3VyY2VzIGZvciB0aGlzIGNhbGwgaW4gZWl0aGVyIGNhc2Ugd2Ugb3B0IHRvIGRvIG5vdGhpbmcuIFdlIGNhbiBjb25zaWRlciBtYWtpbmcgdGhpcyBhIHdhcm5pbmdcbiAgICAvLyBidXQgdGhlcmUgbWF5IGJlIHRpbWVzIHdoZXJlIGNhbGxpbmcgYSBmdW5jdGlvbiBvdXRzaWRlIG9mIHJlbmRlciBpcyBpbnRlbnRpb25hbCAoaS5lLiB0byB3YXJtIHVwIGRhdGFcbiAgICAvLyBmZXRjaGluZykgYW5kIHdlIGRvbid0IHdhbnQgdG8gd2FybiBpbiB0aG9zZSBjYXNlcy5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVzb3VyY2VzID0gZ2V0UmVzb3VyY2VzKHJlcXVlc3QpO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGhyZWYgIT09ICdzdHJpbmcnIHx8ICFocmVmKSB7XG4gICAgICBlcnJvcignUmVhY3RET00ucHJlaW5pdCgpOiBFeHBlY3RlZCB0aGUgYGhyZWZgIGFyZ3VtZW50IChmaXJzdCkgdG8gYmUgYSBub24tZW1wdHkgc3RyaW5nIGJ1dCBlbmNvdW50ZXJlZCAlcyBpbnN0ZWFkLicsIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcoaHJlZikpO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucyA9PSBudWxsIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgZXJyb3IoJ1JlYWN0RE9NLnByZWluaXQoKTogRXhwZWN0ZWQgdGhlIGBvcHRpb25zYCBhcmd1bWVudCAoc2Vjb25kKSB0byBiZSBhbiBvYmplY3Qgd2l0aCBhbiBgYXNgIHByb3BlcnR5IGRlc2NyaWJpbmcgdGhlIHR5cGUgb2YgcmVzb3VyY2UgdG8gYmUgcHJlaW5pdGlhbGl6ZWQgYnV0IGVuY291bnRlcmVkICVzIGluc3RlYWQuJywgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcob3B0aW9ucykpO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5hcyAhPT0gJ3N0eWxlJyAmJiBvcHRpb25zLmFzICE9PSAnc2NyaXB0Jykge1xuICAgICAgZXJyb3IoJ1JlYWN0RE9NLnByZWluaXQoKTogRXhwZWN0ZWQgdGhlIGBhc2AgcHJvcGVydHkgaW4gdGhlIGBvcHRpb25zYCBhcmd1bWVudCAoc2Vjb25kKSB0byBjb250YWluIGEgdmFsaWQgdmFsdWUgZGVzY3JpYmluZyB0aGUgdHlwZSBvZiByZXNvdXJjZSB0byBiZSBwcmVpbml0aWFsaXplZCBidXQgZW5jb3VudGVyZWQgJXMgaW5zdGVhZC4gVmFsaWQgdmFsdWVzIGZvciBgYXNgIGFyZSBcInN0eWxlXCIgYW5kIFwic2NyaXB0XCIuJywgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcob3B0aW9ucy5hcykpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgaHJlZiA9PT0gJ3N0cmluZycgJiYgaHJlZiAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgIHZhciBhcyA9IG9wdGlvbnMuYXM7XG5cbiAgICBzd2l0Y2ggKGFzKSB7XG4gICAgICBjYXNlICdzdHlsZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIga2V5ID0gZ2V0UmVzb3VyY2VLZXkoYXMsIGhyZWYpO1xuICAgICAgICAgIHZhciByZXNvdXJjZSA9IHJlc291cmNlcy5zdHlsZXNNYXAuZ2V0KGtleSk7XG4gICAgICAgICAgdmFyIHByZWNlZGVuY2UgPSBvcHRpb25zLnByZWNlZGVuY2UgfHwgJ2RlZmF1bHQnO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGRldlJlc291cmNlID0gZ2V0QXNSZXNvdXJjZURFVihyZXNvdXJjZSk7XG5cbiAgICAgICAgICAgIGlmIChkZXZSZXNvdXJjZSkge1xuICAgICAgICAgICAgICB2YXIgcmVzb3VyY2VQcm9wcyA9IHN0eWxlc2hlZXRQcm9wc0Zyb21QcmVpbml0T3B0aW9ucyhocmVmLCBwcmVjZWRlbmNlLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgICB2YXIgcHJvcHNFcXVpdmFsZW50ID0gYXNzaWduKHt9LCByZXNvdXJjZVByb3BzLCBfZGVmaW5lUHJvcGVydHkoe1xuICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IG9wdGlvbnMucHJlY2VkZW5jZVxuICAgICAgICAgICAgICB9LCAnZGF0YS1wcmVjZWRlbmNlJywgbnVsbCkpO1xuXG4gICAgICAgICAgICAgIHN3aXRjaCAoZGV2UmVzb3VyY2UuX19wcm92ZW5hbmNlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAncmVuZGVyZWQnOlxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlmZmVyZW5jZURlc2NyaXB0aW9uID0gZGVzY3JpYmVEaWZmZXJlbmNlc0ZvclByZWluaXRPdmVyU3R5bGVzaGVldCggLy8gRGlmZiB0aGUgcHJvcHMgZnJvbSB0aGUgSlNYIGVsZW1lbnQsIG5vdCB0aGUgZGVyaXZlZCByZXNvdXJjZSBwcm9wc1xuICAgICAgICAgICAgICAgICAgICBwcm9wc0VxdWl2YWxlbnQsIGRldlJlc291cmNlLl9fb3JpZ2luYWxQcm9wcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpZmZlcmVuY2VEZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdSZWFjdERPTS5wcmVpbml0KCk6IEZvciBgaHJlZmAgXCIlc1wiLCB0aGUgb3B0aW9ucyBwcm92aWRlZCBjb25mbGljdCB3aXRoIHByb3BzIGZvdW5kIG9uIGEgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIHByZWNlZGVuY2U9XCIlc1wiIGhyZWY9XCIlc1wiIC4uLi8+IHRoYXQgd2FzIGFscmVhZHkgcmVuZGVyZWQuJyArICcgUmVhY3Qgd2lsbCBhbHdheXMgdXNlIHRoZSBwcm9wcyBvciBvcHRpb25zIGl0IGZpcnN0IGVuY291bnRlcnMgZm9yIGEgaG9pc3RhYmxlIHN0eWxlc2hlZXQgZm9yIGEgZ2l2ZW4gYGhyZWZgIGFuZCBhbnkgbGF0ZXIgcHJvcHMgb3Igb3B0aW9ucyB3aWxsIGJlIGlnbm9yZWQgaWYgZGlmZmVyZW50LicgKyAnIEdlbmVyYWxseSwgUmVhY3RET00ucHJlaW5pdCgpIGlzIHVzZWZ1bCB3aGVuIHlvdSBhcmUgbm90IHlldCByZW5kZXJpbmcgYSBzdHlsZXNoZWV0IGJ1dCB5b3UgYW50aWNpcGF0ZSBpdCB3aWxsIGJlIHVzZWQgc29vbi4nICsgJyBJbiB0aGlzIGNhc2UgdGhlIHN0eWxlc2hlZXQgd2FzIGFscmVhZHkgcmVuZGVyZWQgc28gcHJlaW5pdGlhbGl6aW5nIGl0IGRvZXMgbm90IHByb3ZpZGUgYW55IGFkZGl0aW9uYWwgYmVuZWZpdC4nICsgJyBUbyByZXNvbHZlLCB0cnkgbWFraW5nIHRoZSBwcm9wcyBhbmQgb3B0aW9ucyBhZ3JlZSBiZXR3ZWVuIHRoZSA8bGluayByZWw9XCJzdHlsZXNoZWV0XCIgLi4uLz4gYW5kIHRoZSBgUmVhY3RET00ucHJlaW5pdCgpYCBjYWxsIG9yJyArICcgcmVtb3ZlIHRoZSBgUmVhY3RET00ucHJlaW5pdCgpYCBjYWxsLiVzJywgaHJlZiwgZGV2UmVzb3VyY2UuX19vcmlnaW5hbFByb3BzLnByZWNlZGVuY2UsIGhyZWYsIGRpZmZlcmVuY2VEZXNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNhc2UgJ3ByZWluaXQnOlxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2RpZmZlcmVuY2VEZXNjcmlwdGlvbjQgPSBkZXNjcmliZURpZmZlcmVuY2VzRm9yUHJlaW5pdHMoIC8vIERpZmYgdGhlIHByb3BzIGZyb20gdGhlIEpTWCBlbGVtZW50LCBub3QgdGhlIGRlcml2ZWQgcmVzb3VyY2UgcHJvcHNcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNFcXVpdmFsZW50LCBkZXZSZXNvdXJjZS5fX3Byb3BzRXF1aXZhbGVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kaWZmZXJlbmNlRGVzY3JpcHRpb240KSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ1JlYWN0RE9NLnByZWluaXQoKTogRm9yIGBocmVmYCBcIiVzXCIsIHRoZSBvcHRpb25zIHByb3ZpZGVkIGNvbmZsaWN0IHdpdGggYW5vdGhlciBjYWxsIHRvIGBSZWFjdERPTS5wcmVpbml0KFwiJXNcIiwgeyBhczogXCJzdHlsZVwiLCAuLi4gfSlgLicgKyAnIFJlYWN0IHdpbGwgYWx3YXlzIHVzZSB0aGUgb3B0aW9ucyBpdCBmaXJzdCBlbmNvdW50ZXJzIHdoZW4gcHJlaW5pdGlhbGl6aW5nIGEgaG9pc3RhYmxlIHN0eWxlc2hlZXQgZm9yIGEgZ2l2ZW4gYGhyZWZgIGFuZCBhbnkgbGF0ZXIgb3B0aW9ucyB3aWxsIGJlIGlnbm9yZWQgaWYgZGlmZmVyZW50LicgKyAnIFRyeSB1cGRhdGluZyBhbGwgY2FsbHMgdG8gYFJlYWN0RE9NLnByZWluaXQoKWAgZm9yIGEgZ2l2ZW4gYGhyZWZgIHRvIHVzZSB0aGUgc2FtZSBvcHRpb25zLCBvciBvbmx5IGNhbGwgYFJlYWN0RE9NLnByZWluaXQoKWAgb25jZSBwZXIgYGhyZWZgLiVzJywgaHJlZiwgaHJlZiwgX2RpZmZlcmVuY2VEZXNjcmlwdGlvbjQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXJlc291cmNlKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBOb1N0YXRlO1xuICAgICAgICAgICAgdmFyIHByZWxvYWRSZXNvdXJjZSA9IHJlc291cmNlcy5wcmVsb2Fkc01hcC5nZXQoa2V5KTtcblxuICAgICAgICAgICAgaWYgKHByZWxvYWRSZXNvdXJjZSAmJiBwcmVsb2FkUmVzb3VyY2Uuc3RhdGUgJiBGbHVzaGVkKSB7XG4gICAgICAgICAgICAgIHN0YXRlID0gUHJlbG9hZEZsdXNoZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc291cmNlID0ge1xuICAgICAgICAgICAgICB0eXBlOiAnc3R5bGVzaGVldCcsXG4gICAgICAgICAgICAgIGNodW5rczogW10sXG4gICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgcHJvcHM6IHN0eWxlc2hlZXRQcm9wc0Zyb21QcmVpbml0T3B0aW9ucyhocmVmLCBwcmVjZWRlbmNlLCBvcHRpb25zKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc291cmNlcy5zdHlsZXNNYXAuc2V0KGtleSwgcmVzb3VyY2UpO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG1hcmtBc0ltcGVyYXRpdmVSZXNvdXJjZURFVihyZXNvdXJjZSwgJ3ByZWluaXQnLCBocmVmLCBvcHRpb25zLCBhc3NpZ24oe30sIHJlc291cmNlLnByb3BzLCBfZGVmaW5lUHJvcGVydHkoe1xuICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IHByZWNlZGVuY2VcbiAgICAgICAgICAgICAgfSwgJ2RhdGEtcHJlY2VkZW5jZScsIHVuZGVmaW5lZCkpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHByZWNlZGVuY2VTZXQgPSByZXNvdXJjZXMucHJlY2VkZW5jZXMuZ2V0KHByZWNlZGVuY2UpO1xuXG4gICAgICAgICAgICBpZiAoIXByZWNlZGVuY2VTZXQpIHtcbiAgICAgICAgICAgICAgcHJlY2VkZW5jZVNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgcmVzb3VyY2VzLnByZWNlZGVuY2VzLnNldChwcmVjZWRlbmNlLCBwcmVjZWRlbmNlU2V0KTtcbiAgICAgICAgICAgICAgdmFyIGVtcHR5U3R5bGVSZXNvdXJjZSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3R5bGUnLFxuICAgICAgICAgICAgICAgIGNodW5rczogW10sXG4gICAgICAgICAgICAgICAgc3RhdGU6IE5vU3RhdGUsXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IHByZWNlZGVuY2UsXG4gICAgICAgICAgICAgICAgICBocmVmczogW11cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHByZWNlZGVuY2VTZXQuYWRkKGVtcHR5U3R5bGVSZXNvdXJjZSk7XG5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChyZXNvdXJjZXMuc3R5bGVQcmVjZWRlbmNlcy5oYXMocHJlY2VkZW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdSZWFjdCBjb25zdHJ1Y3RlZCBhbiBlbXB0eSBzdHlsZSByZXNvdXJjZSB3aGVuIGEgc3R5bGUgcmVzb3VyY2UgYWxyZWFkeSBleGlzdHMgZm9yIHRoaXMgcHJlY2VkZW5jZTogXCIlc1wiLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicsIHByZWNlZGVuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJlc291cmNlcy5zdHlsZVByZWNlZGVuY2VzLnNldChwcmVjZWRlbmNlLCBlbXB0eVN0eWxlUmVzb3VyY2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmVjZWRlbmNlU2V0LmFkZChyZXNvdXJjZSk7XG4gICAgICAgICAgICBmbHVzaFJlc291cmNlcyhyZXF1ZXN0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc2NyaXB0JzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBzcmMgPSBocmVmO1xuXG4gICAgICAgICAgdmFyIF9rZXkgPSBnZXRSZXNvdXJjZUtleShhcywgc3JjKTtcblxuICAgICAgICAgIHZhciBfcmVzb3VyY2UgPSByZXNvdXJjZXMuc2NyaXB0c01hcC5nZXQoX2tleSk7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2RldlJlc291cmNlID0gZ2V0QXNSZXNvdXJjZURFVihfcmVzb3VyY2UpO1xuXG4gICAgICAgICAgICBpZiAoX2RldlJlc291cmNlKSB7XG4gICAgICAgICAgICAgIHZhciBfcHJvcHNFcXVpdmFsZW50ID0gc2NyaXB0UHJvcHNGcm9tUHJlaW5pdE9wdGlvbnMoc3JjLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgICBzd2l0Y2ggKF9kZXZSZXNvdXJjZS5fX3Byb3ZlbmFuY2UpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdyZW5kZXJlZCc6XG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfZGlmZmVyZW5jZURlc2NyaXB0aW9uNSA9IGRlc2NyaWJlRGlmZmVyZW5jZXNGb3JQcmVpbml0T3ZlclNjcmlwdCggLy8gRGlmZiB0aGUgcHJvcHMgZnJvbSB0aGUgSlNYIGVsZW1lbnQsIG5vdCB0aGUgZGVyaXZlZCByZXNvdXJjZSBwcm9wc1xuICAgICAgICAgICAgICAgICAgICBfcHJvcHNFcXVpdmFsZW50LCBfZGV2UmVzb3VyY2UuX19vcmlnaW5hbFByb3BzKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoX2RpZmZlcmVuY2VEZXNjcmlwdGlvbjUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcignUmVhY3RET00ucHJlaW5pdCgpOiBGb3IgYGhyZWZgIFwiJXNcIiwgdGhlIG9wdGlvbnMgcHJvdmlkZWQgY29uZmxpY3Qgd2l0aCBwcm9wcyBmb3VuZCBvbiBhIDxzY3JpcHQgYXN5bmM9e3RydWV9IHNyYz1cIiVzXCIgLi4uLz4gdGhhdCB3YXMgYWxyZWFkeSByZW5kZXJlZC4nICsgJyBSZWFjdCB3aWxsIGFsd2F5cyB1c2UgdGhlIHByb3BzIG9yIG9wdGlvbnMgaXQgZmlyc3QgZW5jb3VudGVycyBmb3IgYSBob2lzdGFibGUgc2NyaXB0IGZvciBhIGdpdmVuIGBocmVmYCBhbmQgYW55IGxhdGVyIHByb3BzIG9yIG9wdGlvbnMgd2lsbCBiZSBpZ25vcmVkIGlmIGRpZmZlcmVudC4nICsgJyBHZW5lcmFsbHksIFJlYWN0RE9NLnByZWluaXQoKSBpcyB1c2VmdWwgd2hlbiB5b3UgYXJlIG5vdCB5ZXQgcmVuZGVyaW5nIGEgc2NyaXB0IGJ1dCB5b3UgYW50aWNpcGF0ZSBpdCB3aWxsIGJlIHVzZWQgc29vbiBhbmQgd2FudCB0byBnbyBiZXlvbmQgcHJlbG9hZGluZyBpdCBhbmQgaGF2ZSBpdCcgKyAnIGV4ZWN1dGUgZWFybHkuIEluIHRoaXMgY2FzZSB0aGUgc2NyaXB0IHdhcyBhbHJlYWR5IHJlbmRlcmVkIHNvIHByZWluaXRpYWxpemluZyBpdCBkb2VzIG5vdCBwcm92aWRlIGFueSBhZGRpdGlvbmFsIGJlbmVmaXQuJyArICcgVG8gcmVzb2x2ZSwgdHJ5IG1ha2luZyB0aGUgcHJvcHMgYW5kIG9wdGlvbnMgYWdyZWUgYmV0d2VlbiB0aGUgPHNjcmlwdCAuLi4vPiBhbmQgdGhlIGBSZWFjdERPTS5wcmVpbml0KClgIGNhbGwgb3IgcmVtb3ZlIHRoZSBgUmVhY3RET00ucHJlaW5pdCgpYCBjYWxsLiVzJywgaHJlZiwgaHJlZiwgX2RpZmZlcmVuY2VEZXNjcmlwdGlvbjUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjYXNlICdwcmVpbml0JzpcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9kaWZmZXJlbmNlRGVzY3JpcHRpb242ID0gZGVzY3JpYmVEaWZmZXJlbmNlc0ZvclByZWluaXRzKCAvLyBEaWZmIHRoZSBwcm9wcyBmcm9tIHRoZSBKU1ggZWxlbWVudCwgbm90IHRoZSBkZXJpdmVkIHJlc291cmNlIHByb3BzXG4gICAgICAgICAgICAgICAgICAgIF9wcm9wc0VxdWl2YWxlbnQsIF9kZXZSZXNvdXJjZS5fX3Byb3BzRXF1aXZhbGVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kaWZmZXJlbmNlRGVzY3JpcHRpb242KSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ1JlYWN0RE9NLnByZWluaXQoKTogRm9yIGBocmVmYCBcIiVzXCIsIHRoZSBvcHRpb25zIHByb3ZpZGVkIGNvbmZsaWN0IHdpdGggYW5vdGhlciBjYWxsIHRvIGBSZWFjdERPTS5wcmVpbml0KFwiJXNcIiwgeyBhczogXCJzY3JpcHRcIiwgLi4uIH0pYC4nICsgJyBSZWFjdCB3aWxsIGFsd2F5cyB1c2UgdGhlIG9wdGlvbnMgaXQgZmlyc3QgZW5jb3VudGVycyB3aGVuIHByZWluaXRpYWxpemluZyBhIGhvaXN0YWJsZSBzY3JpcHQgZm9yIGEgZ2l2ZW4gYGhyZWZgIGFuZCBhbnkgbGF0ZXIgb3B0aW9ucyB3aWxsIGJlIGlnbm9yZWQgaWYgZGlmZmVyZW50LicgKyAnIFRyeSB1cGRhdGluZyBhbGwgY2FsbHMgdG8gYFJlYWN0RE9NLnByZWluaXQoKWAgZm9yIGEgZ2l2ZW4gYGhyZWZgIHRvIHVzZSB0aGUgc2FtZSBvcHRpb25zLCBvciBvbmx5IGNhbGwgYFJlYWN0RE9NLnByZWluaXQoKWAgb25jZSBwZXIgYGhyZWZgLiVzJywgaHJlZiwgaHJlZiwgX2RpZmZlcmVuY2VEZXNjcmlwdGlvbjYpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIV9yZXNvdXJjZSkge1xuICAgICAgICAgICAgX3Jlc291cmNlID0ge1xuICAgICAgICAgICAgICB0eXBlOiAnc2NyaXB0JyxcbiAgICAgICAgICAgICAgY2h1bmtzOiBbXSxcbiAgICAgICAgICAgICAgc3RhdGU6IE5vU3RhdGUsXG4gICAgICAgICAgICAgIHByb3BzOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzb3VyY2VzLnNjcmlwdHNNYXAuc2V0KF9rZXksIF9yZXNvdXJjZSk7XG5cbiAgICAgICAgICAgIHZhciBfcmVzb3VyY2VQcm9wcyA9IHNjcmlwdFByb3BzRnJvbVByZWluaXRPcHRpb25zKHNyYywgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbWFya0FzSW1wZXJhdGl2ZVJlc291cmNlREVWKF9yZXNvdXJjZSwgJ3ByZWluaXQnLCBocmVmLCBvcHRpb25zLCBfcmVzb3VyY2VQcm9wcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc291cmNlcy5zY3JpcHRzLmFkZChfcmVzb3VyY2UpO1xuICAgICAgICAgICAgcHVzaFNjcmlwdEltcGwoX3Jlc291cmNlLmNodW5rcywgX3Jlc291cmNlUHJvcHMpO1xuICAgICAgICAgICAgZmx1c2hSZXNvdXJjZXMocmVxdWVzdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICB9XG59IC8vIFRoaXMgZnVuY3Rpb24gaXMgb25seSBzYWZlIHRvIGNhbGwgYXQgUmVxdWVzdCBzdGFydCB0aW1lIHNpbmNlIGl0IGFzc3VtZXNcbi8vIHRoYXQgZWFjaCBzY3JpcHQgaGFzIG5vdCBhbHJlYWR5IGJlZW4gcHJlbG9hZGVkLiBJZiB3ZSBmaW5kIGEgbmVlZCB0byBwcmVsb2FkXG4vLyBzY3JpcHRzIGF0IGFueSBvdGhlciBwb2ludCBpbiB0aW1lIHdlIHdpbGwgbmVlZCB0byBjaGVjayB3aGV0aGVyIHRoZSBwcmVsb2FkXG4vLyBhbHJlYWR5IGV4aXN0cyBhbmQgbm90IGFzc3VtZSBpdFxuXG5cbmZ1bmN0aW9uIHByZWxvYWRCb290c3RyYXBTY3JpcHQocmVzb3VyY2VzLCBzcmMsIG5vbmNlLCBpbnRlZ3JpdHksIGNyb3NzT3JpZ2luKSB7XG4gIHZhciBrZXkgPSBnZXRSZXNvdXJjZUtleSgnc2NyaXB0Jywgc3JjKTtcblxuICB7XG4gICAgaWYgKHJlc291cmNlcy5wcmVsb2Fkc01hcC5oYXMoa2V5KSkge1xuICAgICAgLy8gVGhpcyBpcyBjb2RlZCBhcyBhIFJlYWN0IGVycm9yIGJlY2F1c2UgaXQgc2hvdWxkIGJlIGltcG9zc2libGUgZm9yIGEgdXNlcnNwYWNlIHByZWxvYWQgdG8gcHJlZW1wdCB0aGlzIGNhbGxcbiAgICAgIC8vIElmIGEgdXNlcnNwYWNlIHByZWxvYWQgY2FuIHByZWVtcHQgaXQgdGhlbiB0aGlzIGFzc3VtcHRpb24gaXMgYnJva2VuIGFuZCB3ZSBuZWVkIHRvIHJlY29uc2lkZXIgdGhpcyBzdHJhdGVneVxuICAgICAgLy8gcmF0aGVyIHRoYW4gaW5zdHJ1Y3QgdGhlIHVzZXIgdG8gbm90IHByZWxvYWQgdGhlaXIgYm9vdHN0cmFwIHNjcmlwdHMgdGhlbXNlbHZlc1xuICAgICAgZXJyb3IoJ0ludGVybmFsIFJlYWN0IEVycm9yOiBSZWFjdCBleHBlY3RlZCBib290c3RyYXAgc2NyaXB0IHdpdGggc3JjIFwiJXNcIiB0byBub3QgaGF2ZSBiZWVuIHByZWxvYWRlZCBhbHJlYWR5LiBwbGVhc2UgZmlsZSBhbiBpc3N1ZScsIHNyYyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3BzID0ge1xuICAgIHJlbDogJ3ByZWxvYWQnLFxuICAgIGhyZWY6IHNyYyxcbiAgICBhczogJ3NjcmlwdCcsXG4gICAgZmV0Y2hQcmlvcml0eTogJ2xvdycsXG4gICAgbm9uY2U6IG5vbmNlLFxuICAgIGludGVncml0eTogaW50ZWdyaXR5LFxuICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpblxuICB9O1xuICB2YXIgcmVzb3VyY2UgPSB7XG4gICAgdHlwZTogJ3ByZWxvYWQnLFxuICAgIGNodW5rczogW10sXG4gICAgc3RhdGU6IE5vU3RhdGUsXG4gICAgcHJvcHM6IHByb3BzXG4gIH07XG4gIHJlc291cmNlcy5wcmVsb2Fkc01hcC5zZXQoa2V5LCByZXNvdXJjZSk7XG4gIHJlc291cmNlcy5ib290c3RyYXBTY3JpcHRzLmFkZChyZXNvdXJjZSk7XG4gIHB1c2hMaW5rSW1wbChyZXNvdXJjZS5jaHVua3MsIHByb3BzKTtcbn0gLy8gVGhpcyBmdW5jdGlvbiBpcyBvbmx5IHNhZmUgdG8gY2FsbCBhdCBSZXF1ZXN0IHN0YXJ0IHRpbWUgc2luY2UgaXQgYXNzdW1lc1xuLy8gdGhhdCBlYWNoIG1vZHVsZSBoYXMgbm90IGFscmVhZHkgYmVlbiBwcmVsb2FkZWQuIElmIHdlIGZpbmQgYSBuZWVkIHRvIHByZWxvYWRcbi8vIHNjcmlwdHMgYXQgYW55IG90aGVyIHBvaW50IGluIHRpbWUgd2Ugd2lsbCBuZWVkIHRvIGNoZWNrIHdoZXRoZXIgdGhlIHByZWxvYWRcbi8vIGFscmVhZHkgZXhpc3RzIGFuZCBub3QgYXNzdW1lIGl0XG5cblxuZnVuY3Rpb24gcHJlbG9hZEJvb3RzdHJhcE1vZHVsZShyZXNvdXJjZXMsIHNyYywgbm9uY2UsIGludGVncml0eSwgY3Jvc3NPcmlnaW4pIHtcbiAgdmFyIGtleSA9IGdldFJlc291cmNlS2V5KCdzY3JpcHQnLCBzcmMpO1xuXG4gIHtcbiAgICBpZiAocmVzb3VyY2VzLnByZWxvYWRzTWFwLmhhcyhrZXkpKSB7XG4gICAgICAvLyBUaGlzIGlzIGNvZGVkIGFzIGEgUmVhY3QgZXJyb3IgYmVjYXVzZSBpdCBzaG91bGQgYmUgaW1wb3NzaWJsZSBmb3IgYSB1c2Vyc3BhY2UgcHJlbG9hZCB0byBwcmVlbXB0IHRoaXMgY2FsbFxuICAgICAgLy8gSWYgYSB1c2Vyc3BhY2UgcHJlbG9hZCBjYW4gcHJlZW1wdCBpdCB0aGVuIHRoaXMgYXNzdW1wdGlvbiBpcyBicm9rZW4gYW5kIHdlIG5lZWQgdG8gcmVjb25zaWRlciB0aGlzIHN0cmF0ZWd5XG4gICAgICAvLyByYXRoZXIgdGhhbiBpbnN0cnVjdCB0aGUgdXNlciB0byBub3QgcHJlbG9hZCB0aGVpciBib290c3RyYXAgc2NyaXB0cyB0aGVtc2VsdmVzXG4gICAgICBlcnJvcignSW50ZXJuYWwgUmVhY3QgRXJyb3I6IFJlYWN0IGV4cGVjdGVkIGJvb3RzdHJhcCBtb2R1bGUgd2l0aCBzcmMgXCIlc1wiIHRvIG5vdCBoYXZlIGJlZW4gcHJlbG9hZGVkIGFscmVhZHkuIHBsZWFzZSBmaWxlIGFuIGlzc3VlJywgc3JjKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvcHMgPSB7XG4gICAgcmVsOiAnbW9kdWxlcHJlbG9hZCcsXG4gICAgaHJlZjogc3JjLFxuICAgIGZldGNoUHJpb3JpdHk6ICdsb3cnLFxuICAgIG5vbmNlOiBub25jZSxcbiAgICBpbnRlZ3JpdHk6IGludGVncml0eSxcbiAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW5cbiAgfTtcbiAgdmFyIHJlc291cmNlID0ge1xuICAgIHR5cGU6ICdwcmVsb2FkJyxcbiAgICBjaHVua3M6IFtdLFxuICAgIHN0YXRlOiBOb1N0YXRlLFxuICAgIHByb3BzOiBwcm9wc1xuICB9O1xuICByZXNvdXJjZXMucHJlbG9hZHNNYXAuc2V0KGtleSwgcmVzb3VyY2UpO1xuICByZXNvdXJjZXMuYm9vdHN0cmFwU2NyaXB0cy5hZGQocmVzb3VyY2UpO1xuICBwdXNoTGlua0ltcGwocmVzb3VyY2UuY2h1bmtzLCBwcm9wcyk7XG4gIHJldHVybjtcbn1cblxuZnVuY3Rpb24gaW50ZXJuYWxQcmVpbml0U2NyaXB0KHJlc291cmNlcywgc3JjLCBjaHVua3MpIHtcbiAgdmFyIGtleSA9IGdldFJlc291cmNlS2V5KCdzY3JpcHQnLCBzcmMpO1xuICB2YXIgcmVzb3VyY2UgPSByZXNvdXJjZXMuc2NyaXB0c01hcC5nZXQoa2V5KTtcblxuICBpZiAoIXJlc291cmNlKSB7XG4gICAgcmVzb3VyY2UgPSB7XG4gICAgICB0eXBlOiAnc2NyaXB0JyxcbiAgICAgIGNodW5rczogY2h1bmtzLFxuICAgICAgc3RhdGU6IE5vU3RhdGUsXG4gICAgICBwcm9wczogbnVsbFxuICAgIH07XG4gICAgcmVzb3VyY2VzLnNjcmlwdHNNYXAuc2V0KGtleSwgcmVzb3VyY2UpO1xuICAgIHJlc291cmNlcy5zY3JpcHRzLmFkZChyZXNvdXJjZSk7XG4gIH1cblxuICByZXR1cm47XG59XG5cbmZ1bmN0aW9uIHByZWxvYWRQcm9wc0Zyb21QcmVsb2FkT3B0aW9ucyhocmVmLCBhcywgb3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIHJlbDogJ3ByZWxvYWQnLFxuICAgIGFzOiBhcyxcbiAgICAvLyBUaGVyZSBpcyBhIGJ1ZyBpbiBTYWZhcmkgd2hlcmUgaW1hZ2VTcmNTZXQgaXMgbm90IHJlc3BlY3RlZCBvbiBwcmVsb2FkIGxpbmtzXG4gICAgLy8gc28gd2Ugb21pdCB0aGUgaHJlZiBoZXJlIGlmIHdlIGhhdmUgaW1hZ2VTcmNTZXQgYi9jIHNhZmFyaSB3aWxsIGxvYWQgdGhlIHdyb25nIGltYWdlLlxuICAgIC8vIFRoaXMgaGFybXMgb2xkZXIgYnJvd2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IGltYWdlU3JjU2V0IGJ5IG1ha2luZyB0aGVpciBwcmVsb2FkcyBub3Qgd29ya1xuICAgIC8vIGJ1dCB0aGlzIHBvcHVsYXRpb24gaXMgc2hyaW5raW5nIGZhc3QgYW5kIGlzIGFscmVhZHkgc21hbGwgc28gd2UgYWNjZXB0IHRoaXMgdHJhZGVvZmYuXG4gICAgaHJlZjogYXMgPT09ICdpbWFnZScgJiYgb3B0aW9ucy5pbWFnZVNyY1NldCA/IHVuZGVmaW5lZCA6IGhyZWYsXG4gICAgY3Jvc3NPcmlnaW46IGFzID09PSAnZm9udCcgPyAnJyA6IG9wdGlvbnMuY3Jvc3NPcmlnaW4sXG4gICAgaW50ZWdyaXR5OiBvcHRpb25zLmludGVncml0eSxcbiAgICB0eXBlOiBvcHRpb25zLnR5cGUsXG4gICAgbm9uY2U6IG9wdGlvbnMubm9uY2UsXG4gICAgZmV0Y2hQcmlvcml0eTogb3B0aW9ucy5mZXRjaFByaW9yaXR5LFxuICAgIGltYWdlU3JjU2V0OiBvcHRpb25zLmltYWdlU3JjU2V0LFxuICAgIGltYWdlU2l6ZXM6IG9wdGlvbnMuaW1hZ2VTaXplcyxcbiAgICByZWZlcnJlclBvbGljeTogb3B0aW9ucy5yZWZlcnJlclBvbGljeVxuICB9O1xufVxuXG5mdW5jdGlvbiBwcmVsb2FkQXNTdHlsZVByb3BzRnJvbVByb3BzKGhyZWYsIHByb3BzKSB7XG4gIHJldHVybiB7XG4gICAgcmVsOiAncHJlbG9hZCcsXG4gICAgYXM6ICdzdHlsZScsXG4gICAgaHJlZjogaHJlZixcbiAgICBjcm9zc09yaWdpbjogcHJvcHMuY3Jvc3NPcmlnaW4sXG4gICAgZmV0Y2hQcmlvcml0eTogcHJvcHMuZmV0Y2hQcmlvcml0eSxcbiAgICBpbnRlZ3JpdHk6IHByb3BzLmludGVncml0eSxcbiAgICBtZWRpYTogcHJvcHMubWVkaWEsXG4gICAgaHJlZkxhbmc6IHByb3BzLmhyZWZMYW5nLFxuICAgIHJlZmVycmVyUG9saWN5OiBwcm9wcy5yZWZlcnJlclBvbGljeVxuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZXNoZWV0UHJvcHNGcm9tUHJlaW5pdE9wdGlvbnMoaHJlZiwgcHJlY2VkZW5jZSwgb3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIHJlbDogJ3N0eWxlc2hlZXQnLFxuICAgIGhyZWY6IGhyZWYsXG4gICAgJ2RhdGEtcHJlY2VkZW5jZSc6IHByZWNlZGVuY2UsXG4gICAgY3Jvc3NPcmlnaW46IG9wdGlvbnMuY3Jvc3NPcmlnaW4sXG4gICAgaW50ZWdyaXR5OiBvcHRpb25zLmludGVncml0eSxcbiAgICBmZXRjaFByaW9yaXR5OiBvcHRpb25zLmZldGNoUHJpb3JpdHlcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVzaGVldFByb3BzRnJvbVJhd1Byb3BzKHJhd1Byb3BzKSB7XG4gIHJldHVybiBhc3NpZ24oe30sIHJhd1Byb3BzLCB7XG4gICAgJ2RhdGEtcHJlY2VkZW5jZSc6IHJhd1Byb3BzLnByZWNlZGVuY2UsXG4gICAgcHJlY2VkZW5jZTogbnVsbFxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRvcHRQcmVsb2FkUHJvcHNGb3JTdHlsZXNoZWV0UHJvcHMocmVzb3VyY2VQcm9wcywgcHJlbG9hZFByb3BzKSB7XG4gIGlmIChyZXNvdXJjZVByb3BzLmNyb3NzT3JpZ2luID09IG51bGwpIHJlc291cmNlUHJvcHMuY3Jvc3NPcmlnaW4gPSBwcmVsb2FkUHJvcHMuY3Jvc3NPcmlnaW47XG4gIGlmIChyZXNvdXJjZVByb3BzLmludGVncml0eSA9PSBudWxsKSByZXNvdXJjZVByb3BzLmludGVncml0eSA9IHByZWxvYWRQcm9wcy5pbnRlZ3JpdHk7XG59XG5cbmZ1bmN0aW9uIHNjcmlwdFByb3BzRnJvbVByZWluaXRPcHRpb25zKHNyYywgb3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIHNyYzogc3JjLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGNyb3NzT3JpZ2luOiBvcHRpb25zLmNyb3NzT3JpZ2luLFxuICAgIGludGVncml0eTogb3B0aW9ucy5pbnRlZ3JpdHksXG4gICAgbm9uY2U6IG9wdGlvbnMubm9uY2UsXG4gICAgZmV0Y2hQcmlvcml0eTogb3B0aW9ucy5mZXRjaFByaW9yaXR5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGFkb3B0UHJlbG9hZFByb3BzRm9yU2NyaXB0UHJvcHMocmVzb3VyY2VQcm9wcywgcHJlbG9hZFByb3BzKSB7XG4gIGlmIChyZXNvdXJjZVByb3BzLmNyb3NzT3JpZ2luID09IG51bGwpIHJlc291cmNlUHJvcHMuY3Jvc3NPcmlnaW4gPSBwcmVsb2FkUHJvcHMuY3Jvc3NPcmlnaW47XG4gIGlmIChyZXNvdXJjZVByb3BzLmludGVncml0eSA9PSBudWxsKSByZXNvdXJjZVByb3BzLmludGVncml0eSA9IHByZWxvYWRQcm9wcy5pbnRlZ3JpdHk7XG59XG5cbmZ1bmN0aW9uIGhvaXN0U3R5bGVSZXNvdXJjZShyZXNvdXJjZSkge1xuICB0aGlzLmFkZChyZXNvdXJjZSk7XG59XG5cbmZ1bmN0aW9uIGhvaXN0UmVzb3VyY2VzKHJlc291cmNlcywgc291cmNlKSB7XG4gIHZhciBjdXJyZW50Qm91bmRhcnlSZXNvdXJjZXMgPSByZXNvdXJjZXMuYm91bmRhcnlSZXNvdXJjZXM7XG5cbiAgaWYgKGN1cnJlbnRCb3VuZGFyeVJlc291cmNlcykge1xuICAgIHNvdXJjZS5mb3JFYWNoKGhvaXN0U3R5bGVSZXNvdXJjZSwgY3VycmVudEJvdW5kYXJ5UmVzb3VyY2VzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrQXNSZW5kZXJlZFJlc291cmNlREVWKHJlc291cmNlLCBvcmlnaW5hbFByb3BzKSB7XG4gIHtcbiAgICB2YXIgZGV2UmVzb3VyY2UgPSByZXNvdXJjZTtcblxuICAgIGlmICh0eXBlb2YgZGV2UmVzb3VyY2UuX19wcm92ZW5hbmNlID09PSAnc3RyaW5nJykge1xuICAgICAgZXJyb3IoJ1Jlc291cmNlIGFscmVhZHkgbWFya2VkIGZvciBERVYgdHlwZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICB9XG5cbiAgICBkZXZSZXNvdXJjZS5fX3Byb3ZlbmFuY2UgPSAncmVuZGVyZWQnO1xuICAgIGRldlJlc291cmNlLl9fb3JpZ2luYWxQcm9wcyA9IG9yaWdpbmFsUHJvcHM7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya0FzSW1wZXJhdGl2ZVJlc291cmNlREVWKHJlc291cmNlLCBwcm92ZW5hbmNlLCBvcmlnaW5hbEhyZWYsIG9yaWdpbmFsT3B0aW9ucywgcHJvcHNFcXVpdmFsZW50KSB7XG4gIHtcbiAgICB2YXIgZGV2UmVzb3VyY2UgPSByZXNvdXJjZTtcblxuICAgIGlmICh0eXBlb2YgZGV2UmVzb3VyY2UuX19wcm92ZW5hbmNlID09PSAnc3RyaW5nJykge1xuICAgICAgZXJyb3IoJ1Jlc291cmNlIGFscmVhZHkgbWFya2VkIGZvciBERVYgdHlwZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICB9XG5cbiAgICBkZXZSZXNvdXJjZS5fX3Byb3ZlbmFuY2UgPSBwcm92ZW5hbmNlO1xuICAgIGRldlJlc291cmNlLl9fb3JpZ2luYWxIcmVmID0gb3JpZ2luYWxIcmVmO1xuICAgIGRldlJlc291cmNlLl9fb3JpZ2luYWxPcHRpb25zID0gb3JpZ2luYWxPcHRpb25zO1xuICAgIGRldlJlc291cmNlLl9fcHJvcHNFcXVpdmFsZW50ID0gcHJvcHNFcXVpdmFsZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFzUmVzb3VyY2VERVYocmVzb3VyY2UpIHtcbiAge1xuICAgIGlmIChyZXNvdXJjZSkge1xuICAgICAgaWYgKHR5cGVvZiByZXNvdXJjZS5fX3Byb3ZlbmFuY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiByZXNvdXJjZTtcbiAgICAgIH1cblxuICAgICAgZXJyb3IoJ1Jlc291cmNlIHdhcyBub3QgbWFya2VkIGZvciBERVYgdHlwZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVSZXNwb25zZVN0YXRlKHJlc291cmNlcywgZ2VuZXJhdGVTdGF0aWNNYXJrdXAsIGlkZW50aWZpZXJQcmVmaXgsIGV4dGVybmFsUnVudGltZUNvbmZpZykge1xuICB2YXIgcmVzcG9uc2VTdGF0ZSA9IGNyZWF0ZVJlc3BvbnNlU3RhdGUkMShyZXNvdXJjZXMsIGlkZW50aWZpZXJQcmVmaXgsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZXh0ZXJuYWxSdW50aW1lQ29uZmlnKTtcbiAgcmV0dXJuIHtcbiAgICAvLyBLZWVwIHRoaXMgaW4gc3luYyB3aXRoIFJlYWN0Rml6ekNvbmZpZ0RPTVxuICAgIGJvb3RzdHJhcENodW5rczogcmVzcG9uc2VTdGF0ZS5ib290c3RyYXBDaHVua3MsXG4gICAgcGxhY2Vob2xkZXJQcmVmaXg6IHJlc3BvbnNlU3RhdGUucGxhY2Vob2xkZXJQcmVmaXgsXG4gICAgc2VnbWVudFByZWZpeDogcmVzcG9uc2VTdGF0ZS5zZWdtZW50UHJlZml4LFxuICAgIGJvdW5kYXJ5UHJlZml4OiByZXNwb25zZVN0YXRlLmJvdW5kYXJ5UHJlZml4LFxuICAgIGlkUHJlZml4OiByZXNwb25zZVN0YXRlLmlkUHJlZml4LFxuICAgIG5leHRTdXNwZW5zZUlEOiByZXNwb25zZVN0YXRlLm5leHRTdXNwZW5zZUlELFxuICAgIHN0cmVhbWluZ0Zvcm1hdDogcmVzcG9uc2VTdGF0ZS5zdHJlYW1pbmdGb3JtYXQsXG4gICAgc3RhcnRJbmxpbmVTY3JpcHQ6IHJlc3BvbnNlU3RhdGUuc3RhcnRJbmxpbmVTY3JpcHQsXG4gICAgaW5zdHJ1Y3Rpb25zOiByZXNwb25zZVN0YXRlLmluc3RydWN0aW9ucyxcbiAgICBleHRlcm5hbFJ1bnRpbWVTY3JpcHQ6IHJlc3BvbnNlU3RhdGUuZXh0ZXJuYWxSdW50aW1lU2NyaXB0LFxuICAgIGh0bWxDaHVua3M6IHJlc3BvbnNlU3RhdGUuaHRtbENodW5rcyxcbiAgICBoZWFkQ2h1bmtzOiByZXNwb25zZVN0YXRlLmhlYWRDaHVua3MsXG4gICAgaGFzQm9keTogcmVzcG9uc2VTdGF0ZS5oYXNCb2R5LFxuICAgIGNoYXJzZXRDaHVua3M6IHJlc3BvbnNlU3RhdGUuY2hhcnNldENodW5rcyxcbiAgICBwcmVjb25uZWN0Q2h1bmtzOiByZXNwb25zZVN0YXRlLnByZWNvbm5lY3RDaHVua3MsXG4gICAgcHJlbG9hZENodW5rczogcmVzcG9uc2VTdGF0ZS5wcmVsb2FkQ2h1bmtzLFxuICAgIGhvaXN0YWJsZUNodW5rczogcmVzcG9uc2VTdGF0ZS5ob2lzdGFibGVDaHVua3MsXG4gICAgc3R5bGVzVG9Ib2lzdDogcmVzcG9uc2VTdGF0ZS5zdHlsZXNUb0hvaXN0LFxuICAgIC8vIFRoaXMgaXMgYW4gZXh0cmEgZmllbGQgZm9yIHRoZSBsZWdhY3kgcmVuZGVyZXJcbiAgICBnZW5lcmF0ZVN0YXRpY01hcmt1cDogZ2VuZXJhdGVTdGF0aWNNYXJrdXBcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvb3RGb3JtYXRDb250ZXh0KCkge1xuICByZXR1cm4ge1xuICAgIGluc2VydGlvbk1vZGU6IEhUTUxfTU9ERSxcbiAgICAvLyBXZSBza2lwIHRoZSByb290IG1vZGUgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIGVtaXQgdGhlIERPQ1RZUEUgaW4gbGVnYWN5IG1vZGUuXG4gICAgc2VsZWN0ZWRWYWx1ZTogbnVsbCxcbiAgICBub3NjcmlwdFRhZ0luU2NvcGU6IGZhbHNlXG4gIH07XG59XG5mdW5jdGlvbiBwdXNoVGV4dEluc3RhbmNlKHRhcmdldCwgdGV4dCwgcmVzcG9uc2VTdGF0ZSwgdGV4dEVtYmVkZGVkKSB7XG4gIGlmIChyZXNwb25zZVN0YXRlLmdlbmVyYXRlU3RhdGljTWFya3VwKSB7XG4gICAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0ZXh0KSkpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHVzaFRleHRJbnN0YW5jZSQxKHRhcmdldCwgdGV4dCwgcmVzcG9uc2VTdGF0ZSwgdGV4dEVtYmVkZGVkKTtcbiAgfVxufVxuZnVuY3Rpb24gcHVzaFNlZ21lbnRGaW5hbGUodGFyZ2V0LCByZXNwb25zZVN0YXRlLCBsYXN0UHVzaGVkVGV4dCwgdGV4dEVtYmVkZGVkKSB7XG4gIGlmIChyZXNwb25zZVN0YXRlLmdlbmVyYXRlU3RhdGljTWFya3VwKSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwdXNoU2VnbWVudEZpbmFsZSQxKHRhcmdldCwgcmVzcG9uc2VTdGF0ZSwgbGFzdFB1c2hlZFRleHQsIHRleHRFbWJlZGRlZCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdyaXRlU3RhcnRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlKSB7XG4gIGlmIChyZXNwb25zZVN0YXRlLmdlbmVyYXRlU3RhdGljTWFya3VwKSB7XG4gICAgLy8gQSBjb21wbGV0ZWQgYm91bmRhcnkgaXMgZG9uZSBhbmQgZG9lc24ndCBuZWVkIGEgcmVwcmVzZW50YXRpb24gaW4gdGhlIEhUTUxcbiAgICAvLyBpZiB3ZSdyZSBub3QgZ29pbmcgdG8gYmUgaHlkcmF0aW5nIGl0LlxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHdyaXRlU3RhcnRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5JDEoZGVzdGluYXRpb24pO1xufVxuZnVuY3Rpb24gd3JpdGVTdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZSwgLy8gZmx1c2hpbmcgdGhlc2UgZXJyb3IgYXJndW1lbnRzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBpbiB0aGlzIGxlZ2FjeSBzdHJlYW1pbmcgZm9ybWF0LlxuZXJyb3JEaWdlc3QsIGVycm9yTWVzc2FnZSwgZXJyb3JDb21wb25lbnRTdGFjaykge1xuICBpZiAocmVzcG9uc2VTdGF0ZS5nZW5lcmF0ZVN0YXRpY01hcmt1cCkge1xuICAgIC8vIEEgY2xpZW50IHJlbmRlcmVkIGJvdW5kYXJ5IGlzIGRvbmUgYW5kIGRvZXNuJ3QgbmVlZCBhIHJlcHJlc2VudGF0aW9uIGluIHRoZSBIVE1MXG4gICAgLy8gc2luY2Ugd2UnbGwgbmV2ZXIgaHlkcmF0ZSBpdC4gVGhpcyBpcyBhcmd1YWJseSBhbiBlcnJvciBpbiBzdGF0aWMgZ2VuZXJhdGlvbi5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB3cml0ZVN0YXJ0Q2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5JDEoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUsIGVycm9yRGlnZXN0LCBlcnJvck1lc3NhZ2UsIGVycm9yQ29tcG9uZW50U3RhY2spO1xufVxuZnVuY3Rpb24gd3JpdGVFbmRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlKSB7XG4gIGlmIChyZXNwb25zZVN0YXRlLmdlbmVyYXRlU3RhdGljTWFya3VwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gd3JpdGVFbmRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5JDEoZGVzdGluYXRpb24pO1xufVxuZnVuY3Rpb24gd3JpdGVFbmRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUpIHtcbiAgaWYgKHJlc3BvbnNlU3RhdGUuZ2VuZXJhdGVTdGF0aWNNYXJrdXApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB3cml0ZUVuZENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSQxKGRlc3RpbmF0aW9uKTtcbn1cblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0Jyk7XG52YXIgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnNlcnZlcl9jb250ZXh0Jyk7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5Jyk7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJyk7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbnZhciBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfREVGQVVMVF9WQUxVRV9OT1RfTE9BREVEID0gU3ltYm9sLmZvcigncmVhY3QuZGVmYXVsdF92YWx1ZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lO1xuXG4gIGlmIChkaXNwbGF5TmFtZSkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgfVxuXG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XG59IC8vIEtlZXAgaW4gc3luYyB3aXRoIHJlYWN0LXJlY29uY2lsZXIvZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlclxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufSAvLyBOb3RlIHRoYXQgdGhlIHJlY29uY2lsZXIgcGFja2FnZSBzaG91bGQgZ2VuZXJhbGx5IHByZWZlciB0byB1c2UgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcigpIGluc3RlYWQuXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY29udGV4dDIgPSB0eXBlO1xuICAgICAgICAgIHJldHVybiAoY29udGV4dDIuZGlzcGxheU5hbWUgfHwgY29udGV4dDIuX2dsb2JhbE5hbWUpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgLy8gaW4gc2ltcGxlIGNvbXBvbmVudHMgdG9vXG5cblxuICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgIC8vIHNpbGVuY2UgdGhlIGVycm9yLlxuICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbWF5YmVQcm9taXNlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcbiAgICAgICAgICAgICAgICAvLyBzcGxpY2UgaXQgaW4gdG8gbWFrZSB0aGUgc3RhY2sgbW9yZSByZWFkYWJsZS5cblxuXG4gICAgICAgICAgICAgICAgaWYgKGZuLmRpc3BsYXlOYW1lICYmIF9mcmFtZS5pbmNsdWRlcygnPGFub255bW91cz4nKSkge1xuICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVDbGFzc0NvbXBvbmVudEZyYW1lKGN0b3IsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoY3RvciwgdHJ1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdCQxKENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0JDEodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKGhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQ7XG5cbntcbiAgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0ID0ge307XG59XG5cbnZhciBlbXB0eUNvbnRleHRPYmplY3QgPSB7fTtcblxue1xuICBPYmplY3QuZnJlZXplKGVtcHR5Q29udGV4dE9iamVjdCk7XG59XG5cbmZ1bmN0aW9uIGdldE1hc2tlZENvbnRleHQodHlwZSwgdW5tYXNrZWRDb250ZXh0KSB7XG4gIHtcbiAgICB2YXIgY29udGV4dFR5cGVzID0gdHlwZS5jb250ZXh0VHlwZXM7XG5cbiAgICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgICAgcmV0dXJuIGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICB9XG5cbiAgICB2YXIgY29udGV4dCA9IHt9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIGNvbnRleHRUeXBlcykge1xuICAgICAgY29udGV4dFtrZXldID0gdW5tYXNrZWRDb250ZXh0W2tleV07XG4gICAgfVxuXG4gICAge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgJ1Vua25vd24nO1xuICAgICAgY2hlY2tQcm9wVHlwZXMoY29udGV4dFR5cGVzLCBjb250ZXh0LCAnY29udGV4dCcsIG5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzQ2hpbGRDb250ZXh0KGluc3RhbmNlLCB0eXBlLCBwYXJlbnRDb250ZXh0LCBjaGlsZENvbnRleHRUeXBlcykge1xuICB7XG4gICAgLy8gVE9ETyAoYnZhdWdobikgUmVwbGFjZSB0aGlzIGJlaGF2aW9yIHdpdGggYW4gaW52YXJpYW50KCkgaW4gdGhlIGZ1dHVyZS5cbiAgICAvLyBJdCBoYXMgb25seSBiZWVuIGFkZGVkIGluIEZpYmVyIHRvIG1hdGNoIHRoZSAodW5pbnRlbnRpb25hbCkgYmVoYXZpb3IgaW4gU3RhY2suXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgIGlmICghd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCclcy5jaGlsZENvbnRleHRUeXBlcyBpcyBzcGVjaWZpZWQgYnV0IHRoZXJlIGlzIG5vIGdldENoaWxkQ29udGV4dCgpIG1ldGhvZCAnICsgJ29uIHRoZSBpbnN0YW5jZS4gWW91IGNhbiBlaXRoZXIgZGVmaW5lIGdldENoaWxkQ29udGV4dCgpIG9uICVzIG9yIHJlbW92ZSAnICsgJ2NoaWxkQ29udGV4dFR5cGVzIGZyb20gaXQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkQ29udGV4dCA9IGluc3RhbmNlLmdldENoaWxkQ29udGV4dCgpO1xuXG4gICAgZm9yICh2YXIgY29udGV4dEtleSBpbiBjaGlsZENvbnRleHQpIHtcbiAgICAgIGlmICghKGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0VHlwZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8ICdVbmtub3duJykgKyBcIi5nZXRDaGlsZENvbnRleHQoKToga2V5IFxcXCJcIiArIGNvbnRleHRLZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8ICdVbmtub3duJztcbiAgICAgIGNoZWNrUHJvcFR5cGVzKGNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHQsICdjaGlsZCBjb250ZXh0JywgbmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFzc2lnbih7fSwgcGFyZW50Q29udGV4dCwgY2hpbGRDb250ZXh0KTtcbiAgfVxufVxuXG52YXIgcmVuZGVyZXJTaWdpbDtcblxue1xuICAvLyBVc2UgdGhpcyB0byBkZXRlY3QgbXVsdGlwbGUgcmVuZGVyZXJzIHVzaW5nIHRoZSBzYW1lIGNvbnRleHRcbiAgcmVuZGVyZXJTaWdpbCA9IHt9O1xufSAvLyBVc2VkIHRvIHN0b3JlIHRoZSBwYXJlbnQgcGF0aCBvZiBhbGwgY29udGV4dCBvdmVycmlkZXMgaW4gYSBzaGFyZWQgbGlua2VkIGxpc3QuXG4vLyBGb3JtaW5nIGEgcmV2ZXJzZSB0cmVlLlxuLy8gVGhlIHN0cnVjdHVyZSBvZiBhIGNvbnRleHQgc25hcHNob3QgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmaWxlLlxuLy8gQ3VycmVudGx5LCBpdCdzIGltcGxlbWVudGVkIGFzIHRyYWNraW5nIHRoZSBjdXJyZW50IGFjdGl2ZSBub2RlLlxuXG5cbnZhciByb290Q29udGV4dFNuYXBzaG90ID0gbnVsbDsgLy8gV2UgYXNzdW1lIHRoYXQgdGhpcyBydW50aW1lIG93bnMgdGhlIFwiY3VycmVudFwiIGZpZWxkIG9uIGFsbCBSZWFjdENvbnRleHQgaW5zdGFuY2VzLlxuLy8gVGhpcyBnbG9iYWwgKGFjdHVhbGx5IHRocmVhZCBsb2NhbCkgc3RhdGUgcmVwcmVzZW50cyB3aGF0IHN0YXRlIGFsbCB0aG9zZSBcImN1cnJlbnRcIixcbi8vIGZpZWxkcyBhcmUgY3VycmVudGx5IGluLlxuXG52YXIgY3VycmVudEFjdGl2ZVNuYXBzaG90ID0gbnVsbDtcblxuZnVuY3Rpb24gcG9wTm9kZShwcmV2KSB7XG4gIHtcbiAgICBwcmV2LmNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBwcmV2LnBhcmVudFZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hOb2RlKG5leHQpIHtcbiAge1xuICAgIG5leHQuY29udGV4dC5fY3VycmVudFZhbHVlMiA9IG5leHQudmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wVG9OZWFyZXN0Q29tbW9uQW5jZXN0b3IocHJldiwgbmV4dCkge1xuICBpZiAocHJldiA9PT0gbmV4dCkgOyBlbHNlIHtcbiAgICBwb3BOb2RlKHByZXYpO1xuICAgIHZhciBwYXJlbnRQcmV2ID0gcHJldi5wYXJlbnQ7XG4gICAgdmFyIHBhcmVudE5leHQgPSBuZXh0LnBhcmVudDtcblxuICAgIGlmIChwYXJlbnRQcmV2ID09PSBudWxsKSB7XG4gICAgICBpZiAocGFyZW50TmV4dCAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzdGFja3MgbXVzdCByZWFjaCB0aGUgcm9vdCBhdCB0aGUgc2FtZSB0aW1lLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGFyZW50TmV4dCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzdGFja3MgbXVzdCByZWFjaCB0aGUgcm9vdCBhdCB0aGUgc2FtZSB0aW1lLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfVxuXG4gICAgICBwb3BUb05lYXJlc3RDb21tb25BbmNlc3RvcihwYXJlbnRQcmV2LCBwYXJlbnROZXh0KTtcbiAgICB9IC8vIE9uIHRoZSB3YXkgYmFjaywgd2UgcHVzaCB0aGUgbmV3IG9uZXMgdGhhdCB3ZXJlbid0IGNvbW1vbi5cblxuXG4gICAgcHVzaE5vZGUobmV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wQWxsUHJldmlvdXMocHJldikge1xuICBwb3BOb2RlKHByZXYpO1xuICB2YXIgcGFyZW50UHJldiA9IHByZXYucGFyZW50O1xuXG4gIGlmIChwYXJlbnRQcmV2ICE9PSBudWxsKSB7XG4gICAgcG9wQWxsUHJldmlvdXMocGFyZW50UHJldik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaEFsbE5leHQobmV4dCkge1xuICB2YXIgcGFyZW50TmV4dCA9IG5leHQucGFyZW50O1xuXG4gIGlmIChwYXJlbnROZXh0ICE9PSBudWxsKSB7XG4gICAgcHVzaEFsbE5leHQocGFyZW50TmV4dCk7XG4gIH1cblxuICBwdXNoTm9kZShuZXh0KTtcbn1cblxuZnVuY3Rpb24gcG9wUHJldmlvdXNUb0NvbW1vbkxldmVsKHByZXYsIG5leHQpIHtcbiAgcG9wTm9kZShwcmV2KTtcbiAgdmFyIHBhcmVudFByZXYgPSBwcmV2LnBhcmVudDtcblxuICBpZiAocGFyZW50UHJldiA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRlcHRoIG11c3QgZXF1YWwgYXQgbGVhc3QgYXQgemVybyBiZWZvcmUgcmVhY2hpbmcgdGhlIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gIH1cblxuICBpZiAocGFyZW50UHJldi5kZXB0aCA9PT0gbmV4dC5kZXB0aCkge1xuICAgIC8vIFdlIGZvdW5kIHRoZSBzYW1lIGxldmVsLiBOb3cgd2UganVzdCBuZWVkIHRvIGZpbmQgYSBzaGFyZWQgYW5jZXN0b3IuXG4gICAgcG9wVG9OZWFyZXN0Q29tbW9uQW5jZXN0b3IocGFyZW50UHJldiwgbmV4dCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgbXVzdCBzdGlsbCBiZSBkZWVwZXIuXG4gICAgcG9wUHJldmlvdXNUb0NvbW1vbkxldmVsKHBhcmVudFByZXYsIG5leHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvcE5leHRUb0NvbW1vbkxldmVsKHByZXYsIG5leHQpIHtcbiAgdmFyIHBhcmVudE5leHQgPSBuZXh0LnBhcmVudDtcblxuICBpZiAocGFyZW50TmV4dCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRlcHRoIG11c3QgZXF1YWwgYXQgbGVhc3QgYXQgemVybyBiZWZvcmUgcmVhY2hpbmcgdGhlIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gIH1cblxuICBpZiAocHJldi5kZXB0aCA9PT0gcGFyZW50TmV4dC5kZXB0aCkge1xuICAgIC8vIFdlIGZvdW5kIHRoZSBzYW1lIGxldmVsLiBOb3cgd2UganVzdCBuZWVkIHRvIGZpbmQgYSBzaGFyZWQgYW5jZXN0b3IuXG4gICAgcG9wVG9OZWFyZXN0Q29tbW9uQW5jZXN0b3IocHJldiwgcGFyZW50TmV4dCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgbXVzdCBzdGlsbCBiZSBkZWVwZXIuXG4gICAgcG9wTmV4dFRvQ29tbW9uTGV2ZWwocHJldiwgcGFyZW50TmV4dCk7XG4gIH1cblxuICBwdXNoTm9kZShuZXh0KTtcbn0gLy8gUGVyZm9ybSBjb250ZXh0IHN3aXRjaGluZyB0byB0aGUgbmV3IHNuYXBzaG90LlxuLy8gVG8gbWFrZSBpdCBjaGVhcCB0byByZWFkIG1hbnkgY29udGV4dHMsIHdoaWxlIG5vdCBzdXNwZW5kaW5nLCB3ZSBtYWtlIHRoZSBzd2l0Y2ggZWFnZXJseSBieVxuLy8gdXBkYXRpbmcgYWxsIHRoZSBjb250ZXh0J3MgY3VycmVudCB2YWx1ZXMuIFRoYXQgd2F5IHJlYWRzLCBhbHdheXMganVzdCByZWFkIHRoZSBjdXJyZW50IHZhbHVlLlxuLy8gQXQgdGhlIGNvc3Qgb2YgdXBkYXRpbmcgY29udGV4dHMgZXZlbiBpZiB0aGV5J3JlIG5ldmVyIHJlYWQgYnkgdGhpcyBzdWJ0cmVlLlxuXG5cbmZ1bmN0aW9uIHN3aXRjaENvbnRleHQobmV3U25hcHNob3QpIHtcbiAgLy8gVGhlIGJhc2ljIGFsZ29yaXRobSB3ZSBuZWVkIHRvIGRvIGlzIHRvIHBvcCBiYWNrIGFueSBjb250ZXh0cyB0aGF0IGFyZSBubyBsb25nZXIgb24gdGhlIHN0YWNrLlxuICAvLyBXZSBhbHNvIG5lZWQgdG8gdXBkYXRlIGFueSBuZXcgY29udGV4dHMgdGhhdCBhcmUgbm93IG9uIHRoZSBzdGFjayB3aXRoIHRoZSBkZWVwZXN0IHZhbHVlLlxuICAvLyBUaGUgZWFzaWVzdCB3YXkgdG8gdXBkYXRlIG5ldyBjb250ZXh0cyBpcyB0byBqdXN0IHJlYXBwbHkgdGhlbSBpbiByZXZlcnNlIG9yZGVyIGZyb20gdGhlXG4gIC8vIHBlcnNwZWN0aXZlIG9mIHRoZSBiYWNrcG9pbnRlcnMuIFRvIGF2b2lkIGFsbG9jYXRpbmcgYSBsb3Qgd2hlbiBzd2l0Y2hpbmcsIHdlIHVzZSB0aGUgc3RhY2tcbiAgLy8gZm9yIHRoYXQuIFRoZXJlZm9yZSB0aGlzIGFsZ29yaXRobSBpcyByZWN1cnNpdmUuXG4gIC8vIDEpIEZpcnN0IHdlIHBvcCB3aGljaCBldmVyIHNuYXBzaG90IHRyZWUgd2FzIGRlZXBlc3QuIFBvcHBpbmcgb2xkIGNvbnRleHRzIGFzIHdlIGdvLlxuICAvLyAyKSBUaGVuIHdlIGZpbmQgdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIGZyb20gdGhlcmUuIFBvcHBpbmcgb2xkIGNvbnRleHRzIGFzIHdlIGdvLlxuICAvLyAzKSBUaGVuIHdlIHJlYXBwbHkgbmV3IGNvbnRleHRzIG9uIHRoZSB3YXkgYmFjayB1cCB0aGUgc3RhY2suXG4gIHZhciBwcmV2ID0gY3VycmVudEFjdGl2ZVNuYXBzaG90O1xuICB2YXIgbmV4dCA9IG5ld1NuYXBzaG90O1xuXG4gIGlmIChwcmV2ICE9PSBuZXh0KSB7XG4gICAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBUaGlzIGhhcyB0byBiZSBub24tbnVsbCBzaW5jZSBpdCdzIG5vdCBlcXVhbCB0byBwcmV2LlxuICAgICAgcHVzaEFsbE5leHQobmV4dCk7XG4gICAgfSBlbHNlIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICBwb3BBbGxQcmV2aW91cyhwcmV2KTtcbiAgICB9IGVsc2UgaWYgKHByZXYuZGVwdGggPT09IG5leHQuZGVwdGgpIHtcbiAgICAgIHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHByZXYsIG5leHQpO1xuICAgIH0gZWxzZSBpZiAocHJldi5kZXB0aCA+IG5leHQuZGVwdGgpIHtcbiAgICAgIHBvcFByZXZpb3VzVG9Db21tb25MZXZlbChwcmV2LCBuZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9wTmV4dFRvQ29tbW9uTGV2ZWwocHJldiwgbmV4dCk7XG4gICAgfVxuXG4gICAgY3VycmVudEFjdGl2ZVNuYXBzaG90ID0gbmV4dDtcbiAgfVxufVxuZnVuY3Rpb24gcHVzaFByb3ZpZGVyKGNvbnRleHQsIG5leHRWYWx1ZSkge1xuICB2YXIgcHJldlZhbHVlO1xuXG4gIHtcbiAgICBwcmV2VmFsdWUgPSBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBuZXh0VmFsdWU7XG5cbiAgICB7XG4gICAgICBpZiAoY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiAhPT0gdW5kZWZpbmVkICYmIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgIT09IG51bGwgJiYgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiAhPT0gcmVuZGVyZXJTaWdpbCkge1xuICAgICAgICBlcnJvcignRGV0ZWN0ZWQgbXVsdGlwbGUgcmVuZGVyZXJzIGNvbmN1cnJlbnRseSByZW5kZXJpbmcgdGhlICcgKyAnc2FtZSBjb250ZXh0IHByb3ZpZGVyLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC4nKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9IHJlbmRlcmVyU2lnaWw7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByZXZOb2RlID0gY3VycmVudEFjdGl2ZVNuYXBzaG90O1xuICB2YXIgbmV3Tm9kZSA9IHtcbiAgICBwYXJlbnQ6IHByZXZOb2RlLFxuICAgIGRlcHRoOiBwcmV2Tm9kZSA9PT0gbnVsbCA/IDAgOiBwcmV2Tm9kZS5kZXB0aCArIDEsXG4gICAgY29udGV4dDogY29udGV4dCxcbiAgICBwYXJlbnRWYWx1ZTogcHJldlZhbHVlLFxuICAgIHZhbHVlOiBuZXh0VmFsdWVcbiAgfTtcbiAgY3VycmVudEFjdGl2ZVNuYXBzaG90ID0gbmV3Tm9kZTtcbiAgcmV0dXJuIG5ld05vZGU7XG59XG5mdW5jdGlvbiBwb3BQcm92aWRlcihjb250ZXh0KSB7XG4gIHZhciBwcmV2U25hcHNob3QgPSBjdXJyZW50QWN0aXZlU25hcHNob3Q7XG5cbiAgaWYgKHByZXZTbmFwc2hvdCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJpZWQgdG8gcG9wIGEgQ29udGV4dCBhdCB0aGUgcm9vdCBvZiB0aGUgYXBwLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICB9XG5cbiAge1xuICAgIGlmIChwcmV2U25hcHNob3QuY29udGV4dCAhPT0gY29udGV4dCkge1xuICAgICAgZXJyb3IoJ1RoZSBwYXJlbnQgY29udGV4dCBpcyBub3QgdGhlIGV4cGVjdGVkIGNvbnRleHQuIFRoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIHZhciBfdmFsdWUgPSBwcmV2U25hcHNob3QucGFyZW50VmFsdWU7XG5cbiAgICBpZiAoX3ZhbHVlID09PSBSRUFDVF9TRVJWRVJfQ09OVEVYVF9ERUZBVUxUX1ZBTFVFX05PVF9MT0FERUQpIHtcbiAgICAgIHByZXZTbmFwc2hvdC5jb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gcHJldlNuYXBzaG90LmNvbnRleHQuX2RlZmF1bHRWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldlNuYXBzaG90LmNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBfdmFsdWU7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgIT09IHVuZGVmaW5lZCAmJiBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyICE9PSBudWxsICYmIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgIT09IHJlbmRlcmVyU2lnaWwpIHtcbiAgICAgICAgZXJyb3IoJ0RldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSAnICsgJ3NhbWUgY29udGV4dCBwcm92aWRlci4gVGhpcyBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPSByZW5kZXJlclNpZ2lsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjdXJyZW50QWN0aXZlU25hcHNob3QgPSBwcmV2U25hcHNob3QucGFyZW50O1xufVxuZnVuY3Rpb24gZ2V0QWN0aXZlQ29udGV4dCgpIHtcbiAgcmV0dXJuIGN1cnJlbnRBY3RpdmVTbmFwc2hvdDtcbn1cbmZ1bmN0aW9uIHJlYWRDb250ZXh0JDEoY29udGV4dCkge1xuICB2YXIgdmFsdWUgPSBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcbiAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbW9kdWxlIGlzIGN1cnJlbnRseSBzaGFyZWQgYW5kIGFzc3VtZWQgdG8gYmUgc3RhdGVsZXNzLlxuICogSWYgdGhpcyBiZWNvbWVzIGFuIGFjdHVhbCBNYXAsIHRoYXQgd2lsbCBicmVhay5cbiAqL1xuZnVuY3Rpb24gZ2V0KGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFscztcbn1cbmZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gIGtleS5fcmVhY3RJbnRlcm5hbHMgPSB2YWx1ZTtcbn1cblxudmFyIGRpZFdhcm5BYm91dE5vb3BVcGRhdGVGb3JDb21wb25lbnQgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50ID0ge307XG52YXIgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlO1xudmFyIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZTtcbnZhciBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlO1xudmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZTtcbnZhciBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZTtcbnZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcztcbnZhciBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGU7XG52YXIgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrO1xuXG57XG4gIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcyA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBuZXcgU2V0KCk7XG59XG5cbmZ1bmN0aW9uIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICB7XG4gICAgaWYgKGNhbGxiYWNrID09PSBudWxsIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBrZXkgPSBjYWxsZXJOYW1lICsgJ18nICsgY2FsbGJhY2s7XG5cbiAgICBpZiAoIWRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5oYXMoa2V5KSkge1xuICAgICAgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmFkZChrZXkpO1xuXG4gICAgICBlcnJvcignJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlKHR5cGUsIHBhcnRpYWxTdGF0ZSkge1xuICB7XG4gICAgaWYgKHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZXJyb3IoJyVzLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpOiBBIHZhbGlkIHN0YXRlIG9iamVjdCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gJyArICdZb3UgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICB2YXIgX2NvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBfY29uc3RydWN0b3IgJiYgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKF9jb25zdHJ1Y3RvcikgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIHZhciB3YXJuaW5nS2V5ID0gY29tcG9uZW50TmFtZSArICcuJyArIGNhbGxlck5hbWU7XG5cbiAgICBpZiAoZGlkV2FybkFib3V0Tm9vcFVwZGF0ZUZvckNvbXBvbmVudFt3YXJuaW5nS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVycm9yKCclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvdXRzaWRlIGNvbXBvbmVudFdpbGxNb3VudCgpIG9uIHRoZSBzZXJ2ZXIuICcgKyAnVGhpcyBpcyBhIG5vLW9wLlxcblxcblBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lLCBjb21wb25lbnROYW1lKTtcblxuICAgIGRpZFdhcm5BYm91dE5vb3BVcGRhdGVGb3JDb21wb25lbnRbd2FybmluZ0tleV0gPSB0cnVlO1xuICB9XG59XG5cbnZhciBjbGFzc0NvbXBvbmVudFVwZGF0ZXIgPSB7XG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKGluc3QpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIC8vICRGbG93Rml4TWVbbWlzc2luZy1sb2NhbC1hbm5vdF1cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAoaW5zdCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgaW50ZXJuYWxzID0gZ2V0KGluc3QpO1xuXG4gICAgaWYgKGludGVybmFscy5xdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgd2Fybk5vb3AoaW5zdCwgJ3NldFN0YXRlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVybmFscy5xdWV1ZS5wdXNoKHBheWxvYWQpO1xuXG4gICAgICB7XG4gICAgICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGludGVybmFscyA9IGdldChpbnN0KTtcbiAgICBpbnRlcm5hbHMucmVwbGFjZSA9IHRydWU7XG4gICAgaW50ZXJuYWxzLnF1ZXVlID0gW3BheWxvYWRdO1xuXG4gICAge1xuICAgICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8vICRGbG93Rml4TWVbbWlzc2luZy1sb2NhbC1hbm5vdF1cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoaW5zdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgaW50ZXJuYWxzID0gZ2V0KGluc3QpO1xuXG4gICAgaWYgKGludGVybmFscy5xdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgd2Fybk5vb3AoaW5zdCwgJ2ZvcmNlVXBkYXRlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyhpbnN0YW5jZSwgY3RvciwgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLCBwcmV2U3RhdGUsIG5leHRQcm9wcykge1xuICB2YXIgcGFydGlhbFN0YXRlID0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKTtcblxuICB7XG4gICAgd2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlKGN0b3IsIHBhcnRpYWxTdGF0ZSk7XG4gIH0gLy8gTWVyZ2UgdGhlIHBhcnRpYWwgc3RhdGUgYW5kIHRoZSBwcmV2aW91cyBzdGF0ZS5cblxuXG4gIHZhciBuZXdTdGF0ZSA9IHBhcnRpYWxTdGF0ZSA9PT0gbnVsbCB8fCBwYXJ0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCA/IHByZXZTdGF0ZSA6IGFzc2lnbih7fSwgcHJldlN0YXRlLCBwYXJ0aWFsU3RhdGUpO1xuICByZXR1cm4gbmV3U3RhdGU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdENsYXNzSW5zdGFuY2UoY3RvciwgcHJvcHMsIG1hc2tlZExlZ2FjeUNvbnRleHQpIHtcbiAgdmFyIGNvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG4gIHZhciBjb250ZXh0VHlwZSA9IGN0b3IuY29udGV4dFR5cGU7XG5cbiAge1xuICAgIGlmICgnY29udGV4dFR5cGUnIGluIGN0b3IpIHtcbiAgICAgIHZhciBpc1ZhbGlkID0gLy8gQWxsb3cgbnVsbCBmb3IgY29uZGl0aW9uYWwgZGVjbGFyYXRpb25cbiAgICAgIGNvbnRleHRUeXBlID09PSBudWxsIHx8IGNvbnRleHRUeXBlICE9PSB1bmRlZmluZWQgJiYgY29udGV4dFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSAmJiBjb250ZXh0VHlwZS5fY29udGV4dCA9PT0gdW5kZWZpbmVkOyAvLyBOb3QgYSA8Q29udGV4dC5Db25zdW1lcj5cblxuICAgICAgaWYgKCFpc1ZhbGlkICYmICFkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuaGFzKGN0b3IpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5hZGQoY3Rvcik7XG4gICAgICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuXG4gICAgICAgIGlmIChjb250ZXh0VHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byB1bmRlZmluZWQuICcgKyAnVGhpcyBjYW4gYmUgY2F1c2VkIGJ5IGEgdHlwbyBvciBieSBtaXhpbmcgdXAgbmFtZWQgYW5kIGRlZmF1bHQgaW1wb3J0cy4gJyArICdUaGlzIGNhbiBhbHNvIGhhcHBlbiBkdWUgdG8gYSBjaXJjdWxhciBkZXBlbmRlbmN5LCBzbyAnICsgJ3RyeSBtb3ZpbmcgdGhlIGNyZWF0ZUNvbnRleHQoKSBjYWxsIHRvIGEgc2VwYXJhdGUgZmlsZS4nO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGEgJyArIHR5cGVvZiBjb250ZXh0VHlwZSArICcuJztcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSkge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIHRoZSBDb250ZXh0LlByb3ZpZGVyIGluc3RlYWQ/JztcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0VHlwZS5fY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gPENvbnRleHQuQ29uc3VtZXI+XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgdGhlIENvbnRleHQuQ29uc3VtZXIgaW5zdGVhZD8nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYW4gb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNvbnRleHRUeXBlKS5qb2luKCcsICcpICsgJ30uJztcbiAgICAgICAgfVxuXG4gICAgICAgIGVycm9yKCclcyBkZWZpbmVzIGFuIGludmFsaWQgY29udGV4dFR5cGUuICcgKyAnY29udGV4dFR5cGUgc2hvdWxkIHBvaW50IHRvIHRoZSBDb250ZXh0IG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVDb250ZXh0KCkuJXMnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0NvbXBvbmVudCcsIGFkZGVuZHVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgIGNvbnRleHQgPSByZWFkQ29udGV4dCQxKGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0ID0gbWFza2VkTGVnYWN5Q29udGV4dDtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IG5ldyBjdG9yKHByb3BzLCBjb250ZXh0KTtcblxuICB7XG4gICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAoaW5zdGFuY2Uuc3RhdGUgPT09IG51bGwgfHwgaW5zdGFuY2Uuc3RhdGUgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignYCVzYCB1c2VzIGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGJ1dCBpdHMgaW5pdGlhbCBzdGF0ZSBpcyAnICsgJyVzLiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZC4gSW5zdGVhZCwgZGVmaW5lIHRoZSBpbml0aWFsIHN0YXRlIGJ5ICcgKyAnYXNzaWduaW5nIGFuIG9iamVjdCB0byBgdGhpcy5zdGF0ZWAgaW4gdGhlIGNvbnN0cnVjdG9yIG9mIGAlc2AuICcgKyAnVGhpcyBlbnN1cmVzIHRoYXQgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYXJndW1lbnRzIGhhdmUgYSBjb25zaXN0ZW50IHNoYXBlLicsIGNvbXBvbmVudE5hbWUsIGluc3RhbmNlLnN0YXRlID09PSBudWxsID8gJ251bGwnIDogJ3VuZGVmaW5lZCcsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH0gLy8gSWYgbmV3IGNvbXBvbmVudCBBUElzIGFyZSBkZWZpbmVkLCBcInVuc2FmZVwiIGxpZmVjeWNsZXMgd29uJ3QgYmUgY2FsbGVkLlxuICAgIC8vIFdhcm4gYWJvdXQgdGhlc2UgbGlmZWN5Y2xlcyBpZiB0aGV5IGFyZSBwcmVzZW50LlxuICAgIC8vIERvbid0IHdhcm4gYWJvdXQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBtZXRob2RzIHRob3VnaC5cblxuXG4gICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBmb3VuZFdpbGxNb3VudE5hbWUgPSBudWxsO1xuICAgICAgdmFyIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSBudWxsO1xuICAgICAgdmFyIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBudWxsO1xuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxNb3VudE5hbWUgPSAnY29tcG9uZW50V2lsbE1vdW50JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsTW91bnROYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsTW91bnQnO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICAgIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gJ2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSc7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgfHwgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbCB8fCBmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgICB2YXIgbmV3QXBpTmFtZSA9IHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyA/ICdnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKScgOiAnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSc7XG5cbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmhhcyhfY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmFkZChfY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgICBlcnJvcignVW5zYWZlIGxlZ2FjeSBsaWZlY3ljbGVzIHdpbGwgbm90IGJlIGNhbGxlZCBmb3IgY29tcG9uZW50cyB1c2luZyBuZXcgY29tcG9uZW50IEFQSXMuXFxuXFxuJyArICclcyB1c2VzICVzIGJ1dCBhbHNvIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgbGVnYWN5IGxpZmVjeWNsZXM6JXMlcyVzXFxuXFxuJyArICdUaGUgYWJvdmUgbGlmZWN5Y2xlcyBzaG91bGQgYmUgcmVtb3ZlZC4gTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTpcXG4nICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMnLCBfY29tcG9uZW50TmFtZSwgbmV3QXBpTmFtZSwgZm91bmRXaWxsTW91bnROYW1lICE9PSBudWxsID8gXCJcXG4gIFwiICsgZm91bmRXaWxsTW91bnROYW1lIDogJycsIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgIT09IG51bGwgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lIDogJycsIGZvdW5kV2lsbFVwZGF0ZU5hbWUgIT09IG51bGwgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxVcGRhdGVOYW1lIDogJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5mdW5jdGlvbiBjaGVja0NsYXNzSW5zdGFuY2UoaW5zdGFuY2UsIGN0b3IsIG5ld1Byb3BzKSB7XG4gIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JztcbiAgICB2YXIgcmVuZGVyUHJlc2VudCA9IGluc3RhbmNlLnJlbmRlcjtcblxuICAgIGlmICghcmVuZGVyUHJlc2VudCkge1xuICAgICAgaWYgKGN0b3IucHJvdG90eXBlICYmIHR5cGVvZiBjdG9yLnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3IoJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IGRpZCB5b3UgYWNjaWRlbnRhbGx5IHJldHVybiBhbiBvYmplY3QgZnJvbSB0aGUgY29uc3RydWN0b3I/JywgbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuJywgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmdldEluaXRpYWxTdGF0ZSAmJiAhaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkICYmICFpbnN0YW5jZS5zdGF0ZSkge1xuICAgICAgZXJyb3IoJ2dldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzICYmICFpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcFR5cGVzKSB7XG4gICAgICBlcnJvcigncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmNvbnRleHRUeXBlKSB7XG4gICAgICBlcnJvcignY29udGV4dFR5cGUgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZSBpbnN0ZWFkLicsIG5hbWUpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChpbnN0YW5jZS5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgZXJyb3IoJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3Rvci5jb250ZXh0VHlwZSAmJiBjdG9yLmNvbnRleHRUeXBlcyAmJiAhZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMuaGFzKGN0b3IpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzLmFkZChjdG9yKTtcblxuICAgICAgICBlcnJvcignJXMgZGVjbGFyZXMgYm90aCBjb250ZXh0VHlwZXMgYW5kIGNvbnRleHRUeXBlIHN0YXRpYyBwcm9wZXJ0aWVzLiAnICsgJ1RoZSBsZWdhY3kgY29udGV4dFR5cGVzIHByb3BlcnR5IHdpbGwgYmUgaWdub3JlZC4nLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChjdG9yLnByb3RvdHlwZSAmJiBjdG9yLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCAmJiB0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkuICcgKyAnc2hvdWxkQ29tcG9uZW50VXBkYXRlIHNob3VsZCBub3QgYmUgdXNlZCB3aGVuIGV4dGVuZGluZyBSZWFjdC5QdXJlQ29tcG9uZW50LiAnICsgJ1BsZWFzZSBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpcyB1c2VkLicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQSBwdXJlIGNvbXBvbmVudCcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/JywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzKCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnSWYgeW91IG1lYW50IHRvIHVwZGF0ZSB0aGUgc3RhdGUgaW4gcmVzcG9uc2UgdG8gY2hhbmdpbmcgcHJvcHMsICcgKyAndXNlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKS4gSWYgeW91IG1lYW50IHRvIGZldGNoIGRhdGEgb3IgJyArICdydW4gc2lkZS1lZmZlY3RzIG9yIG11dGF0aW9ucyBhZnRlciBSZWFjdCBoYXMgdXBkYXRlZCB0aGUgVUksIHVzZSBjb21wb25lbnREaWRVcGRhdGUoKS4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIGhhc011dGF0ZWRQcm9wcyA9IGluc3RhbmNlLnByb3BzICE9PSBuZXdQcm9wcztcblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcyAhPT0gdW5kZWZpbmVkICYmIGhhc011dGF0ZWRQcm9wcykge1xuICAgICAgZXJyb3IoJyVzKC4uLik6IFdoZW4gY2FsbGluZyBzdXBlcigpIGluIGAlc2AsIG1ha2Ugc3VyZSB0byBwYXNzICcgKyBcInVwIHRoZSBzYW1lIHByb3BzIHRoYXQgeW91ciBjb21wb25lbnQncyBjb25zdHJ1Y3RvciB3YXMgcGFzc2VkLlwiLCBuYW1lLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuZGVmYXVsdFByb3BzKSB7XG4gICAgICBlcnJvcignU2V0dGluZyBkZWZhdWx0UHJvcHMgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSBpZ25vcmVkLicgKyAnIEluc3RlYWQsIGRlZmluZSBkZWZhdWx0UHJvcHMgYXMgYSBzdGF0aWMgcHJvcGVydHkgb24gJXMuJywgbmFtZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlICE9PSAnZnVuY3Rpb24nICYmICFkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuaGFzKGN0b3IpKSB7XG4gICAgICBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuYWRkKGN0b3IpO1xuXG4gICAgICBlcnJvcignJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgc2hvdWxkIGJlIHVzZWQgd2l0aCBjb21wb25lbnREaWRVcGRhdGUoKS4gJyArICdUaGlzIGNvbXBvbmVudCBkZWZpbmVzIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgb25seS4nLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXM6IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclczogZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGN0b3IuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclczogZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBpcyBkZWZpbmVkIGFzIGEgc3RhdGljIG1ldGhvZCAnICsgJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kLicsIG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBzdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gICAgaWYgKHN0YXRlICYmICh0eXBlb2Ygc3RhdGUgIT09ICdvYmplY3QnIHx8IGlzQXJyYXkoc3RhdGUpKSkge1xuICAgICAgZXJyb3IoJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjdG9yLmNoaWxkQ29udGV4dFR5cGVzICE9PSAnb2JqZWN0Jykge1xuICAgICAgZXJyb3IoJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gJyArICd1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgbmFtZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsTW91bnQodHlwZSwgaW5zdGFuY2UpIHtcbiAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICBpZiAoaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgIGlmICghZGlkV2FybkFib3V0RGVwcmVjYXRlZFdpbGxNb3VudFtjb21wb25lbnROYW1lXSkge1xuICAgICAgICAgIHdhcm4oIC8vIGtlZXAgdGhpcyB3YXJuaW5nIGluIHN5bmMgd2l0aCBSZWFjdFN0cmljdE1vZGVXYXJuaW5nLmpzXG4gICAgICAgICAgJ2NvbXBvbmVudFdpbGxNb3VudCBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgY29kZSBmcm9tIGNvbXBvbmVudFdpbGxNb3VudCB0byBjb21wb25lbnREaWRNb3VudCAocHJlZmVycmVkIGluIG1vc3QgY2FzZXMpICcgKyAnb3IgdGhlIGNvbnN0cnVjdG9yLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICB9XG5cbiAgaWYgKG9sZFN0YXRlICE9PSBpbnN0YW5jZS5zdGF0ZSkge1xuICAgIHtcbiAgICAgIGVycm9yKCclcy5jb21wb25lbnRXaWxsTW91bnQoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvIHRoaXMuc3RhdGUgaXMgJyArIFwiZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8ICdDb21wb25lbnQnKTtcbiAgICB9XG5cbiAgICBjbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NVcGRhdGVRdWV1ZShpbnRlcm5hbEluc3RhbmNlLCBpbnN0LCBwcm9wcywgbWFza2VkTGVnYWN5Q29udGV4dCkge1xuICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5xdWV1ZSAhPT0gbnVsbCAmJiBpbnRlcm5hbEluc3RhbmNlLnF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgb2xkUXVldWUgPSBpbnRlcm5hbEluc3RhbmNlLnF1ZXVlO1xuICAgIHZhciBvbGRSZXBsYWNlID0gaW50ZXJuYWxJbnN0YW5jZS5yZXBsYWNlO1xuICAgIGludGVybmFsSW5zdGFuY2UucXVldWUgPSBudWxsO1xuICAgIGludGVybmFsSW5zdGFuY2UucmVwbGFjZSA9IGZhbHNlO1xuXG4gICAgaWYgKG9sZFJlcGxhY2UgJiYgb2xkUXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgICBpbnN0LnN0YXRlID0gb2xkUXVldWVbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuZXh0U3RhdGUgPSBvbGRSZXBsYWNlID8gb2xkUXVldWVbMF0gOiBpbnN0LnN0YXRlO1xuICAgICAgdmFyIGRvbnRNdXRhdGUgPSB0cnVlO1xuXG4gICAgICBmb3IgKHZhciBpID0gb2xkUmVwbGFjZSA/IDEgOiAwOyBpIDwgb2xkUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnRpYWwgPSBvbGRRdWV1ZVtpXTtcbiAgICAgICAgdmFyIHBhcnRpYWxTdGF0ZSA9IHR5cGVvZiBwYXJ0aWFsID09PSAnZnVuY3Rpb24nID8gcGFydGlhbC5jYWxsKGluc3QsIG5leHRTdGF0ZSwgcHJvcHMsIG1hc2tlZExlZ2FjeUNvbnRleHQpIDogcGFydGlhbDtcblxuICAgICAgICBpZiAocGFydGlhbFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoZG9udE11dGF0ZSkge1xuICAgICAgICAgICAgZG9udE11dGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgbmV4dFN0YXRlID0gYXNzaWduKHt9LCBuZXh0U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFzc2lnbihuZXh0U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGluc3Quc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGludGVybmFsSW5zdGFuY2UucXVldWUgPSBudWxsO1xuICB9XG59IC8vIEludm9rZXMgdGhlIG1vdW50IGxpZmUtY3ljbGVzIG9uIGEgcHJldmlvdXNseSBuZXZlciByZW5kZXJlZCBpbnN0YW5jZS5cblxuXG5mdW5jdGlvbiBtb3VudENsYXNzSW5zdGFuY2UoaW5zdGFuY2UsIGN0b3IsIG5ld1Byb3BzLCBtYXNrZWRMZWdhY3lDb250ZXh0KSB7XG4gIHtcbiAgICBjaGVja0NsYXNzSW5zdGFuY2UoaW5zdGFuY2UsIGN0b3IsIG5ld1Byb3BzKTtcbiAgfVxuXG4gIHZhciBpbml0aWFsU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSAhPT0gdW5kZWZpbmVkID8gaW5zdGFuY2Uuc3RhdGUgOiBudWxsO1xuICBpbnN0YW5jZS51cGRhdGVyID0gY2xhc3NDb21wb25lbnRVcGRhdGVyO1xuICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICBpbnN0YW5jZS5zdGF0ZSA9IGluaXRpYWxTdGF0ZTsgLy8gV2UgZG9uJ3QgYm90aGVyIGluaXRpYWxpemluZyB0aGUgcmVmcyBvYmplY3Qgb24gdGhlIHNlcnZlciwgc2luY2Ugd2UncmUgbm90IGdvaW5nIHRvIHJlc29sdmUgdGhlbSBhbnl3YXkuXG4gIC8vIFRoZSBpbnRlcm5hbCBpbnN0YW5jZSB3aWxsIGJlIHVzZWQgdG8gbWFuYWdlIHVwZGF0ZXMgdGhhdCBoYXBwZW4gZHVyaW5nIHRoaXMgbW91bnQuXG5cbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSB7XG4gICAgcXVldWU6IFtdLFxuICAgIHJlcGxhY2U6IGZhbHNlXG4gIH07XG4gIHNldChpbnN0YW5jZSwgaW50ZXJuYWxJbnN0YW5jZSk7XG4gIHZhciBjb250ZXh0VHlwZSA9IGN0b3IuY29udGV4dFR5cGU7XG5cbiAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICBpbnN0YW5jZS5jb250ZXh0ID0gcmVhZENvbnRleHQkMShjb250ZXh0VHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IG1hc2tlZExlZ2FjeUNvbnRleHQ7XG4gIH1cblxuICB7XG4gICAgaWYgKGluc3RhbmNlLnN0YXRlID09PSBuZXdQcm9wcykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignJXM6IEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0byBhc3NpZ24gcHJvcHMgZGlyZWN0bHkgdG8gc3RhdGUgJyArIFwiYmVjYXVzZSB1cGRhdGVzIHRvIHByb3BzIHdvbid0IGJlIHJlZmxlY3RlZCBpbiBzdGF0ZS4gXCIgKyAnSW4gbW9zdCBjYXNlcywgaXQgaXMgYmV0dGVyIHRvIHVzZSBwcm9wcyBkaXJlY3RseS4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG5cbiAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKGluc3RhbmNlLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIGluaXRpYWxTdGF0ZSwgbmV3UHJvcHMpO1xuICB9IC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuXG5cbiAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgIT09ICdmdW5jdGlvbicgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgY2FsbENvbXBvbmVudFdpbGxNb3VudChjdG9yLCBpbnN0YW5jZSk7IC8vIElmIHdlIGhhZCBhZGRpdGlvbmFsIHN0YXRlIHVwZGF0ZXMgZHVyaW5nIHRoaXMgbGlmZS1jeWNsZSwgbGV0J3NcbiAgICAvLyBwcm9jZXNzIHRoZW0gbm93LlxuXG4gICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKGludGVybmFsSW5zdGFuY2UsIGluc3RhbmNlLCBuZXdQcm9wcywgbWFza2VkTGVnYWN5Q29udGV4dCk7XG4gIH1cbn1cblxuLy8gSWRzIGFyZSBiYXNlIDMyIHN0cmluZ3Mgd2hvc2UgYmluYXJ5IHJlcHJlc2VudGF0aW9uIGNvcnJlc3BvbmRzIHRvIHRoZVxuLy8gcG9zaXRpb24gb2YgYSBub2RlIGluIGEgdHJlZS5cbi8vIEV2ZXJ5IHRpbWUgdGhlIHRyZWUgZm9ya3MgaW50byBtdWx0aXBsZSBjaGlsZHJlbiwgd2UgYWRkIGFkZGl0aW9uYWwgYml0cyB0b1xuLy8gdGhlIGxlZnQgb2YgdGhlIHNlcXVlbmNlIHRoYXQgcmVwcmVzZW50IHRoZSBwb3NpdGlvbiBvZiB0aGUgY2hpbGQgd2l0aGluIHRoZVxuLy8gY3VycmVudCBsZXZlbCBvZiBjaGlsZHJlbi5cbi8vXG4vLyAgICAgIDAwMTAxICAgICAgIDAwMDEwMDAxMDExMDEwMTAxXG4vLyAgICAgIOKVsOKUgOKUrOKUgOKVryAgICAgICDilbDilIDilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDila9cbi8vICAgRm9yayA1IG9mIDIwICAgICAgIFBhcmVudCBpZFxuLy9cbi8vIFRoZSBsZWFkaW5nIDBzIGFyZSBpbXBvcnRhbnQuIEluIHRoZSBhYm92ZSBleGFtcGxlLCB5b3Ugb25seSBuZWVkIDMgYml0cyB0b1xuLy8gcmVwcmVzZW50IHNsb3QgNS4gSG93ZXZlciwgeW91IG5lZWQgNSBiaXRzIHRvIHJlcHJlc2VudCBhbGwgdGhlIGZvcmtzIGF0XG4vLyB0aGUgY3VycmVudCBsZXZlbCwgc28gd2UgbXVzdCBhY2NvdW50IGZvciB0aGUgZW1wdHkgYml0cyBhdCB0aGUgZW5kLlxuLy9cbi8vIEZvciB0aGlzIHNhbWUgcmVhc29uLCBzbG90cyBhcmUgMS1pbmRleGVkIGluc3RlYWQgb2YgMC1pbmRleGVkLiBPdGhlcndpc2UsXG4vLyB0aGUgemVyb3RoIGlkIGF0IGEgbGV2ZWwgd291bGQgYmUgaW5kaXN0aW5ndWlzaGFibGUgZnJvbSBpdHMgcGFyZW50LlxuLy9cbi8vIElmIGEgbm9kZSBoYXMgb25seSBvbmUgY2hpbGQsIGFuZCBkb2VzIG5vdCBtYXRlcmlhbGl6ZSBhbiBpZCAoaS5lLiBkb2VzIG5vdFxuLy8gY29udGFpbiBhIHVzZUlkIGhvb2spLCB0aGVuIHdlIGRvbid0IG5lZWQgdG8gYWxsb2NhdGUgYW55IHNwYWNlIGluIHRoZVxuLy8gc2VxdWVuY2UuIEl0J3MgdHJlYXRlZCBhcyBhIHRyYW5zcGFyZW50IGluZGlyZWN0aW9uLiBGb3IgZXhhbXBsZSwgdGhlc2UgdHdvXG4vLyB0cmVlcyBwcm9kdWNlIHRoZSBzYW1lIGlkczpcbi8vXG4vLyA8PiAgICAgICAgICAgICAgICAgICAgICAgICAgPD5cbi8vICAgPEluZGlyZWN0aW9uPiAgICAgICAgICAgICAgIDxBIC8+XG4vLyAgICAgPEEgLz4gICAgICAgICAgICAgICAgICAgICA8QiAvPlxuLy8gICA8L0luZGlyZWN0aW9uPiAgICAgICAgICAgIDwvPlxuLy8gICA8QiAvPlxuLy8gPC8+XG4vL1xuLy8gSG93ZXZlciwgd2UgY2Fubm90IHNraXAgYW55IG5vZGUgdGhhdCBtYXRlcmlhbGl6ZXMgYW4gaWQuIE90aGVyd2lzZSwgYSBwYXJlbnRcbi8vIGlkIHRoYXQgZG9lcyBub3QgZm9yayB3b3VsZCBiZSBpbmRpc3Rpbmd1aXNoYWJsZSBmcm9tIGl0cyBjaGlsZCBpZC4gRm9yXG4vLyBleGFtcGxlLCB0aGlzIHRyZWUgZG9lcyBub3QgZm9yaywgYnV0IHRoZSBwYXJlbnQgYW5kIGNoaWxkIG11c3QgaGF2ZVxuLy8gZGlmZmVyZW50IGlkcy5cbi8vXG4vLyA8UGFyZW50PlxuLy8gICA8Q2hpbGQgLz5cbi8vIDwvUGFyZW50PlxuLy9cbi8vIFRvIGhhbmRsZSB0aGlzIHNjZW5hcmlvLCBldmVyeSB0aW1lIHdlIG1hdGVyaWFsaXplIGFuIGlkLCB3ZSBhbGxvY2F0ZSBhXG4vLyBuZXcgbGV2ZWwgd2l0aCBhIHNpbmdsZSBzbG90LiBZb3UgY2FuIHRoaW5rIG9mIHRoaXMgYXMgYSBmb3JrIHdpdGggb25seSBvbmVcbi8vIHByb25nLCBvciBhbiBhcnJheSBvZiBjaGlsZHJlbiB3aXRoIGxlbmd0aCAxLlxuLy9cbi8vIEl0J3MgcG9zc2libGUgZm9yIHRoZSBzaXplIG9mIHRoZSBzZXF1ZW5jZSB0byBleGNlZWQgMzIgYml0cywgdGhlIG1heFxuLy8gc2l6ZSBmb3IgYml0d2lzZSBvcGVyYXRpb25zLiBXaGVuIHRoaXMgaGFwcGVucywgd2UgbWFrZSBtb3JlIHJvb20gYnlcbi8vIGNvbnZlcnRpbmcgdGhlIHJpZ2h0IHBhcnQgb2YgdGhlIGlkIHRvIGEgc3RyaW5nIGFuZCBzdG9yaW5nIGl0IGluIGFuIG92ZXJmbG93XG4vLyB2YXJpYWJsZS4gV2UgdXNlIGEgYmFzZSAzMiBzdHJpbmcgcmVwcmVzZW50YXRpb24sIGJlY2F1c2UgMzIgaXMgdGhlIGxhcmdlc3Rcbi8vIHBvd2VyIG9mIDIgdGhhdCBpcyBzdXBwb3J0ZWQgYnkgdG9TdHJpbmcoKS4gV2Ugd2FudCB0aGUgYmFzZSB0byBiZSBsYXJnZSBzb1xuLy8gdGhhdCB0aGUgcmVzdWx0aW5nIGlkcyBhcmUgY29tcGFjdCwgYW5kIHdlIHdhbnQgdGhlIGJhc2UgdG8gYmUgYSBwb3dlciBvZiAyXG4vLyBiZWNhdXNlIGV2ZXJ5IGxvZzIoYmFzZSkgYml0cyBjb3JyZXNwb25kcyB0byBhIHNpbmdsZSBjaGFyYWN0ZXIsIGkuZS4gZXZlcnlcbi8vIGxvZzIoMzIpID0gNSBiaXRzLiBUaGF0IG1lYW5zIHdlIGNhbiBsb3AgYml0cyBvZmYgdGhlIGVuZCA1IGF0IGEgdGltZSB3aXRob3V0XG4vLyBhZmZlY3RpbmcgdGhlIGZpbmFsIHJlc3VsdC5cbnZhciBlbXB0eVRyZWVDb250ZXh0ID0ge1xuICBpZDogMSxcbiAgb3ZlcmZsb3c6ICcnXG59O1xuZnVuY3Rpb24gZ2V0VHJlZUlkKGNvbnRleHQpIHtcbiAgdmFyIG92ZXJmbG93ID0gY29udGV4dC5vdmVyZmxvdztcbiAgdmFyIGlkV2l0aExlYWRpbmdCaXQgPSBjb250ZXh0LmlkO1xuICB2YXIgaWQgPSBpZFdpdGhMZWFkaW5nQml0ICYgfmdldExlYWRpbmdCaXQoaWRXaXRoTGVhZGluZ0JpdCk7XG4gIHJldHVybiBpZC50b1N0cmluZygzMikgKyBvdmVyZmxvdztcbn1cbmZ1bmN0aW9uIHB1c2hUcmVlQ29udGV4dChiYXNlQ29udGV4dCwgdG90YWxDaGlsZHJlbiwgaW5kZXgpIHtcbiAgdmFyIGJhc2VJZFdpdGhMZWFkaW5nQml0ID0gYmFzZUNvbnRleHQuaWQ7XG4gIHZhciBiYXNlT3ZlcmZsb3cgPSBiYXNlQ29udGV4dC5vdmVyZmxvdzsgLy8gVGhlIGxlZnRtb3N0IDEgbWFya3MgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UsIG5vbi1pbmNsdXNpdmUuIEl0J3Mgbm90IHBhcnRcbiAgLy8gb2YgdGhlIGlkOyB3ZSB1c2UgaXQgdG8gYWNjb3VudCBmb3IgbGVhZGluZyAwcy5cblxuICB2YXIgYmFzZUxlbmd0aCA9IGdldEJpdExlbmd0aChiYXNlSWRXaXRoTGVhZGluZ0JpdCkgLSAxO1xuICB2YXIgYmFzZUlkID0gYmFzZUlkV2l0aExlYWRpbmdCaXQgJiB+KDEgPDwgYmFzZUxlbmd0aCk7XG4gIHZhciBzbG90ID0gaW5kZXggKyAxO1xuICB2YXIgbGVuZ3RoID0gZ2V0Qml0TGVuZ3RoKHRvdGFsQ2hpbGRyZW4pICsgYmFzZUxlbmd0aDsgLy8gMzAgaXMgdGhlIG1heCBsZW5ndGggd2UgY2FuIHN0b3JlIHdpdGhvdXQgb3ZlcmZsb3dpbmcsIHRha2luZyBpbnRvXG4gIC8vIGNvbnNpZGVyYXRpb24gdGhlIGxlYWRpbmcgMSB3ZSB1c2UgdG8gbWFyayB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZS5cblxuICBpZiAobGVuZ3RoID4gMzApIHtcbiAgICAvLyBXZSBvdmVyZmxvd2VkIHRoZSBiaXR3aXNlLXNhZmUgcmFuZ2UuIEZhbGwgYmFjayB0byBzbG93ZXIgYWxnb3JpdGhtLlxuICAgIC8vIFRoaXMgYnJhbmNoIGFzc3VtZXMgdGhlIGxlbmd0aCBvZiB0aGUgYmFzZSBpZCBpcyBncmVhdGVyIHRoYW4gNTsgaXQgd29uJ3RcbiAgICAvLyB3b3JrIGZvciBzbWFsbGVyIGlkcywgYmVjYXVzZSB5b3UgbmVlZCA1IGJpdHMgcGVyIGNoYXJhY3Rlci5cbiAgICAvL1xuICAgIC8vIFdlIGVuY29kZSB0aGUgaWQgaW4gbXVsdGlwbGUgc3RlcHM6IGZpcnN0IHRoZSBiYXNlIGlkLCB0aGVuIHRoZVxuICAgIC8vIHJlbWFpbmluZyBkaWdpdHMuXG4gICAgLy9cbiAgICAvLyBFYWNoIDUgYml0IHNlcXVlbmNlIGNvcnJlc3BvbmRzIHRvIGEgc2luZ2xlIGJhc2UgMzIgY2hhcmFjdGVyLiBTbyBmb3JcbiAgICAvLyBleGFtcGxlLCBpZiB0aGUgY3VycmVudCBpZCBpcyAyMyBiaXRzIGxvbmcsIHdlIGNhbiBjb252ZXJ0IDIwIG9mIHRob3NlXG4gICAgLy8gYml0cyBpbnRvIGEgc3RyaW5nIG9mIDQgY2hhcmFjdGVycywgd2l0aCAzIGJpdHMgbGVmdCBvdmVyLlxuICAgIC8vXG4gICAgLy8gRmlyc3QgY2FsY3VsYXRlIGhvdyBtYW55IGJpdHMgaW4gdGhlIGJhc2UgaWQgcmVwcmVzZW50IGEgY29tcGxldGVcbiAgICAvLyBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzLlxuICAgIHZhciBudW1iZXJPZk92ZXJmbG93Qml0cyA9IGJhc2VMZW5ndGggLSBiYXNlTGVuZ3RoICUgNTsgLy8gVGhlbiBjcmVhdGUgYSBiaXRtYXNrIHRoYXQgc2VsZWN0cyBvbmx5IHRob3NlIGJpdHMuXG5cbiAgICB2YXIgbmV3T3ZlcmZsb3dCaXRzID0gKDEgPDwgbnVtYmVyT2ZPdmVyZmxvd0JpdHMpIC0gMTsgLy8gU2VsZWN0IHRoZSBiaXRzLCBhbmQgY29udmVydCB0aGVtIHRvIGEgYmFzZSAzMiBzdHJpbmcuXG5cbiAgICB2YXIgbmV3T3ZlcmZsb3cgPSAoYmFzZUlkICYgbmV3T3ZlcmZsb3dCaXRzKS50b1N0cmluZygzMik7IC8vIE5vdyB3ZSBjYW4gcmVtb3ZlIHRob3NlIGJpdHMgZnJvbSB0aGUgYmFzZSBpZC5cblxuICAgIHZhciByZXN0T2ZCYXNlSWQgPSBiYXNlSWQgPj4gbnVtYmVyT2ZPdmVyZmxvd0JpdHM7XG4gICAgdmFyIHJlc3RPZkJhc2VMZW5ndGggPSBiYXNlTGVuZ3RoIC0gbnVtYmVyT2ZPdmVyZmxvd0JpdHM7IC8vIEZpbmFsbHksIGVuY29kZSB0aGUgcmVzdCBvZiB0aGUgYml0cyB1c2luZyB0aGUgbm9ybWFsIGFsZ29yaXRobS4gQmVjYXVzZVxuICAgIC8vIHdlIG1hZGUgbW9yZSByb29tLCB0aGlzIHRpbWUgaXQgd29uJ3Qgb3ZlcmZsb3cuXG5cbiAgICB2YXIgcmVzdE9mTGVuZ3RoID0gZ2V0Qml0TGVuZ3RoKHRvdGFsQ2hpbGRyZW4pICsgcmVzdE9mQmFzZUxlbmd0aDtcbiAgICB2YXIgcmVzdE9mTmV3Qml0cyA9IHNsb3QgPDwgcmVzdE9mQmFzZUxlbmd0aDtcbiAgICB2YXIgaWQgPSByZXN0T2ZOZXdCaXRzIHwgcmVzdE9mQmFzZUlkO1xuICAgIHZhciBvdmVyZmxvdyA9IG5ld092ZXJmbG93ICsgYmFzZU92ZXJmbG93O1xuICAgIHJldHVybiB7XG4gICAgICBpZDogMSA8PCByZXN0T2ZMZW5ndGggfCBpZCxcbiAgICAgIG92ZXJmbG93OiBvdmVyZmxvd1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gTm9ybWFsIHBhdGhcbiAgICB2YXIgbmV3Qml0cyA9IHNsb3QgPDwgYmFzZUxlbmd0aDtcblxuICAgIHZhciBfaWQgPSBuZXdCaXRzIHwgYmFzZUlkO1xuXG4gICAgdmFyIF9vdmVyZmxvdyA9IGJhc2VPdmVyZmxvdztcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IDEgPDwgbGVuZ3RoIHwgX2lkLFxuICAgICAgb3ZlcmZsb3c6IF9vdmVyZmxvd1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Qml0TGVuZ3RoKG51bWJlcikge1xuICByZXR1cm4gMzIgLSBjbHozMihudW1iZXIpO1xufVxuXG5mdW5jdGlvbiBnZXRMZWFkaW5nQml0KGlkKSB7XG4gIHJldHVybiAxIDw8IGdldEJpdExlbmd0aChpZCkgLSAxO1xufSAvLyBUT0RPOiBNYXRoLmNsejMyIGlzIHN1cHBvcnRlZCBpbiBOb2RlIDEyKy4gTWF5YmUgd2UgY2FuIGRyb3AgdGhlIGZhbGxiYWNrLlxuXG5cbnZhciBjbHozMiA9IE1hdGguY2x6MzIgPyBNYXRoLmNsejMyIDogY2x6MzJGYWxsYmFjazsgLy8gQ291bnQgbGVhZGluZyB6ZXJvcy5cbi8vIEJhc2VkIG9uOlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9jbHozMlxuXG52YXIgbG9nID0gTWF0aC5sb2c7XG52YXIgTE4yID0gTWF0aC5MTjI7XG5cbmZ1bmN0aW9uIGNsejMyRmFsbGJhY2soeCkge1xuICB2YXIgYXNVaW50ID0geCA+Pj4gMDtcblxuICBpZiAoYXNVaW50ID09PSAwKSB7XG4gICAgcmV0dXJuIDMyO1xuICB9XG5cbiAgcmV0dXJuIDMxIC0gKGxvZyhhc1VpbnQpIC8gTE4yIHwgMCkgfCAwO1xufVxuXG4vLyBDb3JyZXNwb25kcyB0byBSZWFjdEZpYmVyV2FrZWFibGUgYW5kIFJlYWN0RmxpZ2h0V2FrZWFibGUgbW9kdWxlcy4gR2VuZXJhbGx5LFxuLy8gY2hhbmdlcyB0byBvbmUgbW9kdWxlIHNob3VsZCBiZSByZWZsZWN0ZWQgaW4gdGhlIG90aGVycy5cbi8vIFRPRE86IFJlbmFtZSB0aGlzIG1vZHVsZSBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgRmliZXIgb25lIHRvIFwiVGhlbmFibGVcIlxuLy8gaW5zdGVhZCBvZiBcIldha2VhYmxlXCIuIE9yIHNvbWUgb3RoZXIgbW9yZSBhcHByb3ByaWF0ZSBuYW1lLlxuLy8gQW4gZXJyb3IgdGhhdCBpcyB0aHJvd24gKGUuZy4gYnkgYHVzZWApIHRvIHRyaWdnZXIgU3VzcGVuc2UuIElmIHdlXG4vLyBkZXRlY3QgdGhpcyBpcyBjYXVnaHQgYnkgdXNlcnNwYWNlLCB3ZSdsbCBsb2cgYSB3YXJuaW5nIGluIGRldmVsb3BtZW50LlxudmFyIFN1c3BlbnNlRXhjZXB0aW9uID0gbmV3IEVycm9yKFwiU3VzcGVuc2UgRXhjZXB0aW9uOiBUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IhIEl0J3MgYW4gaW1wbGVtZW50YXRpb24gXCIgKyAnZGV0YWlsIG9mIGB1c2VgIHRvIGludGVycnVwdCB0aGUgY3VycmVudCByZW5kZXIuIFlvdSBtdXN0IGVpdGhlciAnICsgJ3JldGhyb3cgaXQgaW1tZWRpYXRlbHksIG9yIG1vdmUgdGhlIGB1c2VgIGNhbGwgb3V0c2lkZSBvZiB0aGUgJyArICdgdHJ5L2NhdGNoYCBibG9jay4gQ2FwdHVyaW5nIHdpdGhvdXQgcmV0aHJvd2luZyB3aWxsIGxlYWQgdG8gJyArICd1bmV4cGVjdGVkIGJlaGF2aW9yLlxcblxcbicgKyAnVG8gaGFuZGxlIGFzeW5jIGVycm9ycywgd3JhcCB5b3VyIGNvbXBvbmVudCBpbiBhbiBlcnJvciBib3VuZGFyeSwgb3IgJyArIFwiY2FsbCB0aGUgcHJvbWlzZSdzIGAuY2F0Y2hgIG1ldGhvZCBhbmQgcGFzcyB0aGUgcmVzdWx0IHRvIGB1c2VgXCIpO1xuZnVuY3Rpb24gY3JlYXRlVGhlbmFibGVTdGF0ZSgpIHtcbiAgLy8gVGhlIFRoZW5hYmxlU3RhdGUgaXMgY3JlYXRlZCB0aGUgZmlyc3QgdGltZSBhIGNvbXBvbmVudCBzdXNwZW5kcy4gSWYgaXRcbiAgLy8gc3VzcGVuZHMgYWdhaW4sIHdlJ2xsIHJldXNlIHRoZSBzYW1lIHN0YXRlLlxuICByZXR1cm4gW107XG59XG5cbmZ1bmN0aW9uIG5vb3AkMigpIHt9XG5cbmZ1bmN0aW9uIHRyYWNrVXNlZFRoZW5hYmxlKHRoZW5hYmxlU3RhdGUsIHRoZW5hYmxlLCBpbmRleCkge1xuICB2YXIgcHJldmlvdXMgPSB0aGVuYWJsZVN0YXRlW2luZGV4XTtcblxuICBpZiAocHJldmlvdXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoZW5hYmxlU3RhdGUucHVzaCh0aGVuYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHByZXZpb3VzICE9PSB0aGVuYWJsZSkge1xuICAgICAgLy8gUmV1c2UgdGhlIHByZXZpb3VzIHRoZW5hYmxlLCBhbmQgZHJvcCB0aGUgbmV3IG9uZS4gV2UgY2FuIGFzc3VtZVxuICAgICAgLy8gdGhleSByZXByZXNlbnQgdGhlIHNhbWUgdmFsdWUsIGJlY2F1c2UgY29tcG9uZW50cyBhcmUgaWRlbXBvdGVudC5cbiAgICAgIC8vIEF2b2lkIGFuIHVuaGFuZGxlZCByZWplY3Rpb24gZXJyb3JzIGZvciB0aGUgUHJvbWlzZXMgdGhhdCB3ZSdsbFxuICAgICAgLy8gaW50ZW50aW9uYWxseSBpZ25vcmUuXG4gICAgICB0aGVuYWJsZS50aGVuKG5vb3AkMiwgbm9vcCQyKTtcbiAgICAgIHRoZW5hYmxlID0gcHJldmlvdXM7XG4gICAgfVxuICB9IC8vIFdlIHVzZSBhbiBleHBhbmRvIHRvIHRyYWNrIHRoZSBzdGF0dXMgYW5kIHJlc3VsdCBvZiBhIHRoZW5hYmxlIHNvIHRoYXQgd2VcbiAgLy8gY2FuIHN5bmNocm9ub3VzbHkgdW53cmFwIHRoZSB2YWx1ZS4gVGhpbmsgb2YgdGhpcyBhcyBhbiBleHRlbnNpb24gb2YgdGhlXG4gIC8vIFByb21pc2UgQVBJLCBvciBhIGN1c3RvbSBpbnRlcmZhY2UgdGhhdCBpcyBhIHN1cGVyc2V0IG9mIFRoZW5hYmxlLlxuICAvL1xuICAvLyBJZiB0aGUgdGhlbmFibGUgZG9lc24ndCBoYXZlIGEgc3RhdHVzLCBzZXQgaXQgdG8gXCJwZW5kaW5nXCIgYW5kIGF0dGFjaFxuICAvLyBhIGxpc3RlbmVyIHRoYXQgd2lsbCB1cGRhdGUgaXRzIHN0YXR1cyBhbmQgcmVzdWx0IHdoZW4gaXQgcmVzb2x2ZXMuXG5cblxuICBzd2l0Y2ggKHRoZW5hYmxlLnN0YXR1cykge1xuICAgIGNhc2UgJ2Z1bGZpbGxlZCc6XG4gICAgICB7XG4gICAgICAgIHZhciBmdWxmaWxsZWRWYWx1ZSA9IHRoZW5hYmxlLnZhbHVlO1xuICAgICAgICByZXR1cm4gZnVsZmlsbGVkVmFsdWU7XG4gICAgICB9XG5cbiAgICBjYXNlICdyZWplY3RlZCc6XG4gICAgICB7XG4gICAgICAgIHZhciByZWplY3RlZEVycm9yID0gdGhlbmFibGUucmVhc29uO1xuICAgICAgICB0aHJvdyByZWplY3RlZEVycm9yO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGVuYWJsZS5zdGF0dXMgPT09ICdzdHJpbmcnKSA7IGVsc2Uge1xuICAgICAgICAgIHZhciBwZW5kaW5nVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICBwZW5kaW5nVGhlbmFibGUuc3RhdHVzID0gJ3BlbmRpbmcnO1xuICAgICAgICAgIHBlbmRpbmdUaGVuYWJsZS50aGVuKGZ1bmN0aW9uIChmdWxmaWxsZWRWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoZW5hYmxlLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgICAgICAgIHZhciBmdWxmaWxsZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgICBmdWxmaWxsZWRUaGVuYWJsZS5zdGF0dXMgPSAnZnVsZmlsbGVkJztcbiAgICAgICAgICAgICAgZnVsZmlsbGVkVGhlbmFibGUudmFsdWUgPSBmdWxmaWxsZWRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICh0aGVuYWJsZS5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgICB2YXIgcmVqZWN0ZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgICByZWplY3RlZFRoZW5hYmxlLnN0YXR1cyA9ICdyZWplY3RlZCc7XG4gICAgICAgICAgICAgIHJlamVjdGVkVGhlbmFibGUucmVhc29uID0gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7IC8vIENoZWNrIG9uZSBtb3JlIHRpbWUgaW4gY2FzZSB0aGUgdGhlbmFibGUgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuXG4gICAgICAgICAgc3dpdGNoICh0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Z1bGZpbGxlZCc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgZnVsZmlsbGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVsZmlsbGVkVGhlbmFibGUudmFsdWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAncmVqZWN0ZWQnOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHJlamVjdGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgICAgICB0aHJvdyByZWplY3RlZFRoZW5hYmxlLnJlYXNvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBTdXNwZW5kLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaHJvd2luZyBoZXJlIGlzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCB0aGF0IGFsbG93cyB1cyB0byB1bndpbmQgdGhlXG4gICAgICAgIC8vIGNhbGwgc3RhY2suIEJ1dCB3ZSBzaG91bGRuJ3QgYWxsb3cgaXQgdG8gbGVhayBpbnRvIHVzZXJzcGFjZS4gVGhyb3cgYW5cbiAgICAgICAgLy8gb3BhcXVlIHBsYWNlaG9sZGVyIHZhbHVlIGluc3RlYWQgb2YgdGhlIGFjdHVhbCB0aGVuYWJsZS4gSWYgaXQgZG9lc24ndFxuICAgICAgICAvLyBnZXQgY2FwdHVyZWQgYnkgdGhlIHdvcmsgbG9vcCwgbG9nIGEgd2FybmluZywgYmVjYXVzZSB0aGF0IG1lYW5zXG4gICAgICAgIC8vIHNvbWV0aGluZyBpbiB1c2Vyc3BhY2UgbXVzdCBoYXZlIGNhdWdodCBpdC5cblxuXG4gICAgICAgIHN1c3BlbmRlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgIHRocm93IFN1c3BlbnNlRXhjZXB0aW9uO1xuICAgICAgfVxuICB9XG59IC8vIFRoaXMgaXMgdXNlZCB0byB0cmFjayB0aGUgYWN0dWFsIHRoZW5hYmxlIHRoYXQgc3VzcGVuZGVkIHNvIGl0IGNhbiBiZVxuLy8gcGFzc2VkIHRvIHRoZSByZXN0IG9mIHRoZSBTdXNwZW5zZSBpbXBsZW1lbnRhdGlvbiDigJQgd2hpY2gsIGZvciBoaXN0b3JpY2FsXG4vLyByZWFzb25zLCBleHBlY3RzIHRvIHJlY2VpdmUgYSB0aGVuYWJsZS5cblxudmFyIHN1c3BlbmRlZFRoZW5hYmxlID0gbnVsbDtcbmZ1bmN0aW9uIGdldFN1c3BlbmRlZFRoZW5hYmxlKCkge1xuICAvLyBUaGlzIGlzIGNhbGxlZCByaWdodCBhZnRlciBgdXNlYCBzdXNwZW5kcyBieSB0aHJvd2luZyBhbiBleGNlcHRpb24uIGB1c2VgXG4gIC8vIHRocm93cyBhbiBvcGFxdWUgdmFsdWUgaW5zdGVhZCBvZiB0aGUgdGhlbmFibGUgaXRzZWxmIHNvIHRoYXQgaXQgY2FuJ3QgYmVcbiAgLy8gY2F1Z2h0IGluIHVzZXJzcGFjZS4gVGhlbiB0aGUgd29yayBsb29wIGFjY2Vzc2VzIHRoZSBhY3R1YWwgdGhlbmFibGUgdXNpbmdcbiAgLy8gdGhpcyBmdW5jdGlvbi5cbiAgaWYgKHN1c3BlbmRlZFRoZW5hYmxlID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIHN1c3BlbmRlZCB0aGVuYWJsZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgJyArICdhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIHZhciB0aGVuYWJsZSA9IHN1c3BlbmRlZFRoZW5hYmxlO1xuICBzdXNwZW5kZWRUaGVuYWJsZSA9IG51bGw7XG4gIHJldHVybiB0aGVuYWJsZTtcbn1cblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICByZXR1cm4geCA9PT0geSAmJiAoeCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkpIHx8IHggIT09IHggJiYgeSAhPT0geSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICA7XG59XG5cbnZhciBvYmplY3RJcyA9IC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbnR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBpcztcblxudmFyIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IG51bGw7XG52YXIgY3VycmVudGx5UmVuZGVyaW5nVGFzayA9IG51bGw7XG52YXIgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xudmFyIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7IC8vIFdoZXRoZXIgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgaG9vayBpcyBhIHJlLXJlbmRlcmVkIGhvb2tcblxudmFyIGlzUmVSZW5kZXIgPSBmYWxzZTsgLy8gV2hldGhlciBhbiB1cGRhdGUgd2FzIHNjaGVkdWxlZCBkdXJpbmcgdGhlIGN1cnJlbnRseSBleGVjdXRpbmcgcmVuZGVyIHBhc3MuXG5cbnZhciBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7IC8vIENvdW50cyB0aGUgbnVtYmVyIG9mIHVzZUlkIGhvb2tzIGluIHRoaXMgY29tcG9uZW50XG5cbnZhciBsb2NhbElkQ291bnRlciA9IDA7IC8vIENvdW50cyB0aGUgbnVtYmVyIG9mIHVzZSh0aGVuYWJsZSkgY2FsbHMgaW4gdGhpcyBjb21wb25lbnRcblxudmFyIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMDtcbnZhciB0aGVuYWJsZVN0YXRlID0gbnVsbDsgLy8gTGF6aWx5IGNyZWF0ZWQgbWFwIG9mIHJlbmRlci1waGFzZSB1cGRhdGVzXG5cbnZhciByZW5kZXJQaGFzZVVwZGF0ZXMgPSBudWxsOyAvLyBDb3VudGVyIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMuXG5cbnZhciBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG52YXIgUkVfUkVOREVSX0xJTUlUID0gMjU7XG52YXIgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7IC8vIEluIERFViwgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyBwcmltaXRpdmUgaG9va1xuXG52YXIgY3VycmVudEhvb2tOYW1lSW5EZXY7XG5cbmZ1bmN0aW9uIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKSB7XG4gIGlmIChjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3InICsgJyBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbicgKyAnMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuJyArICcyLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuJyArICczLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS4nKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAoaXNJbkhvb2tVc2VyQ29kZUluRGV2KSB7XG4gICAgICBlcnJvcignRG8gbm90IGNhbGwgSG9va3MgaW5zaWRlIHVzZUVmZmVjdCguLi4pLCB1c2VNZW1vKC4uLiksIG9yIG90aGVyIGJ1aWx0LWluIEhvb2tzLiAnICsgJ1lvdSBjYW4gb25seSBjYWxsIEhvb2tzIGF0IHRoZSB0b3AgbGV2ZWwgb2YgeW91ciBSZWFjdCBmdW5jdGlvbi4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3J1bGVzLW9mLWhvb2tzJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudDtcbn1cblxuZnVuY3Rpb24gYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykge1xuICBpZiAocHJldkRlcHMgPT09IG51bGwpIHtcbiAgICB7XG4gICAgICBlcnJvcignJXMgcmVjZWl2ZWQgYSBmaW5hbCBhcmd1bWVudCBkdXJpbmcgdGhpcyByZW5kZXIsIGJ1dCBub3QgZHVyaW5nICcgKyAndGhlIHByZXZpb3VzIHJlbmRlci4gRXZlbiB0aG91Z2ggdGhlIGZpbmFsIGFyZ3VtZW50IGlzIG9wdGlvbmFsLCAnICsgJ2l0cyB0eXBlIGNhbm5vdCBjaGFuZ2UgYmV0d2VlbiByZW5kZXJzLicsIGN1cnJlbnRIb29rTmFtZUluRGV2KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB7XG4gICAgLy8gRG9uJ3QgYm90aGVyIGNvbXBhcmluZyBsZW5ndGhzIGluIHByb2QgYmVjYXVzZSB0aGVzZSBhcnJheXMgc2hvdWxkIGJlXG4gICAgLy8gcGFzc2VkIGlubGluZS5cbiAgICBpZiAobmV4dERlcHMubGVuZ3RoICE9PSBwcmV2RGVwcy5sZW5ndGgpIHtcbiAgICAgIGVycm9yKCdUaGUgZmluYWwgYXJndW1lbnQgcGFzc2VkIHRvICVzIGNoYW5nZWQgc2l6ZSBiZXR3ZWVuIHJlbmRlcnMuIFRoZSAnICsgJ29yZGVyIGFuZCBzaXplIG9mIHRoaXMgYXJyYXkgbXVzdCByZW1haW4gY29uc3RhbnQuXFxuXFxuJyArICdQcmV2aW91czogJXNcXG4nICsgJ0luY29taW5nOiAlcycsIGN1cnJlbnRIb29rTmFtZUluRGV2LCBcIltcIiArIG5leHREZXBzLmpvaW4oJywgJykgKyBcIl1cIiwgXCJbXCIgKyBwcmV2RGVwcy5qb2luKCcsICcpICsgXCJdXCIpO1xuICAgIH1cbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJldkRlcHMubGVuZ3RoICYmIGkgPCBuZXh0RGVwcy5sZW5ndGg7IGkrKykge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgIGlmIChvYmplY3RJcyhuZXh0RGVwc1tpXSwgcHJldkRlcHNbaV0pKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSG9vaygpIHtcbiAgaWYgKG51bWJlck9mUmVSZW5kZXJzID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVuZGVyZWQgbW9yZSBob29rcyB0aGFuIGR1cmluZyB0aGUgcHJldmlvdXMgcmVuZGVyJyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1lbW9pemVkU3RhdGU6IG51bGwsXG4gICAgcXVldWU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSB7XG4gIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBob29rIGluIHRoZSBsaXN0XG4gICAgaWYgKGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgICBpc1JlUmVuZGVyID0gZmFsc2U7XG4gICAgICBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZUhvb2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUncyBhbHJlYWR5IGEgd29yay1pbi1wcm9ncmVzcy4gUmV1c2UgaXQuXG4gICAgICBpc1JlUmVuZGVyID0gdHJ1ZTtcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPT09IG51bGwpIHtcbiAgICAgIGlzUmVSZW5kZXIgPSBmYWxzZTsgLy8gQXBwZW5kIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3RcblxuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPSBjcmVhdGVIb29rKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXJlJ3MgYWxyZWFkeSBhIHdvcmstaW4tcHJvZ3Jlc3MuIFJldXNlIGl0LlxuICAgICAgaXNSZVJlbmRlciA9IHRydWU7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlVG9Vc2VIb29rcyh0YXNrLCBjb21wb25lbnRJZGVudGl0eSwgcHJldlRoZW5hYmxlU3RhdGUpIHtcbiAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gY29tcG9uZW50SWRlbnRpdHk7XG4gIGN1cnJlbnRseVJlbmRlcmluZ1Rhc2sgPSB0YXNrO1xuXG4gIHtcbiAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTtcbiAgfSAvLyBUaGUgZm9sbG93aW5nIHNob3VsZCBoYXZlIGFscmVhZHkgYmVlbiByZXNldFxuICAvLyBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gIC8vIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgLy8gbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xuICAvLyByZW5kZXJQaGFzZVVwZGF0ZXMgPSBudWxsO1xuICAvLyB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuXG5cbiAgbG9jYWxJZENvdW50ZXIgPSAwO1xuICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDA7XG4gIHRoZW5hYmxlU3RhdGUgPSBwcmV2VGhlbmFibGVTdGF0ZTtcbn1cbmZ1bmN0aW9uIGZpbmlzaEhvb2tzKENvbXBvbmVudCwgcHJvcHMsIGNoaWxkcmVuLCByZWZPckNvbnRleHQpIHtcbiAgLy8gVGhpcyBtdXN0IGJlIGNhbGxlZCBhZnRlciBldmVyeSBmdW5jdGlvbiBjb21wb25lbnQgdG8gcHJldmVudCBob29rcyBmcm9tXG4gIC8vIGJlaW5nIHVzZWQgaW4gY2xhc3Nlcy5cbiAgd2hpbGUgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUpIHtcbiAgICAvLyBVcGRhdGVzIHdlcmUgc2NoZWR1bGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLiBUaGV5IGFyZSBzdG9yZWQgaW5cbiAgICAvLyB0aGUgYHJlbmRlclBoYXNlVXBkYXRlc2AgbWFwLiBDYWxsIHRoZSBjb21wb25lbnQgYWdhaW4sIHJldXNpbmcgdGhlXG4gICAgLy8gd29yay1pbi1wcm9ncmVzcyBob29rcyBhbmQgYXBwbHlpbmcgdGhlIGFkZGl0aW9uYWwgdXBkYXRlcyBvbiB0b3AuIEtlZXBcbiAgICAvLyByZXN0YXJ0aW5nIHVudGlsIG5vIG1vcmUgdXBkYXRlcyBhcmUgc2NoZWR1bGVkLlxuICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcbiAgICBsb2NhbElkQ291bnRlciA9IDA7XG4gICAgdGhlbmFibGVJbmRleENvdW50ZXIgPSAwO1xuICAgIG51bWJlck9mUmVSZW5kZXJzICs9IDE7IC8vIFN0YXJ0IG92ZXIgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0XG5cbiAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICAgIGNoaWxkcmVuID0gQ29tcG9uZW50KHByb3BzLCByZWZPckNvbnRleHQpO1xuICB9XG5cbiAgcmVzZXRIb29rc1N0YXRlKCk7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cbmZ1bmN0aW9uIGdldFRoZW5hYmxlU3RhdGVBZnRlclN1c3BlbmRpbmcoKSB7XG4gIHZhciBzdGF0ZSA9IHRoZW5hYmxlU3RhdGU7XG4gIHRoZW5hYmxlU3RhdGUgPSBudWxsO1xuICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiBjaGVja0RpZFJlbmRlcklkSG9vaygpIHtcbiAgLy8gVGhpcyBzaG91bGQgYmUgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIGV2ZXJ5IGZpbmlzaEhvb2tzIGNhbGwuXG4gIC8vIENvbmNlcHR1YWxseSwgaXQncyBwYXJ0IG9mIHRoZSByZXR1cm4gdmFsdWUgb2YgZmluaXNoSG9va3M7IGl0J3Mgb25seSBhXG4gIC8vIHNlcGFyYXRlIGZ1bmN0aW9uIHRvIGF2b2lkIHVzaW5nIGFuIGFycmF5IHR1cGxlLlxuICB2YXIgZGlkUmVuZGVySWRIb29rID0gbG9jYWxJZENvdW50ZXIgIT09IDA7XG4gIHJldHVybiBkaWRSZW5kZXJJZEhvb2s7XG59IC8vIFJlc2V0IHRoZSBpbnRlcm5hbCBob29rcyBzdGF0ZSBpZiBhbiBlcnJvciBvY2N1cnMgd2hpbGUgcmVuZGVyaW5nIGEgY29tcG9uZW50XG5cbmZ1bmN0aW9uIHJlc2V0SG9va3NTdGF0ZSgpIHtcbiAge1xuICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlO1xuICB9XG5cbiAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gbnVsbDtcbiAgY3VycmVudGx5UmVuZGVyaW5nVGFzayA9IG51bGw7XG4gIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcbiAgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG4gIHJlbmRlclBoYXNlVXBkYXRlcyA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlYWRDb250ZXh0KGNvbnRleHQpIHtcbiAge1xuICAgIGlmIChpc0luSG9va1VzZXJDb2RlSW5EZXYpIHtcbiAgICAgIGVycm9yKCdDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiAnICsgJ0luIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuICcgKyAnSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90ICcgKyAnaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZENvbnRleHQkMShjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gdXNlQ29udGV4dChjb250ZXh0KSB7XG4gIHtcbiAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgfVxuXG4gIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgcmV0dXJuIHJlYWRDb250ZXh0JDEoY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIGJhc2ljU3RhdGVSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXTogRmxvdyBkb2Vzbid0IGxpa2UgbWl4ZWQgdHlwZXNcbiAgcmV0dXJuIHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicgPyBhY3Rpb24oc3RhdGUpIDogYWN0aW9uO1xufVxuXG5mdW5jdGlvbiB1c2VTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAge1xuICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgfVxuXG4gIHJldHVybiB1c2VSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyLCAvLyB1c2VSZWR1Y2VyIGhhcyBhIHNwZWNpYWwgY2FzZSB0byBzdXBwb3J0IGxhenkgdXNlU3RhdGUgaW5pdGlhbGl6ZXJzXG4gIGluaXRpYWxTdGF0ZSk7XG59XG5mdW5jdGlvbiB1c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAge1xuICAgIGlmIChyZWR1Y2VyICE9PSBiYXNpY1N0YXRlUmVkdWNlcikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgfVxuICB9XG5cbiAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcblxuICBpZiAoaXNSZVJlbmRlcikge1xuICAgIC8vIFRoaXMgaXMgYSByZS1yZW5kZXIuIEFwcGx5IHRoZSBuZXcgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgdG8gdGhlIHByZXZpb3VzXG4gICAgLy8gY3VycmVudCBob29rLlxuICAgIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzSG9vay5xdWV1ZTtcbiAgICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaDtcblxuICAgIGlmIChyZW5kZXJQaGFzZVVwZGF0ZXMgIT09IG51bGwpIHtcbiAgICAgIC8vIFJlbmRlciBwaGFzZSB1cGRhdGVzIGFyZSBzdG9yZWQgaW4gYSBtYXAgb2YgcXVldWUgLT4gbGlua2VkIGxpc3RcbiAgICAgIHZhciBmaXJzdFJlbmRlclBoYXNlVXBkYXRlID0gcmVuZGVyUGhhc2VVcGRhdGVzLmdldChxdWV1ZSk7XG5cbiAgICAgIGlmIChmaXJzdFJlbmRlclBoYXNlVXBkYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgIHJlbmRlclBoYXNlVXBkYXRlcy5kZWxldGUocXVldWUpOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuICAgICAgICB2YXIgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgdmFyIHVwZGF0ZSA9IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGU7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8vIFByb2Nlc3MgdGhpcyByZW5kZXIgcGhhc2UgdXBkYXRlLiBXZSBkb24ndCBoYXZlIHRvIGNoZWNrIHRoZVxuICAgICAgICAgIC8vIHByaW9yaXR5IGJlY2F1c2UgaXQgd2lsbCBhbHdheXMgYmUgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnRcbiAgICAgICAgICAvLyByZW5kZXIncy5cbiAgICAgICAgICB2YXIgYWN0aW9uID0gdXBkYXRlLmFjdGlvbjtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV3U3RhdGUgPSByZWR1Y2VyKG5ld1N0YXRlLCBhY3Rpb24pO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gICAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSB3ZSBiYWlsIG91dCB3aGVuIHdlIGdldCBhIG51bGxcblxuXG4gICAgICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKHVwZGF0ZSAhPT0gbnVsbCk7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgcmV0dXJuIFtuZXdTdGF0ZSwgZGlzcGF0Y2hdO1xuICAgICAgfVxuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgIHJldHVybiBbd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpbml0aWFsU3RhdGU7XG5cbiAgICBpZiAocmVkdWNlciA9PT0gYmFzaWNTdGF0ZVJlZHVjZXIpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYHVzZVN0YXRlYC5cbiAgICAgIGluaXRpYWxTdGF0ZSA9IHR5cGVvZiBpbml0aWFsQXJnID09PSAnZnVuY3Rpb24nID8gaW5pdGlhbEFyZygpIDogaW5pdGlhbEFyZztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdGlhbFN0YXRlID0gaW5pdCAhPT0gdW5kZWZpbmVkID8gaW5pdChpbml0aWFsQXJnKSA6IGluaXRpYWxBcmc7XG4gICAgfVxuXG4gICAge1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSBpbml0aWFsU3RhdGU7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG4gICAgdmFyIF9xdWV1ZSA9IHdvcmtJblByb2dyZXNzSG9vay5xdWV1ZSA9IHtcbiAgICAgIGxhc3Q6IG51bGwsXG4gICAgICBkaXNwYXRjaDogbnVsbFxuICAgIH07XG5cbiAgICB2YXIgX2Rpc3BhdGNoID0gX3F1ZXVlLmRpc3BhdGNoID0gZGlzcGF0Y2hBY3Rpb24uYmluZChudWxsLCBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQsIF9xdWV1ZSk7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICByZXR1cm4gW3dvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLCBfZGlzcGF0Y2hdO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVzZU1lbW8obmV4dENyZWF0ZSwgZGVwcykge1xuICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcblxuICBpZiAod29ya0luUHJvZ3Jlc3NIb29rICE9PSBudWxsKSB7XG4gICAgdmFyIHByZXZTdGF0ZSA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuXG4gICAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5leHREZXBzICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBwcmV2RGVwcyA9IHByZXZTdGF0ZVsxXTtcblxuICAgICAgICBpZiAoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykpIHtcbiAgICAgICAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IHRydWU7XG4gIH1cblxuICB2YXIgbmV4dFZhbHVlID0gbmV4dENyZWF0ZSgpO1xuXG4gIHtcbiAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTtcbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gW25leHRWYWx1ZSwgbmV4dERlcHNdO1xuICByZXR1cm4gbmV4dFZhbHVlO1xufVxuXG5mdW5jdGlvbiB1c2VSZWYoaW5pdGlhbFZhbHVlKSB7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBwcmV2aW91c1JlZiA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChwcmV2aW91c1JlZiA9PT0gbnVsbCkge1xuICAgIHZhciByZWYgPSB7XG4gICAgICBjdXJyZW50OiBpbml0aWFsVmFsdWVcbiAgICB9O1xuXG4gICAge1xuICAgICAgT2JqZWN0LnNlYWwocmVmKTtcbiAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IHJlZjtcbiAgICByZXR1cm4gcmVmO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcmV2aW91c1JlZjtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEFjdGlvbihjb21wb25lbnRJZGVudGl0eSwgcXVldWUsIGFjdGlvbikge1xuICBpZiAobnVtYmVyT2ZSZVJlbmRlcnMgPj0gUkVfUkVOREVSX0xJTUlUKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUb28gbWFueSByZS1yZW5kZXJzLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiByZW5kZXJzIHRvIHByZXZlbnQgJyArICdhbiBpbmZpbml0ZSBsb29wLicpO1xuICB9XG5cbiAgaWYgKGNvbXBvbmVudElkZW50aXR5ID09PSBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQpIHtcbiAgICAvLyBUaGlzIGlzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gU3Rhc2ggaXQgaW4gYSBsYXppbHktY3JlYXRlZCBtYXAgb2ZcbiAgICAvLyBxdWV1ZSAtPiBsaW5rZWQgbGlzdCBvZiB1cGRhdGVzLiBBZnRlciB0aGlzIHJlbmRlciBwYXNzLCB3ZSdsbCByZXN0YXJ0XG4gICAgLy8gYW5kIGFwcGx5IHRoZSBzdGFzaGVkIHVwZGF0ZXMgb24gdG9wIG9mIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2suXG4gICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IHRydWU7XG4gICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAocmVuZGVyUGhhc2VVcGRhdGVzID09PSBudWxsKSB7XG4gICAgICByZW5kZXJQaGFzZVVwZGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPSByZW5kZXJQaGFzZVVwZGF0ZXMuZ2V0KHF1ZXVlKTtcblxuICAgIGlmIChmaXJzdFJlbmRlclBoYXNlVXBkYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgcmVuZGVyUGhhc2VVcGRhdGVzLnNldChxdWV1ZSwgdXBkYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXBwZW5kIHRoZSB1cGRhdGUgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cbiAgICAgIHZhciBsYXN0UmVuZGVyUGhhc2VVcGRhdGUgPSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlO1xuXG4gICAgICB3aGlsZSAobGFzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgbGFzdFJlbmRlclBoYXNlVXBkYXRlID0gbGFzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQ7XG4gICAgICB9XG5cbiAgICAgIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0ID0gdXBkYXRlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICByZXR1cm4gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrO1xuICB9LCBkZXBzKTtcbn1cblxuZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgaWYgKGdldFNlcnZlclNuYXBzaG90ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZ2V0U2VydmVyU25hcHNob3QsIHdoaWNoIGlzIHJlcXVpcmVkIGZvciAnICsgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBXaWxsIHJldmVydCB0byBjbGllbnQgcmVuZGVyaW5nLicpO1xuICB9XG5cbiAgcmV0dXJuIGdldFNlcnZlclNuYXBzaG90KCk7XG59XG5cbmZ1bmN0aW9uIHVzZURlZmVycmVkVmFsdWUodmFsdWUpIHtcbiAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVuc3VwcG9ydGVkU3RhcnRUcmFuc2l0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0VHJhbnNpdGlvbiBjYW5ub3QgYmUgY2FsbGVkIGR1cmluZyBzZXJ2ZXIgcmVuZGVyaW5nLicpO1xufVxuXG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uKCkge1xuICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHJldHVybiBbZmFsc2UsIHVuc3VwcG9ydGVkU3RhcnRUcmFuc2l0aW9uXTtcbn1cblxuZnVuY3Rpb24gdXNlSWQoKSB7XG4gIHZhciB0YXNrID0gY3VycmVudGx5UmVuZGVyaW5nVGFzaztcbiAgdmFyIHRyZWVJZCA9IGdldFRyZWVJZCh0YXNrLnRyZWVDb250ZXh0KTtcbiAgdmFyIHJlc3BvbnNlU3RhdGUgPSBjdXJyZW50UmVzcG9uc2VTdGF0ZTtcblxuICBpZiAocmVzcG9uc2VTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuJyk7XG4gIH1cblxuICB2YXIgbG9jYWxJZCA9IGxvY2FsSWRDb3VudGVyKys7XG4gIHJldHVybiBtYWtlSWQocmVzcG9uc2VTdGF0ZSwgdHJlZUlkLCBsb2NhbElkKTtcbn1cblxuZnVuY3Rpb24gdXNlKHVzYWJsZSkge1xuICBpZiAodXNhYmxlICE9PSBudWxsICYmIHR5cGVvZiB1c2FibGUgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICAgIGlmICh0eXBlb2YgdXNhYmxlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB0aGVuYWJsZS5cbiAgICAgIHZhciB0aGVuYWJsZSA9IHVzYWJsZTtcbiAgICAgIHJldHVybiB1bndyYXBUaGVuYWJsZSh0aGVuYWJsZSk7XG4gICAgfSBlbHNlIGlmICh1c2FibGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB1c2FibGUuJCR0eXBlb2YgPT09IFJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEUpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdXNhYmxlO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH1cbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gIHRocm93IG5ldyBFcnJvcignQW4gdW5zdXBwb3J0ZWQgdHlwZSB3YXMgcGFzc2VkIHRvIHVzZSgpOiAnICsgU3RyaW5nKHVzYWJsZSkpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBUaGVuYWJsZSh0aGVuYWJsZSkge1xuICB2YXIgaW5kZXggPSB0aGVuYWJsZUluZGV4Q291bnRlcjtcbiAgdGhlbmFibGVJbmRleENvdW50ZXIgKz0gMTtcblxuICBpZiAodGhlbmFibGVTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHRoZW5hYmxlU3RhdGUgPSBjcmVhdGVUaGVuYWJsZVN0YXRlKCk7XG4gIH1cblxuICByZXR1cm4gdHJhY2tVc2VkVGhlbmFibGUodGhlbmFibGVTdGF0ZSwgdGhlbmFibGUsIGluZGV4KTtcbn1cblxuZnVuY3Rpb24gdW5zdXBwb3J0ZWRSZWZyZXNoKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NhY2hlIGNhbm5vdCBiZSByZWZyZXNoZWQgZHVyaW5nIHNlcnZlciByZW5kZXJpbmcuJyk7XG59XG5cbmZ1bmN0aW9uIHVzZUNhY2hlUmVmcmVzaCgpIHtcbiAgcmV0dXJuIHVuc3VwcG9ydGVkUmVmcmVzaDtcbn1cblxuZnVuY3Rpb24gbm9vcCQxKCkge31cblxudmFyIEhvb2tzRGlzcGF0Y2hlciA9IHtcbiAgcmVhZENvbnRleHQ6IHJlYWRDb250ZXh0LFxuICB1c2U6IHVzZSxcbiAgdXNlQ29udGV4dDogdXNlQ29udGV4dCxcbiAgdXNlTWVtbzogdXNlTWVtbyxcbiAgdXNlUmVkdWNlcjogdXNlUmVkdWNlcixcbiAgdXNlUmVmOiB1c2VSZWYsXG4gIHVzZVN0YXRlOiB1c2VTdGF0ZSxcbiAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBub29wJDEsXG4gIHVzZUxheW91dEVmZmVjdDogbm9vcCQxLFxuICB1c2VDYWxsYmFjazogdXNlQ2FsbGJhY2ssXG4gIC8vIHVzZUltcGVyYXRpdmVIYW5kbGUgaXMgbm90IHJ1biBpbiB0aGUgc2VydmVyIGVudmlyb25tZW50XG4gIHVzZUltcGVyYXRpdmVIYW5kbGU6IG5vb3AkMSxcbiAgLy8gRWZmZWN0cyBhcmUgbm90IHJ1biBpbiB0aGUgc2VydmVyIGVudmlyb25tZW50LlxuICB1c2VFZmZlY3Q6IG5vb3AkMSxcbiAgLy8gRGVidWdnaW5nIGVmZmVjdFxuICB1c2VEZWJ1Z1ZhbHVlOiBub29wJDEsXG4gIHVzZURlZmVycmVkVmFsdWU6IHVzZURlZmVycmVkVmFsdWUsXG4gIHVzZVRyYW5zaXRpb246IHVzZVRyYW5zaXRpb24sXG4gIHVzZUlkOiB1c2VJZCxcbiAgLy8gU3Vic2NyaXB0aW9ucyBhcmUgbm90IHNldHVwIGluIGEgc2VydmVyIGVudmlyb25tZW50LlxuICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogdXNlU3luY0V4dGVybmFsU3RvcmVcbn07XG5cbntcbiAgSG9va3NEaXNwYXRjaGVyLnVzZUNhY2hlUmVmcmVzaCA9IHVzZUNhY2hlUmVmcmVzaDtcbn1cblxudmFyIGN1cnJlbnRSZXNwb25zZVN0YXRlID0gbnVsbDtcbmZ1bmN0aW9uIHNldEN1cnJlbnRSZXNwb25zZVN0YXRlKHJlc3BvbnNlU3RhdGUpIHtcbiAgY3VycmVudFJlc3BvbnNlU3RhdGUgPSByZXNwb25zZVN0YXRlO1xufVxuXG5mdW5jdGlvbiBnZXRDYWNoZVNpZ25hbCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQuJyk7XG59XG5cbmZ1bmN0aW9uIGdldENhY2hlRm9yVHlwZShyZXNvdXJjZVR5cGUpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQuJyk7XG59XG5cbnZhciBEZWZhdWx0Q2FjaGVEaXNwYXRjaGVyID0ge1xuICBnZXRDYWNoZVNpZ25hbDogZ2V0Q2FjaGVTaWduYWwsXG4gIGdldENhY2hlRm9yVHlwZTogZ2V0Q2FjaGVGb3JUeXBlXG59O1xuXG5mdW5jdGlvbiBnZXRTdGFja0J5Q29tcG9uZW50U3RhY2tOb2RlKGNvbXBvbmVudFN0YWNrKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICB2YXIgbm9kZSA9IGNvbXBvbmVudFN0YWNrO1xuXG4gICAgZG8ge1xuICAgICAgc3dpdGNoIChub2RlLnRhZykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgaW5mbyArPSBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShub2RlLnR5cGUsIG51bGwsIG51bGwpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpbmZvICs9IGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShub2RlLnR5cGUsIG51bGwsIG51bGwpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBpbmZvICs9IGRlc2NyaWJlQ2xhc3NDb21wb25lbnRGcmFtZShub2RlLnR5cGUsIG51bGwsIG51bGwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSB3ZSBiYWlsIG91dCB3aGVuIHdlIGdldCBhIG51bGxcblxuXG4gICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgfSB3aGlsZSAobm9kZSk7XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfSBjYXRjaCAoeCkge1xuICAgIHJldHVybiAnXFxuRXJyb3IgZ2VuZXJhdGluZyBzdGFjazogJyArIHgubWVzc2FnZSArICdcXG4nICsgeC5zdGFjaztcbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgUmVhY3RDdXJyZW50Q2FjaGUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRDYWNoZTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBQRU5ESU5HID0gMDtcbnZhciBDT01QTEVURUQgPSAxO1xudmFyIEZMVVNIRUQgPSAyO1xudmFyIEFCT1JURUQgPSAzO1xudmFyIEVSUk9SRUQgPSA0O1xudmFyIE9QRU4gPSAwO1xudmFyIENMT1NJTkcgPSAxO1xudmFyIENMT1NFRCA9IDI7IC8vIFRoaXMgaXMgYSBkZWZhdWx0IGhldXJpc3RpYyBmb3IgaG93IHRvIHNwbGl0IHVwIHRoZSBIVE1MIGNvbnRlbnQgaW50byBwcm9ncmVzc2l2ZVxuLy8gbG9hZGluZy4gT3VyIGdvYWwgaXMgdG8gYmUgYWJsZSB0byBkaXNwbGF5IGFkZGl0aW9uYWwgbmV3IGNvbnRlbnQgYWJvdXQgZXZlcnkgNTAwbXMuXG4vLyBGYXN0ZXIgdGhhbiB0aGF0IGlzIHVubmVjZXNzYXJ5IGFuZCBzaG91bGQgYmUgdGhyb3R0bGVkIG9uIHRoZSBjbGllbnQuIEl0IGFsc29cbi8vIGFkZHMgdW5uZWNlc3Nhcnkgb3ZlcmhlYWQgdG8gZG8gbW9yZSBzcGxpdHMuIFdlIGRvbid0IGtub3cgaWYgaXQncyBhIGhpZ2hlciBvciBsb3dlclxuLy8gZW5kIGRldmljZSBidXQgaGlnaGVyIGVuZCBzdWZmZXIgbGVzcyBmcm9tIHRoZSBvdmVyaGVhZCB0aGFuIGxvd2VyIGVuZCBkb2VzIGZyb21cbi8vIG5vdCBnZXR0aW5nIHNtYWxsIGVub3VnaCBwaWVjZXMuIFdlIGVycm9yIG9uIHRoZSBzaWRlIG9mIGxvdyBlbmQuXG4vLyBXZSBiYXNlIHRoaXMgb24gbG93IGVuZCAzRyBzcGVlZHMgd2hpY2ggaXMgYWJvdXQgNTAwa2JpdHMgcGVyIHNlY29uZC4gV2UgYXNzdW1lXG4vLyB0aGF0IHRoZXJlIGNhbiBiZSBhIHJlYXNvbmFibGUgZHJvcCBvZmYgZnJvbSBtYXggYmFuZHdpZHRoIHdoaWNoIGxlYXZlcyB5b3Ugd2l0aFxuLy8gYXMgbGl0dGxlIGFzIDgwJS4gV2UgY2FuIHJlY2VpdmUgaGFsZiBvZiB0aGF0IGVhY2ggNTAwbXMgLSBhdCBiZXN0LiBJbiBwcmFjdGljZSxcbi8vIGEgbGl0dGxlIGJhbmR3aWR0aCBpcyBsb3N0IHRvIHByb2Nlc3NpbmcgYW5kIGNvbnRlbnRpb24gLSBlLmcuIENTUyBhbmQgaW1hZ2VzIHRoYXRcbi8vIGFyZSBkb3dubG9hZGVkIGFsb25nIHdpdGggdGhlIG1haW4gY29udGVudC4gU28gd2UgZXN0aW1hdGUgYWJvdXQgaGFsZiBvZiB0aGF0IHRvIGJlXG4vLyB0aGUgbG93ZXIgZW5kIHRocm91Z2hwdXQuIEluIG90aGVyIHdvcmRzLCB3ZSBleHBlY3QgdGhhdCB5b3UgY2FuIGF0IGxlYXN0IHNob3dcbi8vIGFib3V0IDEyLjVrYiBvZiBjb250ZW50IHBlciA1MDBtcy4gTm90IGNvdW50aW5nIHN0YXJ0aW5nIGxhdGVuY3kgZm9yIHRoZSBmaXJzdFxuLy8gcGFpbnQuXG4vLyA1MDAgKiAxMDI0IC8gOCAqIC44ICogMC41IC8gMlxuXG52YXIgREVGQVVMVF9QUk9HUkVTU0lWRV9DSFVOS19TSVpFID0gMTI4MDA7XG5cbmZ1bmN0aW9uIGRlZmF1bHRFcnJvckhhbmRsZXIoZXJyb3IpIHtcbiAgY29uc29sZVsnZXJyb3InXShlcnJvcik7IC8vIERvbid0IHRyYW5zZm9ybSB0byBvdXIgd3JhcHBlclxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gY3JlYXRlUmVxdWVzdChjaGlsZHJlbiwgcmVzb3VyY2VzLCByZXNwb25zZVN0YXRlLCByb290Rm9ybWF0Q29udGV4dCwgcHJvZ3Jlc3NpdmVDaHVua1NpemUsIG9uRXJyb3IsIG9uQWxsUmVhZHksIG9uU2hlbGxSZWFkeSwgb25TaGVsbEVycm9yLCBvbkZhdGFsRXJyb3IpIHtcbiAgcHJlcGFyZUhvc3REaXNwYXRjaGVyKCk7XG4gIHZhciBwaW5nZWRUYXNrcyA9IFtdO1xuICB2YXIgYWJvcnRTZXQgPSBuZXcgU2V0KCk7XG4gIHZhciByZXF1ZXN0ID0ge1xuICAgIGRlc3RpbmF0aW9uOiBudWxsLFxuICAgIGZsdXNoU2NoZWR1bGVkOiBmYWxzZSxcbiAgICByZXNwb25zZVN0YXRlOiByZXNwb25zZVN0YXRlLFxuICAgIHByb2dyZXNzaXZlQ2h1bmtTaXplOiBwcm9ncmVzc2l2ZUNodW5rU2l6ZSA9PT0gdW5kZWZpbmVkID8gREVGQVVMVF9QUk9HUkVTU0lWRV9DSFVOS19TSVpFIDogcHJvZ3Jlc3NpdmVDaHVua1NpemUsXG4gICAgc3RhdHVzOiBPUEVOLFxuICAgIGZhdGFsRXJyb3I6IG51bGwsXG4gICAgbmV4dFNlZ21lbnRJZDogMCxcbiAgICBhbGxQZW5kaW5nVGFza3M6IDAsXG4gICAgcGVuZGluZ1Jvb3RUYXNrczogMCxcbiAgICByZXNvdXJjZXM6IHJlc291cmNlcyxcbiAgICBjb21wbGV0ZWRSb290U2VnbWVudDogbnVsbCxcbiAgICBhYm9ydGFibGVUYXNrczogYWJvcnRTZXQsXG4gICAgcGluZ2VkVGFza3M6IHBpbmdlZFRhc2tzLFxuICAgIGNsaWVudFJlbmRlcmVkQm91bmRhcmllczogW10sXG4gICAgY29tcGxldGVkQm91bmRhcmllczogW10sXG4gICAgcGFydGlhbEJvdW5kYXJpZXM6IFtdLFxuICAgIG9uRXJyb3I6IG9uRXJyb3IgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRFcnJvckhhbmRsZXIgOiBvbkVycm9yLFxuICAgIG9uQWxsUmVhZHk6IG9uQWxsUmVhZHkgPT09IHVuZGVmaW5lZCA/IG5vb3AgOiBvbkFsbFJlYWR5LFxuICAgIG9uU2hlbGxSZWFkeTogb25TaGVsbFJlYWR5ID09PSB1bmRlZmluZWQgPyBub29wIDogb25TaGVsbFJlYWR5LFxuICAgIG9uU2hlbGxFcnJvcjogb25TaGVsbEVycm9yID09PSB1bmRlZmluZWQgPyBub29wIDogb25TaGVsbEVycm9yLFxuICAgIG9uRmF0YWxFcnJvcjogb25GYXRhbEVycm9yID09PSB1bmRlZmluZWQgPyBub29wIDogb25GYXRhbEVycm9yXG4gIH07IC8vIFRoaXMgc2VnbWVudCByZXByZXNlbnRzIHRoZSByb290IGZhbGxiYWNrLlxuXG4gIHZhciByb290U2VnbWVudCA9IGNyZWF0ZVBlbmRpbmdTZWdtZW50KHJlcXVlc3QsIDAsIG51bGwsIHJvb3RGb3JtYXRDb250ZXh0LCAvLyBSb290IHNlZ21lbnRzIGFyZSBuZXZlciBlbWJlZGRlZCBpbiBUZXh0IG9uIGVpdGhlciBlZGdlXG4gIGZhbHNlLCBmYWxzZSk7IC8vIFRoZXJlIGlzIG5vIHBhcmVudCBzbyBjb25jZXB0dWFsbHksIHdlJ3JlIHVuYmxvY2tlZCB0byBmbHVzaCB0aGlzIHNlZ21lbnQuXG5cbiAgcm9vdFNlZ21lbnQucGFyZW50Rmx1c2hlZCA9IHRydWU7XG4gIHZhciByb290VGFzayA9IGNyZWF0ZVRhc2socmVxdWVzdCwgbnVsbCwgY2hpbGRyZW4sIG51bGwsIHJvb3RTZWdtZW50LCBhYm9ydFNldCwgZW1wdHlDb250ZXh0T2JqZWN0LCByb290Q29udGV4dFNuYXBzaG90LCBlbXB0eVRyZWVDb250ZXh0KTtcbiAgcGluZ2VkVGFza3MucHVzaChyb290VGFzayk7XG4gIHJldHVybiByZXF1ZXN0O1xufVxudmFyIGN1cnJlbnRSZXF1ZXN0ID0gbnVsbDtcbmZ1bmN0aW9uIHJlc29sdmVSZXF1ZXN0KCkge1xuICBpZiAoY3VycmVudFJlcXVlc3QpIHJldHVybiBjdXJyZW50UmVxdWVzdDtcblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcGluZ1Rhc2socmVxdWVzdCwgdGFzaykge1xuICB2YXIgcGluZ2VkVGFza3MgPSByZXF1ZXN0LnBpbmdlZFRhc2tzO1xuICBwaW5nZWRUYXNrcy5wdXNoKHRhc2spO1xuXG4gIGlmIChyZXF1ZXN0LnBpbmdlZFRhc2tzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPSByZXF1ZXN0LmRlc3RpbmF0aW9uICE9PSBudWxsO1xuICAgIHNjaGVkdWxlV29yayhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybVdvcmsocmVxdWVzdCk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShyZXF1ZXN0LCBmYWxsYmFja0Fib3J0YWJsZVRhc2tzKSB7XG4gIHJldHVybiB7XG4gICAgaWQ6IFVOSU5JVElBTElaRURfU1VTUEVOU0VfQk9VTkRBUllfSUQsXG4gICAgcm9vdFNlZ21lbnRJRDogLTEsXG4gICAgcGFyZW50Rmx1c2hlZDogZmFsc2UsXG4gICAgcGVuZGluZ1Rhc2tzOiAwLFxuICAgIGZvcmNlQ2xpZW50UmVuZGVyOiBmYWxzZSxcbiAgICBjb21wbGV0ZWRTZWdtZW50czogW10sXG4gICAgYnl0ZVNpemU6IDAsXG4gICAgZmFsbGJhY2tBYm9ydGFibGVUYXNrczogZmFsbGJhY2tBYm9ydGFibGVUYXNrcyxcbiAgICBlcnJvckRpZ2VzdDogbnVsbCxcbiAgICByZXNvdXJjZXM6IGNyZWF0ZUJvdW5kYXJ5UmVzb3VyY2VzKClcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGFzayhyZXF1ZXN0LCB0aGVuYWJsZVN0YXRlLCBub2RlLCBibG9ja2VkQm91bmRhcnksIGJsb2NrZWRTZWdtZW50LCBhYm9ydFNldCwgbGVnYWN5Q29udGV4dCwgY29udGV4dCwgdHJlZUNvbnRleHQpIHtcbiAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MrKztcblxuICBpZiAoYmxvY2tlZEJvdW5kYXJ5ID09PSBudWxsKSB7XG4gICAgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzKys7XG4gIH0gZWxzZSB7XG4gICAgYmxvY2tlZEJvdW5kYXJ5LnBlbmRpbmdUYXNrcysrO1xuICB9XG5cbiAgdmFyIHRhc2sgPSB7XG4gICAgbm9kZTogbm9kZSxcbiAgICBwaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcGluZ1Rhc2socmVxdWVzdCwgdGFzayk7XG4gICAgfSxcbiAgICBibG9ja2VkQm91bmRhcnk6IGJsb2NrZWRCb3VuZGFyeSxcbiAgICBibG9ja2VkU2VnbWVudDogYmxvY2tlZFNlZ21lbnQsXG4gICAgYWJvcnRTZXQ6IGFib3J0U2V0LFxuICAgIGxlZ2FjeUNvbnRleHQ6IGxlZ2FjeUNvbnRleHQsXG4gICAgY29udGV4dDogY29udGV4dCxcbiAgICB0cmVlQ29udGV4dDogdHJlZUNvbnRleHQsXG4gICAgdGhlbmFibGVTdGF0ZTogdGhlbmFibGVTdGF0ZVxuICB9O1xuXG4gIHtcbiAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gbnVsbDtcbiAgfVxuXG4gIGFib3J0U2V0LmFkZCh0YXNrKTtcbiAgcmV0dXJuIHRhc2s7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBlbmRpbmdTZWdtZW50KHJlcXVlc3QsIGluZGV4LCBib3VuZGFyeSwgZm9ybWF0Q29udGV4dCwgbGFzdFB1c2hlZFRleHQsIHRleHRFbWJlZGRlZCkge1xuICByZXR1cm4ge1xuICAgIHN0YXR1czogUEVORElORyxcbiAgICBpZDogLTEsXG4gICAgLy8gbGF6aWx5IGFzc2lnbmVkIGxhdGVyXG4gICAgaW5kZXg6IGluZGV4LFxuICAgIHBhcmVudEZsdXNoZWQ6IGZhbHNlLFxuICAgIGNodW5rczogW10sXG4gICAgY2hpbGRyZW46IFtdLFxuICAgIGZvcm1hdENvbnRleHQ6IGZvcm1hdENvbnRleHQsXG4gICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgIGxhc3RQdXNoZWRUZXh0OiBsYXN0UHVzaGVkVGV4dCxcbiAgICB0ZXh0RW1iZWRkZWQ6IHRleHRFbWJlZGRlZFxuICB9O1xufSAvLyBERVYtb25seSBnbG9iYWwgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIHRhc2tcblxuXG52YXIgY3VycmVudFRhc2tJbkRFViA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRTdGFja0luREVWKCkge1xuICB7XG4gICAgaWYgKGN1cnJlbnRUYXNrSW5ERVYgPT09IG51bGwgfHwgY3VycmVudFRhc2tJbkRFVi5jb21wb25lbnRTdGFjayA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRTdGFja0J5Q29tcG9uZW50U3RhY2tOb2RlKGN1cnJlbnRUYXNrSW5ERVYuY29tcG9uZW50U3RhY2spO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hCdWlsdEluQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrLCB0eXBlKSB7XG4gIHtcbiAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0ge1xuICAgICAgdGFnOiAwLFxuICAgICAgcGFyZW50OiB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgdHlwZTogdHlwZVxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaEZ1bmN0aW9uQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrLCB0eXBlKSB7XG4gIHtcbiAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0ge1xuICAgICAgdGFnOiAxLFxuICAgICAgcGFyZW50OiB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgdHlwZTogdHlwZVxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaENsYXNzQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrLCB0eXBlKSB7XG4gIHtcbiAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0ge1xuICAgICAgdGFnOiAyLFxuICAgICAgcGFyZW50OiB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgdHlwZTogdHlwZVxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKSB7XG4gIHtcbiAgICBpZiAodGFzay5jb21wb25lbnRTdGFjayA9PT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWRseSBwb3BwZWQgdG9vIG1hbnkgc3RhY2sgZnJhbWVzLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gdGFzay5jb21wb25lbnRTdGFjay5wYXJlbnQ7XG4gICAgfVxuICB9XG59IC8vIHN0YXNoIHRoZSBjb21wb25lbnQgc3RhY2sgb2YgYW4gdW53aW5kaW5nIGVycm9yIHVudGlsIGl0IGlzIHByb2Nlc3NlZFxuXG5cbnZhciBsYXN0Qm91bmRhcnlFcnJvckNvbXBvbmVudFN0YWNrRGV2ID0gbnVsbDtcblxuZnVuY3Rpb24gY2FwdHVyZUJvdW5kYXJ5RXJyb3JEZXRhaWxzRGV2KGJvdW5kYXJ5LCBlcnJvcikge1xuICB7XG4gICAgdmFyIGVycm9yTWVzc2FnZTtcblxuICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvcjtcbiAgICB9IGVsc2UgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gICAgICBlcnJvck1lc3NhZ2UgPSBTdHJpbmcoZXJyb3IpO1xuICAgIH1cblxuICAgIHZhciBlcnJvckNvbXBvbmVudFN0YWNrID0gbGFzdEJvdW5kYXJ5RXJyb3JDb21wb25lbnRTdGFja0RldiB8fCBnZXRDdXJyZW50U3RhY2tJbkRFVigpO1xuICAgIGxhc3RCb3VuZGFyeUVycm9yQ29tcG9uZW50U3RhY2tEZXYgPSBudWxsO1xuICAgIGJvdW5kYXJ5LmVycm9yTWVzc2FnZSA9IGVycm9yTWVzc2FnZTtcbiAgICBib3VuZGFyeS5lcnJvckNvbXBvbmVudFN0YWNrID0gZXJyb3JDb21wb25lbnRTdGFjaztcbiAgfVxufVxuXG5mdW5jdGlvbiBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yKSB7XG4gIC8vIElmIHRoaXMgY2FsbGJhY2sgZXJyb3JzLCB3ZSBpbnRlbnRpb25hbGx5IGxldCB0aGF0IGVycm9yIGJ1YmJsZSB1cCB0byBiZWNvbWUgYSBmYXRhbCBlcnJvclxuICAvLyBzbyB0aGF0IHNvbWVvbmUgZml4ZXMgdGhlIGVycm9yIHJlcG9ydGluZyBpbnN0ZWFkIG9mIGhpZGluZyBpdC5cbiAgdmFyIGVycm9yRGlnZXN0ID0gcmVxdWVzdC5vbkVycm9yKGVycm9yKTtcblxuICBpZiAoZXJyb3JEaWdlc3QgIT0gbnVsbCAmJiB0eXBlb2YgZXJyb3JEaWdlc3QgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJvbkVycm9yIHJldHVybmVkIHNvbWV0aGluZyB3aXRoIGEgdHlwZSBvdGhlciB0aGFuIFxcXCJzdHJpbmdcXFwiLiBvbkVycm9yIHNob3VsZCByZXR1cm4gYSBzdHJpbmcgYW5kIG1heSByZXR1cm4gbnVsbCBvciB1bmRlZmluZWQgYnV0IG11c3Qgbm90IHJldHVybiBhbnl0aGluZyBlbHNlLiBJdCByZWNlaXZlZCBzb21ldGhpbmcgb2YgdHlwZSBcXFwiXCIgKyB0eXBlb2YgZXJyb3JEaWdlc3QgKyBcIlxcXCIgaW5zdGVhZFwiKTtcbiAgfVxuXG4gIHJldHVybiBlcnJvckRpZ2VzdDtcbn1cblxuZnVuY3Rpb24gZmF0YWxFcnJvcihyZXF1ZXN0LCBlcnJvcikge1xuICAvLyBUaGlzIGlzIGNhbGxlZCBvdXRzaWRlIGVycm9yIGhhbmRsaW5nIGNvZGUgc3VjaCBhcyBpZiB0aGUgcm9vdCBlcnJvcnMgb3V0c2lkZVxuICAvLyBhIHN1c3BlbnNlIGJvdW5kYXJ5IG9yIGlmIHRoZSByb290IHN1c3BlbnNlIGJvdW5kYXJ5J3MgZmFsbGJhY2sgZXJyb3JzLlxuICAvLyBJdCdzIGFsc28gY2FsbGVkIGlmIFJlYWN0IGl0c2VsZiBvciBpdHMgaG9zdCBjb25maWdzIGVycm9ycy5cbiAgdmFyIG9uU2hlbGxFcnJvciA9IHJlcXVlc3Qub25TaGVsbEVycm9yO1xuICBvblNoZWxsRXJyb3IoZXJyb3IpO1xuICB2YXIgb25GYXRhbEVycm9yID0gcmVxdWVzdC5vbkZhdGFsRXJyb3I7XG4gIG9uRmF0YWxFcnJvcihlcnJvcik7XG5cbiAgaWYgKHJlcXVlc3QuZGVzdGluYXRpb24gIT09IG51bGwpIHtcbiAgICByZXF1ZXN0LnN0YXR1cyA9IENMT1NFRDtcbiAgICBjbG9zZVdpdGhFcnJvcihyZXF1ZXN0LmRlc3RpbmF0aW9uLCBlcnJvcik7XG4gIH0gZWxzZSB7XG4gICAgcmVxdWVzdC5zdGF0dXMgPSBDTE9TSU5HO1xuICAgIHJlcXVlc3QuZmF0YWxFcnJvciA9IGVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlclN1c3BlbnNlQm91bmRhcnkocmVxdWVzdCwgdGFzaywgcHJvcHMpIHtcbiAgcHVzaEJ1aWx0SW5Db21wb25lbnRTdGFja0luREVWKHRhc2ssICdTdXNwZW5zZScpO1xuICB2YXIgcGFyZW50Qm91bmRhcnkgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeTtcbiAgdmFyIHBhcmVudFNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50OyAvLyBFYWNoIHRpbWUgd2UgZW50ZXIgYSBzdXNwZW5zZSBib3VuZGFyeSwgd2Ugc3BsaXQgb3V0IGludG8gYSBuZXcgc2VnbWVudCBmb3JcbiAgLy8gdGhlIGZhbGxiYWNrIHNvIHRoYXQgd2UgY2FuIGxhdGVyIHJlcGxhY2UgdGhhdCBzZWdtZW50IHdpdGggdGhlIGNvbnRlbnQuXG4gIC8vIFRoaXMgYWxzbyBsZXRzIHVzIHNwbGl0IG91dCB0aGUgbWFpbiBjb250ZW50IGV2ZW4gaWYgaXQgZG9lc24ndCBzdXNwZW5kLFxuICAvLyBpbiBjYXNlIGl0IGVuZHMgdXAgZ2VuZXJhdGluZyBhIGxhcmdlIHN1YnRyZWUgb2YgY29udGVudC5cblxuICB2YXIgZmFsbGJhY2sgPSBwcm9wcy5mYWxsYmFjaztcbiAgdmFyIGNvbnRlbnQgPSBwcm9wcy5jaGlsZHJlbjtcbiAgdmFyIGZhbGxiYWNrQWJvcnRTZXQgPSBuZXcgU2V0KCk7XG4gIHZhciBuZXdCb3VuZGFyeSA9IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkocmVxdWVzdCwgZmFsbGJhY2tBYm9ydFNldCk7XG4gIHZhciBpbnNlcnRpb25JbmRleCA9IHBhcmVudFNlZ21lbnQuY2h1bmtzLmxlbmd0aDsgLy8gVGhlIGNoaWxkcmVuIG9mIHRoZSBib3VuZGFyeSBzZWdtZW50IGlzIGFjdHVhbGx5IHRoZSBmYWxsYmFjay5cblxuICB2YXIgYm91bmRhcnlTZWdtZW50ID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQocmVxdWVzdCwgaW5zZXJ0aW9uSW5kZXgsIG5ld0JvdW5kYXJ5LCBwYXJlbnRTZWdtZW50LmZvcm1hdENvbnRleHQsIC8vIGJvdW5kYXJpZXMgbmV2ZXIgcmVxdWlyZSB0ZXh0IGVtYmVkZGluZyBhdCB0aGVpciBlZGdlcyBiZWNhdXNlIGNvbW1lbnQgbm9kZXMgYm91bmQgdGhlbVxuICBmYWxzZSwgZmFsc2UpO1xuICBwYXJlbnRTZWdtZW50LmNoaWxkcmVuLnB1c2goYm91bmRhcnlTZWdtZW50KTsgLy8gVGhlIHBhcmVudFNlZ21lbnQgaGFzIGEgY2hpbGQgU2VnbWVudCBhdCB0aGlzIGluZGV4IHNvIHdlIHJlc2V0IHRoZSBsYXN0UHVzaGVkVGV4dCBtYXJrZXIgb24gdGhlIHBhcmVudFxuXG4gIHBhcmVudFNlZ21lbnQubGFzdFB1c2hlZFRleHQgPSBmYWxzZTsgLy8gVGhpcyBzZWdtZW50IGlzIHRoZSBhY3R1YWwgY2hpbGQgY29udGVudC4gV2UgY2FuIHN0YXJ0IHJlbmRlcmluZyB0aGF0IGltbWVkaWF0ZWx5LlxuXG4gIHZhciBjb250ZW50Um9vdFNlZ21lbnQgPSBjcmVhdGVQZW5kaW5nU2VnbWVudChyZXF1ZXN0LCAwLCBudWxsLCBwYXJlbnRTZWdtZW50LmZvcm1hdENvbnRleHQsIC8vIGJvdW5kYXJpZXMgbmV2ZXIgcmVxdWlyZSB0ZXh0IGVtYmVkZGluZyBhdCB0aGVpciBlZGdlcyBiZWNhdXNlIGNvbW1lbnQgbm9kZXMgYm91bmQgdGhlbVxuICBmYWxzZSwgZmFsc2UpOyAvLyBXZSBtYXJrIHRoZSByb290IHNlZ21lbnQgYXMgaGF2aW5nIGl0cyBwYXJlbnQgZmx1c2hlZC4gSXQncyBub3QgcmVhbGx5IGZsdXNoZWQgYnV0IHRoZXJlIGlzXG4gIC8vIG5vIHBhcmVudCBzZWdtZW50IHNvIHRoZXJlJ3Mgbm90aGluZyB0byB3YWl0IG9uLlxuXG4gIGNvbnRlbnRSb290U2VnbWVudC5wYXJlbnRGbHVzaGVkID0gdHJ1ZTsgLy8gQ3VycmVudGx5IHRoaXMgaXMgcnVubmluZyBzeW5jaHJvbm91c2x5LiBXZSBjb3VsZCBpbnN0ZWFkIHNjaGVkdWxlIHRoaXMgdG8gcGluZ2VkVGFza3MuXG4gIC8vIEkgc3VzcGVjdCB0aGF0IHRoZXJlIG1pZ2h0IGJlIHNvbWUgZWZmaWNpZW5jeSBiZW5lZml0cyBmcm9tIG5vdCBjcmVhdGluZyB0aGUgc3VzcGVuZGVkIHRhc2tcbiAgLy8gYW5kIGluc3RlYWQganVzdCB1c2luZyB0aGUgc3RhY2sgaWYgcG9zc2libGUuXG4gIC8vIFRPRE86IENhbGwgdGhpcyBkaXJlY3RseSBpbnN0ZWFkIG9mIG1lc3Npbmcgd2l0aCBzYXZpbmcgYW5kIHJlc3RvcmluZyBjb250ZXh0cy5cbiAgLy8gV2UgY2FuIHJldXNlIHRoZSBjdXJyZW50IGNvbnRleHQgYW5kIHRhc2sgdG8gcmVuZGVyIHRoZSBjb250ZW50IGltbWVkaWF0ZWx5IHdpdGhvdXRcbiAgLy8gY29udGV4dCBzd2l0Y2hpbmcuIFdlIGp1c3QgbmVlZCB0byB0ZW1wb3JhcmlseSBzd2l0Y2ggd2hpY2ggYm91bmRhcnkgYW5kIHdoaWNoIHNlZ21lbnRcbiAgLy8gd2UncmUgd3JpdGluZyB0by4gSWYgc29tZXRoaW5nIHN1c3BlbmRzLCBpdCdsbCBzcGF3biBuZXcgc3VzcGVuZGVkIHRhc2sgd2l0aCB0aGF0IGNvbnRleHQuXG5cbiAgdGFzay5ibG9ja2VkQm91bmRhcnkgPSBuZXdCb3VuZGFyeTtcbiAgdGFzay5ibG9ja2VkU2VnbWVudCA9IGNvbnRlbnRSb290U2VnbWVudDtcblxuICB7XG4gICAgc2V0Q3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlSZXNvdXJjZXNUYXJnZXQocmVxdWVzdC5yZXNvdXJjZXMsIG5ld0JvdW5kYXJ5LnJlc291cmNlcyk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFdlIHVzZSB0aGUgc2FmZSBmb3JtIGJlY2F1c2Ugd2UgZG9uJ3QgaGFuZGxlIHN1c3BlbmRpbmcgaGVyZS4gT25seSBlcnJvciBoYW5kbGluZy5cbiAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNvbnRlbnQpO1xuICAgIHB1c2hTZWdtZW50RmluYWxlKGNvbnRlbnRSb290U2VnbWVudC5jaHVua3MsIHJlcXVlc3QucmVzcG9uc2VTdGF0ZSwgY29udGVudFJvb3RTZWdtZW50Lmxhc3RQdXNoZWRUZXh0LCBjb250ZW50Um9vdFNlZ21lbnQudGV4dEVtYmVkZGVkKTtcbiAgICBjb250ZW50Um9vdFNlZ21lbnQuc3RhdHVzID0gQ09NUExFVEVEO1xuICAgIHF1ZXVlQ29tcGxldGVkU2VnbWVudChuZXdCb3VuZGFyeSwgY29udGVudFJvb3RTZWdtZW50KTtcblxuICAgIGlmIChuZXdCb3VuZGFyeS5wZW5kaW5nVGFza3MgPT09IDApIHtcbiAgICAgIC8vIFRoaXMgbXVzdCBoYXZlIGJlZW4gdGhlIGxhc3Qgc2VnbWVudCB3ZSB3ZXJlIHdhaXRpbmcgb24uIFRoaXMgYm91bmRhcnkgaXMgbm93IGNvbXBsZXRlLlxuICAgICAgLy8gVGhlcmVmb3JlIHdlIHdvbid0IG5lZWQgdGhlIGZhbGxiYWNrLiBXZSBlYXJseSByZXR1cm4gc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGNyZWF0ZVxuICAgICAgLy8gdGhlIGZhbGxiYWNrLlxuICAgICAgcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29udGVudFJvb3RTZWdtZW50LnN0YXR1cyA9IEVSUk9SRUQ7XG4gICAgbmV3Qm91bmRhcnkuZm9yY2VDbGllbnRSZW5kZXIgPSB0cnVlO1xuICAgIG5ld0JvdW5kYXJ5LmVycm9yRGlnZXN0ID0gbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG5cbiAgICB7XG4gICAgICBjYXB0dXJlQm91bmRhcnlFcnJvckRldGFpbHNEZXYobmV3Qm91bmRhcnksIGVycm9yKTtcbiAgICB9IC8vIFdlIGRvbid0IG5lZWQgdG8gZGVjcmVtZW50IGFueSB0YXNrIG51bWJlcnMgYmVjYXVzZSB3ZSBkaWRuJ3Qgc3Bhd24gYW55IG5ldyB0YXNrLlxuICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gc2NoZWR1bGUgYW55IHRhc2sgYmVjYXVzZSB3ZSBrbm93IHRoZSBwYXJlbnQgaGFzIHdyaXR0ZW4geWV0LlxuICAgIC8vIFdlIGRvIG5lZWQgdG8gZmFsbHRocm91Z2ggdG8gY3JlYXRlIHRoZSBmYWxsYmFjayB0aG91Z2guXG5cbiAgfSBmaW5hbGx5IHtcbiAgICB7XG4gICAgICBzZXRDdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeVJlc291cmNlc1RhcmdldChyZXF1ZXN0LnJlc291cmNlcywgcGFyZW50Qm91bmRhcnkgPyBwYXJlbnRCb3VuZGFyeS5yZXNvdXJjZXMgOiBudWxsKTtcbiAgICB9XG5cbiAgICB0YXNrLmJsb2NrZWRCb3VuZGFyeSA9IHBhcmVudEJvdW5kYXJ5O1xuICAgIHRhc2suYmxvY2tlZFNlZ21lbnQgPSBwYXJlbnRTZWdtZW50O1xuICB9IC8vIFdlIGNyZWF0ZSBzdXNwZW5kZWQgdGFzayBmb3IgdGhlIGZhbGxiYWNrIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byBhY3R1YWxseSB3b3JrXG4gIC8vIG9uIGl0IHlldCBpbiBjYXNlIHdlIGZpbmlzaCB0aGUgbWFpbiBjb250ZW50LCBzbyB3ZSBxdWV1ZSBmb3IgbGF0ZXIuXG5cblxuICB2YXIgc3VzcGVuZGVkRmFsbGJhY2tUYXNrID0gY3JlYXRlVGFzayhyZXF1ZXN0LCBudWxsLCBmYWxsYmFjaywgcGFyZW50Qm91bmRhcnksIGJvdW5kYXJ5U2VnbWVudCwgZmFsbGJhY2tBYm9ydFNldCwgdGFzay5sZWdhY3lDb250ZXh0LCB0YXNrLmNvbnRleHQsIHRhc2sudHJlZUNvbnRleHQpO1xuXG4gIHtcbiAgICBzdXNwZW5kZWRGYWxsYmFja1Rhc2suY29tcG9uZW50U3RhY2sgPSB0YXNrLmNvbXBvbmVudFN0YWNrO1xuICB9IC8vIFRPRE86IFRoaXMgc2hvdWxkIGJlIHF1ZXVlZCBhdCBhIHNlcGFyYXRlIGxvd2VyIHByaW9yaXR5IHF1ZXVlIHNvIHRoYXQgd2Ugb25seSB3b3JrXG4gIC8vIG9uIHByZXBhcmluZyBmYWxsYmFja3MgaWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBtYWluIGNvbnRlbnQgdG8gdGFzayBvbi5cblxuXG4gIHJlcXVlc3QucGluZ2VkVGFza3MucHVzaChzdXNwZW5kZWRGYWxsYmFja1Rhc2spO1xuICBwb3BDb21wb25lbnRTdGFja0luREVWKHRhc2spO1xufVxuXG5mdW5jdGlvbiByZW5kZXJIb3N0RWxlbWVudChyZXF1ZXN0LCB0YXNrLCB0eXBlLCBwcm9wcykge1xuICBwdXNoQnVpbHRJbkNvbXBvbmVudFN0YWNrSW5ERVYodGFzaywgdHlwZSk7XG4gIHZhciBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcbiAgdmFyIGNoaWxkcmVuID0gcHVzaFN0YXJ0SW5zdGFuY2Uoc2VnbWVudC5jaHVua3MsIHR5cGUsIHByb3BzLCByZXF1ZXN0LnJlc291cmNlcywgcmVxdWVzdC5yZXNwb25zZVN0YXRlLCBzZWdtZW50LmZvcm1hdENvbnRleHQsIHNlZ21lbnQubGFzdFB1c2hlZFRleHQpO1xuICBzZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gZmFsc2U7XG4gIHZhciBwcmV2Q29udGV4dCA9IHNlZ21lbnQuZm9ybWF0Q29udGV4dDtcbiAgc2VnbWVudC5mb3JtYXRDb250ZXh0ID0gZ2V0Q2hpbGRGb3JtYXRDb250ZXh0KHByZXZDb250ZXh0LCB0eXBlLCBwcm9wcyk7IC8vIFdlIHVzZSB0aGUgbm9uLWRlc3RydWN0aXZlIGZvcm0gYmVjYXVzZSBpZiBzb21ldGhpbmcgc3VzcGVuZHMsIHdlIHN0aWxsXG4gIC8vIG5lZWQgdG8gcG9wIGJhY2sgdXAgYW5kIGZpbmlzaCB0aGlzIHN1YnRyZWUgb2YgSFRNTC5cblxuICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuKTsgLy8gV2UgZXhwZWN0IHRoYXQgZXJyb3JzIHdpbGwgZmF0YWwgdGhlIHdob2xlIHRhc2sgYW5kIHRoYXQgd2UgZG9uJ3QgbmVlZFxuICAvLyB0aGUgY29ycmVjdCBjb250ZXh0LiBUaGVyZWZvcmUgdGhpcyBpcyBub3QgaW4gYSBmaW5hbGx5LlxuXG4gIHNlZ21lbnQuZm9ybWF0Q29udGV4dCA9IHByZXZDb250ZXh0O1xuICBwdXNoRW5kSW5zdGFuY2Uoc2VnbWVudC5jaHVua3MsIHR5cGUsIHByb3BzLCByZXF1ZXN0LnJlc3BvbnNlU3RhdGUsIHByZXZDb250ZXh0KTtcbiAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9IGZhbHNlO1xuICBwb3BDb21wb25lbnRTdGFja0luREVWKHRhc2spO1xufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHJldHVybiBDb21wb25lbnQucHJvdG90eXBlICYmIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudDtcbn1cblxuZnVuY3Rpb24gcmVuZGVyV2l0aEhvb2tzKHJlcXVlc3QsIHRhc2ssIHByZXZUaGVuYWJsZVN0YXRlLCBDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcpIHtcbiAgdmFyIGNvbXBvbmVudElkZW50aXR5ID0ge307XG4gIHByZXBhcmVUb1VzZUhvb2tzKHRhc2ssIGNvbXBvbmVudElkZW50aXR5LCBwcmV2VGhlbmFibGVTdGF0ZSk7XG4gIHZhciByZXN1bHQgPSBDb21wb25lbnQocHJvcHMsIHNlY29uZEFyZyk7XG4gIHJldHVybiBmaW5pc2hIb29rcyhDb21wb25lbnQsIHByb3BzLCByZXN1bHQsIHNlY29uZEFyZyk7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaENsYXNzQ29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIGluc3RhbmNlLCBDb21wb25lbnQsIHByb3BzKSB7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSBpbnN0YW5jZS5yZW5kZXIoKTtcblxuICB7XG4gICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBwcm9wcykge1xuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKSB7XG4gICAgICAgIGVycm9yKCdJdCBsb29rcyBsaWtlICVzIGlzIHJlYXNzaWduaW5nIGl0cyBvd24gYHRoaXMucHJvcHNgIHdoaWxlIHJlbmRlcmluZy4gJyArICdUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIGNhbiBsZWFkIHRvIGNvbmZ1c2luZyBidWdzLicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdhIGNvbXBvbmVudCcpO1xuICAgICAgfVxuXG4gICAgICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgdmFyIGNoaWxkQ29udGV4dFR5cGVzID0gQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzO1xuXG4gICAgaWYgKGNoaWxkQ29udGV4dFR5cGVzICE9PSBudWxsICYmIGNoaWxkQ29udGV4dFR5cGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBwcmV2aW91c0NvbnRleHQgPSB0YXNrLmxlZ2FjeUNvbnRleHQ7XG4gICAgICB2YXIgbWVyZ2VkQ29udGV4dCA9IHByb2Nlc3NDaGlsZENvbnRleHQoaW5zdGFuY2UsIENvbXBvbmVudCwgcHJldmlvdXNDb250ZXh0LCBjaGlsZENvbnRleHRUeXBlcyk7XG4gICAgICB0YXNrLmxlZ2FjeUNvbnRleHQgPSBtZXJnZWRDb250ZXh0O1xuICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG51bGwsIG5leHRDaGlsZHJlbik7XG4gICAgICB0YXNrLmxlZ2FjeUNvbnRleHQgPSBwcmV2aW91c0NvbnRleHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG51bGwsIG5leHRDaGlsZHJlbik7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNsYXNzQ29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIENvbXBvbmVudCwgcHJvcHMpIHtcbiAgcHVzaENsYXNzQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrLCBDb21wb25lbnQpO1xuICB2YXIgbWFza2VkQ29udGV4dCA9IGdldE1hc2tlZENvbnRleHQoQ29tcG9uZW50LCB0YXNrLmxlZ2FjeUNvbnRleHQpIDtcbiAgdmFyIGluc3RhbmNlID0gY29uc3RydWN0Q2xhc3NJbnN0YW5jZShDb21wb25lbnQsIHByb3BzLCBtYXNrZWRDb250ZXh0KTtcbiAgbW91bnRDbGFzc0luc3RhbmNlKGluc3RhbmNlLCBDb21wb25lbnQsIHByb3BzLCBtYXNrZWRDb250ZXh0KTtcbiAgZmluaXNoQ2xhc3NDb21wb25lbnQocmVxdWVzdCwgdGFzaywgaW5zdGFuY2UsIENvbXBvbmVudCwgcHJvcHMpO1xuICBwb3BDb21wb25lbnRTdGFja0luREVWKHRhc2spO1xufVxuXG52YXIgZGlkV2FybkFib3V0QmFkQ2xhc3MgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50ID0ge307XG52YXIgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG52YXIgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9O1xudmFyIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgPSBmYWxzZTtcbnZhciBkaWRXYXJuQWJvdXREZWZhdWx0UHJvcHNPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG52YXIgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IGZhbHNlO1xudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbnZhciBoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIgPSBmYWxzZTsgLy8gVGhpcyB3b3VsZCB0eXBpY2FsbHkgYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgYnV0IHdlIHN0aWxsIHN1cHBvcnQgbW9kdWxlIHBhdHRlcm5cbi8vIGNvbXBvbmVudHMgZm9yIHNvbWUgcmVhc29uLlxuXG5mdW5jdGlvbiByZW5kZXJJbmRldGVybWluYXRlQ29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIHByZXZUaGVuYWJsZVN0YXRlLCBDb21wb25lbnQsIHByb3BzKSB7XG4gIHZhciBsZWdhY3lDb250ZXh0O1xuXG4gIHtcbiAgICBsZWdhY3lDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dChDb21wb25lbnQsIHRhc2subGVnYWN5Q29udGV4dCk7XG4gIH1cblxuICBwdXNoRnVuY3Rpb25Db21wb25lbnRTdGFja0luREVWKHRhc2ssIENvbXBvbmVudCk7XG5cbiAge1xuICAgIGlmIChDb21wb25lbnQucHJvdG90eXBlICYmIHR5cGVvZiBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciB2YWx1ZSA9IHJlbmRlcldpdGhIb29rcyhyZXF1ZXN0LCB0YXNrLCBwcmV2VGhlbmFibGVTdGF0ZSwgQ29tcG9uZW50LCBwcm9wcywgbGVnYWN5Q29udGV4dCk7XG4gIHZhciBoYXNJZCA9IGNoZWNrRGlkUmVuZGVySWRIb29rKCk7XG5cbiAge1xuICAgIC8vIFN1cHBvcnQgZm9yIG1vZHVsZSBjb21wb25lbnRzIGlzIGRlcHJlY2F0ZWQgYW5kIGlzIHJlbW92ZWQgYmVoaW5kIGEgZmxhZy5cbiAgICAvLyBXaGV0aGVyIG9yIG5vdCBpdCB3b3VsZCBjcmFzaCBsYXRlciwgd2Ugd2FudCB0byBzaG93IGEgZ29vZCBtZXNzYWdlIGluIERFViBmaXJzdC5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUucmVuZGVyID09PSAnZnVuY3Rpb24nICYmIHZhbHVlLiQkdHlwZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBiZSBhIGZ1bmN0aW9uIGNvbXBvbmVudCB0aGF0IHJldHVybnMgYSBjbGFzcyBpbnN0YW5jZS4gJyArICdDaGFuZ2UgJXMgdG8gYSBjbGFzcyB0aGF0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuICcgKyBcIklmIHlvdSBjYW4ndCB1c2UgYSBjbGFzcyB0cnkgYXNzaWduaW5nIHRoZSBwcm90b3R5cGUgb24gdGhlIGZ1bmN0aW9uIGFzIGEgd29ya2Fyb3VuZC4gXCIgKyBcImAlcy5wcm90b3R5cGUgPSBSZWFjdC5Db21wb25lbnQucHJvdG90eXBlYC4gRG9uJ3QgdXNlIGFuIGFycm93IGZ1bmN0aW9uIHNpbmNlIGl0IFwiICsgJ2Nhbm5vdCBiZSBjYWxsZWQgd2l0aCBgbmV3YCBieSBSZWFjdC4nLCBfY29tcG9uZW50TmFtZSwgX2NvbXBvbmVudE5hbWUsIF9jb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCAvLyBSdW4gdGhlc2UgY2hlY2tzIGluIHByb2R1Y3Rpb24gb25seSBpZiB0aGUgZmxhZyBpcyBvZmYuXG4gIC8vIEV2ZW50dWFsbHkgd2UnbGwgZGVsZXRlIHRoaXMgYnJhbmNoIGFsdG9nZXRoZXIuXG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZS4kJHR5cGVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAge1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lMiA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lMl0pIHtcbiAgICAgICAgZXJyb3IoJ1RoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgdGhhdCByZXR1cm5zIGEgY2xhc3MgaW5zdGFuY2UuICcgKyAnQ2hhbmdlICVzIHRvIGEgY2xhc3MgdGhhdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLiAnICsgXCJJZiB5b3UgY2FuJ3QgdXNlIGEgY2xhc3MgdHJ5IGFzc2lnbmluZyB0aGUgcHJvdG90eXBlIG9uIHRoZSBmdW5jdGlvbiBhcyBhIHdvcmthcm91bmQuIFwiICsgXCJgJXMucHJvdG90eXBlID0gUmVhY3QuQ29tcG9uZW50LnByb3RvdHlwZWAuIERvbid0IHVzZSBhbiBhcnJvdyBmdW5jdGlvbiBzaW5jZSBpdCBcIiArICdjYW5ub3QgYmUgY2FsbGVkIHdpdGggYG5ld2AgYnkgUmVhY3QuJywgX2NvbXBvbmVudE5hbWUyLCBfY29tcG9uZW50TmFtZTIsIF9jb21wb25lbnROYW1lMik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTJdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtb3VudENsYXNzSW5zdGFuY2UodmFsdWUsIENvbXBvbmVudCwgcHJvcHMsIGxlZ2FjeUNvbnRleHQpO1xuICAgIGZpbmlzaENsYXNzQ29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIHZhbHVlLCBDb21wb25lbnQsIHByb3BzKTtcbiAgfSBlbHNlIHtcblxuICAgIHtcbiAgICAgIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldihDb21wb25lbnQpO1xuICAgIH0gLy8gV2UncmUgbm93IHN1Y2Nlc3NmdWxseSBwYXN0IHRoaXMgdGFzaywgYW5kIHdlIGRvbid0IGhhdmUgdG8gcG9wIGJhY2sgdG9cbiAgICAvLyB0aGUgcHJldmlvdXMgdGFzayBldmVyeSBhZ2Fpbiwgc28gd2UgY2FuIHVzZSB0aGUgZGVzdHJ1Y3RpdmUgcmVjdXJzaXZlIGZvcm0uXG5cblxuICAgIGlmIChoYXNJZCkge1xuICAgICAgLy8gVGhpcyBjb21wb25lbnQgbWF0ZXJpYWxpemVkIGFuIGlkLiBXZSB0cmVhdCB0aGlzIGFzIGl0cyBvd24gbGV2ZWwsIHdpdGhcbiAgICAgIC8vIGEgc2luZ2xlIFwiY2hpbGRcIiBzbG90LlxuICAgICAgdmFyIHByZXZUcmVlQ29udGV4dCA9IHRhc2sudHJlZUNvbnRleHQ7XG4gICAgICB2YXIgdG90YWxDaGlsZHJlbiA9IDE7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdGFzay50cmVlQ29udGV4dCA9IHB1c2hUcmVlQ29udGV4dChwcmV2VHJlZUNvbnRleHQsIHRvdGFsQ2hpbGRyZW4sIGluZGV4KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG51bGwsIHZhbHVlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRhc2sudHJlZUNvbnRleHQgPSBwcmV2VHJlZUNvbnRleHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBudWxsLCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KENvbXBvbmVudCkge1xuICB7XG4gICAgaWYgKENvbXBvbmVudCkge1xuICAgICAgaWYgKENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcykge1xuICAgICAgICBlcnJvcignJXMoLi4uKTogY2hpbGRDb250ZXh0VHlwZXMgY2Fubm90IGJlIGRlZmluZWQgb24gYSBmdW5jdGlvbiBjb21wb25lbnQuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoQ29tcG9uZW50LmRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXREZWZhdWx0UHJvcHNPbkZ1bmN0aW9uQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCclczogU3VwcG9ydCBmb3IgZGVmYXVsdFByb3BzIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIGZ1bmN0aW9uIGNvbXBvbmVudHMgJyArICdpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBVc2UgSmF2YVNjcmlwdCBkZWZhdWx0IHBhcmFtZXRlcnMgaW5zdGVhZC4nLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXREZWZhdWx0UHJvcHNPbkZ1bmN0aW9uQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZTMgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTNdKSB7XG4gICAgICAgIGVycm9yKCclczogRnVuY3Rpb24gY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuJywgX2NvbXBvbmVudE5hbWUzKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lM10gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgQ29tcG9uZW50LmNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBDb21wb25lbnQuY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZTQgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lNF0pIHtcbiAgICAgICAgZXJyb3IoJyVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGNvbnRleHRUeXBlLicsIF9jb21wb25lbnROYW1lNCk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lNF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgYmFzZVByb3BzKSB7XG4gIGlmIChDb21wb25lbnQgJiYgQ29tcG9uZW50LmRlZmF1bHRQcm9wcykge1xuICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wcy4gVGFrZW4gZnJvbSBSZWFjdEVsZW1lbnRcbiAgICB2YXIgcHJvcHMgPSBhc3NpZ24oe30sIGJhc2VQcm9wcyk7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IENvbXBvbmVudC5kZWZhdWx0UHJvcHM7XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwcm9wcztcbiAgfVxuXG4gIHJldHVybiBiYXNlUHJvcHM7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckZvcndhcmRSZWYocmVxdWVzdCwgdGFzaywgcHJldlRoZW5hYmxlU3RhdGUsIHR5cGUsIHByb3BzLCByZWYpIHtcbiAgcHVzaEZ1bmN0aW9uQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrLCB0eXBlLnJlbmRlcik7XG4gIHZhciBjaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rcyhyZXF1ZXN0LCB0YXNrLCBwcmV2VGhlbmFibGVTdGF0ZSwgdHlwZS5yZW5kZXIsIHByb3BzLCByZWYpO1xuICB2YXIgaGFzSWQgPSBjaGVja0RpZFJlbmRlcklkSG9vaygpO1xuXG4gIGlmIChoYXNJZCkge1xuICAgIC8vIFRoaXMgY29tcG9uZW50IG1hdGVyaWFsaXplZCBhbiBpZC4gV2UgdHJlYXQgdGhpcyBhcyBpdHMgb3duIGxldmVsLCB3aXRoXG4gICAgLy8gYSBzaW5nbGUgXCJjaGlsZFwiIHNsb3QuXG4gICAgdmFyIHByZXZUcmVlQ29udGV4dCA9IHRhc2sudHJlZUNvbnRleHQ7XG4gICAgdmFyIHRvdGFsQ2hpbGRyZW4gPSAxO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdGFzay50cmVlQ29udGV4dCA9IHB1c2hUcmVlQ29udGV4dChwcmV2VHJlZUNvbnRleHQsIHRvdGFsQ2hpbGRyZW4sIGluZGV4KTtcblxuICAgIHRyeSB7XG4gICAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbnVsbCwgY2hpbGRyZW4pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHJldlRyZWVDb250ZXh0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbnVsbCwgY2hpbGRyZW4pO1xuICB9XG5cbiAgcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyTWVtbyhyZXF1ZXN0LCB0YXNrLCBwcmV2VGhlbmFibGVTdGF0ZSwgdHlwZSwgcHJvcHMsIHJlZikge1xuICB2YXIgaW5uZXJUeXBlID0gdHlwZS50eXBlO1xuICB2YXIgcmVzb2x2ZWRQcm9wcyA9IHJlc29sdmVEZWZhdWx0UHJvcHMoaW5uZXJUeXBlLCBwcm9wcyk7XG4gIHJlbmRlckVsZW1lbnQocmVxdWVzdCwgdGFzaywgcHJldlRoZW5hYmxlU3RhdGUsIGlubmVyVHlwZSwgcmVzb2x2ZWRQcm9wcywgcmVmKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyQ29udGV4dENvbnN1bWVyKHJlcXVlc3QsIHRhc2ssIGNvbnRleHQsIHByb3BzKSB7XG4gIC8vIFRoZSBsb2dpYyBiZWxvdyBmb3IgQ29udGV4dCBkaWZmZXJzIGRlcGVuZGluZyBvbiBQUk9EIG9yIERFViBtb2RlLiBJblxuICAvLyBERVYgbW9kZSwgd2UgY3JlYXRlIGEgc2VwYXJhdGUgb2JqZWN0IGZvciBDb250ZXh0LkNvbnN1bWVyIHRoYXQgYWN0c1xuICAvLyBsaWtlIGEgcHJveHkgdG8gQ29udGV4dC4gVGhpcyBwcm94eSBvYmplY3QgYWRkcyB1bm5lY2Vzc2FyeSBjb2RlIGluIFBST0RcbiAgLy8gc28gd2UgdXNlIHRoZSBvbGQgYmVoYXZpb3VyIChDb250ZXh0LkNvbnN1bWVyIHJlZmVyZW5jZXMgQ29udGV4dCkgdG9cbiAgLy8gcmVkdWNlIHNpemUgYW5kIG92ZXJoZWFkLiBUaGUgc2VwYXJhdGUgb2JqZWN0IHJlZmVyZW5jZXMgY29udGV4dCB2aWFcbiAgLy8gYSBwcm9wZXJ0eSBjYWxsZWQgXCJfY29udGV4dFwiLCB3aGljaCBhbHNvIGdpdmVzIHVzIHRoZSBhYmlsaXR5IHRvIGNoZWNrXG4gIC8vIGluIERFViBtb2RlIGlmIHRoaXMgcHJvcGVydHkgZXhpc3RzIG9yIG5vdCBhbmQgd2FybiBpZiBpdCBkb2VzIG5vdC5cbiAge1xuICAgIGlmIChjb250ZXh0Ll9jb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFRoaXMgbWF5IGJlIGJlY2F1c2UgaXQncyBhIENvbnRleHQgKHJhdGhlciB0aGFuIGEgQ29uc3VtZXIpLlxuICAgICAgLy8gT3IgaXQgbWF5IGJlIGJlY2F1c2UgaXQncyBvbGRlciBSZWFjdCB3aGVyZSB0aGV5J3JlIHRoZSBzYW1lIHRoaW5nLlxuICAgICAgLy8gV2Ugb25seSB3YW50IHRvIHdhcm4gaWYgd2UncmUgc3VyZSBpdCdzIGEgbmV3IFJlYWN0LlxuICAgICAgaWYgKGNvbnRleHQgIT09IGNvbnRleHQuQ29uc3VtZXIpIHtcbiAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIpIHtcbiAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIgPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dD4gZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Db25zdW1lcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0ID0gY29udGV4dC5fY29udGV4dDtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVuZGVyID0gcHJvcHMuY2hpbGRyZW47XG5cbiAge1xuICAgIGlmICh0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignQSBjb250ZXh0IGNvbnN1bWVyIHdhcyByZW5kZXJlZCB3aXRoIG11bHRpcGxlIGNoaWxkcmVuLCBvciBhIGNoaWxkICcgKyBcInRoYXQgaXNuJ3QgYSBmdW5jdGlvbi4gQSBjb250ZXh0IGNvbnN1bWVyIGV4cGVjdHMgYSBzaW5nbGUgY2hpbGQgXCIgKyAndGhhdCBpcyBhIGZ1bmN0aW9uLiBJZiB5b3UgZGlkIHBhc3MgYSBmdW5jdGlvbiwgbWFrZSBzdXJlIHRoZXJlICcgKyAnaXMgbm8gdHJhaWxpbmcgb3IgbGVhZGluZyB3aGl0ZXNwYWNlIGFyb3VuZCBpdC4nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV3VmFsdWUgPSByZWFkQ29udGV4dCQxKGNvbnRleHQpO1xuICB2YXIgbmV3Q2hpbGRyZW4gPSByZW5kZXIobmV3VmFsdWUpO1xuICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbnVsbCwgbmV3Q2hpbGRyZW4pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJDb250ZXh0UHJvdmlkZXIocmVxdWVzdCwgdGFzaywgdHlwZSwgcHJvcHMpIHtcbiAgdmFyIGNvbnRleHQgPSB0eXBlLl9jb250ZXh0O1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gIHZhciBwcmV2U25hcHNob3Q7XG5cbiAge1xuICAgIHByZXZTbmFwc2hvdCA9IHRhc2suY29udGV4dDtcbiAgfVxuXG4gIHRhc2suY29udGV4dCA9IHB1c2hQcm92aWRlcihjb250ZXh0LCB2YWx1ZSk7XG4gIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBudWxsLCBjaGlsZHJlbik7XG4gIHRhc2suY29udGV4dCA9IHBvcFByb3ZpZGVyKGNvbnRleHQpO1xuXG4gIHtcbiAgICBpZiAocHJldlNuYXBzaG90ICE9PSB0YXNrLmNvbnRleHQpIHtcbiAgICAgIGVycm9yKCdQb3BwaW5nIHRoZSBjb250ZXh0IHByb3ZpZGVyIGRpZCBub3QgcmV0dXJuIGJhY2sgdG8gdGhlIG9yaWdpbmFsIHNuYXBzaG90LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJMYXp5Q29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIHByZXZUaGVuYWJsZVN0YXRlLCBsYXp5Q29tcG9uZW50LCBwcm9wcywgcmVmKSB7XG4gIHB1c2hCdWlsdEluQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrLCAnTGF6eScpO1xuICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcbiAgdmFyIENvbXBvbmVudCA9IGluaXQocGF5bG9hZCk7XG4gIHZhciByZXNvbHZlZFByb3BzID0gcmVzb2x2ZURlZmF1bHRQcm9wcyhDb21wb25lbnQsIHByb3BzKTtcbiAgcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCBwcmV2VGhlbmFibGVTdGF0ZSwgQ29tcG9uZW50LCByZXNvbHZlZFByb3BzLCByZWYpO1xuICBwb3BDb21wb25lbnRTdGFja0luREVWKHRhc2spO1xufVxuXG5mdW5jdGlvbiByZW5kZXJPZmZzY3JlZW4ocmVxdWVzdCwgdGFzaywgcHJvcHMpIHtcbiAgdmFyIG1vZGUgPSBwcm9wcy5tb2RlO1xuXG4gIGlmIChtb2RlID09PSAnaGlkZGVuJykgOyBlbHNlIHtcbiAgICAvLyBBIHZpc2libGUgT2Zmc2NyZWVuIGJvdW5kYXJ5IGlzIHRyZWF0ZWQgZXhhY3RseSBsaWtlIGEgZnJhZ21lbnQ6IGFcbiAgICAvLyBwdXJlIGluZGlyZWN0aW9uLlxuICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBudWxsLCBwcm9wcy5jaGlsZHJlbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCBwcmV2VGhlbmFibGVTdGF0ZSwgdHlwZSwgcHJvcHMsIHJlZikge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoc2hvdWxkQ29uc3RydWN0KHR5cGUpKSB7XG4gICAgICByZW5kZXJDbGFzc0NvbXBvbmVudChyZXF1ZXN0LCB0YXNrLCB0eXBlLCBwcm9wcyk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlckluZGV0ZXJtaW5hdGVDb21wb25lbnQocmVxdWVzdCwgdGFzaywgcHJldlRoZW5hYmxlU3RhdGUsIHR5cGUsIHByb3BzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVuZGVySG9zdEVsZW1lbnQocmVxdWVzdCwgdGFzaywgdHlwZSwgcHJvcHMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIC8vIExlZ2FjeUhpZGRlbiBhY3RzIHRoZSBzYW1lIGFzIGEgZnJhZ21lbnQuIFRoaXMgb25seSB3b3JrcyBiZWNhdXNlIHdlXG4gICAgLy8gY3VycmVudGx5IGFzc3VtZSB0aGF0IGV2ZXJ5IGluc3RhbmNlIG9mIExlZ2FjeUhpZGRlbiBpcyBhY2NvbXBhbmllZCBieSBhXG4gICAgLy8gaG9zdCBjb21wb25lbnQgd3JhcHBlci4gSW4gdGhlIGhpZGRlbiBtb2RlLCB0aGUgaG9zdCBjb21wb25lbnQgaXMgZ2l2ZW4gYVxuICAgIC8vIGBoaWRkZW5gIGF0dHJpYnV0ZSwgd2hpY2ggZW5zdXJlcyB0aGF0IHRoZSBpbml0aWFsIEhUTUwgaXMgbm90IHZpc2libGUuXG4gICAgLy8gVG8gc3VwcG9ydCB0aGUgdXNlIG9mIExlZ2FjeUhpZGRlbiBhcyBhIHRydWUgZnJhZ21lbnQsIHdpdGhvdXQgYW4gZXh0cmFcbiAgICAvLyBET00gbm9kZSwgd2Ugd291bGQgaGF2ZSB0byBoaWRlIHRoZSBpbml0aWFsIEhUTUwgaW4gc29tZSBvdGhlciB3YXkuXG4gICAgLy8gVE9ETzogRGVsZXRlIGluIExlZ2FjeUhpZGRlbi4gSXQncyBhbiB1bnN0YWJsZSBBUEkgb25seSB1c2VkIGluIHRoZVxuICAgIC8vIHd3dyBidWlsZC4gQXMgYSBtaWdyYXRpb24gc3RlcCwgd2UgY291bGQgYWRkIGEgc3BlY2lhbCBwcm9wIHRvIE9mZnNjcmVlblxuICAgIC8vIHRoYXQgc2ltdWxhdGVzIHRoZSBvbGQgYmVoYXZpb3IgKG5vIGhpZGluZywgbm8gY2hhbmdlIHRvIGVmZmVjdHMpLlxuICAgIGNhc2UgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFOlxuICAgIGNhc2UgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEU6XG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICB7XG4gICAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBudWxsLCBwcm9wcy5jaGlsZHJlbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgUkVBQ1RfT0ZGU0NSRUVOX1RZUEU6XG4gICAgICB7XG4gICAgICAgIHJlbmRlck9mZnNjcmVlbihyZXF1ZXN0LCB0YXNrLCBwcm9wcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAge1xuICAgICAgICBwdXNoQnVpbHRJbkNvbXBvbmVudFN0YWNrSW5ERVYodGFzaywgJ1N1c3BlbnNlTGlzdCcpOyAvLyBUT0RPOiBTdXNwZW5zZUxpc3Qgc2hvdWxkIGNvbnRyb2wgdGhlIGJvdW5kYXJpZXMuXG5cbiAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG51bGwsIHByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBSRUFDVF9TQ09QRV9UWVBFOlxuICAgICAge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVhY3RET01TZXJ2ZXIgZG9lcyBub3QgeWV0IHN1cHBvcnQgc2NvcGUgY29tcG9uZW50cy4nKTtcbiAgICAgIH1cblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHJlbmRlclN1c3BlbnNlQm91bmRhcnkocmVxdWVzdCwgdGFzaywgcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICByZW5kZXJGb3J3YXJkUmVmKHJlcXVlc3QsIHRhc2ssIHByZXZUaGVuYWJsZVN0YXRlLCB0eXBlLCBwcm9wcywgcmVmKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICByZW5kZXJNZW1vKHJlcXVlc3QsIHRhc2ssIHByZXZUaGVuYWJsZVN0YXRlLCB0eXBlLCBwcm9wcywgcmVmKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmVuZGVyQ29udGV4dFByb3ZpZGVyKHJlcXVlc3QsIHRhc2ssIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICByZW5kZXJDb250ZXh0Q29uc3VtZXIocmVxdWVzdCwgdGFzaywgdHlwZSwgcHJvcHMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHJlbmRlckxhenlDb21wb25lbnQocmVxdWVzdCwgdGFzaywgcHJldlRoZW5hYmxlU3RhdGUsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgaW5mbyA9ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgXCIgKyAnbmFtZWQgaW1wb3J0cy4nO1xuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gJyArICdjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpICcgKyAoXCJidXQgZ290OiBcIiArICh0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUpICsgXCIuXCIgKyBpbmZvKSk7XG59IC8vICRGbG93Rml4TWVbbWlzc2luZy1sb2NhbC1hbm5vdF1cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUl0ZXJhYmxlKGl0ZXJhYmxlLCBpdGVyYXRvckZuKSB7XG4gIHtcbiAgICAvLyBXZSBkb24ndCBzdXBwb3J0IHJlbmRlcmluZyBHZW5lcmF0b3JzIGJlY2F1c2UgaXQncyBhIG11dGF0aW9uLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEyOTk1XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgaXRlcmFibGVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0dlbmVyYXRvcicpIHtcbiAgICAgIGlmICghZGlkV2FybkFib3V0R2VuZXJhdG9ycykge1xuICAgICAgICBlcnJvcignVXNpbmcgR2VuZXJhdG9ycyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMgYmVjYXVzZSBlbnVtZXJhdGluZyBhIGdlbmVyYXRvciBtdXRhdGVzIGl0LiAnICsgJ1lvdSBtYXkgY29udmVydCBpdCB0byBhbiBhcnJheSB3aXRoIGBBcnJheS5mcm9tKClgIG9yIHRoZSAnICsgJ2BbLi4uc3ByZWFkXWAgb3BlcmF0b3IgYmVmb3JlIHJlbmRlcmluZy4gS2VlcCBpbiBtaW5kICcgKyAneW91IG1pZ2h0IG5lZWQgdG8gcG9seWZpbGwgdGhlc2UgZmVhdHVyZXMgZm9yIG9sZGVyIGJyb3dzZXJzLicpO1xuICAgICAgfVxuXG4gICAgICBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID0gdHJ1ZTtcbiAgICB9IC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuXG5cbiAgICBpZiAoaXRlcmFibGUuZW50cmllcyA9PT0gaXRlcmF0b3JGbikge1xuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNYXBzKSB7XG4gICAgICAgIGVycm9yKCdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4nKTtcbiAgICAgIH1cblxuICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCAvLyBUaGUgdGhlbmFibGUgc3RhdGUgcmV1c2VkIGZyb20gdGhlIHByZXZpb3VzIGF0dGVtcHQsIGlmIGFueS4gVGhpcyBpcyBhbG1vc3Rcbi8vIGFsd2F5cyBudWxsLCBleGNlcHQgd2hlbiBjYWxsZWQgYnkgcmV0cnlUYXNrLlxucHJldlRoZW5hYmxlU3RhdGUsIG5vZGUpIHtcbiAge1xuICAgIC8vIEluIERldiB3ZSB3cmFwIHJlbmRlck5vZGVEZXN0cnVjdGl2ZUltcGwgaW4gYSB0cnkgLyBjYXRjaCBzbyB3ZSBjYW4gY2FwdHVyZVxuICAgIC8vIGEgY29tcG9uZW50IHN0YWNrIGF0IHRoZSByaWdodCBwbGFjZSBpbiB0aGUgdHJlZS4gV2UgZG9uJ3QgZG8gdGhpcyBpbiByZW5kZXJOb2RlXG4gICAgLy8gYmVjdWFzZSBpdCBpcyBub3QgY2FsbGVkIGF0IGV2ZXJ5IGxheWVyIG9mIHRoZSB0cmVlIGFuZCB3ZSBtYXkgbG9zZSBmcmFtZXNcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHJlbmRlck5vZGVEZXN0cnVjdGl2ZUltcGwocmVxdWVzdCwgdGFzaywgcHJldlRoZW5hYmxlU3RhdGUsIG5vZGUpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCAmJiB0eXBlb2YgeC50aGVuID09PSAnZnVuY3Rpb24nKSA7IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGFuIGVycm9yLCBzdGFzaCB0aGUgY29tcG9uZW50IHN0YWNrIGlmIGl0IGlzIG51bGwuXG4gICAgICAgIGxhc3RCb3VuZGFyeUVycm9yQ29tcG9uZW50U3RhY2tEZXYgPSBsYXN0Qm91bmRhcnlFcnJvckNvbXBvbmVudFN0YWNrRGV2ICE9PSBudWxsID8gbGFzdEJvdW5kYXJ5RXJyb3JDb21wb25lbnRTdGFja0RldiA6IGdldEN1cnJlbnRTdGFja0luREVWKCk7XG4gICAgICB9IC8vIHJldGhyb3cgc28gbm9ybWFsIHN1c3BlbnNlIGxvZ2ljIGNhbiBoYW5kbGUgdGhyb3duIHZhbHVlIGFjY29yZGluZ2x5XG5cblxuICAgICAgdGhyb3cgeDtcbiAgICB9XG4gIH1cbn0gLy8gVGhpcyBmdW5jdGlvbiBieSBpdCBzZWxmIHJlbmRlcnMgYSBub2RlIGFuZCBjb25zdW1lcyB0aGUgdGFzayBieSBtdXRhdGluZyBpdFxuLy8gdG8gdXBkYXRlIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBzdGF0ZS5cblxuXG5mdW5jdGlvbiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmVJbXBsKHJlcXVlc3QsIHRhc2ssIHByZXZUaGVuYWJsZVN0YXRlLCBub2RlKSB7XG4gIC8vIFN0YXNoIHRoZSBub2RlIHdlJ3JlIHdvcmtpbmcgb24uIFdlJ2xsIHBpY2sgdXAgZnJvbSB0aGlzIHRhc2sgaW4gY2FzZVxuICAvLyBzb21ldGhpbmcgc3VzcGVuZHMuXG4gIHRhc2subm9kZSA9IG5vZGU7IC8vIEhhbmRsZSBvYmplY3QgdHlwZXNcblxuICBpZiAodHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIG5vZGUgIT09IG51bGwpIHtcbiAgICBzd2l0Y2ggKG5vZGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSBub2RlO1xuICAgICAgICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuICAgICAgICAgIHZhciBwcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gICAgICAgICAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICAgICAgICAgIHJlbmRlckVsZW1lbnQocmVxdWVzdCwgdGFzaywgcHJldlRoZW5hYmxlU3RhdGUsIHR5cGUsIHByb3BzLCByZWYpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvcnRhbHMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IHRoZSBzZXJ2ZXIgcmVuZGVyZXIuICcgKyAnUmVuZGVyIHRoZW0gY29uZGl0aW9uYWxseSBzbyB0aGF0IHRoZXkgb25seSBhcHBlYXIgb24gdGhlIGNsaWVudCByZW5kZXIuJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlOb2RlID0gbm9kZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlOb2RlLl9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eU5vZGUuX2luaXQ7XG4gICAgICAgICAgdmFyIHJlc29sdmVkTm9kZTtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlc29sdmVkTm9kZSA9IGluaXQocGF5bG9hZCk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCAmJiB0eXBlb2YgeC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBMYXp5IGluaXRpYWxpemVyIGlzIHN1c3BlbmRpbmcuIHB1c2ggYSB0ZW1wb3JhcnkgZnJhbWUgb250byB0aGUgc3RhY2sgc28gaXQgY2FuIGJlXG4gICAgICAgICAgICAgICAgLy8gcG9wcGVkIG9mZiBpbiBzcGF3bk5ld1N1c3BlbmRlZFRhc2suIFRoaXMgYWxpZ25zIHN0YWNrIGJlaGF2aW9yIGJldHdlZW4gTGF6eSBpbiBlbGVtZW50IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgLy8gdnMgQ29tcG9uZW50IHBvc2l0aW9uLiBXZSBkbyBub3Qgd2FudCB0aGUgZnJhbWUgZm9yIEVycm9ycyBzbyB3ZSBleGNsdXNpdmVseSBkbyB0aGlzIGluXG4gICAgICAgICAgICAgICAgLy8gdGhlIHdha2VhYmxlIGJyYW5jaFxuICAgICAgICAgICAgICAgIHB1c2hCdWlsdEluQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrLCAnTGF6eScpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhyb3cgeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbnVsbCwgcmVzb2x2ZWROb2RlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgcmVuZGVyQ2hpbGRyZW5BcnJheShyZXF1ZXN0LCB0YXNrLCBub2RlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAge1xuICAgICAgICB2YWxpZGF0ZUl0ZXJhYmxlKG5vZGUsIGl0ZXJhdG9yRm4pO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG5cbiAgICAgIGlmIChpdGVyYXRvcikge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGtub3cgaG93IG1hbnkgdG90YWwgY2hpbGRyZW4gYXJlIGluIHRoaXMgc2V0LCBzbyB0aGF0IHdlXG4gICAgICAgIC8vIGNhbiBhbGxvY2F0ZSBlbm91Z2ggaWQgc2xvdHMgdG8gYWNvbW1vZGF0ZSB0aGVtLiBTbyB3ZSBtdXN0IGV4aGF1c3RcbiAgICAgICAgLy8gdGhlIGl0ZXJhdG9yIGJlZm9yZSB3ZSBzdGFydCByZWN1cnNpdmVseSByZW5kZXJpbmcgdGhlIGNoaWxkcmVuLlxuICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIG5vdCBncmVhdCBidXQgSSB0aGluayBpdCdzIGluaGVyZW50IHRvIHRoZSBpZFxuICAgICAgICAvLyBnZW5lcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7IC8vIElmIHRoZXJlIGFyZSBub3QgZW50cmllcywgd2UgbmVlZCB0byBwdXNoIGFuIGVtcHR5IHNvIHdlIHN0YXJ0IGJ5IGNoZWNraW5nIHRoYXQuXG5cbiAgICAgICAgaWYgKCFzdGVwLmRvbmUpIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goc3RlcC52YWx1ZSk7XG4gICAgICAgICAgICBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIH0gd2hpbGUgKCFzdGVwLmRvbmUpO1xuXG4gICAgICAgICAgcmVuZGVyQ2hpbGRyZW5BcnJheShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gLy8gVXNhYmxlcyBhcmUgYSB2YWxpZCBSZWFjdCBub2RlIHR5cGUuIFdoZW4gUmVhY3QgZW5jb3VudGVycyBhIFVzYWJsZSBpblxuICAgIC8vIGEgY2hpbGQgcG9zaXRpb24sIGl0IHVud3JhcHMgaXQgdXNpbmcgdGhlIHNhbWUgYWxnb3JpdGhtIGFzIGB1c2VgLiBGb3JcbiAgICAvLyBleGFtcGxlLCBmb3IgcHJvbWlzZXMsIFJlYWN0IHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIHRvIHVud2luZCB0aGVcbiAgICAvLyBzdGFjaywgdGhlbiByZXBsYXkgdGhlIGNvbXBvbmVudCBvbmNlIHRoZSBwcm9taXNlIHJlc29sdmVzLlxuICAgIC8vXG4gICAgLy8gQSBkaWZmZXJlbmNlIGZyb20gYHVzZWAgaXMgdGhhdCBSZWFjdCB3aWxsIGtlZXAgdW53cmFwcGluZyB0aGUgdmFsdWVcbiAgICAvLyB1bnRpbCBpdCByZWFjaGVzIGEgbm9uLVVzYWJsZSB0eXBlLlxuICAgIC8vXG4gICAgLy8gZS5nLiBVc2FibGU8VXNhYmxlPFVzYWJsZTxUPj4+IHNob3VsZCByZXNvbHZlIHRvIFRcblxuXG4gICAgdmFyIG1heWJlVXNhYmxlID0gbm9kZTtcblxuICAgIGlmICh0eXBlb2YgbWF5YmVVc2FibGUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHRoZW5hYmxlID0gbWF5YmVVc2FibGU7XG4gICAgICByZXR1cm4gcmVuZGVyTm9kZURlc3RydWN0aXZlSW1wbChyZXF1ZXN0LCB0YXNrLCBudWxsLCB1bndyYXBUaGVuYWJsZSh0aGVuYWJsZSkpO1xuICAgIH1cblxuICAgIGlmIChtYXliZVVzYWJsZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IG1heWJlVXNhYmxlLiQkdHlwZW9mID09PSBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFKSB7XG4gICAgICB2YXIgY29udGV4dCA9IG1heWJlVXNhYmxlO1xuICAgICAgcmV0dXJuIHJlbmRlck5vZGVEZXN0cnVjdGl2ZUltcGwocmVxdWVzdCwgdGFzaywgbnVsbCwgcmVhZENvbnRleHQkMShjb250ZXh0KSk7XG4gICAgfSAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG5cblxuICAgIHZhciBjaGlsZFN0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChub2RlKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICsgKGNoaWxkU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMobm9kZSkuam9pbignLCAnKSArICd9JyA6IGNoaWxkU3RyaW5nKSArIFwiKS4gXCIgKyAnSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQuJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICAgIHNlZ21lbnQubGFzdFB1c2hlZFRleHQgPSBwdXNoVGV4dEluc3RhbmNlKHRhc2suYmxvY2tlZFNlZ21lbnQuY2h1bmtzLCBub2RlLCByZXF1ZXN0LnJlc3BvbnNlU3RhdGUsIHNlZ21lbnQubGFzdFB1c2hlZFRleHQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgX3NlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICAgIF9zZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gcHVzaFRleHRJbnN0YW5jZSh0YXNrLmJsb2NrZWRTZWdtZW50LmNodW5rcywgJycgKyBub2RlLCByZXF1ZXN0LnJlc3BvbnNlU3RhdGUsIF9zZWdtZW50Lmxhc3RQdXNoZWRUZXh0KTtcbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmICcgKyAneW91IHJldHVybiBhIENvbXBvbmVudCBpbnN0ZWFkIG9mIDxDb21wb25lbnQgLz4gZnJvbSByZW5kZXIuICcgKyAnT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNoaWxkcmVuQXJyYXkocmVxdWVzdCwgdGFzaywgY2hpbGRyZW4pIHtcbiAgdmFyIHRvdGFsQ2hpbGRyZW4gPSBjaGlsZHJlbi5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbENoaWxkcmVuOyBpKyspIHtcbiAgICB2YXIgcHJldlRyZWVDb250ZXh0ID0gdGFzay50cmVlQ29udGV4dDtcbiAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHVzaFRyZWVDb250ZXh0KHByZXZUcmVlQ29udGV4dCwgdG90YWxDaGlsZHJlbiwgaSk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gV2UgbmVlZCB0byB1c2UgdGhlIG5vbi1kZXN0cnVjdGl2ZSBmb3JtIHNvIHRoYXQgd2UgY2FuIHNhZmVseSBwb3AgYmFja1xuICAgICAgLy8gdXAgYW5kIHJlbmRlciB0aGUgc2libGluZyBpZiBzb21ldGhpbmcgc3VzcGVuZHMuXG4gICAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuW2ldKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGFzay50cmVlQ29udGV4dCA9IHByZXZUcmVlQ29udGV4dDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3Bhd25OZXdTdXNwZW5kZWRUYXNrKHJlcXVlc3QsIHRhc2ssIHRoZW5hYmxlU3RhdGUsIHgpIHtcbiAgLy8gU29tZXRoaW5nIHN1c3BlbmRlZCwgd2UnbGwgbmVlZCB0byBjcmVhdGUgYSBuZXcgc2VnbWVudCBhbmQgcmVzb2x2ZSBpdCBsYXRlci5cbiAgdmFyIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICB2YXIgaW5zZXJ0aW9uSW5kZXggPSBzZWdtZW50LmNodW5rcy5sZW5ndGg7XG4gIHZhciBuZXdTZWdtZW50ID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQocmVxdWVzdCwgaW5zZXJ0aW9uSW5kZXgsIG51bGwsIHNlZ21lbnQuZm9ybWF0Q29udGV4dCwgLy8gQWRvcHQgdGhlIHBhcmVudCBzZWdtZW50J3MgbGVhZGluZyB0ZXh0IGVtYmVkXG4gIHNlZ21lbnQubGFzdFB1c2hlZFRleHQsIC8vIEFzc3VtZSB3ZSBhcmUgdGV4dCBlbWJlZGRlZCBhdCB0aGUgdHJhaWxpbmcgZWRnZVxuICB0cnVlKTtcbiAgc2VnbWVudC5jaGlsZHJlbi5wdXNoKG5ld1NlZ21lbnQpOyAvLyBSZXNldCBsYXN0UHVzaGVkVGV4dCBmb3IgY3VycmVudCBTZWdtZW50IHNpbmNlIHRoZSBuZXcgU2VnbWVudCBcImNvbnN1bWVkXCIgaXRcblxuICBzZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gZmFsc2U7XG4gIHZhciBuZXdUYXNrID0gY3JlYXRlVGFzayhyZXF1ZXN0LCB0aGVuYWJsZVN0YXRlLCB0YXNrLm5vZGUsIHRhc2suYmxvY2tlZEJvdW5kYXJ5LCBuZXdTZWdtZW50LCB0YXNrLmFib3J0U2V0LCB0YXNrLmxlZ2FjeUNvbnRleHQsIHRhc2suY29udGV4dCwgdGFzay50cmVlQ29udGV4dCk7XG5cbiAge1xuICAgIGlmICh0YXNrLmNvbXBvbmVudFN0YWNrICE9PSBudWxsKSB7XG4gICAgICAvLyBXZSBwb3Agb25lIHRhc2sgb2ZmIHRoZSBzdGFjayBiZWNhdXNlIHRoZSBub2RlIHRoYXQgc3VzcGVuZGVkIHdpbGwgYmUgdHJpZWQgYWdhaW4sXG4gICAgICAvLyB3aGljaCB3aWxsIGFkZCBpdCBiYWNrIG9udG8gdGhlIHN0YWNrLlxuICAgICAgbmV3VGFzay5jb21wb25lbnRTdGFjayA9IHRhc2suY29tcG9uZW50U3RhY2sucGFyZW50O1xuICAgIH1cbiAgfVxuXG4gIHZhciBwaW5nID0gbmV3VGFzay5waW5nO1xuICB4LnRoZW4ocGluZywgcGluZyk7XG59IC8vIFRoaXMgaXMgYSBub24tZGVzdHJ1Y3RpdmUgZm9ybSBvZiByZW5kZXJpbmcgYSBub2RlLiBJZiBpdCBzdXNwZW5kcyBpdCBzcGF3bnNcbi8vIGEgbmV3IHRhc2sgYW5kIHJlc3RvcmVzIHRoZSBjb250ZXh0IG9mIHRoaXMgdGFzayB0byB3aGF0IGl0IHdhcyBiZWZvcmUuXG5cblxuZnVuY3Rpb24gcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBub2RlKSB7XG4gIC8vIFN0b3JlIGhvdyBtdWNoIHdlJ3ZlIHB1c2hlZCBhdCB0aGlzIHBvaW50IHNvIHdlIGNhbiByZXNldCBpdCBpbiBjYXNlIHNvbWV0aGluZ1xuICAvLyBzdXNwZW5kZWQgcGFydGlhbGx5IHRocm91Z2ggd3JpdGluZyBzb21ldGhpbmcuXG4gIHZhciBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gc2VnbWVudC5jaGlsZHJlbi5sZW5ndGg7XG4gIHZhciBjaHVua0xlbmd0aCA9IHNlZ21lbnQuY2h1bmtzLmxlbmd0aDsgLy8gU25hcHNob3QgdGhlIGN1cnJlbnQgY29udGV4dCBpbiBjYXNlIHNvbWV0aGluZyB0aHJvd3MgdG8gaW50ZXJydXB0IHRoZVxuICAvLyBwcm9jZXNzLlxuXG4gIHZhciBwcmV2aW91c0Zvcm1hdENvbnRleHQgPSB0YXNrLmJsb2NrZWRTZWdtZW50LmZvcm1hdENvbnRleHQ7XG4gIHZhciBwcmV2aW91c0xlZ2FjeUNvbnRleHQgPSB0YXNrLmxlZ2FjeUNvbnRleHQ7XG4gIHZhciBwcmV2aW91c0NvbnRleHQgPSB0YXNrLmNvbnRleHQ7XG4gIHZhciBwcmV2aW91c0NvbXBvbmVudFN0YWNrID0gbnVsbDtcblxuICB7XG4gICAgcHJldmlvdXNDb21wb25lbnRTdGFjayA9IHRhc2suY29tcG9uZW50U3RhY2s7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbnVsbCwgbm9kZSk7XG4gIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgcmVzZXRIb29rc1N0YXRlKCk7IC8vIFJlc2V0IHRoZSB3cml0ZSBwb2ludGVycyB0byB3aGVyZSB3ZSBzdGFydGVkLlxuXG4gICAgc2VnbWVudC5jaGlsZHJlbi5sZW5ndGggPSBjaGlsZHJlbkxlbmd0aDtcbiAgICBzZWdtZW50LmNodW5rcy5sZW5ndGggPSBjaHVua0xlbmd0aDtcbiAgICB2YXIgeCA9IHRocm93blZhbHVlID09PSBTdXNwZW5zZUV4Y2VwdGlvbiA/IC8vIFRoaXMgaXMgYSBzcGVjaWFsIHR5cGUgb2YgZXhjZXB0aW9uIHVzZWQgZm9yIFN1c3BlbnNlLiBGb3IgaGlzdG9yaWNhbFxuICAgIC8vIHJlYXNvbnMsIHRoZSByZXN0IG9mIHRoZSBTdXNwZW5zZSBpbXBsZW1lbnRhdGlvbiBleHBlY3RzIHRoZSB0aHJvd25cbiAgICAvLyB2YWx1ZSB0byBiZSBhIHRoZW5hYmxlLCBiZWNhdXNlIGJlZm9yZSBgdXNlYCBleGlzdGVkIHRoYXQgd2FzIHRoZVxuICAgIC8vICh1bnN0YWJsZSkgQVBJIGZvciBzdXNwZW5kaW5nLiBUaGlzIGltcGxlbWVudGF0aW9uIGRldGFpbCBjYW4gY2hhbmdlXG4gICAgLy8gbGF0ZXIsIG9uY2Ugd2UgZGVwcmVjYXRlIHRoZSBvbGQgQVBJIGluIGZhdm9yIG9mIGB1c2VgLlxuICAgIGdldFN1c3BlbmRlZFRoZW5hYmxlKCkgOiB0aHJvd25WYWx1ZTsgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuXG4gICAgaWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsICYmIHR5cGVvZiB4LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciB3YWtlYWJsZSA9IHg7XG4gICAgICB2YXIgdGhlbmFibGVTdGF0ZSA9IGdldFRoZW5hYmxlU3RhdGVBZnRlclN1c3BlbmRpbmcoKTtcbiAgICAgIHNwYXduTmV3U3VzcGVuZGVkVGFzayhyZXF1ZXN0LCB0YXNrLCB0aGVuYWJsZVN0YXRlLCB3YWtlYWJsZSk7IC8vIFJlc3RvcmUgdGhlIGNvbnRleHQuIFdlIGFzc3VtZSB0aGF0IHRoaXMgd2lsbCBiZSByZXN0b3JlZCBieSB0aGUgaW5uZXJcbiAgICAgIC8vIGZ1bmN0aW9ucyBpbiBjYXNlIG5vdGhpbmcgdGhyb3dzIHNvIHdlIGRvbid0IHVzZSBcImZpbmFsbHlcIiBoZXJlLlxuXG4gICAgICB0YXNrLmJsb2NrZWRTZWdtZW50LmZvcm1hdENvbnRleHQgPSBwcmV2aW91c0Zvcm1hdENvbnRleHQ7XG4gICAgICB0YXNrLmxlZ2FjeUNvbnRleHQgPSBwcmV2aW91c0xlZ2FjeUNvbnRleHQ7XG4gICAgICB0YXNrLmNvbnRleHQgPSBwcmV2aW91c0NvbnRleHQ7IC8vIFJlc3RvcmUgYWxsIGFjdGl2ZSBSZWFjdENvbnRleHRzIHRvIHdoYXQgdGhleSB3ZXJlIGJlZm9yZS5cblxuICAgICAgc3dpdGNoQ29udGV4dChwcmV2aW91c0NvbnRleHQpO1xuXG4gICAgICB7XG4gICAgICAgIHRhc2suY29tcG9uZW50U3RhY2sgPSBwcmV2aW91c0NvbXBvbmVudFN0YWNrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlc3RvcmUgdGhlIGNvbnRleHQuIFdlIGFzc3VtZSB0aGF0IHRoaXMgd2lsbCBiZSByZXN0b3JlZCBieSB0aGUgaW5uZXJcbiAgICAgIC8vIGZ1bmN0aW9ucyBpbiBjYXNlIG5vdGhpbmcgdGhyb3dzIHNvIHdlIGRvbid0IHVzZSBcImZpbmFsbHlcIiBoZXJlLlxuICAgICAgdGFzay5ibG9ja2VkU2VnbWVudC5mb3JtYXRDb250ZXh0ID0gcHJldmlvdXNGb3JtYXRDb250ZXh0O1xuICAgICAgdGFzay5sZWdhY3lDb250ZXh0ID0gcHJldmlvdXNMZWdhY3lDb250ZXh0O1xuICAgICAgdGFzay5jb250ZXh0ID0gcHJldmlvdXNDb250ZXh0OyAvLyBSZXN0b3JlIGFsbCBhY3RpdmUgUmVhY3RDb250ZXh0cyB0byB3aGF0IHRoZXkgd2VyZSBiZWZvcmUuXG5cbiAgICAgIHN3aXRjaENvbnRleHQocHJldmlvdXNDb250ZXh0KTtcblxuICAgICAge1xuICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgICAgIH0gLy8gV2UgYXNzdW1lIHRoYXQgd2UgZG9uJ3QgbmVlZCB0aGUgY29ycmVjdCBjb250ZXh0LlxuICAgICAgLy8gTGV0J3MgdGVybWluYXRlIHRoZSByZXN0IG9mIHRoZSB0cmVlIGFuZCBkb24ndCByZW5kZXIgYW55IHNpYmxpbmdzLlxuXG5cbiAgICAgIHRocm93IHg7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGVycm9yZWRUYXNrKHJlcXVlc3QsIGJvdW5kYXJ5LCBzZWdtZW50LCBlcnJvcikge1xuICAvLyBSZXBvcnQgdGhlIGVycm9yIHRvIGEgZ2xvYmFsIGhhbmRsZXIuXG4gIHZhciBlcnJvckRpZ2VzdCA9IGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuXG4gIGlmIChib3VuZGFyeSA9PT0gbnVsbCkge1xuICAgIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICB9IGVsc2Uge1xuICAgIGJvdW5kYXJ5LnBlbmRpbmdUYXNrcy0tO1xuXG4gICAgaWYgKCFib3VuZGFyeS5mb3JjZUNsaWVudFJlbmRlcikge1xuICAgICAgYm91bmRhcnkuZm9yY2VDbGllbnRSZW5kZXIgPSB0cnVlO1xuICAgICAgYm91bmRhcnkuZXJyb3JEaWdlc3QgPSBlcnJvckRpZ2VzdDtcblxuICAgICAge1xuICAgICAgICBjYXB0dXJlQm91bmRhcnlFcnJvckRldGFpbHNEZXYoYm91bmRhcnksIGVycm9yKTtcbiAgICAgIH0gLy8gUmVnYXJkbGVzcyBvZiB3aGF0IGhhcHBlbnMgbmV4dCwgdGhpcyBib3VuZGFyeSB3b24ndCBiZSBkaXNwbGF5ZWQsXG4gICAgICAvLyBzbyB3ZSBjYW4gZmx1c2ggaXQsIGlmIHRoZSBwYXJlbnQgYWxyZWFkeSBmbHVzaGVkLlxuXG5cbiAgICAgIGlmIChib3VuZGFyeS5wYXJlbnRGbHVzaGVkKSB7XG4gICAgICAgIC8vIFdlIGRvbid0IGhhdmUgYSBwcmVmZXJlbmNlIHdoZXJlIGluIHRoZSBxdWV1ZSB0aGlzIGdvZXMgc2luY2UgaXQncyBsaWtlbHlcbiAgICAgICAgLy8gdG8gZXJyb3Igb24gdGhlIGNsaWVudCBhbnl3YXkuIEhvd2V2ZXIsIGludGVudGlvbmFsbHkgY2xpZW50LXJlbmRlcmVkXG4gICAgICAgIC8vIGJvdW5kYXJpZXMgc2hvdWxkIGJlIGZsdXNoZWQgZWFybGllciBzbyB0aGF0IHRoZXkgY2FuIHN0YXJ0IG9uIHRoZSBjbGllbnQuXG4gICAgICAgIC8vIFdlIHJldXNlIHRoZSBzYW1lIHF1ZXVlIGZvciBlcnJvcnMuXG4gICAgICAgIHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzLS07XG5cbiAgaWYgKHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzID09PSAwKSB7XG4gICAgdmFyIG9uQWxsUmVhZHkgPSByZXF1ZXN0Lm9uQWxsUmVhZHk7XG4gICAgb25BbGxSZWFkeSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFib3J0VGFza1NvZnQodGFzaykge1xuICAvLyBUaGlzIGFib3J0cyB0YXNrIHdpdGhvdXQgYWJvcnRpbmcgdGhlIHBhcmVudCBib3VuZGFyeSB0aGF0IGl0IGJsb2Nrcy5cbiAgLy8gSXQncyB1c2VkIGZvciB3aGVuIHdlIGRpZG4ndCBuZWVkIHRoaXMgdGFzayB0byBjb21wbGV0ZSB0aGUgdHJlZS5cbiAgLy8gSWYgdGFzayB3YXMgbmVlZGVkLCB0aGVuIGl0IHNob3VsZCB1c2UgYWJvcnRUYXNrIGluc3RlYWQuXG4gIHZhciByZXF1ZXN0ID0gdGhpcztcbiAgdmFyIGJvdW5kYXJ5ID0gdGFzay5ibG9ja2VkQm91bmRhcnk7XG4gIHZhciBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcbiAgc2VnbWVudC5zdGF0dXMgPSBBQk9SVEVEO1xuICBmaW5pc2hlZFRhc2socmVxdWVzdCwgYm91bmRhcnksIHNlZ21lbnQpO1xufVxuXG5mdW5jdGlvbiBhYm9ydFRhc2sodGFzaywgcmVxdWVzdCwgZXJyb3IpIHtcbiAgLy8gVGhpcyBhYm9ydHMgdGhlIHRhc2sgYW5kIGFib3J0cyB0aGUgcGFyZW50IHRoYXQgaXQgYmxvY2tzLCBwdXR0aW5nIGl0IGludG9cbiAgLy8gY2xpZW50IHJlbmRlcmVkIG1vZGUuXG4gIHZhciBib3VuZGFyeSA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5O1xuICB2YXIgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG4gIHNlZ21lbnQuc3RhdHVzID0gQUJPUlRFRDtcblxuICBpZiAoYm91bmRhcnkgPT09IG51bGwpIHtcbiAgICByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcy0tOyAvLyBXZSBkaWRuJ3QgY29tcGxldGUgdGhlIHJvb3Qgc28gd2UgaGF2ZSBub3RoaW5nIHRvIHNob3cuIFdlIGNhbiBjbG9zZVxuICAgIC8vIHRoZSByZXF1ZXN0O1xuXG4gICAgaWYgKHJlcXVlc3Quc3RhdHVzICE9PSBDTE9TSU5HICYmIHJlcXVlc3Quc3RhdHVzICE9PSBDTE9TRUQpIHtcbiAgICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICAgICAgZmF0YWxFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJvdW5kYXJ5LnBlbmRpbmdUYXNrcy0tO1xuXG4gICAgaWYgKCFib3VuZGFyeS5mb3JjZUNsaWVudFJlbmRlcikge1xuICAgICAgYm91bmRhcnkuZm9yY2VDbGllbnRSZW5kZXIgPSB0cnVlO1xuICAgICAgYm91bmRhcnkuZXJyb3JEaWdlc3QgPSByZXF1ZXN0Lm9uRXJyb3IoZXJyb3IpO1xuXG4gICAgICB7XG4gICAgICAgIHZhciBlcnJvclByZWZpeCA9ICdUaGUgc2VydmVyIGRpZCBub3QgZmluaXNoIHRoaXMgU3VzcGVuc2UgYm91bmRhcnk6ICc7XG4gICAgICAgIHZhciBlcnJvck1lc3NhZ2U7XG5cbiAgICAgICAgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yUHJlZml4ICsgZXJyb3IubWVzc2FnZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvclByZWZpeCArIFN0cmluZyhlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJldmlvdXNUYXNrSW5EZXYgPSBjdXJyZW50VGFza0luREVWO1xuICAgICAgICBjdXJyZW50VGFza0luREVWID0gdGFzaztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNhcHR1cmVCb3VuZGFyeUVycm9yRGV0YWlsc0Rldihib3VuZGFyeSwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBjdXJyZW50VGFza0luREVWID0gcHJldmlvdXNUYXNrSW5EZXY7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGJvdW5kYXJ5LnBhcmVudEZsdXNoZWQpIHtcbiAgICAgICAgcmVxdWVzdC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSk7XG4gICAgICB9XG4gICAgfSAvLyBJZiB0aGlzIGJvdW5kYXJ5IHdhcyBzdGlsbCBwZW5kaW5nIHRoZW4gd2UgaGF2ZW4ndCBhbHJlYWR5IGNhbmNlbGxlZCBpdHMgZmFsbGJhY2tzLlxuICAgIC8vIFdlJ2xsIG5lZWQgdG8gYWJvcnQgdGhlIGZhbGxiYWNrcywgd2hpY2ggd2lsbCBhbHNvIGVycm9yIHRoYXQgcGFyZW50IGJvdW5kYXJ5LlxuXG5cbiAgICBib3VuZGFyeS5mYWxsYmFja0Fib3J0YWJsZVRhc2tzLmZvckVhY2goZnVuY3Rpb24gKGZhbGxiYWNrVGFzaykge1xuICAgICAgcmV0dXJuIGFib3J0VGFzayhmYWxsYmFja1Rhc2ssIHJlcXVlc3QsIGVycm9yKTtcbiAgICB9KTtcbiAgICBib3VuZGFyeS5mYWxsYmFja0Fib3J0YWJsZVRhc2tzLmNsZWFyKCk7XG4gICAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MtLTtcblxuICAgIGlmIChyZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcyA9PT0gMCkge1xuICAgICAgdmFyIG9uQWxsUmVhZHkgPSByZXF1ZXN0Lm9uQWxsUmVhZHk7XG4gICAgICBvbkFsbFJlYWR5KCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHF1ZXVlQ29tcGxldGVkU2VnbWVudChib3VuZGFyeSwgc2VnbWVudCkge1xuICBpZiAoc2VnbWVudC5jaHVua3MubGVuZ3RoID09PSAwICYmIHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIHNlZ21lbnQuY2hpbGRyZW5bMF0uYm91bmRhcnkgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIGFuIGVtcHR5IHNlZ21lbnQuIFRoZXJlJ3Mgbm90aGluZyB0byB3cml0ZSwgc28gd2UgY2FuIGluc3RlYWQgdHJhbnNmZXIgdGhlIElEXG4gICAgLy8gdG8gdGhlIGNoaWxkLiBUaGF0IHdheSBhbnkgZXhpc3RpbmcgcmVmZXJlbmNlcyBwb2ludCB0byB0aGUgY2hpbGQuXG4gICAgdmFyIGNoaWxkU2VnbWVudCA9IHNlZ21lbnQuY2hpbGRyZW5bMF07XG4gICAgY2hpbGRTZWdtZW50LmlkID0gc2VnbWVudC5pZDtcbiAgICBjaGlsZFNlZ21lbnQucGFyZW50Rmx1c2hlZCA9IHRydWU7XG5cbiAgICBpZiAoY2hpbGRTZWdtZW50LnN0YXR1cyA9PT0gQ09NUExFVEVEKSB7XG4gICAgICBxdWV1ZUNvbXBsZXRlZFNlZ21lbnQoYm91bmRhcnksIGNoaWxkU2VnbWVudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjb21wbGV0ZWRTZWdtZW50cyA9IGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzO1xuICAgIGNvbXBsZXRlZFNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoZWRUYXNrKHJlcXVlc3QsIGJvdW5kYXJ5LCBzZWdtZW50KSB7XG4gIGlmIChib3VuZGFyeSA9PT0gbnVsbCkge1xuICAgIGlmIChzZWdtZW50LnBhcmVudEZsdXNoZWQpIHtcbiAgICAgIGlmIChyZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgY2FuIG9ubHkgYmUgb25lIHJvb3Qgc2VnbWVudC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgfVxuXG4gICAgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzLS07XG5cbiAgICBpZiAocmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzID09PSAwKSB7XG4gICAgICAvLyBXZSBoYXZlIGNvbXBsZXRlZCB0aGUgc2hlbGwgc28gdGhlIHNoZWxsIGNhbid0IGVycm9yIGFueW1vcmUuXG4gICAgICByZXF1ZXN0Lm9uU2hlbGxFcnJvciA9IG5vb3A7XG4gICAgICB2YXIgb25TaGVsbFJlYWR5ID0gcmVxdWVzdC5vblNoZWxsUmVhZHk7XG4gICAgICBvblNoZWxsUmVhZHkoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYm91bmRhcnkucGVuZGluZ1Rhc2tzLS07XG5cbiAgICBpZiAoYm91bmRhcnkuZm9yY2VDbGllbnRSZW5kZXIpIDsgZWxzZSBpZiAoYm91bmRhcnkucGVuZGluZ1Rhc2tzID09PSAwKSB7XG4gICAgICAvLyBUaGlzIG11c3QgaGF2ZSBiZWVuIHRoZSBsYXN0IHNlZ21lbnQgd2Ugd2VyZSB3YWl0aW5nIG9uLiBUaGlzIGJvdW5kYXJ5IGlzIG5vdyBjb21wbGV0ZS5cbiAgICAgIGlmIChzZWdtZW50LnBhcmVudEZsdXNoZWQpIHtcbiAgICAgICAgLy8gT3VyIHBhcmVudCBzZWdtZW50IGFscmVhZHkgZmx1c2hlZCwgc28gd2UgbmVlZCB0byBzY2hlZHVsZSB0aGlzIHNlZ21lbnQgdG8gYmUgZW1pdHRlZC5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSBzZWdtZW50IHRoYXQgd2FzIGFib3J0ZWQsIHdlJ2xsIHdyaXRlIG90aGVyIGNvbnRlbnQgaW5zdGVhZCBzbyB3ZSBkb24ndCBuZWVkXG4gICAgICAgIC8vIHRvIGVtaXQgaXQuXG4gICAgICAgIGlmIChzZWdtZW50LnN0YXR1cyA9PT0gQ09NUExFVEVEKSB7XG4gICAgICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBzZWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYm91bmRhcnkucGFyZW50Rmx1c2hlZCkge1xuICAgICAgICAvLyBUaGUgc2VnbWVudCBtaWdodCBiZSBwYXJ0IG9mIGEgc2VnbWVudCB0aGF0IGRpZG4ndCBmbHVzaCB5ZXQsIGJ1dCBpZiB0aGUgYm91bmRhcnknc1xuICAgICAgICAvLyBwYXJlbnQgZmx1c2hlZCwgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGUgYm91bmRhcnkgdG8gYmUgZW1pdHRlZC5cbiAgICAgICAgcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpO1xuICAgICAgfSAvLyBXZSBjYW4gbm93IGNhbmNlbCBhbnkgcGVuZGluZyB0YXNrIG9uIHRoZSBmYWxsYmFjayBzaW5jZSB3ZSB3b24ndCBuZWVkIHRvIHNob3cgaXQgYW55bW9yZS5cbiAgICAgIC8vIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGFmdGVyIHdlIHJlYWQgdGhlIHBhcmVudEZsdXNoZWQgZmxhZ3MgYmVjYXVzZSBhYm9ydGluZyBjYW4gZmluaXNoXG4gICAgICAvLyB3b3JrIHdoaWNoIGNhbiB0cmlnZ2VyIHVzZXIgY29kZSwgd2hpY2ggY2FuIHN0YXJ0IGZsdXNoaW5nLCB3aGljaCBjYW4gY2hhbmdlIHRob3NlIGZsYWdzLlxuXG5cbiAgICAgIGJvdW5kYXJ5LmZhbGxiYWNrQWJvcnRhYmxlVGFza3MuZm9yRWFjaChhYm9ydFRhc2tTb2Z0LCByZXF1ZXN0KTtcbiAgICAgIGJvdW5kYXJ5LmZhbGxiYWNrQWJvcnRhYmxlVGFza3MuY2xlYXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNlZ21lbnQucGFyZW50Rmx1c2hlZCkge1xuICAgICAgICAvLyBPdXIgcGFyZW50IGFscmVhZHkgZmx1c2hlZCwgc28gd2UgbmVlZCB0byBzY2hlZHVsZSB0aGlzIHNlZ21lbnQgdG8gYmUgZW1pdHRlZC5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSBzZWdtZW50IHRoYXQgd2FzIGFib3J0ZWQsIHdlJ2xsIHdyaXRlIG90aGVyIGNvbnRlbnQgaW5zdGVhZCBzbyB3ZSBkb24ndCBuZWVkXG4gICAgICAgIC8vIHRvIGVtaXQgaXQuXG4gICAgICAgIGlmIChzZWdtZW50LnN0YXR1cyA9PT0gQ09NUExFVEVEKSB7XG4gICAgICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBzZWdtZW50KTtcbiAgICAgICAgICB2YXIgY29tcGxldGVkU2VnbWVudHMgPSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cztcblxuICAgICAgICAgIGlmIChjb21wbGV0ZWRTZWdtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgc2luY2Ugd2UgbGFzdCBmbHVzaGVkIHRoYXQgd2UgY29tcGxldGVkIGFueXRoaW5nLlxuICAgICAgICAgICAgLy8gV2UgY2FuIHNjaGVkdWxlIHRoaXMgYm91bmRhcnkgdG8gZW1pdCBpdHMgcGFydGlhbGx5IGNvbXBsZXRlZCBzZWdtZW50cyBlYXJseVxuICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgcGFyZW50IGhhcyBhbHJlYWR5IGJlZW4gZmx1c2hlZC5cbiAgICAgICAgICAgIGlmIChib3VuZGFyeS5wYXJlbnRGbHVzaGVkKSB7XG4gICAgICAgICAgICAgIHJlcXVlc3QucGFydGlhbEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MtLTtcblxuICBpZiAocmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgPT09IDApIHtcbiAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGNhbGxlZCBhdCB0aGUgdmVyeSBlbmQgc28gdGhhdCB3ZSBjYW4gc3luY2hyb25vdXNseSB3cml0ZSB0aGUgcmVzdWx0XG4gICAgLy8gaW4gdGhlIGNhbGxiYWNrIGlmIG5lZWRlZC5cbiAgICB2YXIgb25BbGxSZWFkeSA9IHJlcXVlc3Qub25BbGxSZWFkeTtcbiAgICBvbkFsbFJlYWR5KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmV0cnlUYXNrKHJlcXVlc3QsIHRhc2spIHtcbiAge1xuICAgIHZhciBibG9ja2VkQm91bmRhcnkgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeTtcbiAgICBzZXRDdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeVJlc291cmNlc1RhcmdldChyZXF1ZXN0LnJlc291cmNlcywgYmxvY2tlZEJvdW5kYXJ5ID8gYmxvY2tlZEJvdW5kYXJ5LnJlc291cmNlcyA6IG51bGwpO1xuICB9XG5cbiAgdmFyIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuXG4gIGlmIChzZWdtZW50LnN0YXR1cyAhPT0gUEVORElORykge1xuICAgIC8vIFdlIGNvbXBsZXRlZCB0aGlzIGJ5IG90aGVyIG1lYW5zIGJlZm9yZSB3ZSBoYWQgYSBjaGFuY2UgdG8gcmV0cnkgaXQuXG4gICAgcmV0dXJuO1xuICB9IC8vIFdlIHJlc3RvcmUgdGhlIGNvbnRleHQgdG8gd2hhdCBpdCB3YXMgd2hlbiB3ZSBzdXNwZW5kZWQuXG4gIC8vIFdlIGRvbid0IHJlc3RvcmUgaXQgYWZ0ZXIgd2UgbGVhdmUgYmVjYXVzZSBpdCdzIGxpa2VseSB0aGF0IHdlJ2xsIGVuZCB1cFxuICAvLyBuZWVkaW5nIGEgdmVyeSBzaW1pbGFyIGNvbnRleHQgc29vbiBhZ2Fpbi5cblxuXG4gIHN3aXRjaENvbnRleHQodGFzay5jb250ZXh0KTtcbiAgdmFyIHByZXZUYXNrSW5ERVYgPSBudWxsO1xuXG4gIHtcbiAgICBwcmV2VGFza0luREVWID0gY3VycmVudFRhc2tJbkRFVjtcbiAgICBjdXJyZW50VGFza0luREVWID0gdGFzaztcbiAgfVxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoO1xuICB2YXIgY2h1bmtMZW5ndGggPSBzZWdtZW50LmNodW5rcy5sZW5ndGg7XG5cbiAgdHJ5IHtcbiAgICAvLyBXZSBjYWxsIHRoZSBkZXN0cnVjdGl2ZSBmb3JtIHRoYXQgbXV0YXRlcyB0aGlzIHRhc2suIFRoYXQgd2F5IGlmIHNvbWV0aGluZ1xuICAgIC8vIHN1c3BlbmRzIGFnYWluLCB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdGFzayBpbnN0ZWFkIG9mIHNwYXduaW5nIGEgbmV3IG9uZS5cbiAgICAvLyBSZXNldCB0aGUgdGFzaydzIHRoZW5hYmxlIHN0YXRlIGJlZm9yZSBjb250aW51aW5nLCBzbyB0aGF0IGlmIGEgbGF0ZXJcbiAgICAvLyBjb21wb25lbnQgc3VzcGVuZHMgd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRhc2sgb2JqZWN0LiBJZiB0aGUgc2FtZVxuICAgIC8vIGNvbXBvbmVudCBzdXNwZW5kcyBhZ2FpbiwgdGhlIHRoZW5hYmxlIHN0YXRlIHdpbGwgYmUgcmVzdG9yZWQuXG4gICAgdmFyIHByZXZUaGVuYWJsZVN0YXRlID0gdGFzay50aGVuYWJsZVN0YXRlO1xuICAgIHRhc2sudGhlbmFibGVTdGF0ZSA9IG51bGw7XG4gICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIHByZXZUaGVuYWJsZVN0YXRlLCB0YXNrLm5vZGUpO1xuICAgIHB1c2hTZWdtZW50RmluYWxlKHNlZ21lbnQuY2h1bmtzLCByZXF1ZXN0LnJlc3BvbnNlU3RhdGUsIHNlZ21lbnQubGFzdFB1c2hlZFRleHQsIHNlZ21lbnQudGV4dEVtYmVkZGVkKTtcbiAgICB0YXNrLmFib3J0U2V0LmRlbGV0ZSh0YXNrKTtcbiAgICBzZWdtZW50LnN0YXR1cyA9IENPTVBMRVRFRDtcbiAgICBmaW5pc2hlZFRhc2socmVxdWVzdCwgdGFzay5ibG9ja2VkQm91bmRhcnksIHNlZ21lbnQpO1xuICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgIHJlc2V0SG9va3NTdGF0ZSgpOyAvLyBSZXNldCB0aGUgd3JpdGUgcG9pbnRlcnMgdG8gd2hlcmUgd2Ugc3RhcnRlZC5cblxuICAgIHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoID0gY2hpbGRyZW5MZW5ndGg7XG4gICAgc2VnbWVudC5jaHVua3MubGVuZ3RoID0gY2h1bmtMZW5ndGg7XG4gICAgdmFyIHggPSB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb24gPyAvLyBUaGlzIGlzIGEgc3BlY2lhbCB0eXBlIG9mIGV4Y2VwdGlvbiB1c2VkIGZvciBTdXNwZW5zZS4gRm9yIGhpc3RvcmljYWxcbiAgICAvLyByZWFzb25zLCB0aGUgcmVzdCBvZiB0aGUgU3VzcGVuc2UgaW1wbGVtZW50YXRpb24gZXhwZWN0cyB0aGUgdGhyb3duXG4gICAgLy8gdmFsdWUgdG8gYmUgYSB0aGVuYWJsZSwgYmVjYXVzZSBiZWZvcmUgYHVzZWAgZXhpc3RlZCB0aGF0IHdhcyB0aGVcbiAgICAvLyAodW5zdGFibGUpIEFQSSBmb3Igc3VzcGVuZGluZy4gVGhpcyBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgY2FuIGNoYW5nZVxuICAgIC8vIGxhdGVyLCBvbmNlIHdlIGRlcHJlY2F0ZSB0aGUgb2xkIEFQSSBpbiBmYXZvciBvZiBgdXNlYC5cbiAgICBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpIDogdGhyb3duVmFsdWU7IC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cblxuICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCAmJiB0eXBlb2YgeC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBTb21ldGhpbmcgc3VzcGVuZGVkIGFnYWluLCBsZXQncyBwaWNrIGl0IGJhY2sgdXAgbGF0ZXIuXG4gICAgICB2YXIgcGluZyA9IHRhc2sucGluZztcbiAgICAgIHgudGhlbihwaW5nLCBwaW5nKTtcbiAgICAgIHRhc2sudGhlbmFibGVTdGF0ZSA9IGdldFRoZW5hYmxlU3RhdGVBZnRlclN1c3BlbmRpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFzay5hYm9ydFNldC5kZWxldGUodGFzayk7XG4gICAgICBzZWdtZW50LnN0YXR1cyA9IEVSUk9SRUQ7XG4gICAgICBlcnJvcmVkVGFzayhyZXF1ZXN0LCB0YXNrLmJsb2NrZWRCb3VuZGFyeSwgc2VnbWVudCwgeCk7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHtcbiAgICAgIHNldEN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5UmVzb3VyY2VzVGFyZ2V0KHJlcXVlc3QucmVzb3VyY2VzLCBudWxsKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBjdXJyZW50VGFza0luREVWID0gcHJldlRhc2tJbkRFVjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGVyZm9ybVdvcmsocmVxdWVzdCkge1xuICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IENMT1NFRCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwcmV2Q29udGV4dCA9IGdldEFjdGl2ZUNvbnRleHQoKTtcbiAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBIb29rc0Rpc3BhdGNoZXI7XG4gIHZhciBwcmV2Q2FjaGVEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2Q2FjaGVEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50Q2FjaGUuY3VycmVudDtcbiAgICBSZWFjdEN1cnJlbnRDYWNoZS5jdXJyZW50ID0gRGVmYXVsdENhY2hlRGlzcGF0Y2hlcjtcbiAgfVxuXG4gIHZhciBwcmV2UmVxdWVzdCA9IGN1cnJlbnRSZXF1ZXN0O1xuICBjdXJyZW50UmVxdWVzdCA9IHJlcXVlc3Q7XG4gIHZhciBwcmV2R2V0Q3VycmVudFN0YWNrSW1wbDtcblxuICB7XG4gICAgcHJldkdldEN1cnJlbnRTdGFja0ltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaztcbiAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IGdldEN1cnJlbnRTdGFja0luREVWO1xuICB9XG5cbiAgdmFyIHByZXZSZXNwb25zZVN0YXRlID0gY3VycmVudFJlc3BvbnNlU3RhdGU7XG4gIHNldEN1cnJlbnRSZXNwb25zZVN0YXRlKHJlcXVlc3QucmVzcG9uc2VTdGF0ZSk7XG5cbiAgdHJ5IHtcbiAgICB2YXIgcGluZ2VkVGFza3MgPSByZXF1ZXN0LnBpbmdlZFRhc2tzO1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHBpbmdlZFRhc2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdGFzayA9IHBpbmdlZFRhc2tzW2ldO1xuICAgICAgcmV0cnlUYXNrKHJlcXVlc3QsIHRhc2spO1xuICAgIH1cblxuICAgIHBpbmdlZFRhc2tzLnNwbGljZSgwLCBpKTtcblxuICAgIGlmIChyZXF1ZXN0LmRlc3RpbmF0aW9uICE9PSBudWxsKSB7XG4gICAgICBmbHVzaENvbXBsZXRlZFF1ZXVlcyhyZXF1ZXN0LCByZXF1ZXN0LmRlc3RpbmF0aW9uKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gICAgZmF0YWxFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gIH0gZmluYWxseSB7XG4gICAgc2V0Q3VycmVudFJlc3BvbnNlU3RhdGUocHJldlJlc3BvbnNlU3RhdGUpO1xuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50Q2FjaGUuY3VycmVudCA9IHByZXZDYWNoZURpc3BhdGNoZXI7XG4gICAgfVxuXG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBwcmV2R2V0Q3VycmVudFN0YWNrSW1wbDtcbiAgICB9XG5cbiAgICBpZiAocHJldkRpc3BhdGNoZXIgPT09IEhvb2tzRGlzcGF0Y2hlcikge1xuICAgICAgLy8gVGhpcyBtZWFucyB0aGF0IHdlIHdlcmUgaW4gYSByZWVudHJhbnQgd29yayBsb29wLiBUaGlzIGNvdWxkIGhhcHBlblxuICAgICAgLy8gaW4gYSByZW5kZXJlciB0aGF0IHN1cHBvcnRzIHN5bmNocm9ub3VzIHdvcmsgbGlrZSByZW5kZXJUb1N0cmluZyxcbiAgICAgIC8vIHdoZW4gaXQncyBjYWxsZWQgZnJvbSB3aXRoaW4gYW5vdGhlciByZW5kZXJlci5cbiAgICAgIC8vIE5vcm1hbGx5IHdlIGRvbid0IGJvdGhlciBzd2l0Y2hpbmcgdGhlIGNvbnRleHRzIHRvIHRoZWlyIHJvb3QvZGVmYXVsdFxuICAgICAgLy8gdmFsdWVzIHdoZW4gbGVhdmluZyBiZWNhdXNlIHdlJ2xsIGxpa2VseSBuZWVkIHRoZSBzYW1lIG9yIHNpbWlsYXJcbiAgICAgIC8vIGNvbnRleHQgYWdhaW4uIEhvd2V2ZXIsIHdoZW4gd2UncmUgaW5zaWRlIGEgc3luY2hyb25vdXMgbG9vcCBsaWtlIHRoaXNcbiAgICAgIC8vIHdlJ2xsIHRvIHJlc3RvcmUgdGhlIGNvbnRleHQgdG8gd2hhdCBpdCB3YXMgYmVmb3JlIHJldHVybmluZy5cbiAgICAgIHN3aXRjaENvbnRleHQocHJldkNvbnRleHQpO1xuICAgIH1cblxuICAgIGN1cnJlbnRSZXF1ZXN0ID0gcHJldlJlcXVlc3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hTdWJ0cmVlKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50KSB7XG4gIHNlZ21lbnQucGFyZW50Rmx1c2hlZCA9IHRydWU7XG5cbiAgc3dpdGNoIChzZWdtZW50LnN0YXR1cykge1xuICAgIGNhc2UgUEVORElORzpcbiAgICAgIHtcbiAgICAgICAgLy8gV2UncmUgZW1pdHRpbmcgYSBwbGFjZWhvbGRlciBmb3IgdGhpcyBzZWdtZW50IHRvIGJlIGZpbGxlZCBpbiBsYXRlci5cbiAgICAgICAgLy8gVGhlcmVmb3JlIHdlJ2xsIG5lZWQgdG8gYXNzaWduIGl0IGFuIElEIC0gdG8gcmVmZXIgdG8gaXQgYnkuXG4gICAgICAgIHZhciBzZWdtZW50SUQgPSBzZWdtZW50LmlkID0gcmVxdWVzdC5uZXh0U2VnbWVudElkKys7IC8vIFdoZW4gdGhpcyBzZWdtZW50IGZpbmFsbHkgY29tcGxldGVzIGl0IHdvbid0IGJlIGVtYmVkZGVkIGluIHRleHQgc2luY2UgaXQgd2lsbCBmbHVzaCBzZXBhcmF0ZWx5XG5cbiAgICAgICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9IGZhbHNlO1xuICAgICAgICBzZWdtZW50LnRleHRFbWJlZGRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gd3JpdGVQbGFjZWhvbGRlcihkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZXNwb25zZVN0YXRlLCBzZWdtZW50SUQpO1xuICAgICAgfVxuXG4gICAgY2FzZSBDT01QTEVURUQ6XG4gICAgICB7XG4gICAgICAgIHNlZ21lbnQuc3RhdHVzID0gRkxVU0hFRDtcbiAgICAgICAgdmFyIHIgPSB0cnVlO1xuICAgICAgICB2YXIgY2h1bmtzID0gc2VnbWVudC5jaHVua3M7XG4gICAgICAgIHZhciBjaHVua0lkeCA9IDA7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHNlZ21lbnQuY2hpbGRyZW47XG5cbiAgICAgICAgZm9yICh2YXIgY2hpbGRJZHggPSAwOyBjaGlsZElkeCA8IGNoaWxkcmVuLmxlbmd0aDsgY2hpbGRJZHgrKykge1xuICAgICAgICAgIHZhciBuZXh0Q2hpbGQgPSBjaGlsZHJlbltjaGlsZElkeF07IC8vIFdyaXRlIGFsbCB0aGUgY2h1bmtzIHVwIHVudGlsIHRoZSBuZXh0IGNoaWxkLlxuXG4gICAgICAgICAgZm9yICg7IGNodW5rSWR4IDwgbmV4dENoaWxkLmluZGV4OyBjaHVua0lkeCsrKSB7XG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjaHVua3NbY2h1bmtJZHhdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByID0gZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBuZXh0Q2hpbGQpO1xuICAgICAgICB9IC8vIEZpbmFsbHkganVzdCB3cml0ZSBhbGwgdGhlIHJlbWFpbmluZyBjaHVua3NcblxuXG4gICAgICAgIGZvciAoOyBjaHVua0lkeCA8IGNodW5rcy5sZW5ndGggLSAxOyBjaHVua0lkeCsrKSB7XG4gICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2h1bmtzW2NodW5rSWR4XSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2h1bmtJZHggPCBjaHVua3MubGVuZ3RoKSB7XG4gICAgICAgICAgciA9IHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGNodW5rc1tjaHVua0lkeF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0ZWQsIGVycm9yZWQgb3IgYWxyZWFkeSBmbHVzaGVkIGJvdW5kYXJpZXMgc2hvdWxkIG5vdCBiZSBmbHVzaGVkIGFnYWluLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCkge1xuICB2YXIgYm91bmRhcnkgPSBzZWdtZW50LmJvdW5kYXJ5O1xuXG4gIGlmIChib3VuZGFyeSA9PT0gbnVsbCkge1xuICAgIC8vIE5vdCBhIHN1c3BlbnNlIGJvdW5kYXJ5LlxuICAgIHJldHVybiBmbHVzaFN1YnRyZWUocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQpO1xuICB9XG5cbiAgYm91bmRhcnkucGFyZW50Rmx1c2hlZCA9IHRydWU7IC8vIFRoaXMgc2VnbWVudCBpcyBhIFN1c3BlbnNlIGJvdW5kYXJ5LiBXZSBuZWVkIHRvIGRlY2lkZSB3aGV0aGVyIHRvXG4gIC8vIGVtaXQgdGhlIGNvbnRlbnQgb3IgdGhlIGZhbGxiYWNrIG5vdy5cblxuICBpZiAoYm91bmRhcnkuZm9yY2VDbGllbnRSZW5kZXIpIHtcbiAgICAvLyBFbWl0IGEgY2xpZW50IHJlbmRlcmVkIHN1c3BlbnNlIGJvdW5kYXJ5IHdyYXBwZXIuXG4gICAgLy8gV2UgbmV2ZXIgcXVldWUgdGhlIGlubmVyIGJvdW5kYXJ5IHNvIHdlJ2xsIG5ldmVyIGVtaXQgaXRzIGNvbnRlbnQgb3IgcGFydGlhbCBzZWdtZW50cy5cbiAgICB3cml0ZVN0YXJ0Q2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlc3BvbnNlU3RhdGUsIGJvdW5kYXJ5LmVycm9yRGlnZXN0LCBib3VuZGFyeS5lcnJvck1lc3NhZ2UsIGJvdW5kYXJ5LmVycm9yQ29tcG9uZW50U3RhY2spOyAvLyBGbHVzaCB0aGUgZmFsbGJhY2suXG5cbiAgICBmbHVzaFN1YnRyZWUocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQpO1xuICAgIHJldHVybiB3cml0ZUVuZENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZXNwb25zZVN0YXRlKTtcbiAgfSBlbHNlIGlmIChib3VuZGFyeS5wZW5kaW5nVGFza3MgPiAwKSB7XG4gICAgLy8gVGhpcyBib3VuZGFyeSBpcyBzdGlsbCBsb2FkaW5nLiBFbWl0IGEgcGVuZGluZyBzdXNwZW5zZSBib3VuZGFyeSB3cmFwcGVyLlxuICAgIC8vIEFzc2lnbiBhbiBJRCB0byByZWZlciB0byB0aGUgZnV0dXJlIGNvbnRlbnQgYnkuXG4gICAgYm91bmRhcnkucm9vdFNlZ21lbnRJRCA9IHJlcXVlc3QubmV4dFNlZ21lbnRJZCsrO1xuXG4gICAgaWYgKGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIElmIHRoaXMgaXMgYXQgbGVhc3QgcGFydGlhbGx5IGNvbXBsZXRlLCB3ZSBjYW4gcXVldWUgaXQgdG8gYmUgcGFydGlhbGx5IGVtaXR0ZWQgZWFybHkuXG4gICAgICByZXF1ZXN0LnBhcnRpYWxCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpO1xuICAgIH0gLy8vIFRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgd2Ugc2hvdWxkIGhhdmUgcmVmZXJlbmNlZCB0aGlzIElELlxuXG5cbiAgICB2YXIgaWQgPSBib3VuZGFyeS5pZCA9IGFzc2lnblN1c3BlbnNlQm91bmRhcnlJRChyZXF1ZXN0LnJlc3BvbnNlU3RhdGUpO1xuICAgIHdyaXRlU3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZXNwb25zZVN0YXRlLCBpZCk7IC8vIEZsdXNoIHRoZSBmYWxsYmFjay5cblxuICAgIGZsdXNoU3VidHJlZShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCk7XG4gICAgcmV0dXJuIHdyaXRlRW5kUGVuZGluZ1N1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24pO1xuICB9IGVsc2UgaWYgKGJvdW5kYXJ5LmJ5dGVTaXplID4gcmVxdWVzdC5wcm9ncmVzc2l2ZUNodW5rU2l6ZSkge1xuICAgIC8vIFRoaXMgYm91bmRhcnkgaXMgbGFyZ2UgYW5kIHdpbGwgYmUgZW1pdHRlZCBzZXBhcmF0ZWx5IHNvIHRoYXQgd2UgY2FuIHByb2dyZXNzaXZlbHkgc2hvd1xuICAgIC8vIG90aGVyIGNvbnRlbnQuIFdlIGFkZCBpdCB0byB0aGUgcXVldWUgZHVyaW5nIHRoZSBmbHVzaCBiZWNhdXNlIHdlIGhhdmUgdG8gZW5zdXJlIHRoYXRcbiAgICAvLyB0aGUgcGFyZW50IGZsdXNoZXMgZmlyc3Qgc28gdGhhdCB0aGVyZSdzIHNvbWV0aGluZyB0byBpbmplY3QgaXQgaW50by5cbiAgICAvLyBXZSBhbHNvIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgaXQncyBlbWl0dGVkIGludG8gdGhlIHF1ZXVlIGluIGEgZGV0ZXJtaW5pc3RpYyBzbG90LlxuICAgIC8vIEkuZS4gd2UgY2FuJ3QgaW5zZXJ0IGl0IGhlcmUgd2hlbiBpdCBjb21wbGV0ZXMuXG4gICAgLy8gQXNzaWduIGFuIElEIHRvIHJlZmVyIHRvIHRoZSBmdXR1cmUgY29udGVudCBieS5cbiAgICBib3VuZGFyeS5yb290U2VnbWVudElEID0gcmVxdWVzdC5uZXh0U2VnbWVudElkKys7XG4gICAgcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpOyAvLyBFbWl0IGEgcGVuZGluZyByZW5kZXJlZCBzdXNwZW5zZSBib3VuZGFyeSB3cmFwcGVyLlxuXG4gICAgd3JpdGVTdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlc3BvbnNlU3RhdGUsIGJvdW5kYXJ5LmlkKTsgLy8gRmx1c2ggdGhlIGZhbGxiYWNrLlxuXG4gICAgZmx1c2hTdWJ0cmVlKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50KTtcbiAgICByZXR1cm4gd3JpdGVFbmRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbik7XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgaG9pc3RSZXNvdXJjZXMocmVxdWVzdC5yZXNvdXJjZXMsIGJvdW5kYXJ5LnJlc291cmNlcyk7XG4gICAgfSAvLyBXZSBjYW4gaW5saW5lIHRoaXMgYm91bmRhcnkncyBjb250ZW50IGFzIGEgY29tcGxldGUgYm91bmRhcnkuXG5cblxuICAgIHdyaXRlU3RhcnRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlc3BvbnNlU3RhdGUpO1xuICAgIHZhciBjb21wbGV0ZWRTZWdtZW50cyA9IGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzO1xuXG4gICAgaWYgKGNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHByZXZpb3VzbHkgdW52aXNpdGVkIGJvdW5kYXJ5IG11c3QgaGF2ZSBleGFjdGx5IG9uZSByb290IHNlZ21lbnQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRlbnRTZWdtZW50ID0gY29tcGxldGVkU2VnbWVudHNbMF07XG4gICAgZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBjb250ZW50U2VnbWVudCk7XG4gICAgcmV0dXJuIHdyaXRlRW5kQ29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZXNwb25zZVN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaENsaWVudFJlbmRlcmVkQm91bmRhcnkocmVxdWVzdCwgZGVzdGluYXRpb24sIGJvdW5kYXJ5KSB7XG4gIHJldHVybiB3cml0ZUNsaWVudFJlbmRlckJvdW5kYXJ5SW5zdHJ1Y3Rpb24oZGVzdGluYXRpb24sIHJlcXVlc3QucmVzcG9uc2VTdGF0ZSwgYm91bmRhcnkuaWQsIGJvdW5kYXJ5LmVycm9yRGlnZXN0LCBib3VuZGFyeS5lcnJvck1lc3NhZ2UsIGJvdW5kYXJ5LmVycm9yQ29tcG9uZW50U3RhY2spO1xufVxuXG5mdW5jdGlvbiBmbHVzaFNlZ21lbnRDb250YWluZXIocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQpIHtcbiAgd3JpdGVTdGFydFNlZ21lbnQoZGVzdGluYXRpb24sIHJlcXVlc3QucmVzcG9uc2VTdGF0ZSwgc2VnbWVudC5mb3JtYXRDb250ZXh0LCBzZWdtZW50LmlkKTtcbiAgZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50KTtcbiAgcmV0dXJuIHdyaXRlRW5kU2VnbWVudChkZXN0aW5hdGlvbiwgc2VnbWVudC5mb3JtYXRDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gZmx1c2hDb21wbGV0ZWRCb3VuZGFyeShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgYm91bmRhcnkpIHtcbiAge1xuICAgIHNldEN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5UmVzb3VyY2VzVGFyZ2V0KHJlcXVlc3QucmVzb3VyY2VzLCBib3VuZGFyeS5yZXNvdXJjZXMpO1xuICB9XG5cbiAgdmFyIGNvbXBsZXRlZFNlZ21lbnRzID0gYm91bmRhcnkuY29tcGxldGVkU2VnbWVudHM7XG4gIHZhciBpID0gMDtcblxuICBmb3IgKDsgaSA8IGNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNlZ21lbnQgPSBjb21wbGV0ZWRTZWdtZW50c1tpXTtcbiAgICBmbHVzaFBhcnRpYWxseUNvbXBsZXRlZFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIGJvdW5kYXJ5LCBzZWdtZW50KTtcbiAgfVxuXG4gIGNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aCA9IDA7XG5cbiAge1xuICAgIHdyaXRlUmVzb3VyY2VzRm9yQm91bmRhcnkoZGVzdGluYXRpb24sIGJvdW5kYXJ5LnJlc291cmNlcywgcmVxdWVzdC5yZXNwb25zZVN0YXRlKTtcbiAgfVxuXG4gIHJldHVybiB3cml0ZUNvbXBsZXRlZEJvdW5kYXJ5SW5zdHJ1Y3Rpb24oZGVzdGluYXRpb24sIHJlcXVlc3QucmVzcG9uc2VTdGF0ZSwgYm91bmRhcnkuaWQsIGJvdW5kYXJ5LnJvb3RTZWdtZW50SUQsIGJvdW5kYXJ5LnJlc291cmNlcyk7XG59XG5cbmZ1bmN0aW9uIGZsdXNoUGFydGlhbEJvdW5kYXJ5KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBib3VuZGFyeSkge1xuICB7XG4gICAgc2V0Q3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlSZXNvdXJjZXNUYXJnZXQocmVxdWVzdC5yZXNvdXJjZXMsIGJvdW5kYXJ5LnJlc291cmNlcyk7XG4gIH1cblxuICB2YXIgY29tcGxldGVkU2VnbWVudHMgPSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cztcbiAgdmFyIGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgY29tcGxldGVkU2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2VnbWVudCA9IGNvbXBsZXRlZFNlZ21lbnRzW2ldO1xuXG4gICAgaWYgKCFmbHVzaFBhcnRpYWxseUNvbXBsZXRlZFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIGJvdW5kYXJ5LCBzZWdtZW50KSkge1xuICAgICAgaSsrO1xuICAgICAgY29tcGxldGVkU2VnbWVudHMuc3BsaWNlKDAsIGkpOyAvLyBPbmx5IHdyaXRlIGFzIG11Y2ggYXMgdGhlIGJ1ZmZlciB3YW50cy4gU29tZXRoaW5nIGhpZ2hlciBwcmlvcml0eVxuICAgICAgLy8gbWlnaHQgd2FudCB0byB3cml0ZSBsYXRlci5cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBsZXRlZFNlZ21lbnRzLnNwbGljZSgwLCBpKTtcblxuICB7XG4gICAgLy8gVGhlIHdheSB0aGlzIGlzIHN0cnVjdHVyZWQgd2Ugb25seSB3cml0ZSByZXNvdXJjZXMgZm9yIHBhcnRpYWwgYm91bmRhcmllc1xuICAgIC8vIGlmIHRoZXJlIGlzIG5vIGJhY2twcmVzc3VyZS4gTGF0ZXIgYmVmb3JlIHdlIGNvbXBsZXRlIHRoZSBib3VuZGFyeSB3ZVxuICAgIC8vIHdpbGwgd3JpdGUgcmVzb3VyY2VzIHJlZ2FyZGxlc3Mgb2YgYmFja3ByZXNzdXJlIGJlZm9yZSB3ZSBlbWl0IHRoZVxuICAgIC8vIGNvbXBsZXRpb24gaW5zdHJ1Y3Rpb25cbiAgICByZXR1cm4gd3JpdGVSZXNvdXJjZXNGb3JCb3VuZGFyeShkZXN0aW5hdGlvbiwgYm91bmRhcnkucmVzb3VyY2VzLCByZXF1ZXN0LnJlc3BvbnNlU3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoUGFydGlhbGx5Q29tcGxldGVkU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgYm91bmRhcnksIHNlZ21lbnQpIHtcbiAgaWYgKHNlZ21lbnQuc3RhdHVzID09PSBGTFVTSEVEKSB7XG4gICAgLy8gV2UndmUgYWxyZWFkeSBmbHVzaGVkIHRoaXMgaW5saW5lLlxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIHNlZ21lbnRJRCA9IHNlZ21lbnQuaWQ7XG5cbiAgaWYgKHNlZ21lbnRJRCA9PT0gLTEpIHtcbiAgICAvLyBUaGlzIHNlZ21lbnQgd2Fzbid0IHByZXZpb3VzbHkgcmVmZXJyZWQgdG8uIFRoaXMgaGFwcGVucyBhdCB0aGUgcm9vdCBvZlxuICAgIC8vIGEgYm91bmRhcnkuIFdlIG1ha2Uga2luZCBvZiBhIGxlYXAgaGVyZSBhbmQgYXNzdW1lIHRoaXMgaXMgdGhlIHJvb3QuXG4gICAgdmFyIHJvb3RTZWdtZW50SUQgPSBzZWdtZW50LmlkID0gYm91bmRhcnkucm9vdFNlZ21lbnRJRDtcblxuICAgIGlmIChyb290U2VnbWVudElEID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHJvb3Qgc2VnbWVudCBJRCBtdXN0IGhhdmUgYmVlbiBhc3NpZ25lZCBieSBub3cuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZsdXNoU2VnbWVudENvbnRhaW5lcihyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgZmx1c2hTZWdtZW50Q29udGFpbmVyKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50KTtcbiAgICByZXR1cm4gd3JpdGVDb21wbGV0ZWRTZWdtZW50SW5zdHJ1Y3Rpb24oZGVzdGluYXRpb24sIHJlcXVlc3QucmVzcG9uc2VTdGF0ZSwgc2VnbWVudElEKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaENvbXBsZXRlZFF1ZXVlcyhyZXF1ZXN0LCBkZXN0aW5hdGlvbikge1xuXG4gIHRyeSB7XG4gICAgLy8gVGhlIHN0cnVjdHVyZSBvZiB0aGlzIGlzIHRvIGdvIHRocm91Z2ggZWFjaCBxdWV1ZSBvbmUgYnkgb25lIGFuZCB3cml0ZVxuICAgIC8vIHVudGlsIHRoZSBzaW5rIHRlbGxzIHVzIHRvIHN0b3AuIFdoZW4gd2Ugc2hvdWxkIHN0b3AsIHdlIHN0aWxsIGZpbmlzaCB3cml0aW5nXG4gICAgLy8gdGhhdCBpdGVtIGZ1bGx5IGFuZCB0aGVuIHlpZWxkLiBBdCB0aGF0IHBvaW50IHdlIHJlbW92ZSB0aGUgYWxyZWFkeSBjb21wbGV0ZWRcbiAgICAvLyBpdGVtcyB1cCB1bnRpbCB0aGUgcG9pbnQgd2UgY29tcGxldGVkIHRoZW0uXG4gICAgdmFyIGk7XG4gICAgdmFyIGNvbXBsZXRlZFJvb3RTZWdtZW50ID0gcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudDtcblxuICAgIGlmIChjb21wbGV0ZWRSb290U2VnbWVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcyA9PT0gMCkge1xuICAgICAgICBpZiAoZW5hYmxlRmxvYXQpIHtcbiAgICAgICAgICB3cml0ZVByZWFtYmxlKGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlc291cmNlcywgcmVxdWVzdC5yZXNwb25zZVN0YXRlLCByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcyA9PT0gMCk7XG4gICAgICAgIH1cblxuICAgICAgICBmbHVzaFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIGNvbXBsZXRlZFJvb3RTZWdtZW50KTtcbiAgICAgICAgcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudCA9IG51bGw7XG4gICAgICAgIHdyaXRlQ29tcGxldGVkUm9vdChkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZXNwb25zZVN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIGhhdmVuJ3QgZmx1c2hlZCB0aGUgcm9vdCB5ZXQgc28gd2UgZG9uJ3QgbmVlZCB0byBjaGVjayBhbnkgb3RoZXIgYnJhbmNoZXMgZnVydGhlciBkb3duXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcyA+IDApIHtcbiAgICAgIC8vIFdlIGhhdmUgbm90IHlldCBmbHVzaGVkIHRoZSByb290IHNlZ21lbnQgc28gd2UgZWFybHkgcmV0dXJuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVuYWJsZUZsb2F0KSB7XG4gICAgICB3cml0ZUhvaXN0YWJsZXMoZGVzdGluYXRpb24sIHJlcXVlc3QucmVzb3VyY2VzLCByZXF1ZXN0LnJlc3BvbnNlU3RhdGUpO1xuICAgIH0gLy8gV2UgZW1pdCBjbGllbnQgcmVuZGVyaW5nIGluc3RydWN0aW9ucyBmb3IgYWxyZWFkeSBlbWl0dGVkIGJvdW5kYXJpZXMgZmlyc3QuXG4gICAgLy8gVGhpcyBpcyBzbyB0aGF0IHdlIGNhbiBzaWduYWwgdG8gdGhlIGNsaWVudCB0byBzdGFydCBjbGllbnQgcmVuZGVyaW5nIHRoZW0gYXNcbiAgICAvLyBzb29uIGFzIHBvc3NpYmxlLlxuXG5cbiAgICB2YXIgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzID0gcmVxdWVzdC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXM7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYm91bmRhcnkgPSBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXNbaV07XG5cbiAgICAgIGlmICghZmx1c2hDbGllbnRSZW5kZXJlZEJvdW5kYXJ5KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBib3VuZGFyeSkpIHtcbiAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgIGkrKztcbiAgICAgICAgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7IC8vIE5leHQgd2UgZW1pdCBhbnkgY29tcGxldGUgYm91bmRhcmllcy4gSXQncyBiZXR0ZXIgdG8gZmF2b3IgYm91bmRhcmllc1xuICAgIC8vIHRoYXQgYXJlIGNvbXBsZXRlbHkgZG9uZSBzaW5jZSB3ZSBjYW4gYWN0dWFsbHkgc2hvdyB0aGVtLCB0aGFuIGl0IGlzIHRvIGVtaXRcbiAgICAvLyBhbnkgaW5kaXZpZHVhbCBzZWdtZW50cyBmcm9tIGEgcGFydGlhbGx5IGNvbXBsZXRlIGJvdW5kYXJ5LlxuXG4gICAgdmFyIGNvbXBsZXRlZEJvdW5kYXJpZXMgPSByZXF1ZXN0LmNvbXBsZXRlZEJvdW5kYXJpZXM7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY29tcGxldGVkQm91bmRhcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF9ib3VuZGFyeSA9IGNvbXBsZXRlZEJvdW5kYXJpZXNbaV07XG5cbiAgICAgIGlmICghZmx1c2hDb21wbGV0ZWRCb3VuZGFyeShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgX2JvdW5kYXJ5KSkge1xuICAgICAgICByZXF1ZXN0LmRlc3RpbmF0aW9uID0gbnVsbDtcbiAgICAgICAgaSsrO1xuICAgICAgICBjb21wbGV0ZWRCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBsZXRlZEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpOyAvLyBBbGxvdyBhbnl0aGluZyB3cml0dGVuIHNvIGZhciB0byBmbHVzaCB0byB0aGUgdW5kZXJseWluZyBzaW5rIGJlZm9yZVxuICAgIC8vIHdlIGNvbnRpbnVlIHdpdGggbG93ZXIgcHJpb3JpdGllcy5cblxuICAgIGNvbXBsZXRlV3JpdGluZyhkZXN0aW5hdGlvbik7XG4gICAgYmVnaW5Xcml0aW5nKGRlc3RpbmF0aW9uKTsgLy8gVE9ETzogSGVyZSB3ZSdsbCBlbWl0IGRhdGEgdXNlZCBieSBoeWRyYXRpb24uXG4gICAgLy8gTmV4dCB3ZSBlbWl0IGFueSBzZWdtZW50cyBvZiBhbnkgYm91bmRhcmllcyB0aGF0IGFyZSBwYXJ0aWFsbHkgY29tcGxldGVcbiAgICAvLyBidXQgbm90IGRlZXBseSBjb21wbGV0ZS5cblxuICAgIHZhciBwYXJ0aWFsQm91bmRhcmllcyA9IHJlcXVlc3QucGFydGlhbEJvdW5kYXJpZXM7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcGFydGlhbEJvdW5kYXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBfYm91bmRhcnkyID0gcGFydGlhbEJvdW5kYXJpZXNbaV07XG5cbiAgICAgIGlmICghZmx1c2hQYXJ0aWFsQm91bmRhcnkocmVxdWVzdCwgZGVzdGluYXRpb24sIF9ib3VuZGFyeTIpKSB7XG4gICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICBpKys7XG4gICAgICAgIHBhcnRpYWxCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhcnRpYWxCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTsgLy8gTmV4dCB3ZSBjaGVjayB0aGUgY29tcGxldGVkIGJvdW5kYXJpZXMgYWdhaW4uIFRoaXMgbWF5IGhhdmUgaGFkXG4gICAgLy8gYm91bmRhcmllcyBhZGRlZCB0byBpdCBpbiBjYXNlIHRoZXkgd2VyZSB0b28gbGFyZ2VkIHRvIGJlIGlubGluZWQuXG4gICAgLy8gTmV3IG9uZXMgbWlnaHQgYmUgYWRkZWQgaW4gdGhpcyBsb29wLlxuXG4gICAgdmFyIGxhcmdlQm91bmRhcmllcyA9IHJlcXVlc3QuY29tcGxldGVkQm91bmRhcmllcztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsYXJnZUJvdW5kYXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBfYm91bmRhcnkzID0gbGFyZ2VCb3VuZGFyaWVzW2ldO1xuXG4gICAgICBpZiAoIWZsdXNoQ29tcGxldGVkQm91bmRhcnkocmVxdWVzdCwgZGVzdGluYXRpb24sIF9ib3VuZGFyeTMpKSB7XG4gICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICBpKys7XG4gICAgICAgIGxhcmdlQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXJnZUJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICB9IGZpbmFsbHkge1xuICAgIGlmIChyZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcyA9PT0gMCAmJiByZXF1ZXN0LnBpbmdlZFRhc2tzLmxlbmd0aCA9PT0gMCAmJiByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5sZW5ndGggPT09IDAgJiYgcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLmxlbmd0aCA9PT0gMCAvLyBXZSBkb24ndCBuZWVkIHRvIGNoZWNrIGFueSBwYXJ0aWFsbHkgY29tcGxldGVkIHNlZ21lbnRzIGJlY2F1c2VcbiAgICAvLyBlaXRoZXIgdGhleSBoYXZlIHBlbmRpbmcgdGFzayBvciB0aGV5J3JlIGNvbXBsZXRlLlxuICAgICkge1xuICAgICAgICByZXF1ZXN0LmZsdXNoU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgICAgICAge1xuICAgICAgICAgIHdyaXRlUG9zdGFtYmxlKGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlc3BvbnNlU3RhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAge1xuICAgICAgICAgIGlmIChyZXF1ZXN0LmFib3J0YWJsZVRhc2tzLnNpemUgIT09IDApIHtcbiAgICAgICAgICAgIGVycm9yKCdUaGVyZSB3YXMgc3RpbGwgYWJvcnRhYmxlIHRhc2sgYXQgdGhlIHJvb3Qgd2hlbiB3ZSBjbG9zZWQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFdlJ3JlIGRvbmUuXG5cblxuICAgICAgICBjbG9zZShkZXN0aW5hdGlvbik7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRXb3JrKHJlcXVlc3QpIHtcbiAgcmVxdWVzdC5mbHVzaFNjaGVkdWxlZCA9IHJlcXVlc3QuZGVzdGluYXRpb24gIT09IG51bGw7XG5cbiAge1xuICAgIHNjaGVkdWxlV29yayhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybVdvcmsocmVxdWVzdCk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5xdWV1ZUZsdXNoKHJlcXVlc3QpIHtcbiAgaWYgKHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPT09IGZhbHNlICYmIC8vIElmIHRoZXJlIGFyZSBwaW5nZWQgdGFza3Mgd2UgYXJlIGdvaW5nIHRvIGZsdXNoIGFueXdheSBhZnRlciB3b3JrIGNvbXBsZXRlc1xuICByZXF1ZXN0LnBpbmdlZFRhc2tzLmxlbmd0aCA9PT0gMCAmJiAvLyBJZiB0aGVyZSBpcyBubyBkZXN0aW5hdGlvbiB0aGVyZSBpcyBub3RoaW5nIHdlIGNhbiBmbHVzaCB0by4gQSBmbHVzaCB3aWxsXG4gIC8vIGhhcHBlbiB3aGVuIHdlIHN0YXJ0IGZsb3dpbmcgYWdhaW5cbiAgcmVxdWVzdC5kZXN0aW5hdGlvbiAhPT0gbnVsbCkge1xuICAgIHZhciBkZXN0aW5hdGlvbiA9IHJlcXVlc3QuZGVzdGluYXRpb247XG4gICAgcmVxdWVzdC5mbHVzaFNjaGVkdWxlZCA9IHRydWU7XG4gICAgc2NoZWR1bGVXb3JrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmbHVzaENvbXBsZXRlZFF1ZXVlcyhyZXF1ZXN0LCBkZXN0aW5hdGlvbik7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRGbG93aW5nKHJlcXVlc3QsIGRlc3RpbmF0aW9uKSB7XG4gIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gQ0xPU0lORykge1xuICAgIHJlcXVlc3Quc3RhdHVzID0gQ0xPU0VEO1xuICAgIGNsb3NlV2l0aEVycm9yKGRlc3RpbmF0aW9uLCByZXF1ZXN0LmZhdGFsRXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gQ0xPU0VEKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHJlcXVlc3QuZGVzdGluYXRpb24gIT09IG51bGwpIHtcbiAgICAvLyBXZSdyZSBhbHJlYWR5IGZsb3dpbmcuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuXG4gIHRyeSB7XG4gICAgZmx1c2hDb21wbGV0ZWRRdWV1ZXMocmVxdWVzdCwgZGVzdGluYXRpb24pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICAgIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICB9XG59IC8vIFRoaXMgaXMgY2FsbGVkIHRvIGVhcmx5IHRlcm1pbmF0ZSBhIHJlcXVlc3QuIEl0IHB1dHMgYWxsIHBlbmRpbmcgYm91bmRhcmllcyBpbiBjbGllbnQgcmVuZGVyZWQgc3RhdGUuXG5cbmZ1bmN0aW9uIGFib3J0KHJlcXVlc3QsIHJlYXNvbikge1xuICB0cnkge1xuICAgIHZhciBhYm9ydGFibGVUYXNrcyA9IHJlcXVlc3QuYWJvcnRhYmxlVGFza3M7XG5cbiAgICBpZiAoYWJvcnRhYmxlVGFza3Muc2l6ZSA+IDApIHtcbiAgICAgIHZhciBlcnJvciA9IHJlYXNvbiA9PT0gdW5kZWZpbmVkID8gbmV3IEVycm9yKCdUaGUgcmVuZGVyIHdhcyBhYm9ydGVkIGJ5IHRoZSBzZXJ2ZXIgd2l0aG91dCBhIHJlYXNvbi4nKSA6IHJlYXNvbjtcbiAgICAgIGFib3J0YWJsZVRhc2tzLmZvckVhY2goZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgcmV0dXJuIGFib3J0VGFzayh0YXNrLCByZXF1ZXN0LCBlcnJvcik7XG4gICAgICB9KTtcbiAgICAgIGFib3J0YWJsZVRhc2tzLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3QuZGVzdGluYXRpb24gIT09IG51bGwpIHtcbiAgICAgIGZsdXNoQ29tcGxldGVkUXVldWVzKHJlcXVlc3QsIHJlcXVlc3QuZGVzdGluYXRpb24pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yKTtcbiAgICBmYXRhbEVycm9yKHJlcXVlc3QsIGVycm9yKTtcbiAgfVxufVxuZnVuY3Rpb24gZmx1c2hSZXNvdXJjZXMocmVxdWVzdCkge1xuICBlbnF1ZXVlRmx1c2gocmVxdWVzdCk7XG59XG5mdW5jdGlvbiBnZXRSZXNvdXJjZXMocmVxdWVzdCkge1xuICByZXR1cm4gcmVxdWVzdC5yZXNvdXJjZXM7XG59XG5cbmZ1bmN0aW9uIG9uRXJyb3IkMSgpIHsvLyBOb24tZmF0YWwgZXJyb3JzIGFyZSBpZ25vcmVkLlxufVxuXG5mdW5jdGlvbiByZW5kZXJUb1N0cmluZ0ltcGwoY2hpbGRyZW4sIG9wdGlvbnMsIGdlbmVyYXRlU3RhdGljTWFya3VwLCBhYm9ydFJlYXNvbiwgdW5zdGFibGVfZXh0ZXJuYWxSdW50aW1lU3JjKSB7XG4gIHZhciBkaWRGYXRhbCA9IGZhbHNlO1xuICB2YXIgZmF0YWxFcnJvciA9IG51bGw7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgdmFyIGRlc3RpbmF0aW9uID0ge1xuICAgIC8vICRGbG93Rml4TWVbbWlzc2luZy1sb2NhbC1hbm5vdF1cbiAgICBwdXNoOiBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIGlmIChjaHVuayAhPT0gbnVsbCkge1xuICAgICAgICByZXN1bHQgKz0gY2h1bms7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgLy8gJEZsb3dGaXhNZVttaXNzaW5nLWxvY2FsLWFubm90XVxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgZGlkRmF0YWwgPSB0cnVlO1xuICAgICAgZmF0YWxFcnJvciA9IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgdmFyIHJlYWR5VG9TdHJlYW0gPSBmYWxzZTtcblxuICBmdW5jdGlvbiBvblNoZWxsUmVhZHkoKSB7XG4gICAgcmVhZHlUb1N0cmVhbSA9IHRydWU7XG4gIH1cblxuICB2YXIgcmVzb3VyY2VzID0gY3JlYXRlUmVzb3VyY2VzKCk7XG4gIHZhciByZXF1ZXN0ID0gY3JlYXRlUmVxdWVzdChjaGlsZHJlbiwgcmVzb3VyY2VzLCBjcmVhdGVSZXNwb25zZVN0YXRlKHJlc291cmNlcywgZ2VuZXJhdGVTdGF0aWNNYXJrdXAsIG9wdGlvbnMgPyBvcHRpb25zLmlkZW50aWZpZXJQcmVmaXggOiB1bmRlZmluZWQsIHVuc3RhYmxlX2V4dGVybmFsUnVudGltZVNyYyksIGNyZWF0ZVJvb3RGb3JtYXRDb250ZXh0KCksIEluZmluaXR5LCBvbkVycm9yJDEsIHVuZGVmaW5lZCwgb25TaGVsbFJlYWR5LCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gIHN0YXJ0V29yayhyZXF1ZXN0KTsgLy8gSWYgYW55dGhpbmcgc3VzcGVuZGVkIGFuZCBpcyBzdGlsbCBwZW5kaW5nLCB3ZSdsbCBhYm9ydCBpdCBiZWZvcmUgd3JpdGluZy5cbiAgLy8gVGhhdCB3YXkgd2Ugd3JpdGUgb25seSBjbGllbnQtcmVuZGVyZWQgYm91bmRhcmllcyBmcm9tIHRoZSBzdGFydC5cblxuICBhYm9ydChyZXF1ZXN0LCBhYm9ydFJlYXNvbik7XG4gIHN0YXJ0Rmxvd2luZyhyZXF1ZXN0LCBkZXN0aW5hdGlvbik7XG5cbiAgaWYgKGRpZEZhdGFsICYmIGZhdGFsRXJyb3IgIT09IGFib3J0UmVhc29uKSB7XG4gICAgdGhyb3cgZmF0YWxFcnJvcjtcbiAgfVxuXG4gIGlmICghcmVhZHlUb1N0cmVhbSkge1xuICAgIC8vIE5vdGU6IFRoaXMgZXJyb3IgbWVzc2FnZSBpcyB0aGUgb25lIHdlIHVzZSBvbiB0aGUgY2xpZW50LiBJdCBkb2Vzbid0XG4gICAgLy8gcmVhbGx5IG1ha2Ugc2Vuc2UgaGVyZS4gQnV0IHRoaXMgaXMgdGhlIGxlZ2FjeSBzZXJ2ZXIgcmVuZGVyZXIsIGFueXdheS5cbiAgICAvLyBXZSdyZSBnb2luZyB0byBkZWxldGUgaXQgc29vbi5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgY29tcG9uZW50IHN1c3BlbmRlZCB3aGlsZSByZXNwb25kaW5nIHRvIHN5bmNocm9ub3VzIGlucHV0LiBUaGlzICcgKyAnd2lsbCBjYXVzZSB0aGUgVUkgdG8gYmUgcmVwbGFjZWQgd2l0aCBhIGxvYWRpbmcgaW5kaWNhdG9yLiBUbyBmaXgsICcgKyAndXBkYXRlcyB0aGF0IHN1c3BlbmQgc2hvdWxkIGJlIHdyYXBwZWQgd2l0aCBzdGFydFRyYW5zaXRpb24uJyk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWRhYmxlKSB7XG4gIF9pbmhlcml0c0xvb3NlKFJlYWN0TWFya3VwUmVhZGFibGVTdHJlYW0sIF9SZWFkYWJsZSk7XG5cbiAgZnVuY3Rpb24gUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbSgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICAvLyBDYWxscyB0aGUgc3RyZWFtLlJlYWRhYmxlKG9wdGlvbnMpIGNvbnN0cnVjdG9yLiBDb25zaWRlciBleHBvc2luZyBidWlsdC1pblxuICAgIC8vIGZlYXR1cmVzIGxpa2UgaGlnaFdhdGVyTWFyayBpbiB0aGUgZnV0dXJlLlxuICAgIF90aGlzID0gX1JlYWRhYmxlLmNhbGwodGhpcywge30pIHx8IHRoaXM7XG4gICAgX3RoaXMucmVxdWVzdCA9IHZvaWQgMDtcbiAgICBfdGhpcy5zdGFydGVkRmxvd2luZyA9IHZvaWQgMDtcbiAgICBfdGhpcy5yZXF1ZXN0ID0gbnVsbDtcbiAgICBfdGhpcy5zdGFydGVkRmxvd2luZyA9IGZhbHNlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfSAvLyAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdXG5cblxuICB2YXIgX3Byb3RvID0gUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLl9kZXN0cm95ID0gZnVuY3Rpb24gX2Rlc3Ryb3koZXJyLCBjYWxsYmFjaykge1xuICAgIGFib3J0KHRoaXMucmVxdWVzdCk7XG4gICAgY2FsbGJhY2soZXJyKTtcbiAgfSAvLyAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdXG4gIDtcblxuICBfcHJvdG8uX3JlYWQgPSBmdW5jdGlvbiBfcmVhZChzaXplKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRlZEZsb3dpbmcpIHtcbiAgICAgIHN0YXJ0Rmxvd2luZyh0aGlzLnJlcXVlc3QsIHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbTtcbn0oc3RyZWFtLlJlYWRhYmxlKTtcblxuZnVuY3Rpb24gb25FcnJvcigpIHsvLyBOb24tZmF0YWwgZXJyb3JzIGFyZSBpZ25vcmVkLlxufVxuXG5mdW5jdGlvbiByZW5kZXJUb05vZGVTdHJlYW1JbXBsKGNoaWxkcmVuLCBvcHRpb25zLCBnZW5lcmF0ZVN0YXRpY01hcmt1cCkge1xuICBmdW5jdGlvbiBvbkFsbFJlYWR5KCkge1xuICAgIC8vIFdlIHdhaXQgdW50aWwgZXZlcnl0aGluZyBoYXMgbG9hZGVkIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS5cbiAgICAvLyBUaGF0IHdheSB3ZSBvbmx5IGVuZCB1cCB3aXRoIGZ1bGx5IHJlc29sdmVkIEhUTUwgZXZlbiBpZiB3ZSBzdXNwZW5kLlxuICAgIGRlc3RpbmF0aW9uLnN0YXJ0ZWRGbG93aW5nID0gdHJ1ZTtcbiAgICBzdGFydEZsb3dpbmcocmVxdWVzdCwgZGVzdGluYXRpb24pO1xuICB9XG5cbiAgdmFyIGRlc3RpbmF0aW9uID0gbmV3IFJlYWN0TWFya3VwUmVhZGFibGVTdHJlYW0oKTtcbiAgdmFyIHJlc291cmNlcyA9IGNyZWF0ZVJlc291cmNlcygpO1xuICB2YXIgcmVxdWVzdCA9IGNyZWF0ZVJlcXVlc3QoY2hpbGRyZW4sIHJlc291cmNlcywgY3JlYXRlUmVzcG9uc2VTdGF0ZShyZXNvdXJjZXMsIGZhbHNlLCBvcHRpb25zID8gb3B0aW9ucy5pZGVudGlmaWVyUHJlZml4IDogdW5kZWZpbmVkKSwgY3JlYXRlUm9vdEZvcm1hdENvbnRleHQoKSwgSW5maW5pdHksIG9uRXJyb3IsIG9uQWxsUmVhZHksIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgZGVzdGluYXRpb24ucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIHN0YXJ0V29yayhyZXF1ZXN0KTtcbiAgcmV0dXJuIGRlc3RpbmF0aW9uO1xufVxuXG5mdW5jdGlvbiByZW5kZXJUb05vZGVTdHJlYW0oY2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAge1xuICAgIGVycm9yKCdyZW5kZXJUb05vZGVTdHJlYW0gaXMgZGVwcmVjYXRlZC4gVXNlIHJlbmRlclRvUGlwZWFibGVTdHJlYW0gaW5zdGVhZC4nKTtcbiAgfVxuXG4gIHJldHVybiByZW5kZXJUb05vZGVTdHJlYW1JbXBsKGNoaWxkcmVuLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyVG9TdGF0aWNOb2RlU3RyZWFtKGNoaWxkcmVuLCBvcHRpb25zKSB7XG4gIHJldHVybiByZW5kZXJUb05vZGVTdHJlYW1JbXBsKGNoaWxkcmVuLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyVG9TdHJpbmcoY2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHJlbmRlclRvU3RyaW5nSW1wbChjaGlsZHJlbiwgb3B0aW9ucywgZmFsc2UsICdUaGUgc2VydmVyIHVzZWQgXCJyZW5kZXJUb1N0cmluZ1wiIHdoaWNoIGRvZXMgbm90IHN1cHBvcnQgU3VzcGVuc2UuIElmIHlvdSBpbnRlbmRlZCBmb3IgdGhpcyBTdXNwZW5zZSBib3VuZGFyeSB0byByZW5kZXIgdGhlIGZhbGxiYWNrIGNvbnRlbnQgb24gdGhlIHNlcnZlciBjb25zaWRlciB0aHJvd2luZyBhbiBFcnJvciBzb21ld2hlcmUgd2l0aGluIHRoZSBTdXNwZW5zZSBib3VuZGFyeS4gSWYgeW91IGludGVuZGVkIHRvIGhhdmUgdGhlIHNlcnZlciB3YWl0IGZvciB0aGUgc3VzcGVuZGVkIGNvbXBvbmVudCBwbGVhc2Ugc3dpdGNoIHRvIFwicmVuZGVyVG9QaXBlYWJsZVN0cmVhbVwiIHdoaWNoIHN1cHBvcnRzIFN1c3BlbnNlIG9uIHRoZSBzZXJ2ZXInKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyVG9TdGF0aWNNYXJrdXAoY2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHJlbmRlclRvU3RyaW5nSW1wbChjaGlsZHJlbiwgb3B0aW9ucywgdHJ1ZSwgJ1RoZSBzZXJ2ZXIgdXNlZCBcInJlbmRlclRvU3RhdGljTWFya3VwXCIgd2hpY2ggZG9lcyBub3Qgc3VwcG9ydCBTdXNwZW5zZS4gSWYgeW91IGludGVuZGVkIHRvIGhhdmUgdGhlIHNlcnZlciB3YWl0IGZvciB0aGUgc3VzcGVuZGVkIGNvbXBvbmVudCBwbGVhc2Ugc3dpdGNoIHRvIFwicmVuZGVyVG9QaXBlYWJsZVN0cmVhbVwiIHdoaWNoIHN1cHBvcnRzIFN1c3BlbnNlIG9uIHRoZSBzZXJ2ZXInKTtcbn1cblxuZXhwb3J0cy5yZW5kZXJUb05vZGVTdHJlYW0gPSByZW5kZXJUb05vZGVTdHJlYW07XG5leHBvcnRzLnJlbmRlclRvU3RhdGljTWFya3VwID0gcmVuZGVyVG9TdGF0aWNNYXJrdXA7XG5leHBvcnRzLnJlbmRlclRvU3RhdGljTm9kZVN0cmVhbSA9IHJlbmRlclRvU3RhdGljTm9kZVN0cmVhbTtcbmV4cG9ydHMucmVuZGVyVG9TdHJpbmcgPSByZW5kZXJUb1N0cmluZztcbmV4cG9ydHMudmVyc2lvbiA9IFJlYWN0VmVyc2lvbjtcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwiUmVhY3QiLCJyZXF1aXJlIiwiUmVhY3RET00iLCJzdHJlYW0iLCJSZWFjdFZlcnNpb24iLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwid2FybiIsImZvcm1hdCIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwicHJpbnRXYXJuaW5nIiwiZXJyb3IiLCJfbGVuMiIsIl9rZXkyIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiY29uY2F0IiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsInNjaGVkdWxlV29yayIsImNhbGxiYWNrIiwiYmVnaW5Xcml0aW5nIiwiZGVzdGluYXRpb24iLCJ3cml0ZUNodW5rIiwiY2h1bmsiLCJ3cml0ZUNodW5rQW5kUmV0dXJuIiwicHVzaCIsImNvbXBsZXRlV3JpdGluZyIsImNsb3NlIiwic3RyaW5nVG9DaHVuayIsImNvbnRlbnQiLCJzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsiLCJjbG9uZVByZWNvbXB1dGVkQ2h1bmsiLCJjbG9zZVdpdGhFcnJvciIsImRlc3Ryb3kiLCJfZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJrZXkiLCJ2YWx1ZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX2luaGVyaXRzTG9vc2UiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsIl9fcHJvdG9fXyIsImFzc2lnbiIsInR5cGVOYW1lIiwiaGFzVG9TdHJpbmdUYWciLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInR5cGUiLCJuYW1lIiwid2lsbENvZXJjaW9uVGhyb3ciLCJ0ZXN0U3RyaW5nQ29lcmNpb24iLCJlIiwiY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbiIsImF0dHJpYnV0ZU5hbWUiLCJjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24iLCJwcm9wTmFtZSIsImNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uIiwiZW5hYmxlRmxvYXQiLCJoYXNPd25Qcm9wZXJ0eSIsIkFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIiLCJBVFRSSUJVVEVfTkFNRV9DSEFSIiwiVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgiLCJSZWdFeHAiLCJpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlIiwidmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlIiwiaXNBdHRyaWJ1dGVOYW1lU2FmZSIsInRlc3QiLCJ1bml0bGVzc051bWJlcnMiLCJTZXQiLCJpc1VuaXRsZXNzTnVtYmVyIiwiaGFzIiwiYWxpYXNlcyIsIk1hcCIsImdldEF0dHJpYnV0ZUFsaWFzIiwiZ2V0IiwiaGFzUmVhZE9ubHlWYWx1ZSIsImJ1dHRvbiIsImNoZWNrYm94IiwiaW1hZ2UiLCJoaWRkZW4iLCJyYWRpbyIsInJlc2V0Iiwic3VibWl0IiwiY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcyIsInRhZ05hbWUiLCJwcm9wcyIsIm9uQ2hhbmdlIiwib25JbnB1dCIsInJlYWRPbmx5IiwiZGlzYWJsZWQiLCJjaGVja2VkIiwiYXJpYVByb3BlcnRpZXMiLCJ3YXJuZWRQcm9wZXJ0aWVzJDEiLCJyQVJJQSQxIiwickFSSUFDYW1lbCQxIiwidmFsaWRhdGVQcm9wZXJ0eSQxIiwiYXJpYU5hbWUiLCJzbGljZSIsInRvTG93ZXJDYXNlIiwiY29ycmVjdE5hbWUiLCJsb3dlckNhc2VkTmFtZSIsInN0YW5kYXJkTmFtZSIsInZhbGlkYXRlUHJvcGVydGllcyQyIiwiaW52YWxpZFByb3BzIiwiaXNWYWxpZCIsInVua25vd25Qcm9wU3RyaW5nIiwicHJvcCIsImpvaW4iLCJkaWRXYXJuVmFsdWVOdWxsIiwidmFsaWRhdGVQcm9wZXJ0aWVzJDEiLCJtdWx0aXBsZSIsImlzQ3VzdG9tRWxlbWVudCIsImluZGV4T2YiLCJwb3NzaWJsZVN0YW5kYXJkTmFtZXMiLCJhY2NlcHQiLCJhY2NlcHRjaGFyc2V0IiwiYWNjZXNza2V5IiwiYWN0aW9uIiwiYWxsb3dmdWxsc2NyZWVuIiwiYWx0IiwiYXMiLCJhc3luYyIsImF1dG9jYXBpdGFsaXplIiwiYXV0b2NvbXBsZXRlIiwiYXV0b2NvcnJlY3QiLCJhdXRvZm9jdXMiLCJhdXRvcGxheSIsImF1dG9zYXZlIiwiY2FwdHVyZSIsImNlbGxwYWRkaW5nIiwiY2VsbHNwYWNpbmciLCJjaGFsbGVuZ2UiLCJjaGFyc2V0IiwiY2hpbGRyZW4iLCJjaXRlIiwiY2xhc3MiLCJjbGFzc2lkIiwiY2xhc3NuYW1lIiwiY29scyIsImNvbHNwYW4iLCJjb250ZW50ZWRpdGFibGUiLCJjb250ZXh0bWVudSIsImNvbnRyb2xzIiwiY29udHJvbHNsaXN0IiwiY29vcmRzIiwiY3Jvc3NvcmlnaW4iLCJkYW5nZXJvdXNseXNldGlubmVyaHRtbCIsImRhdGEiLCJkYXRldGltZSIsImRlZmF1bHQiLCJkZWZhdWx0Y2hlY2tlZCIsImRlZmF1bHR2YWx1ZSIsImRlZmVyIiwiZGlyIiwiZGlzYWJsZXBpY3R1cmVpbnBpY3R1cmUiLCJkaXNhYmxlcmVtb3RlcGxheWJhY2siLCJkb3dubG9hZCIsImRyYWdnYWJsZSIsImVuY3R5cGUiLCJlbnRlcmtleWhpbnQiLCJmZXRjaHByaW9yaXR5IiwiZm9yIiwiZm9ybSIsImZvcm1tZXRob2QiLCJmb3JtYWN0aW9uIiwiZm9ybWVuY3R5cGUiLCJmb3Jtbm92YWxpZGF0ZSIsImZvcm10YXJnZXQiLCJmcmFtZWJvcmRlciIsImhlYWRlcnMiLCJoZWlnaHQiLCJoaWdoIiwiaHJlZiIsImhyZWZsYW5nIiwiaHRtbGZvciIsImh0dHBlcXVpdiIsImljb24iLCJpZCIsImltYWdlc2l6ZXMiLCJpbWFnZXNyY3NldCIsImlubmVyaHRtbCIsImlucHV0bW9kZSIsImludGVncml0eSIsImlzIiwiaXRlbWlkIiwiaXRlbXByb3AiLCJpdGVtcmVmIiwiaXRlbXNjb3BlIiwiaXRlbXR5cGUiLCJrZXlwYXJhbXMiLCJrZXl0eXBlIiwia2luZCIsImxhYmVsIiwibGFuZyIsImxpc3QiLCJsb29wIiwibG93IiwibWFuaWZlc3QiLCJtYXJnaW53aWR0aCIsIm1hcmdpbmhlaWdodCIsIm1heCIsIm1heGxlbmd0aCIsIm1lZGlhIiwibWVkaWFncm91cCIsIm1ldGhvZCIsIm1pbiIsIm1pbmxlbmd0aCIsIm11dGVkIiwibm9tb2R1bGUiLCJub25jZSIsIm5vdmFsaWRhdGUiLCJvcGVuIiwib3B0aW11bSIsInBhdHRlcm4iLCJwbGFjZWhvbGRlciIsInBsYXlzaW5saW5lIiwicG9zdGVyIiwicHJlbG9hZCIsInByb2ZpbGUiLCJyYWRpb2dyb3VwIiwicmVhZG9ubHkiLCJyZWZlcnJlcnBvbGljeSIsInJlbCIsInJlcXVpcmVkIiwicmV2ZXJzZWQiLCJyb2xlIiwicm93cyIsInJvd3NwYW4iLCJzYW5kYm94Iiwic2NvcGUiLCJzY29wZWQiLCJzY3JvbGxpbmciLCJzZWFtbGVzcyIsInNlbGVjdGVkIiwic2hhcGUiLCJzaXplIiwic2l6ZXMiLCJzcGFuIiwic3BlbGxjaGVjayIsInNyYyIsInNyY2RvYyIsInNyY2xhbmciLCJzcmNzZXQiLCJzdGFydCIsInN0ZXAiLCJzdHlsZSIsInN1bW1hcnkiLCJ0YWJpbmRleCIsInRhcmdldCIsInRpdGxlIiwidXNlbWFwIiwid2lkdGgiLCJ3bW9kZSIsIndyYXAiLCJhYm91dCIsImFjY2VudGhlaWdodCIsImFjY3VtdWxhdGUiLCJhZGRpdGl2ZSIsImFsaWdubWVudGJhc2VsaW5lIiwiYWxsb3dyZW9yZGVyIiwiYWxwaGFiZXRpYyIsImFtcGxpdHVkZSIsImFyYWJpY2Zvcm0iLCJhc2NlbnQiLCJhdHRyaWJ1dGVuYW1lIiwiYXR0cmlidXRldHlwZSIsImF1dG9yZXZlcnNlIiwiYXppbXV0aCIsImJhc2VmcmVxdWVuY3kiLCJiYXNlbGluZXNoaWZ0IiwiYmFzZXByb2ZpbGUiLCJiYm94IiwiYmVnaW4iLCJiaWFzIiwiYnkiLCJjYWxjbW9kZSIsImNhcGhlaWdodCIsImNsaXAiLCJjbGlwcGF0aCIsImNsaXBwYXRodW5pdHMiLCJjbGlwcnVsZSIsImNvbG9yIiwiY29sb3JpbnRlcnBvbGF0aW9uIiwiY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVycyIsImNvbG9ycHJvZmlsZSIsImNvbG9ycmVuZGVyaW5nIiwiY29udGVudHNjcmlwdHR5cGUiLCJjb250ZW50c3R5bGV0eXBlIiwiY3Vyc29yIiwiY3giLCJjeSIsImQiLCJkYXRhdHlwZSIsImRlY2VsZXJhdGUiLCJkZXNjZW50IiwiZGlmZnVzZWNvbnN0YW50IiwiZGlyZWN0aW9uIiwiZGlzcGxheSIsImRpdmlzb3IiLCJkb21pbmFudGJhc2VsaW5lIiwiZHVyIiwiZHgiLCJkeSIsImVkZ2Vtb2RlIiwiZWxldmF0aW9uIiwiZW5hYmxlYmFja2dyb3VuZCIsImVuZCIsImV4cG9uZW50IiwiZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZCIsImZpbGwiLCJmaWxsb3BhY2l0eSIsImZpbGxydWxlIiwiZmlsdGVyIiwiZmlsdGVycmVzIiwiZmlsdGVydW5pdHMiLCJmbG9vZG9wYWNpdHkiLCJmbG9vZGNvbG9yIiwiZm9jdXNhYmxlIiwiZm9udGZhbWlseSIsImZvbnRzaXplIiwiZm9udHNpemVhZGp1c3QiLCJmb250c3RyZXRjaCIsImZvbnRzdHlsZSIsImZvbnR2YXJpYW50IiwiZm9udHdlaWdodCIsImZyb20iLCJmeCIsImZ5IiwiZzEiLCJnMiIsImdseXBobmFtZSIsImdseXBob3JpZW50YXRpb25ob3Jpem9udGFsIiwiZ2x5cGhvcmllbnRhdGlvbnZlcnRpY2FsIiwiZ2x5cGhyZWYiLCJncmFkaWVudHRyYW5zZm9ybSIsImdyYWRpZW50dW5pdHMiLCJoYW5naW5nIiwiaG9yaXphZHZ4IiwiaG9yaXpvcmlnaW54IiwiaWRlb2dyYXBoaWMiLCJpbWFnZXJlbmRlcmluZyIsImluMiIsImluIiwiaW5saXN0IiwiaW50ZXJjZXB0IiwiazEiLCJrMiIsImszIiwiazQiLCJrIiwia2VybmVsbWF0cml4Iiwia2VybmVsdW5pdGxlbmd0aCIsImtlcm5pbmciLCJrZXlwb2ludHMiLCJrZXlzcGxpbmVzIiwia2V5dGltZXMiLCJsZW5ndGhhZGp1c3QiLCJsZXR0ZXJzcGFjaW5nIiwibGlnaHRpbmdjb2xvciIsImxpbWl0aW5nY29uZWFuZ2xlIiwibG9jYWwiLCJtYXJrZXJlbmQiLCJtYXJrZXJoZWlnaHQiLCJtYXJrZXJtaWQiLCJtYXJrZXJzdGFydCIsIm1hcmtlcnVuaXRzIiwibWFya2Vyd2lkdGgiLCJtYXNrIiwibWFza2NvbnRlbnR1bml0cyIsIm1hc2t1bml0cyIsIm1hdGhlbWF0aWNhbCIsIm1vZGUiLCJudW1vY3RhdmVzIiwib2Zmc2V0Iiwib3BhY2l0eSIsIm9wZXJhdG9yIiwib3JkZXIiLCJvcmllbnQiLCJvcmllbnRhdGlvbiIsIm9yaWdpbiIsIm92ZXJmbG93Iiwib3ZlcmxpbmVwb3NpdGlvbiIsIm92ZXJsaW5ldGhpY2tuZXNzIiwicGFpbnRvcmRlciIsInBhbm9zZTEiLCJwYXRobGVuZ3RoIiwicGF0dGVybmNvbnRlbnR1bml0cyIsInBhdHRlcm50cmFuc2Zvcm0iLCJwYXR0ZXJudW5pdHMiLCJwb2ludGVyZXZlbnRzIiwicG9pbnRzIiwicG9pbnRzYXR4IiwicG9pbnRzYXR5IiwicG9pbnRzYXR6IiwicHJlZml4IiwicHJlc2VydmVhbHBoYSIsInByZXNlcnZlYXNwZWN0cmF0aW8iLCJwcmltaXRpdmV1bml0cyIsInByb3BlcnR5IiwiciIsInJhZGl1cyIsInJlZngiLCJyZWZ5IiwicmVuZGVyaW5naW50ZW50IiwicmVwZWF0Y291bnQiLCJyZXBlYXRkdXIiLCJyZXF1aXJlZGV4dGVuc2lvbnMiLCJyZXF1aXJlZGZlYXR1cmVzIiwicmVzb3VyY2UiLCJyZXN0YXJ0IiwicmVzdWx0IiwicmVzdWx0cyIsInJvdGF0ZSIsInJ4IiwicnkiLCJzY2FsZSIsInNlY3VyaXR5Iiwic2VlZCIsInNoYXBlcmVuZGVyaW5nIiwic2xvcGUiLCJzcGFjaW5nIiwic3BlY3VsYXJjb25zdGFudCIsInNwZWN1bGFyZXhwb25lbnQiLCJzcGVlZCIsInNwcmVhZG1ldGhvZCIsInN0YXJ0b2Zmc2V0Iiwic3RkZGV2aWF0aW9uIiwic3RlbWgiLCJzdGVtdiIsInN0aXRjaHRpbGVzIiwic3RvcGNvbG9yIiwic3RvcG9wYWNpdHkiLCJzdHJpa2V0aHJvdWdocG9zaXRpb24iLCJzdHJpa2V0aHJvdWdodGhpY2tuZXNzIiwic3RyaW5nIiwic3Ryb2tlIiwic3Ryb2tlZGFzaGFycmF5Iiwic3Ryb2tlZGFzaG9mZnNldCIsInN0cm9rZWxpbmVjYXAiLCJzdHJva2VsaW5lam9pbiIsInN0cm9rZW1pdGVybGltaXQiLCJzdHJva2V3aWR0aCIsInN0cm9rZW9wYWNpdHkiLCJzdXBwcmVzc2NvbnRlbnRlZGl0YWJsZXdhcm5pbmciLCJzdXBwcmVzc2h5ZHJhdGlvbndhcm5pbmciLCJzdXJmYWNlc2NhbGUiLCJzeXN0ZW1sYW5ndWFnZSIsInRhYmxldmFsdWVzIiwidGFyZ2V0eCIsInRhcmdldHkiLCJ0ZXh0YW5jaG9yIiwidGV4dGRlY29yYXRpb24iLCJ0ZXh0bGVuZ3RoIiwidGV4dHJlbmRlcmluZyIsInRvIiwidHJhbnNmb3JtIiwidHJhbnNmb3Jtb3JpZ2luIiwidHlwZW9mIiwidTEiLCJ1MiIsInVuZGVybGluZXBvc2l0aW9uIiwidW5kZXJsaW5ldGhpY2tuZXNzIiwidW5pY29kZSIsInVuaWNvZGViaWRpIiwidW5pY29kZXJhbmdlIiwidW5pdHNwZXJlbSIsInVuc2VsZWN0YWJsZSIsInZhbHBoYWJldGljIiwidmFsdWVzIiwidmVjdG9yZWZmZWN0IiwidmVyc2lvbiIsInZlcnRhZHZ5IiwidmVydG9yaWdpbngiLCJ2ZXJ0b3JpZ2lueSIsInZoYW5naW5nIiwidmlkZW9ncmFwaGljIiwidmlld2JveCIsInZpZXd0YXJnZXQiLCJ2aXNpYmlsaXR5Iiwidm1hdGhlbWF0aWNhbCIsInZvY2FiIiwid2lkdGhzIiwid29yZHNwYWNpbmciLCJ3cml0aW5nbW9kZSIsIngxIiwieDIiLCJ4IiwieGNoYW5uZWxzZWxlY3RvciIsInhoZWlnaHQiLCJ4bGlua2FjdHVhdGUiLCJ4bGlua2FyY3JvbGUiLCJ4bGlua2hyZWYiLCJ4bGlua3JvbGUiLCJ4bGlua3Nob3ciLCJ4bGlua3RpdGxlIiwieGxpbmt0eXBlIiwieG1sYmFzZSIsInhtbGxhbmciLCJ4bWxucyIsInhtbG5zeGxpbmsiLCJ4bWxzcGFjZSIsInkxIiwieTIiLCJ5IiwieWNoYW5uZWxzZWxlY3RvciIsInoiLCJ6b29tYW5kcGFuIiwid2FybmVkUHJvcGVydGllcyIsIkVWRU5UX05BTUVfUkVHRVgiLCJJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgiLCJyQVJJQSIsInJBUklBQ2FtZWwiLCJ2YWxpZGF0ZVByb3BlcnR5IiwiZXZlbnRSZWdpc3RyeSIsInJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMiLCJwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzIiwicmVnaXN0cmF0aW9uTmFtZSIsInVuZGVmaW5lZCIsImlzTmFOIiwid2FyblVua25vd25Qcm9wZXJ0aWVzIiwidW5rbm93blByb3BzIiwidmFsaWRhdGVQcm9wZXJ0aWVzIiwiYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuIiwibXNQYXR0ZXJuJDEiLCJoeXBoZW5QYXR0ZXJuIiwiYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuIiwid2FybmVkU3R5bGVOYW1lcyIsIndhcm5lZFN0eWxlVmFsdWVzIiwid2FybmVkRm9yTmFOVmFsdWUiLCJ3YXJuZWRGb3JJbmZpbml0eVZhbHVlIiwiY2FtZWxpemUiLCJyZXBsYWNlIiwiXyIsImNoYXJhY3RlciIsInRvVXBwZXJDYXNlIiwid2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUiLCJ3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUiLCJjaGFyQXQiLCJ3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24iLCJ3YXJuU3R5bGVWYWx1ZUlzTmFOIiwid2FyblN0eWxlVmFsdWVJc0luZmluaXR5Iiwid2FyblZhbGlkU3R5bGUiLCJpc0Zpbml0ZSIsIm1hdGNoSHRtbFJlZ0V4cCIsImVzY2FwZUh0bWwiLCJzdHIiLCJtYXRjaCIsImV4ZWMiLCJlc2NhcGUiLCJodG1sIiwiaW5kZXgiLCJsYXN0SW5kZXgiLCJjaGFyQ29kZUF0IiwiZXNjYXBlVGV4dEZvckJyb3dzZXIiLCJ0ZXh0IiwidXBwZXJjYXNlUGF0dGVybiIsIm1zUGF0dGVybiIsImh5cGhlbmF0ZVN0eWxlTmFtZSIsImlzSmF2YVNjcmlwdFByb3RvY29sIiwiZGlkV2FybiIsInNhbml0aXplVVJMIiwidXJsIiwic3RyaW5naWZpZWRVUkwiLCJKU09OIiwic3RyaW5naWZ5IiwiaXNBcnJheUltcGwiLCJpc0FycmF5IiwiYSIsImNsaWVudFJlbmRlckJvdW5kYXJ5IiwiY29tcGxldGVCb3VuZGFyeSIsImNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzIiwiY29tcGxldGVTZWdtZW50IiwiZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nT2JqZWN0Rm9yV2FybmluZyIsInRoaW5nIiwiZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmciLCJjb21wYXJlUmVzb3VyY2VQcm9wc0Zvcldhcm5pbmciLCJuZXdQcm9wcyIsImN1cnJlbnRQcm9wcyIsInByb3BEaWZmcyIsImFsbFByb3BzIiwia2V5cyIsImkiLCJuZXdWYWx1ZSIsImN1cnJlbnRWYWx1ZSIsIm1pc3NpbmciLCJleHRyYSIsImRpZmZlcmVudCIsIm9yaWdpbmFsIiwibGF0ZXN0IiwiZGVzY3JpYmVEaWZmZXJlbmNlc0ZvclN0eWxlc2hlZXRzIiwiZGlmZiIsImRlc2NyaXB0aW9uIiwicHJvcFZhbHVlIiwiX3Byb3BOYW1lIiwiX3Byb3BWYWx1ZSIsIl9wcm9wTmFtZTIiLCJsYXRlc3RWYWx1ZSIsIm9yaWdpbmFsVmFsdWUiLCJkZXNjcmliZURpZmZlcmVuY2VzRm9yU3R5bGVzaGVldE92ZXJQcmVpbml0IiwiX3Byb3BOYW1lMyIsImRlc2NyaWJlRGlmZmVyZW5jZXNGb3JQcmVpbml0T3ZlclN0eWxlc2hlZXQiLCJfcHJvcE5hbWU0IiwiX3Byb3BWYWx1ZTIiLCJfcHJvcE5hbWU1IiwiZGVzY3JpYmVEaWZmZXJlbmNlc0ZvclByZWluaXRzIiwiX3Byb3BOYW1lNiIsIl9wcm9wVmFsdWUzIiwiX3Byb3BOYW1lNyIsInByZWxvYWRPcHRpb25zRm9yQ29tcGFyaXNvbiIsImRlc2NyaWJlRGlmZmVyZW5jZXNGb3JQcmVsb2FkcyIsImluY2x1ZGVzIiwiX3Byb3BOYW1lOCIsIl9wcm9wVmFsdWU0IiwiX3Byb3BOYW1lOSIsImRlc2NyaWJlRGlmZmVyZW5jZXNGb3JQcmVsb2FkT3ZlckltcGxpY2l0UHJlbG9hZCIsIl9wcm9wTmFtZTEwIiwiX3Byb3BWYWx1ZTUiLCJfcHJvcE5hbWUxMSIsImRlc2NyaWJlRGlmZmVyZW5jZXNGb3JTY3JpcHRzIiwiX3Byb3BOYW1lMTIiLCJfcHJvcFZhbHVlNiIsIl9wcm9wTmFtZTEzIiwiZGVzY3JpYmVEaWZmZXJlbmNlc0ZvclNjcmlwdE92ZXJQcmVpbml0IiwiX3Byb3BOYW1lMTQiLCJkZXNjcmliZURpZmZlcmVuY2VzRm9yUHJlaW5pdE92ZXJTY3JpcHQiLCJfcHJvcE5hbWUxNSIsIlJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzIiwiUmVhY3RET01DdXJyZW50RGlzcGF0Y2hlciIsIkRpc3BhdGNoZXIiLCJSZWFjdERPTVNlcnZlckRpc3BhdGNoZXIiLCJwcmVmZXRjaEROUyIsInByZWNvbm5lY3QiLCJwcmVpbml0IiwicHJlcGFyZUhvc3REaXNwYXRjaGVyIiwiY3VycmVudCIsIlNjcmlwdFN0cmVhbWluZ0Zvcm1hdCIsIkRhdGFTdHJlYW1pbmdGb3JtYXQiLCJOb3RoaW5nU2VudCIsIlNlbnRDb21wbGV0ZVNlZ21lbnRGdW5jdGlvbiIsIlNlbnRDb21wbGV0ZUJvdW5kYXJ5RnVuY3Rpb24iLCJTZW50Q2xpZW50UmVuZGVyRnVuY3Rpb24iLCJTZW50U3R5bGVJbnNlcnRpb25GdW5jdGlvbiIsImRhdGFFbGVtZW50UXVvdGVkRW5kIiwic3RhcnRJbmxpbmVTY3JpcHQiLCJlbmRJbmxpbmVTY3JpcHQiLCJzdGFydFNjcmlwdFNyYyIsInN0YXJ0TW9kdWxlU3JjIiwic2NyaXB0Tm9uY2UiLCJzY3JpcHRJbnRlZ2lydHkiLCJzY3JpcHRDcm9zc09yaWdpbiIsImVuZEFzeW5jU2NyaXB0IiwiZXNjYXBlQm9vdHN0cmFwU2NyaXB0Q29udGVudCIsInNjcmlwdFRleHQiLCJzY3JpcHRSZWdleCIsInNjcmlwdFJlcGxhY2VyIiwicyIsInN1ZmZpeCIsImNyZWF0ZVJlc3BvbnNlU3RhdGUkMSIsInJlc291cmNlcyIsImlkZW50aWZpZXJQcmVmaXgiLCJib290c3RyYXBTY3JpcHRDb250ZW50IiwiYm9vdHN0cmFwU2NyaXB0cyIsImJvb3RzdHJhcE1vZHVsZXMiLCJleHRlcm5hbFJ1bnRpbWVDb25maWciLCJpZFByZWZpeCIsImlubGluZVNjcmlwdFdpdGhOb25jZSIsImJvb3RzdHJhcENodW5rcyIsImV4dGVybmFsUnVudGltZVNjcmlwdCIsInN0cmVhbWluZ0Zvcm1hdCIsImNodW5rcyIsInB1c2hTY3JpcHRJbXBsIiwic2NyaXB0Q29uZmlnIiwiY3Jvc3NPcmlnaW4iLCJwcmVsb2FkQm9vdHN0cmFwU2NyaXB0IiwiX2kiLCJfc2NyaXB0Q29uZmlnIiwiX3NyYyIsIl9pbnRlZ3JpdHkiLCJfY3Jvc3NPcmlnaW4iLCJwcmVsb2FkQm9vdHN0cmFwTW9kdWxlIiwicGxhY2Vob2xkZXJQcmVmaXgiLCJzZWdtZW50UHJlZml4IiwiYm91bmRhcnlQcmVmaXgiLCJuZXh0U3VzcGVuc2VJRCIsImluc3RydWN0aW9ucyIsImh0bWxDaHVua3MiLCJoZWFkQ2h1bmtzIiwiaGFzQm9keSIsImNoYXJzZXRDaHVua3MiLCJwcmVjb25uZWN0Q2h1bmtzIiwicHJlbG9hZENodW5rcyIsImhvaXN0YWJsZUNodW5rcyIsInN0eWxlc1RvSG9pc3QiLCJST09UX0hUTUxfTU9ERSIsIkhUTUxfSFRNTF9NT0RFIiwiSFRNTF9NT0RFIiwiU1ZHX01PREUiLCJNQVRITUxfTU9ERSIsIkhUTUxfVEFCTEVfTU9ERSIsIkhUTUxfVEFCTEVfQk9EWV9NT0RFIiwiSFRNTF9UQUJMRV9ST1dfTU9ERSIsIkhUTUxfQ09MR1JPVVBfTU9ERSIsImNyZWF0ZUZvcm1hdENvbnRleHQiLCJpbnNlcnRpb25Nb2RlIiwic2VsZWN0ZWRWYWx1ZSIsIm5vc2NyaXB0VGFnSW5TY29wZSIsImdldENoaWxkRm9ybWF0Q29udGV4dCIsInBhcmVudENvbnRleHQiLCJkZWZhdWx0VmFsdWUiLCJVTklOSVRJQUxJWkVEX1NVU1BFTlNFX0JPVU5EQVJZX0lEIiwiYXNzaWduU3VzcGVuc2VCb3VuZGFyeUlEIiwicmVzcG9uc2VTdGF0ZSIsImdlbmVyYXRlZElEIiwidG9TdHJpbmciLCJtYWtlSWQiLCJ0cmVlSWQiLCJsb2NhbElkIiwiZW5jb2RlSFRNTFRleHROb2RlIiwidGV4dFNlcGFyYXRvciIsInB1c2hUZXh0SW5zdGFuY2UkMSIsInRleHRFbWJlZGRlZCIsInB1c2hTZWdtZW50RmluYWxlJDEiLCJsYXN0UHVzaGVkVGV4dCIsInN0eWxlTmFtZUNhY2hlIiwicHJvY2Vzc1N0eWxlTmFtZSIsInN0eWxlTmFtZSIsInNldCIsInN0eWxlQXR0cmlidXRlU3RhcnQiLCJzdHlsZUFzc2lnbiIsInN0eWxlU2VwYXJhdG9yIiwicHVzaFN0eWxlQXR0cmlidXRlIiwiRXJyb3IiLCJpc0ZpcnN0Iiwic3R5bGVWYWx1ZSIsIm5hbWVDaHVuayIsInZhbHVlQ2h1bmsiLCJpc0N1c3RvbVByb3BlcnR5IiwidHJpbSIsImF0dHJpYnV0ZUVuZCIsImF0dHJpYnV0ZVNlcGFyYXRvciIsImF0dHJpYnV0ZUFzc2lnbiIsImF0dHJpYnV0ZUVtcHR5U3RyaW5nIiwicHVzaEJvb2xlYW5BdHRyaWJ1dGUiLCJwdXNoU3RyaW5nQXR0cmlidXRlIiwic3RhcnRIaWRkZW5JbnB1dENodW5rIiwicHVzaEFkZGl0aW9uYWxGb3JtRmllbGQiLCJlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmciLCJwdXNoQWRkaXRpb25hbEZvcm1GaWVsZHMiLCJmb3JtRGF0YSIsImZvckVhY2giLCJwdXNoRm9ybUFjdGlvbkF0dHJpYnV0ZSIsImZvcm1BY3Rpb24iLCJmb3JtRW5jVHlwZSIsImZvcm1NZXRob2QiLCJmb3JtVGFyZ2V0IiwicHVzaEF0dHJpYnV0ZSIsInNhbml0aXplZFZhbHVlIiwiX3Nhbml0aXplZFZhbHVlIiwiZW5kT2ZTdGFydFRhZyIsInB1c2hJbm5lckhUTUwiLCJpbm5lckhUTUwiLCJfX2h0bWwiLCJkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUiLCJkaWRXYXJuRGVmYXVsdENoZWNrZWQiLCJkaWRXYXJuRGVmYXVsdFNlbGVjdFZhbHVlIiwiZGlkV2FybkRlZmF1bHRUZXh0YXJlYVZhbHVlIiwiZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiIsImRpZFdhcm5JbnZhbGlkT3B0aW9uSW5uZXJIVE1MIiwiZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24iLCJkaWRXYXJuRm9ybUFjdGlvblR5cGUiLCJjaGVja1NlbGVjdFByb3AiLCJhcnJheSIsInB1c2hTdGFydFNlbGVjdCIsInN0YXJ0Q2h1bmtGb3JUYWciLCJwcm9wS2V5IiwiZmxhdHRlbk9wdGlvbkNoaWxkcmVuIiwiQ2hpbGRyZW4iLCJjaGlsZCIsInNlbGVjdGVkTWFya2VyQXR0cmlidXRlIiwicHVzaFN0YXJ0T3B0aW9uIiwiZm9ybWF0Q29udGV4dCIsInN0cmluZ1ZhbHVlIiwidiIsInB1c2hTdGFydEZvcm0iLCJwdXNoSW5wdXQiLCJkZWZhdWx0Q2hlY2tlZCIsInB1c2hTdGFydEJ1dHRvbiIsInB1c2hTdGFydFRleHRBcmVhIiwibGVhZGluZ05ld2xpbmUiLCJwdXNoTWV0YSIsIml0ZW1Qcm9wIiwicHVzaFNlbGZDbG9zaW5nIiwiY2hhclNldCIsInB1c2hMaW5rIiwicHJlY2VkZW5jZSIsInB1c2hMaW5rSW1wbCIsImdldFJlc291cmNlS2V5Iiwib25Mb2FkIiwib25FcnJvciIsInByb3BEZXNjcmlwdGlvbiIsInN0eWxlc01hcCIsImRldlJlc291cmNlIiwiZ2V0QXNSZXNvdXJjZURFViIsIl9fcHJvdmVuYW5jZSIsImRpZmZlcmVuY2VEZXNjcmlwdGlvbiIsIl9fb3JpZ2luYWxQcm9wcyIsIl9kaWZmZXJlbmNlRGVzY3JpcHRpb24iLCJfX3Byb3BzRXF1aXZhbGVudCIsInJlc291cmNlUHJvcHMiLCJzdHlsZXNoZWV0UHJvcHNGcm9tUmF3UHJvcHMiLCJwcmVsb2FkUmVzb3VyY2UiLCJwcmVsb2Fkc01hcCIsInN0YXRlIiwiTm9TdGF0ZSIsIkJsb2NrZWQiLCJhZG9wdFByZWxvYWRQcm9wc0ZvclN0eWxlc2hlZXRQcm9wcyIsIkZsdXNoZWQiLCJQcmVsb2FkRmx1c2hlZCIsIm1hcmtBc1JlbmRlcmVkUmVzb3VyY2VERVYiLCJwcmVjZWRlbmNlU2V0IiwicHJlY2VkZW5jZXMiLCJlbXB0eVN0eWxlUmVzb3VyY2UiLCJocmVmcyIsImFkZCIsInN0eWxlUHJlY2VkZW5jZXMiLCJib3VuZGFyeVJlc291cmNlcyIsInB1c2hTdHlsZSIsImNoaWxkVHlwZSIsInB1c2hTdHlsZUltcGwiLCJwdXNoU3R5bGVDb250ZW50cyIsImVuZFRhZzEiLCJlbmRUYWcyIiwiZ2V0SW1hZ2VQcmVsb2FkS2V5IiwiaW1hZ2VTcmNTZXQiLCJpbWFnZVNpemVzIiwidW5pcXVlUGFydCIsInB1c2hJbWciLCJzcmNTZXQiLCJsb2FkaW5nIiwiZmV0Y2hQcmlvcml0eSIsInJlZmVycmVyUG9saWN5IiwiaGlnaEltYWdlUHJlbG9hZHMiLCJidWxrUHJlbG9hZHMiLCJ0YWciLCJwdXNoU3RhcnRNZW51SXRlbSIsInB1c2hUaXRsZSIsIiQkdHlwZW9mIiwicHVzaFRpdGxlSW1wbCIsInB1c2hTdGFydEhlYWQiLCJwdXNoU3RhcnRHZW5lcmljRWxlbWVudCIsInB1c2hTdGFydEh0bWwiLCJET0NUWVBFIiwicHVzaFNjcmlwdCIsImFzeW5jUHJvcCIsInNjcmlwdHNNYXAiLCJfZGlmZmVyZW5jZURlc2NyaXB0aW9uMiIsInNjcmlwdHMiLCJzY3JpcHRQcm9wcyIsImFkb3B0UHJlbG9hZFByb3BzRm9yU2NyaXB0UHJvcHMiLCJkZXNjcmlwdGl2ZVN0YXRlbWVudCIsInB1c2hTdGFydEN1c3RvbUVsZW1lbnQiLCJwdXNoU3RhcnRQcmVmb3JtYXR0ZWRFbGVtZW50IiwiVkFMSURfVEFHX1JFR0VYIiwidmFsaWRhdGVkVGFnQ2FjaGUiLCJ0YWdTdGFydENodW5rIiwicHVzaFN0YXJ0SW5zdGFuY2UiLCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmciLCJjb250ZW50RWRpdGFibGUiLCJwdXNoRW5kSW5zdGFuY2UiLCJ3cml0ZUJvb3RzdHJhcCIsImxhc3RDaHVuayIsIndyaXRlQ29tcGxldGVkUm9vdCIsInBsYWNlaG9sZGVyMSIsInBsYWNlaG9sZGVyMiIsIndyaXRlUGxhY2Vob2xkZXIiLCJmb3JtYXR0ZWRJRCIsInN0YXJ0Q29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSIsInN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkxIiwic3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTIiLCJzdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSIsImVuZFN1c3BlbnNlQm91bmRhcnkiLCJjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjEiLCJjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWwiLCJjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFBIiwiY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQiIsImNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUMiLCJjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjIiLCJ3cml0ZVN0YXJ0Q29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSQxIiwid3JpdGVTdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5Iiwid3JpdGVTdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSQxIiwiZXJyb3JEaWdlc3QiLCJlcnJvck1lc3NzYWdlIiwiZXJyb3JDb21wb25lbnRTdGFjayIsIndyaXRlRW5kQ29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSQxIiwid3JpdGVFbmRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeSIsIndyaXRlRW5kQ2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5JDEiLCJzdGFydFNlZ21lbnRIVE1MIiwic3RhcnRTZWdtZW50SFRNTDIiLCJlbmRTZWdtZW50SFRNTCIsInN0YXJ0U2VnbWVudFNWRyIsInN0YXJ0U2VnbWVudFNWRzIiLCJlbmRTZWdtZW50U1ZHIiwic3RhcnRTZWdtZW50TWF0aE1MIiwic3RhcnRTZWdtZW50TWF0aE1MMiIsImVuZFNlZ21lbnRNYXRoTUwiLCJzdGFydFNlZ21lbnRUYWJsZSIsInN0YXJ0U2VnbWVudFRhYmxlMiIsImVuZFNlZ21lbnRUYWJsZSIsInN0YXJ0U2VnbWVudFRhYmxlQm9keSIsInN0YXJ0U2VnbWVudFRhYmxlQm9keTIiLCJlbmRTZWdtZW50VGFibGVCb2R5Iiwic3RhcnRTZWdtZW50VGFibGVSb3ciLCJzdGFydFNlZ21lbnRUYWJsZVJvdzIiLCJlbmRTZWdtZW50VGFibGVSb3ciLCJzdGFydFNlZ21lbnRDb2xHcm91cCIsInN0YXJ0U2VnbWVudENvbEdyb3VwMiIsImVuZFNlZ21lbnRDb2xHcm91cCIsIndyaXRlU3RhcnRTZWdtZW50Iiwid3JpdGVFbmRTZWdtZW50IiwiY29tcGxldGVTZWdtZW50U2NyaXB0MUZ1bGwiLCJjb21wbGV0ZVNlZ21lbnRTY3JpcHQxUGFydGlhbCIsImNvbXBsZXRlU2VnbWVudFNjcmlwdDIiLCJjb21wbGV0ZVNlZ21lbnRTY3JpcHRFbmQiLCJjb21wbGV0ZVNlZ21lbnREYXRhMSIsImNvbXBsZXRlU2VnbWVudERhdGEyIiwiY29tcGxldGVTZWdtZW50RGF0YUVuZCIsIndyaXRlQ29tcGxldGVkU2VnbWVudEluc3RydWN0aW9uIiwiY29udGVudFNlZ21lbnRJRCIsInNjcmlwdEZvcm1hdCIsImNvbXBsZXRlQm91bmRhcnlTY3JpcHQxRnVsbCIsImNvbXBsZXRlQm91bmRhcnlTY3JpcHQxUGFydGlhbCIsImNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MUZ1bGxCb3RoIiwiY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNTY3JpcHQxRnVsbFBhcnRpYWwiLCJjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFQYXJ0aWFsIiwiY29tcGxldGVCb3VuZGFyeVNjcmlwdDIiLCJjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0M2EiLCJjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0M2IiLCJjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0RW5kIiwiY29tcGxldGVCb3VuZGFyeURhdGExIiwiY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNEYXRhMSIsImNvbXBsZXRlQm91bmRhcnlEYXRhMiIsImNvbXBsZXRlQm91bmRhcnlEYXRhM2EiLCJjb21wbGV0ZUJvdW5kYXJ5RGF0YUVuZCIsIndyaXRlQ29tcGxldGVkQm91bmRhcnlJbnN0cnVjdGlvbiIsImJvdW5kYXJ5SUQiLCJyZXF1aXJlc1N0eWxlSW5zZXJ0aW9uIiwiZm9ybWF0dGVkQ29udGVudElEIiwid3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jaWVzSW5KUyIsIndyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY2llc0luQXR0ciIsIndyaXRlTW9yZSIsImNsaWVudFJlbmRlclNjcmlwdDFGdWxsIiwiY2xpZW50UmVuZGVyU2NyaXB0MVBhcnRpYWwiLCJjbGllbnRSZW5kZXJTY3JpcHQxQSIsImNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsIiwiY2xpZW50UmVuZGVyU2NyaXB0RW5kIiwiY2xpZW50UmVuZGVyRGF0YTEiLCJjbGllbnRSZW5kZXJEYXRhMiIsImNsaWVudFJlbmRlckRhdGEzIiwiY2xpZW50UmVuZGVyRGF0YTQiLCJjbGllbnRSZW5kZXJEYXRhRW5kIiwid3JpdGVDbGllbnRSZW5kZXJCb3VuZGFyeUluc3RydWN0aW9uIiwiZXJyb3JNZXNzYWdlIiwiZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzIiwicmVnZXhGb3JKU1N0cmluZ3NJbkluc3RydWN0aW9uU2NyaXB0cyIsImlucHV0IiwiZXNjYXBlZCIsInJlZ2V4Rm9ySlNTdHJpbmdzSW5TY3JpcHRzIiwiZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMiLCJsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4xIiwibGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMiIsImxhdGVTdHlsZVRhZ1Jlc291cmNlT3BlbjMiLCJsYXRlU3R5bGVUYWdUZW1wbGF0ZUNsb3NlIiwiY3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlIYXNTdHlsZXNUb0hvaXN0IiwiZGVzdGluYXRpb25IYXNDYXBhY2l0eSIsImZsdXNoU3R5bGVUYWdzTGF0ZUZvckJvdW5kYXJ5IiwiRmx1c2hlZEluUHJlYW1ibGUiLCJzcGFjZVNlcGFyYXRvciIsIndyaXRlUmVzb3VyY2VzRm9yQm91bmRhcnkiLCJmbHVzaFJlc291cmNlSW5QcmVhbWJsZSIsImZsdXNoUmVzb3VyY2VMYXRlIiwiRmx1c2hlZExhdGUiLCJwcmVjZWRlbmNlU3R5bGVUYWdSZXNvdXJjZSIsImRpZEZsdXNoUHJlY2VkZW5jZSIsImZsdXNoU3R5bGVJblByZWFtYmxlIiwiZGVsZXRlIiwic3R5bGVUYWdSZXNvdXJjZU9wZW4xIiwic3R5bGVUYWdSZXNvdXJjZU9wZW4yIiwic3R5bGVUYWdSZXNvdXJjZU9wZW4zIiwic3R5bGVUYWdSZXNvdXJjZUNsb3NlIiwiZmx1c2hBbGxTdHlsZXNJblByZWFtYmxlIiwiY2xlYXIiLCJwcmVsb2FkTGF0ZVN0eWxlIiwicHJlbG9hZFByb3BzIiwicHJlbG9hZEFzU3R5bGVQcm9wc0Zyb21Qcm9wcyIsInByZWxvYWRMYXRlU3R5bGVzIiwid3JpdGVQcmVhbWJsZSIsIndpbGxGbHVzaEFsbFNlZ21lbnRzIiwiX3Jlc3BvbnNlU3RhdGUkZXh0ZXJuIiwiaW50ZXJuYWxQcmVpbml0U2NyaXB0IiwicHJlY29ubmVjdHMiLCJmb250UHJlbG9hZHMiLCJ3cml0ZUhvaXN0YWJsZXMiLCJ3cml0ZVBvc3RhbWJsZSIsImFycmF5Rmlyc3RPcGVuQnJhY2tldCIsImFycmF5U3Vic2VxdWVudE9wZW5CcmFja2V0IiwiYXJyYXlJbnRlcnN0aXRpYWwiLCJhcnJheUNsb3NlQnJhY2tldCIsIm5leHRBcnJheU9wZW5CcmFja0NodW5rIiwid3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jeUhyZWZPbmx5SW5KUyIsIndyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY3lJbkpTIiwiY29lcmNlZEhyZWYiLCJjb2VyY2VkUHJlY2VkZW5jZSIsIndyaXRlU3R5bGVSZXNvdXJjZUF0dHJpYnV0ZUluSlMiLCJhdHRyaWJ1dGVWYWx1ZSIsIndyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY3lIcmVmT25seUluQXR0ciIsIndyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY3lJbkF0dHIiLCJ3cml0ZVN0eWxlUmVzb3VyY2VBdHRyaWJ1dGVJbkF0dHIiLCJjcmVhdGVSZXNvdXJjZXMiLCJwcmVjb25uZWN0c01hcCIsImNyZWF0ZUJvdW5kYXJ5UmVzb3VyY2VzIiwic2V0Q3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlSZXNvdXJjZXNUYXJnZXQiLCJvcHRpb25zIiwicmVxdWVzdCIsInJlc29sdmVSZXF1ZXN0IiwiZ2V0UmVzb3VyY2VzIiwiZmx1c2hSZXNvdXJjZXMiLCJlbmNvdW50ZXJlZCIsIl9fb3JpZ2luYWxPcHRpb25zIiwiX2RpZmZlcmVuY2VEZXNjcmlwdGlvbjMiLCJfX2ltcGxpZWRQcm9wcyIsImVsZW1lbnREZXNjcmlwdGlvbiIsInByZWxvYWRQcm9wc0Zyb21QcmVsb2FkT3B0aW9ucyIsIm1hcmtBc0ltcGVyYXRpdmVSZXNvdXJjZURFViIsInN0eWxlc2hlZXRQcm9wc0Zyb21QcmVpbml0T3B0aW9ucyIsInByb3BzRXF1aXZhbGVudCIsIl9kaWZmZXJlbmNlRGVzY3JpcHRpb240IiwiX3Jlc291cmNlIiwiX2RldlJlc291cmNlIiwiX3Byb3BzRXF1aXZhbGVudCIsInNjcmlwdFByb3BzRnJvbVByZWluaXRPcHRpb25zIiwiX2RpZmZlcmVuY2VEZXNjcmlwdGlvbjUiLCJfZGlmZmVyZW5jZURlc2NyaXB0aW9uNiIsIl9yZXNvdXJjZVByb3BzIiwiaHJlZkxhbmciLCJyYXdQcm9wcyIsImhvaXN0U3R5bGVSZXNvdXJjZSIsImhvaXN0UmVzb3VyY2VzIiwic291cmNlIiwiY3VycmVudEJvdW5kYXJ5UmVzb3VyY2VzIiwib3JpZ2luYWxQcm9wcyIsInByb3ZlbmFuY2UiLCJvcmlnaW5hbEhyZWYiLCJvcmlnaW5hbE9wdGlvbnMiLCJfX29yaWdpbmFsSHJlZiIsImNyZWF0ZVJlc3BvbnNlU3RhdGUiLCJnZW5lcmF0ZVN0YXRpY01hcmt1cCIsImNyZWF0ZVJvb3RGb3JtYXRDb250ZXh0IiwicHVzaFRleHRJbnN0YW5jZSIsInB1c2hTZWdtZW50RmluYWxlIiwid3JpdGVTdGFydENvbXBsZXRlZFN1c3BlbnNlQm91bmRhcnkiLCJ3cml0ZVN0YXJ0Q2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5Iiwid3JpdGVFbmRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5Iiwid3JpdGVFbmRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUiLCJSRUFDVF9NRU1PX1RZUEUiLCJSRUFDVF9MQVpZX1RZUEUiLCJSRUFDVF9TQ09QRV9UWVBFIiwiUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUiLCJSRUFDVF9PRkZTQ1JFRU5fVFlQRSIsIlJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSIsIlJFQUNUX0NBQ0hFX1RZUEUiLCJSRUFDVF9TRVJWRVJfQ09OVEVYVF9ERUZBVUxUX1ZBTFVFX05PVF9MT0FERUQiLCJNQVlCRV9JVEVSQVRPUl9TWU1CT0wiLCJpdGVyYXRvciIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwiZ2V0SXRlcmF0b3JGbiIsIm1heWJlSXRlcmFibGUiLCJtYXliZUl0ZXJhdG9yIiwiZ2V0V3JhcHBlZE5hbWUiLCJvdXRlclR5cGUiLCJpbm5lclR5cGUiLCJ3cmFwcGVyTmFtZSIsImRpc3BsYXlOYW1lIiwiZnVuY3Rpb25OYW1lIiwiZ2V0Q29udGV4dE5hbWUiLCJnZXRDb21wb25lbnROYW1lRnJvbVR5cGUiLCJjb250ZXh0IiwicHJvdmlkZXIiLCJfY29udGV4dCIsInJlbmRlciIsIm91dGVyTmFtZSIsImxhenlDb21wb25lbnQiLCJwYXlsb2FkIiwiX3BheWxvYWQiLCJpbml0IiwiX2luaXQiLCJjb250ZXh0MiIsIl9nbG9iYWxOYW1lIiwiZGlzYWJsZWREZXB0aCIsInByZXZMb2ciLCJwcmV2SW5mbyIsInByZXZXYXJuIiwicHJldkVycm9yIiwicHJldkdyb3VwIiwicHJldkdyb3VwQ29sbGFwc2VkIiwicHJldkdyb3VwRW5kIiwiZGlzYWJsZWRMb2ciLCJfX3JlYWN0RGlzYWJsZWRMb2ciLCJkaXNhYmxlTG9ncyIsImxvZyIsImluZm8iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicmVlbmFibGVMb2dzIiwiUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxIiwiUmVhY3RDdXJyZW50RGlzcGF0Y2hlciIsImRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lIiwib3duZXJGbiIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwiV2Vha01hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwiY29udHJvbCIsInByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UiLCJwcmVwYXJlU3RhY2tUcmFjZSIsInByZXZpb3VzRGlzcGF0Y2hlciIsIkZha2UiLCJSZWZsZWN0IiwibWF5YmVQcm9taXNlIiwiY2F0Y2giLCJzYW1wbGUiLCJzYW1wbGVMaW5lcyIsInNwbGl0IiwiY29udHJvbExpbmVzIiwiYyIsIl9mcmFtZSIsInN5bnRoZXRpY0ZyYW1lIiwiZGVzY3JpYmVDbGFzc0NvbXBvbmVudEZyYW1lIiwiY3RvciIsImRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSIsInNob3VsZENvbnN0cnVjdCQxIiwiQ29tcG9uZW50IiwiaXNSZWFjdENvbXBvbmVudCIsImRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFViIsImxvZ2dlZFR5cGVGYWlsdXJlcyIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSIsInNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50IiwiZWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJ3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQiLCJlbXB0eUNvbnRleHRPYmplY3QiLCJmcmVlemUiLCJnZXRNYXNrZWRDb250ZXh0IiwidW5tYXNrZWRDb250ZXh0IiwiY29udGV4dFR5cGVzIiwicHJvY2Vzc0NoaWxkQ29udGV4dCIsImluc3RhbmNlIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJnZXRDaGlsZENvbnRleHQiLCJjaGlsZENvbnRleHQiLCJjb250ZXh0S2V5IiwicmVuZGVyZXJTaWdpbCIsInJvb3RDb250ZXh0U25hcHNob3QiLCJjdXJyZW50QWN0aXZlU25hcHNob3QiLCJwb3BOb2RlIiwicHJldiIsIl9jdXJyZW50VmFsdWUyIiwicGFyZW50VmFsdWUiLCJwdXNoTm9kZSIsIm5leHQiLCJwb3BUb05lYXJlc3RDb21tb25BbmNlc3RvciIsInBhcmVudFByZXYiLCJwYXJlbnQiLCJwYXJlbnROZXh0IiwicG9wQWxsUHJldmlvdXMiLCJwdXNoQWxsTmV4dCIsInBvcFByZXZpb3VzVG9Db21tb25MZXZlbCIsImRlcHRoIiwicG9wTmV4dFRvQ29tbW9uTGV2ZWwiLCJzd2l0Y2hDb250ZXh0IiwibmV3U25hcHNob3QiLCJwdXNoUHJvdmlkZXIiLCJuZXh0VmFsdWUiLCJwcmV2VmFsdWUiLCJfY3VycmVudFJlbmRlcmVyMiIsInByZXZOb2RlIiwibmV3Tm9kZSIsInBvcFByb3ZpZGVyIiwicHJldlNuYXBzaG90IiwiX3ZhbHVlIiwiX2RlZmF1bHRWYWx1ZSIsImdldEFjdGl2ZUNvbnRleHQiLCJyZWFkQ29udGV4dCQxIiwiX3JlYWN0SW50ZXJuYWxzIiwiZGlkV2FybkFib3V0Tm9vcFVwZGF0ZUZvckNvbXBvbmVudCIsImRpZFdhcm5BYm91dERlcHJlY2F0ZWRXaWxsTW91bnQiLCJkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUiLCJkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUiLCJkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlIiwiZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlIiwiZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUiLCJkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcyIsImRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZSIsImRpZFdhcm5PbkludmFsaWRDYWxsYmFjayIsIndhcm5PbkludmFsaWRDYWxsYmFjayIsImNhbGxlck5hbWUiLCJ3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUiLCJwYXJ0aWFsU3RhdGUiLCJ3YXJuTm9vcCIsInB1YmxpY0luc3RhbmNlIiwiX2NvbnN0cnVjdG9yIiwid2FybmluZ0tleSIsImNsYXNzQ29tcG9uZW50VXBkYXRlciIsImlzTW91bnRlZCIsImluc3QiLCJlbnF1ZXVlU2V0U3RhdGUiLCJpbnRlcm5hbHMiLCJxdWV1ZSIsImVucXVldWVSZXBsYWNlU3RhdGUiLCJlbnF1ZXVlRm9yY2VVcGRhdGUiLCJhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsInByZXZTdGF0ZSIsIm5leHRQcm9wcyIsIm5ld1N0YXRlIiwiY29uc3RydWN0Q2xhc3NJbnN0YW5jZSIsIm1hc2tlZExlZ2FjeUNvbnRleHQiLCJjb250ZXh0VHlwZSIsImFkZGVuZHVtIiwiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUiLCJmb3VuZFdpbGxNb3VudE5hbWUiLCJmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lIiwiZm91bmRXaWxsVXBkYXRlTmFtZSIsImNvbXBvbmVudFdpbGxNb3VudCIsIl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmciLCJVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IiwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsIlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIiwiX2NvbXBvbmVudE5hbWUiLCJuZXdBcGlOYW1lIiwiY2hlY2tDbGFzc0luc3RhbmNlIiwicmVuZGVyUHJlc2VudCIsImdldEluaXRpYWxTdGF0ZSIsImlzUmVhY3RDbGFzc0FwcHJvdmVkIiwiZ2V0RGVmYXVsdFByb3BzIiwicHJvcFR5cGVzIiwiY29tcG9uZW50U2hvdWxkVXBkYXRlIiwiaXNQdXJlUmVhY3RDb21wb25lbnQiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJjb21wb25lbnREaWRVbm1vdW50IiwiY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzIiwiY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzIiwiaGFzTXV0YXRlZFByb3BzIiwiZGVmYXVsdFByb3BzIiwiY29tcG9uZW50RGlkVXBkYXRlIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiY2FsbENvbXBvbmVudFdpbGxNb3VudCIsIm9sZFN0YXRlIiwicHJvY2Vzc1VwZGF0ZVF1ZXVlIiwiaW50ZXJuYWxJbnN0YW5jZSIsIm9sZFF1ZXVlIiwib2xkUmVwbGFjZSIsIm5leHRTdGF0ZSIsImRvbnRNdXRhdGUiLCJwYXJ0aWFsIiwibW91bnRDbGFzc0luc3RhbmNlIiwiaW5pdGlhbFN0YXRlIiwidXBkYXRlciIsImVtcHR5VHJlZUNvbnRleHQiLCJnZXRUcmVlSWQiLCJpZFdpdGhMZWFkaW5nQml0IiwiZ2V0TGVhZGluZ0JpdCIsInB1c2hUcmVlQ29udGV4dCIsImJhc2VDb250ZXh0IiwidG90YWxDaGlsZHJlbiIsImJhc2VJZFdpdGhMZWFkaW5nQml0IiwiYmFzZU92ZXJmbG93IiwiYmFzZUxlbmd0aCIsImdldEJpdExlbmd0aCIsImJhc2VJZCIsInNsb3QiLCJudW1iZXJPZk92ZXJmbG93Qml0cyIsIm5ld092ZXJmbG93Qml0cyIsIm5ld092ZXJmbG93IiwicmVzdE9mQmFzZUlkIiwicmVzdE9mQmFzZUxlbmd0aCIsInJlc3RPZkxlbmd0aCIsInJlc3RPZk5ld0JpdHMiLCJuZXdCaXRzIiwiX2lkIiwiX292ZXJmbG93IiwibnVtYmVyIiwiY2x6MzIiLCJNYXRoIiwiY2x6MzJGYWxsYmFjayIsIkxOMiIsImFzVWludCIsIlN1c3BlbnNlRXhjZXB0aW9uIiwiY3JlYXRlVGhlbmFibGVTdGF0ZSIsIm5vb3AkMiIsInRyYWNrVXNlZFRoZW5hYmxlIiwidGhlbmFibGVTdGF0ZSIsInRoZW5hYmxlIiwicHJldmlvdXMiLCJ0aGVuIiwic3RhdHVzIiwiZnVsZmlsbGVkVmFsdWUiLCJyZWplY3RlZEVycm9yIiwicmVhc29uIiwicGVuZGluZ1RoZW5hYmxlIiwiZnVsZmlsbGVkVGhlbmFibGUiLCJyZWplY3RlZFRoZW5hYmxlIiwic3VzcGVuZGVkVGhlbmFibGUiLCJnZXRTdXNwZW5kZWRUaGVuYWJsZSIsIm9iamVjdElzIiwiY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50IiwiY3VycmVudGx5UmVuZGVyaW5nVGFzayIsImZpcnN0V29ya0luUHJvZ3Jlc3NIb29rIiwid29ya0luUHJvZ3Jlc3NIb29rIiwiaXNSZVJlbmRlciIsImRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUiLCJsb2NhbElkQ291bnRlciIsInRoZW5hYmxlSW5kZXhDb3VudGVyIiwicmVuZGVyUGhhc2VVcGRhdGVzIiwibnVtYmVyT2ZSZVJlbmRlcnMiLCJSRV9SRU5ERVJfTElNSVQiLCJpc0luSG9va1VzZXJDb2RlSW5EZXYiLCJjdXJyZW50SG9va05hbWVJbkRldiIsInJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQiLCJhcmVIb29rSW5wdXRzRXF1YWwiLCJuZXh0RGVwcyIsInByZXZEZXBzIiwiY3JlYXRlSG9vayIsIm1lbW9pemVkU3RhdGUiLCJjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2siLCJwcmVwYXJlVG9Vc2VIb29rcyIsInRhc2siLCJjb21wb25lbnRJZGVudGl0eSIsInByZXZUaGVuYWJsZVN0YXRlIiwiZmluaXNoSG9va3MiLCJyZWZPckNvbnRleHQiLCJyZXNldEhvb2tzU3RhdGUiLCJnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nIiwiY2hlY2tEaWRSZW5kZXJJZEhvb2siLCJkaWRSZW5kZXJJZEhvb2siLCJyZWFkQ29udGV4dCIsInVzZUNvbnRleHQiLCJiYXNpY1N0YXRlUmVkdWNlciIsInVzZVN0YXRlIiwidXNlUmVkdWNlciIsInJlZHVjZXIiLCJpbml0aWFsQXJnIiwiZGlzcGF0Y2giLCJmaXJzdFJlbmRlclBoYXNlVXBkYXRlIiwidXBkYXRlIiwiX3F1ZXVlIiwibGFzdCIsIl9kaXNwYXRjaCIsImRpc3BhdGNoQWN0aW9uIiwidXNlTWVtbyIsIm5leHRDcmVhdGUiLCJkZXBzIiwidXNlUmVmIiwiaW5pdGlhbFZhbHVlIiwicHJldmlvdXNSZWYiLCJyZWYiLCJzZWFsIiwibGFzdFJlbmRlclBoYXNlVXBkYXRlIiwidXNlQ2FsbGJhY2siLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsInN1YnNjcmliZSIsImdldFNuYXBzaG90IiwiZ2V0U2VydmVyU25hcHNob3QiLCJ1c2VEZWZlcnJlZFZhbHVlIiwidW5zdXBwb3J0ZWRTdGFydFRyYW5zaXRpb24iLCJ1c2VUcmFuc2l0aW9uIiwidXNlSWQiLCJ0cmVlQ29udGV4dCIsImN1cnJlbnRSZXNwb25zZVN0YXRlIiwidXNlIiwidXNhYmxlIiwidW53cmFwVGhlbmFibGUiLCJ1bnN1cHBvcnRlZFJlZnJlc2giLCJ1c2VDYWNoZVJlZnJlc2giLCJub29wJDEiLCJIb29rc0Rpc3BhdGNoZXIiLCJ1c2VJbnNlcnRpb25FZmZlY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwidXNlRWZmZWN0IiwidXNlRGVidWdWYWx1ZSIsInNldEN1cnJlbnRSZXNwb25zZVN0YXRlIiwiZ2V0Q2FjaGVTaWduYWwiLCJnZXRDYWNoZUZvclR5cGUiLCJyZXNvdXJjZVR5cGUiLCJEZWZhdWx0Q2FjaGVEaXNwYXRjaGVyIiwiZ2V0U3RhY2tCeUNvbXBvbmVudFN0YWNrTm9kZSIsImNvbXBvbmVudFN0YWNrIiwibm9kZSIsIlJlYWN0Q3VycmVudENhY2hlIiwiUEVORElORyIsIkNPTVBMRVRFRCIsIkZMVVNIRUQiLCJBQk9SVEVEIiwiRVJST1JFRCIsIk9QRU4iLCJDTE9TSU5HIiwiQ0xPU0VEIiwiREVGQVVMVF9QUk9HUkVTU0lWRV9DSFVOS19TSVpFIiwiZGVmYXVsdEVycm9ySGFuZGxlciIsIm5vb3AiLCJjcmVhdGVSZXF1ZXN0Iiwicm9vdEZvcm1hdENvbnRleHQiLCJwcm9ncmVzc2l2ZUNodW5rU2l6ZSIsIm9uQWxsUmVhZHkiLCJvblNoZWxsUmVhZHkiLCJvblNoZWxsRXJyb3IiLCJvbkZhdGFsRXJyb3IiLCJwaW5nZWRUYXNrcyIsImFib3J0U2V0IiwiZmx1c2hTY2hlZHVsZWQiLCJmYXRhbEVycm9yIiwibmV4dFNlZ21lbnRJZCIsImFsbFBlbmRpbmdUYXNrcyIsInBlbmRpbmdSb290VGFza3MiLCJjb21wbGV0ZWRSb290U2VnbWVudCIsImFib3J0YWJsZVRhc2tzIiwiY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzIiwiY29tcGxldGVkQm91bmRhcmllcyIsInBhcnRpYWxCb3VuZGFyaWVzIiwicm9vdFNlZ21lbnQiLCJjcmVhdGVQZW5kaW5nU2VnbWVudCIsInBhcmVudEZsdXNoZWQiLCJyb290VGFzayIsImNyZWF0ZVRhc2siLCJjdXJyZW50UmVxdWVzdCIsInBpbmdUYXNrIiwicGVyZm9ybVdvcmsiLCJjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5IiwiZmFsbGJhY2tBYm9ydGFibGVUYXNrcyIsInJvb3RTZWdtZW50SUQiLCJwZW5kaW5nVGFza3MiLCJmb3JjZUNsaWVudFJlbmRlciIsImNvbXBsZXRlZFNlZ21lbnRzIiwiYnl0ZVNpemUiLCJibG9ja2VkQm91bmRhcnkiLCJibG9ja2VkU2VnbWVudCIsImxlZ2FjeUNvbnRleHQiLCJwaW5nIiwiYm91bmRhcnkiLCJjdXJyZW50VGFza0luREVWIiwiZ2V0Q3VycmVudFN0YWNrSW5ERVYiLCJwdXNoQnVpbHRJbkNvbXBvbmVudFN0YWNrSW5ERVYiLCJwdXNoRnVuY3Rpb25Db21wb25lbnRTdGFja0luREVWIiwicHVzaENsYXNzQ29tcG9uZW50U3RhY2tJbkRFViIsInBvcENvbXBvbmVudFN0YWNrSW5ERVYiLCJsYXN0Qm91bmRhcnlFcnJvckNvbXBvbmVudFN0YWNrRGV2IiwiY2FwdHVyZUJvdW5kYXJ5RXJyb3JEZXRhaWxzRGV2IiwibG9nUmVjb3ZlcmFibGVFcnJvciIsInJlbmRlclN1c3BlbnNlQm91bmRhcnkiLCJwYXJlbnRCb3VuZGFyeSIsInBhcmVudFNlZ21lbnQiLCJmYWxsYmFjayIsImZhbGxiYWNrQWJvcnRTZXQiLCJuZXdCb3VuZGFyeSIsImluc2VydGlvbkluZGV4IiwiYm91bmRhcnlTZWdtZW50IiwiY29udGVudFJvb3RTZWdtZW50IiwicmVuZGVyTm9kZSIsInF1ZXVlQ29tcGxldGVkU2VnbWVudCIsInN1c3BlbmRlZEZhbGxiYWNrVGFzayIsInJlbmRlckhvc3RFbGVtZW50Iiwic2VnbWVudCIsInByZXZDb250ZXh0Iiwic2hvdWxkQ29uc3RydWN0IiwicmVuZGVyV2l0aEhvb2tzIiwic2Vjb25kQXJnIiwiZmluaXNoQ2xhc3NDb21wb25lbnQiLCJuZXh0Q2hpbGRyZW4iLCJkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzIiwicHJldmlvdXNDb250ZXh0IiwibWVyZ2VkQ29udGV4dCIsInJlbmRlck5vZGVEZXN0cnVjdGl2ZSIsInJlbmRlckNsYXNzQ29tcG9uZW50IiwibWFza2VkQ29udGV4dCIsImRpZFdhcm5BYm91dEJhZENsYXNzIiwiZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudCIsImRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudCIsImRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnQiLCJkaWRXYXJuQWJvdXREZWZhdWx0UHJvcHNPbkZ1bmN0aW9uQ29tcG9uZW50IiwiZGlkV2FybkFib3V0R2VuZXJhdG9ycyIsImRpZFdhcm5BYm91dE1hcHMiLCJoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIiLCJyZW5kZXJJbmRldGVybWluYXRlQ29tcG9uZW50IiwiaGFzSWQiLCJfY29tcG9uZW50TmFtZTIiLCJ2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYiLCJwcmV2VHJlZUNvbnRleHQiLCJfY29tcG9uZW50TmFtZTMiLCJfY29tcG9uZW50TmFtZTQiLCJyZXNvbHZlRGVmYXVsdFByb3BzIiwiYmFzZVByb3BzIiwicmVuZGVyRm9yd2FyZFJlZiIsInJlbmRlck1lbW8iLCJyZXNvbHZlZFByb3BzIiwicmVuZGVyRWxlbWVudCIsInJlbmRlckNvbnRleHRDb25zdW1lciIsIkNvbnN1bWVyIiwibmV3Q2hpbGRyZW4iLCJyZW5kZXJDb250ZXh0UHJvdmlkZXIiLCJyZW5kZXJMYXp5Q29tcG9uZW50IiwicmVuZGVyT2Zmc2NyZWVuIiwidmFsaWRhdGVJdGVyYWJsZSIsIml0ZXJhYmxlIiwiaXRlcmF0b3JGbiIsImVudHJpZXMiLCJyZW5kZXJOb2RlRGVzdHJ1Y3RpdmVJbXBsIiwibGF6eU5vZGUiLCJyZXNvbHZlZE5vZGUiLCJyZW5kZXJDaGlsZHJlbkFycmF5IiwiZG9uZSIsIm1heWJlVXNhYmxlIiwiY2hpbGRTdHJpbmciLCJfc2VnbWVudCIsInNwYXduTmV3U3VzcGVuZGVkVGFzayIsIm5ld1NlZ21lbnQiLCJuZXdUYXNrIiwiY2hpbGRyZW5MZW5ndGgiLCJjaHVua0xlbmd0aCIsInByZXZpb3VzRm9ybWF0Q29udGV4dCIsInByZXZpb3VzTGVnYWN5Q29udGV4dCIsInByZXZpb3VzQ29tcG9uZW50U3RhY2siLCJ0aHJvd25WYWx1ZSIsIndha2VhYmxlIiwiZXJyb3JlZFRhc2siLCJhYm9ydFRhc2tTb2Z0IiwiZmluaXNoZWRUYXNrIiwiYWJvcnRUYXNrIiwiZXJyb3JQcmVmaXgiLCJwcmV2aW91c1Rhc2tJbkRldiIsImZhbGxiYWNrVGFzayIsImNoaWxkU2VnbWVudCIsInJldHJ5VGFzayIsInByZXZUYXNrSW5ERVYiLCJwcmV2RGlzcGF0Y2hlciIsInByZXZDYWNoZURpc3BhdGNoZXIiLCJwcmV2UmVxdWVzdCIsInByZXZHZXRDdXJyZW50U3RhY2tJbXBsIiwiZ2V0Q3VycmVudFN0YWNrIiwicHJldlJlc3BvbnNlU3RhdGUiLCJzcGxpY2UiLCJmbHVzaENvbXBsZXRlZFF1ZXVlcyIsImZsdXNoU3VidHJlZSIsInNlZ21lbnRJRCIsImNodW5rSWR4IiwiY2hpbGRJZHgiLCJuZXh0Q2hpbGQiLCJmbHVzaFNlZ21lbnQiLCJjb250ZW50U2VnbWVudCIsImZsdXNoQ2xpZW50UmVuZGVyZWRCb3VuZGFyeSIsImZsdXNoU2VnbWVudENvbnRhaW5lciIsImZsdXNoQ29tcGxldGVkQm91bmRhcnkiLCJmbHVzaFBhcnRpYWxseUNvbXBsZXRlZFNlZ21lbnQiLCJmbHVzaFBhcnRpYWxCb3VuZGFyeSIsIl9ib3VuZGFyeSIsIl9ib3VuZGFyeTIiLCJsYXJnZUJvdW5kYXJpZXMiLCJfYm91bmRhcnkzIiwic3RhcnRXb3JrIiwiZW5xdWV1ZUZsdXNoIiwic3RhcnRGbG93aW5nIiwiYWJvcnQiLCJvbkVycm9yJDEiLCJyZW5kZXJUb1N0cmluZ0ltcGwiLCJhYm9ydFJlYXNvbiIsInVuc3RhYmxlX2V4dGVybmFsUnVudGltZVNyYyIsImRpZEZhdGFsIiwicmVhZHlUb1N0cmVhbSIsIkluZmluaXR5IiwiUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbSIsIl9SZWFkYWJsZSIsIl90aGlzIiwic3RhcnRlZEZsb3dpbmciLCJfcHJvdG8iLCJfZGVzdHJveSIsIl9yZWFkIiwiUmVhZGFibGUiLCJyZW5kZXJUb05vZGVTdHJlYW1JbXBsIiwicmVuZGVyVG9Ob2RlU3RyZWFtIiwicmVuZGVyVG9TdGF0aWNOb2RlU3RyZWFtIiwicmVuZGVyVG9TdHJpbmciLCJyZW5kZXJUb1N0YXRpY01hcmt1cCIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-legacy.node.development.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-rendering-stub.development.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-rendering-stub.development.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license React\n * react-dom-server-rendering-stub.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var ReactVersion = \"18.3.0-canary-1a001dac6-20230812\";\n        var Internals = {\n            usingClientEntryPoint: false,\n            Events: null,\n            Dispatcher: {\n                current: null\n            }\n        };\n        var Dispatcher = Internals.Dispatcher;\n        function prefetchDNS(href) {\n            var passedOptionArg;\n            {\n                if (arguments[1] !== undefined) {\n                    passedOptionArg = arguments[1];\n                }\n            }\n            var dispatcher = Dispatcher.current;\n            if (dispatcher) {\n                {\n                    if (passedOptionArg !== undefined) {\n                        // prefetchDNS will warn if you pass reserved options arg. We pass it along in Dev only to\n                        // elicit the warning. In prod we do not forward since it is not a part of the interface.\n                        // @TODO move all arg validation into this file. It needs to be universal anyway so may as well lock down the interace here and\n                        // let the rest of the codebase trust the types\n                        dispatcher.prefetchDNS(href, passedOptionArg);\n                    } else {\n                        dispatcher.prefetchDNS(href);\n                    }\n                }\n            } // We don't error because preconnect needs to be resilient to being called in a variety of scopes\n        // and the runtime may not be capable of responding. The function is optimistic and not critical\n        // so we favor silent bailout over warning or erroring.\n        }\n        function preconnect(href, options) {\n            var dispatcher = Dispatcher.current;\n            if (dispatcher) {\n                dispatcher.preconnect(href, options);\n            } // We don't error because preconnect needs to be resilient to being called in a variety of scopes\n        // and the runtime may not be capable of responding. The function is optimistic and not critical\n        // so we favor silent bailout over warning or erroring.\n        }\n        function preload(href, options) {\n            var dispatcher = Dispatcher.current;\n            if (dispatcher) {\n                dispatcher.preload(href, options);\n            } // We don't error because preload needs to be resilient to being called in a variety of scopes\n        // and the runtime may not be capable of responding. The function is optimistic and not critical\n        // so we favor silent bailout over warning or erroring.\n        }\n        function preinit(href, options) {\n            var dispatcher = Dispatcher.current;\n            if (dispatcher) {\n                dispatcher.preinit(href, options);\n            } // We don't error because preinit needs to be resilient to being called in a variety of scopes\n        // and the runtime may not be capable of responding. The function is optimistic and not critical\n        // so we favor silent bailout over warning or erroring.\n        }\n        function useFormStatus() {\n            {\n                throw new Error(\"Not implemented.\");\n            }\n        }\n        function createPortal() {\n            throw new Error(\"createPortal was called on the server. Portals are not currently\" + \" supported on the server. Update your program to conditionally call\" + \" createPortal on the client only.\");\n        }\n        function flushSync() {\n            throw new Error(\"flushSync was called on the server. This is likely caused by a\" + \" function being called during render or in module scope that was\" + \" intended to be called from an effect or event handler. Update your\" + \" to not call flushSync no the server.\");\n        } // on the server we just call the callback because there is\n        // not update mechanism. Really this should not be called on the\n        // server but since the semantics are generally clear enough we\n        // can provide this trivial implementation.\n        function batchedUpdates(fn, a) {\n            return fn(a);\n        }\n        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;\n        exports.createPortal = createPortal;\n        exports.experimental_useFormStatus = useFormStatus;\n        exports.flushSync = flushSync;\n        exports.preconnect = preconnect;\n        exports.prefetchDNS = prefetchDNS;\n        exports.preinit = preinit;\n        exports.preload = preload;\n        exports.unstable_batchedUpdates = batchedUpdates;\n        exports.version = ReactVersion;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLXNlcnZlci1yZW5kZXJpbmctc3R1Yi5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUNIO1FBRUEsSUFBSUMsZUFBZTtRQUVuQixJQUFJQyxZQUFZO1lBQ2RDLHVCQUF1QjtZQUN2QkMsUUFBUTtZQUNSQyxZQUFZO2dCQUNWQyxTQUFTO1lBQ1g7UUFDRjtRQUVBLElBQUlELGFBQWFILFVBQVVHLFVBQVU7UUFDckMsU0FBU0UsWUFBWUMsSUFBSTtZQUN2QixJQUFJQztZQUVKO2dCQUNFLElBQUlDLFNBQVMsQ0FBQyxFQUFFLEtBQUtDLFdBQVc7b0JBQzlCRixrQkFBa0JDLFNBQVMsQ0FBQyxFQUFFO2dCQUNoQztZQUNGO1lBRUEsSUFBSUUsYUFBYVAsV0FBV0MsT0FBTztZQUVuQyxJQUFJTSxZQUFZO2dCQUNkO29CQUNFLElBQUlILG9CQUFvQkUsV0FBVzt3QkFDakMsMEZBQTBGO3dCQUMxRix5RkFBeUY7d0JBQ3pGLCtIQUErSDt3QkFDL0gsK0NBQStDO3dCQUMvQ0MsV0FBV0wsV0FBVyxDQUFDQyxNQUFNQztvQkFDL0IsT0FBTzt3QkFDTEcsV0FBV0wsV0FBVyxDQUFDQztvQkFDekI7Z0JBQ0Y7WUFDRixFQUFFLGlHQUFpRztRQUNuRyxnR0FBZ0c7UUFDaEcsdURBQXVEO1FBRXpEO1FBQ0EsU0FBU0ssV0FBV0wsSUFBSSxFQUFFTSxPQUFPO1lBQy9CLElBQUlGLGFBQWFQLFdBQVdDLE9BQU87WUFFbkMsSUFBSU0sWUFBWTtnQkFDZEEsV0FBV0MsVUFBVSxDQUFDTCxNQUFNTTtZQUM5QixFQUFFLGlHQUFpRztRQUNuRyxnR0FBZ0c7UUFDaEcsdURBQXVEO1FBRXpEO1FBQ0EsU0FBU0MsUUFBUVAsSUFBSSxFQUFFTSxPQUFPO1lBQzVCLElBQUlGLGFBQWFQLFdBQVdDLE9BQU87WUFFbkMsSUFBSU0sWUFBWTtnQkFDZEEsV0FBV0csT0FBTyxDQUFDUCxNQUFNTTtZQUMzQixFQUFFLDhGQUE4RjtRQUNoRyxnR0FBZ0c7UUFDaEcsdURBQXVEO1FBRXpEO1FBQ0EsU0FBU0UsUUFBUVIsSUFBSSxFQUFFTSxPQUFPO1lBQzVCLElBQUlGLGFBQWFQLFdBQVdDLE9BQU87WUFFbkMsSUFBSU0sWUFBWTtnQkFDZEEsV0FBV0ksT0FBTyxDQUFDUixNQUFNTTtZQUMzQixFQUFFLDhGQUE4RjtRQUNoRyxnR0FBZ0c7UUFDaEcsdURBQXVEO1FBRXpEO1FBRUEsU0FBU0c7WUFDUDtnQkFDRSxNQUFNLElBQUlDLE1BQU07WUFDbEI7UUFDRjtRQUVBLFNBQVNDO1lBQ1AsTUFBTSxJQUFJRCxNQUFNLHFFQUFxRSx3RUFBd0U7UUFDL0o7UUFDQSxTQUFTRTtZQUNQLE1BQU0sSUFBSUYsTUFBTSxtRUFBbUUscUVBQXFFLHdFQUF3RTtRQUNsTyxFQUFFLDJEQUEyRDtRQUM3RCxnRUFBZ0U7UUFDaEUsK0RBQStEO1FBQy9ELDJDQUEyQztRQUUzQyxTQUFTRyxlQUFlQyxFQUFFLEVBQUVDLENBQUM7WUFDM0IsT0FBT0QsR0FBR0M7UUFDWjtRQUVBQywwREFBMEQsR0FBR3RCO1FBQzdEc0Isb0JBQW9CLEdBQUdMO1FBQ3ZCSyxrQ0FBa0MsR0FBR1A7UUFDckNPLGlCQUFpQixHQUFHSjtRQUNwQkksa0JBQWtCLEdBQUdYO1FBQ3JCVyxtQkFBbUIsR0FBR2pCO1FBQ3RCaUIsZUFBZSxHQUFHUjtRQUNsQlEsZUFBZSxHQUFHVDtRQUNsQlMsK0JBQStCLEdBQUdIO1FBQ2xDRyxlQUFlLEdBQUd2QjtJQUNoQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2FoZWd1cnUtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20tc2VydmVyLXJlbmRlcmluZy1zdHViLmRldmVsb3BtZW50LmpzPzhmNDciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtZG9tLXNlcnZlci1yZW5kZXJpbmctc3R1Yi5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0VmVyc2lvbiA9ICcxOC4zLjAtY2FuYXJ5LTFhMDAxZGFjNi0yMDIzMDgxMic7XG5cbnZhciBJbnRlcm5hbHMgPSB7XG4gIHVzaW5nQ2xpZW50RW50cnlQb2ludDogZmFsc2UsXG4gIEV2ZW50czogbnVsbCxcbiAgRGlzcGF0Y2hlcjoge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfVxufTtcblxudmFyIERpc3BhdGNoZXIgPSBJbnRlcm5hbHMuRGlzcGF0Y2hlcjtcbmZ1bmN0aW9uIHByZWZldGNoRE5TKGhyZWYpIHtcbiAgdmFyIHBhc3NlZE9wdGlvbkFyZztcblxuICB7XG4gICAgaWYgKGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXNzZWRPcHRpb25BcmcgPSBhcmd1bWVudHNbMV07XG4gICAgfVxuICB9XG5cbiAgdmFyIGRpc3BhdGNoZXIgPSBEaXNwYXRjaGVyLmN1cnJlbnQ7XG5cbiAgaWYgKGRpc3BhdGNoZXIpIHtcbiAgICB7XG4gICAgICBpZiAocGFzc2VkT3B0aW9uQXJnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gcHJlZmV0Y2hETlMgd2lsbCB3YXJuIGlmIHlvdSBwYXNzIHJlc2VydmVkIG9wdGlvbnMgYXJnLiBXZSBwYXNzIGl0IGFsb25nIGluIERldiBvbmx5IHRvXG4gICAgICAgIC8vIGVsaWNpdCB0aGUgd2FybmluZy4gSW4gcHJvZCB3ZSBkbyBub3QgZm9yd2FyZCBzaW5jZSBpdCBpcyBub3QgYSBwYXJ0IG9mIHRoZSBpbnRlcmZhY2UuXG4gICAgICAgIC8vIEBUT0RPIG1vdmUgYWxsIGFyZyB2YWxpZGF0aW9uIGludG8gdGhpcyBmaWxlLiBJdCBuZWVkcyB0byBiZSB1bml2ZXJzYWwgYW55d2F5IHNvIG1heSBhcyB3ZWxsIGxvY2sgZG93biB0aGUgaW50ZXJhY2UgaGVyZSBhbmRcbiAgICAgICAgLy8gbGV0IHRoZSByZXN0IG9mIHRoZSBjb2RlYmFzZSB0cnVzdCB0aGUgdHlwZXNcbiAgICAgICAgZGlzcGF0Y2hlci5wcmVmZXRjaEROUyhocmVmLCBwYXNzZWRPcHRpb25BcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlzcGF0Y2hlci5wcmVmZXRjaEROUyhocmVmKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gV2UgZG9uJ3QgZXJyb3IgYmVjYXVzZSBwcmVjb25uZWN0IG5lZWRzIHRvIGJlIHJlc2lsaWVudCB0byBiZWluZyBjYWxsZWQgaW4gYSB2YXJpZXR5IG9mIHNjb3Blc1xuICAvLyBhbmQgdGhlIHJ1bnRpbWUgbWF5IG5vdCBiZSBjYXBhYmxlIG9mIHJlc3BvbmRpbmcuIFRoZSBmdW5jdGlvbiBpcyBvcHRpbWlzdGljIGFuZCBub3QgY3JpdGljYWxcbiAgLy8gc28gd2UgZmF2b3Igc2lsZW50IGJhaWxvdXQgb3ZlciB3YXJuaW5nIG9yIGVycm9yaW5nLlxuXG59XG5mdW5jdGlvbiBwcmVjb25uZWN0KGhyZWYsIG9wdGlvbnMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSBEaXNwYXRjaGVyLmN1cnJlbnQ7XG5cbiAgaWYgKGRpc3BhdGNoZXIpIHtcbiAgICBkaXNwYXRjaGVyLnByZWNvbm5lY3QoaHJlZiwgb3B0aW9ucyk7XG4gIH0gLy8gV2UgZG9uJ3QgZXJyb3IgYmVjYXVzZSBwcmVjb25uZWN0IG5lZWRzIHRvIGJlIHJlc2lsaWVudCB0byBiZWluZyBjYWxsZWQgaW4gYSB2YXJpZXR5IG9mIHNjb3Blc1xuICAvLyBhbmQgdGhlIHJ1bnRpbWUgbWF5IG5vdCBiZSBjYXBhYmxlIG9mIHJlc3BvbmRpbmcuIFRoZSBmdW5jdGlvbiBpcyBvcHRpbWlzdGljIGFuZCBub3QgY3JpdGljYWxcbiAgLy8gc28gd2UgZmF2b3Igc2lsZW50IGJhaWxvdXQgb3ZlciB3YXJuaW5nIG9yIGVycm9yaW5nLlxuXG59XG5mdW5jdGlvbiBwcmVsb2FkKGhyZWYsIG9wdGlvbnMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSBEaXNwYXRjaGVyLmN1cnJlbnQ7XG5cbiAgaWYgKGRpc3BhdGNoZXIpIHtcbiAgICBkaXNwYXRjaGVyLnByZWxvYWQoaHJlZiwgb3B0aW9ucyk7XG4gIH0gLy8gV2UgZG9uJ3QgZXJyb3IgYmVjYXVzZSBwcmVsb2FkIG5lZWRzIHRvIGJlIHJlc2lsaWVudCB0byBiZWluZyBjYWxsZWQgaW4gYSB2YXJpZXR5IG9mIHNjb3Blc1xuICAvLyBhbmQgdGhlIHJ1bnRpbWUgbWF5IG5vdCBiZSBjYXBhYmxlIG9mIHJlc3BvbmRpbmcuIFRoZSBmdW5jdGlvbiBpcyBvcHRpbWlzdGljIGFuZCBub3QgY3JpdGljYWxcbiAgLy8gc28gd2UgZmF2b3Igc2lsZW50IGJhaWxvdXQgb3ZlciB3YXJuaW5nIG9yIGVycm9yaW5nLlxuXG59XG5mdW5jdGlvbiBwcmVpbml0KGhyZWYsIG9wdGlvbnMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSBEaXNwYXRjaGVyLmN1cnJlbnQ7XG5cbiAgaWYgKGRpc3BhdGNoZXIpIHtcbiAgICBkaXNwYXRjaGVyLnByZWluaXQoaHJlZiwgb3B0aW9ucyk7XG4gIH0gLy8gV2UgZG9uJ3QgZXJyb3IgYmVjYXVzZSBwcmVpbml0IG5lZWRzIHRvIGJlIHJlc2lsaWVudCB0byBiZWluZyBjYWxsZWQgaW4gYSB2YXJpZXR5IG9mIHNjb3Blc1xuICAvLyBhbmQgdGhlIHJ1bnRpbWUgbWF5IG5vdCBiZSBjYXBhYmxlIG9mIHJlc3BvbmRpbmcuIFRoZSBmdW5jdGlvbiBpcyBvcHRpbWlzdGljIGFuZCBub3QgY3JpdGljYWxcbiAgLy8gc28gd2UgZmF2b3Igc2lsZW50IGJhaWxvdXQgb3ZlciB3YXJuaW5nIG9yIGVycm9yaW5nLlxuXG59XG5cbmZ1bmN0aW9uIHVzZUZvcm1TdGF0dXMoKSB7XG4gIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwoKSB7XG4gIHRocm93IG5ldyBFcnJvcignY3JlYXRlUG9ydGFsIHdhcyBjYWxsZWQgb24gdGhlIHNlcnZlci4gUG9ydGFscyBhcmUgbm90IGN1cnJlbnRseScgKyAnIHN1cHBvcnRlZCBvbiB0aGUgc2VydmVyLiBVcGRhdGUgeW91ciBwcm9ncmFtIHRvIGNvbmRpdGlvbmFsbHkgY2FsbCcgKyAnIGNyZWF0ZVBvcnRhbCBvbiB0aGUgY2xpZW50IG9ubHkuJyk7XG59XG5mdW5jdGlvbiBmbHVzaFN5bmMoKSB7XG4gIHRocm93IG5ldyBFcnJvcignZmx1c2hTeW5jIHdhcyBjYWxsZWQgb24gdGhlIHNlcnZlci4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEnICsgJyBmdW5jdGlvbiBiZWluZyBjYWxsZWQgZHVyaW5nIHJlbmRlciBvciBpbiBtb2R1bGUgc2NvcGUgdGhhdCB3YXMnICsgJyBpbnRlbmRlZCB0byBiZSBjYWxsZWQgZnJvbSBhbiBlZmZlY3Qgb3IgZXZlbnQgaGFuZGxlci4gVXBkYXRlIHlvdXInICsgJyB0byBub3QgY2FsbCBmbHVzaFN5bmMgbm8gdGhlIHNlcnZlci4nKTtcbn0gLy8gb24gdGhlIHNlcnZlciB3ZSBqdXN0IGNhbGwgdGhlIGNhbGxiYWNrIGJlY2F1c2UgdGhlcmUgaXNcbi8vIG5vdCB1cGRhdGUgbWVjaGFuaXNtLiBSZWFsbHkgdGhpcyBzaG91bGQgbm90IGJlIGNhbGxlZCBvbiB0aGVcbi8vIHNlcnZlciBidXQgc2luY2UgdGhlIHNlbWFudGljcyBhcmUgZ2VuZXJhbGx5IGNsZWFyIGVub3VnaCB3ZVxuLy8gY2FuIHByb3ZpZGUgdGhpcyB0cml2aWFsIGltcGxlbWVudGF0aW9uLlxuXG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhmbiwgYSkge1xuICByZXR1cm4gZm4oYSk7XG59XG5cbmV4cG9ydHMuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgPSBJbnRlcm5hbHM7XG5leHBvcnRzLmNyZWF0ZVBvcnRhbCA9IGNyZWF0ZVBvcnRhbDtcbmV4cG9ydHMuZXhwZXJpbWVudGFsX3VzZUZvcm1TdGF0dXMgPSB1c2VGb3JtU3RhdHVzO1xuZXhwb3J0cy5mbHVzaFN5bmMgPSBmbHVzaFN5bmM7XG5leHBvcnRzLnByZWNvbm5lY3QgPSBwcmVjb25uZWN0O1xuZXhwb3J0cy5wcmVmZXRjaEROUyA9IHByZWZldGNoRE5TO1xuZXhwb3J0cy5wcmVpbml0ID0gcHJlaW5pdDtcbmV4cG9ydHMucHJlbG9hZCA9IHByZWxvYWQ7XG5leHBvcnRzLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzID0gYmF0Y2hlZFVwZGF0ZXM7XG5leHBvcnRzLnZlcnNpb24gPSBSZWFjdFZlcnNpb247XG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIlJlYWN0VmVyc2lvbiIsIkludGVybmFscyIsInVzaW5nQ2xpZW50RW50cnlQb2ludCIsIkV2ZW50cyIsIkRpc3BhdGNoZXIiLCJjdXJyZW50IiwicHJlZmV0Y2hETlMiLCJocmVmIiwicGFzc2VkT3B0aW9uQXJnIiwiYXJndW1lbnRzIiwidW5kZWZpbmVkIiwiZGlzcGF0Y2hlciIsInByZWNvbm5lY3QiLCJvcHRpb25zIiwicHJlbG9hZCIsInByZWluaXQiLCJ1c2VGb3JtU3RhdHVzIiwiRXJyb3IiLCJjcmVhdGVQb3J0YWwiLCJmbHVzaFN5bmMiLCJiYXRjaGVkVXBkYXRlcyIsImZuIiwiYSIsImV4cG9ydHMiLCJfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsImV4cGVyaW1lbnRhbF91c2VGb3JtU3RhdHVzIiwidW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMiLCJ2ZXJzaW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-rendering-stub.development.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server.node.development.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server.node.development.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * @license React\n * react-dom-server.node.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! next/dist/compiled/react */ \"(rsc)/./node_modules/next/dist/compiled/react/index.js\");\n        var util = __webpack_require__(/*! util */ \"util\");\n        var async_hooks = __webpack_require__(/*! async_hooks */ \"async_hooks\");\n        var ReactDOM = __webpack_require__(/*! react-dom */ \"(rsc)/./node_modules/next/dist/compiled/react-dom/server-rendering-stub.js\");\n        var ReactVersion = \"18.3.0-canary-1a001dac6-20230812\";\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        // by calls to these methods by a Babel plugin.\n        //\n        // In PROD (or in packages without access to React internals),\n        // they are left as they are instead.\n        function warn(format) {\n            {\n                {\n                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    printWarning(\"warn\", format, args);\n                }\n            }\n        }\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        function scheduleWork(callback) {\n            setImmediate(callback);\n        }\n        function flushBuffered(destination) {\n            // If we don't have any more data to send right now.\n            // Flush whatever is in the buffer to the wire.\n            if (typeof destination.flush === \"function\") {\n                // By convention the Zlib streams provide a flush function for this purpose.\n                // For Express, compression middleware adds this method.\n                destination.flush();\n            }\n        }\n        var VIEW_SIZE = 2048;\n        var currentView = null;\n        var writtenBytes = 0;\n        var destinationHasCapacity$1 = true;\n        function beginWriting(destination) {\n            currentView = new Uint8Array(VIEW_SIZE);\n            writtenBytes = 0;\n            destinationHasCapacity$1 = true;\n        }\n        function writeStringChunk(destination, stringChunk) {\n            if (stringChunk.length === 0) {\n                return;\n            } // maximum possible view needed to encode entire string\n            if (stringChunk.length * 3 > VIEW_SIZE) {\n                if (writtenBytes > 0) {\n                    writeToDestination(destination, currentView.subarray(0, writtenBytes));\n                    currentView = new Uint8Array(VIEW_SIZE);\n                    writtenBytes = 0;\n                }\n                writeToDestination(destination, textEncoder.encode(stringChunk));\n                return;\n            }\n            var target = currentView;\n            if (writtenBytes > 0) {\n                target = currentView.subarray(writtenBytes);\n            }\n            var _textEncoder$encodeIn = textEncoder.encodeInto(stringChunk, target), read = _textEncoder$encodeIn.read, written = _textEncoder$encodeIn.written;\n            writtenBytes += written;\n            if (read < stringChunk.length) {\n                writeToDestination(destination, currentView.subarray(0, writtenBytes));\n                currentView = new Uint8Array(VIEW_SIZE);\n                writtenBytes = textEncoder.encodeInto(stringChunk.slice(read), currentView).written;\n            }\n            if (writtenBytes === VIEW_SIZE) {\n                writeToDestination(destination, currentView);\n                currentView = new Uint8Array(VIEW_SIZE);\n                writtenBytes = 0;\n            }\n        }\n        function writeViewChunk(destination, chunk) {\n            if (chunk.byteLength === 0) {\n                return;\n            }\n            if (chunk.byteLength > VIEW_SIZE) {\n                {\n                    if (precomputedChunkSet && precomputedChunkSet.has(chunk)) {\n                        error(\"A large precomputed chunk was passed to writeChunk without being copied.\" + \" Large chunks get enqueued directly and are not copied. This is incompatible with precomputed chunks because you cannot enqueue the same precomputed chunk twice.\" + ' Use \"cloneChunk\" to make a copy of this large precomputed chunk before writing it. This is a bug in React.');\n                    }\n                }\n                // one that is cached by the streaming renderer. We will enqueu\n                // it directly and expect it is not re-used\n                if (writtenBytes > 0) {\n                    writeToDestination(destination, currentView.subarray(0, writtenBytes));\n                    currentView = new Uint8Array(VIEW_SIZE);\n                    writtenBytes = 0;\n                }\n                writeToDestination(destination, chunk);\n                return;\n            }\n            var bytesToWrite = chunk;\n            var allowableBytes = currentView.length - writtenBytes;\n            if (allowableBytes < bytesToWrite.byteLength) {\n                // this chunk would overflow the current view. We enqueue a full view\n                // and start a new view with the remaining chunk\n                if (allowableBytes === 0) {\n                    // the current view is already full, send it\n                    writeToDestination(destination, currentView);\n                } else {\n                    // fill up the current view and apply the remaining chunk bytes\n                    // to a new view.\n                    currentView.set(bytesToWrite.subarray(0, allowableBytes), writtenBytes);\n                    writtenBytes += allowableBytes;\n                    writeToDestination(destination, currentView);\n                    bytesToWrite = bytesToWrite.subarray(allowableBytes);\n                }\n                currentView = new Uint8Array(VIEW_SIZE);\n                writtenBytes = 0;\n            }\n            currentView.set(bytesToWrite, writtenBytes);\n            writtenBytes += bytesToWrite.byteLength;\n            if (writtenBytes === VIEW_SIZE) {\n                writeToDestination(destination, currentView);\n                currentView = new Uint8Array(VIEW_SIZE);\n                writtenBytes = 0;\n            }\n        }\n        function writeChunk(destination, chunk) {\n            if (typeof chunk === \"string\") {\n                writeStringChunk(destination, chunk);\n            } else {\n                writeViewChunk(destination, chunk);\n            }\n        }\n        function writeToDestination(destination, view) {\n            var currentHasCapacity = destination.write(view);\n            destinationHasCapacity$1 = destinationHasCapacity$1 && currentHasCapacity;\n        }\n        function writeChunkAndReturn(destination, chunk) {\n            writeChunk(destination, chunk);\n            return destinationHasCapacity$1;\n        }\n        function completeWriting(destination) {\n            if (currentView && writtenBytes > 0) {\n                destination.write(currentView.subarray(0, writtenBytes));\n            }\n            currentView = null;\n            writtenBytes = 0;\n            destinationHasCapacity$1 = true;\n        }\n        function close(destination) {\n            destination.end();\n        }\n        var textEncoder = new util.TextEncoder();\n        function stringToChunk(content) {\n            return content;\n        }\n        var precomputedChunkSet = new Set();\n        function stringToPrecomputedChunk(content) {\n            var precomputedChunk = textEncoder.encode(content);\n            {\n                if (precomputedChunkSet) {\n                    precomputedChunkSet.add(precomputedChunk);\n                }\n            }\n            return precomputedChunk;\n        }\n        function clonePrecomputedChunk(precomputedChunk) {\n            return precomputedChunk.length > VIEW_SIZE ? precomputedChunk.slice() : precomputedChunk;\n        }\n        function closeWithError(destination, error) {\n            // $FlowFixMe[incompatible-call]: This is an Error object or the destination accepts other types.\n            destination.destroy(error);\n        }\n        function _defineProperty(obj, key, value) {\n            if (key in obj) {\n                Object.defineProperty(obj, key, {\n                    value: value,\n                    enumerable: true,\n                    configurable: true,\n                    writable: true\n                });\n            } else {\n                obj[key] = value;\n            }\n            return obj;\n        }\n        var assign = Object.assign;\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkAttributeStringCoercion(value, attributeName) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided `%s` attribute is an unsupported type %s.\" + \" This value must be coerced to a string before before using it here.\", attributeName, typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function checkCSSPropertyStringCoercion(value, propName) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided `%s` CSS property is an unsupported type %s.\" + \" This value must be coerced to a string before before using it here.\", propName, typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function checkHtmlStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided HTML markup uses a value of unsupported type %s.\" + \" This value must be coerced to a string before before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        // -----------------------------------------------------------------------------\n        var enableFloat = true; // Enables unstable_useMemoCache hook, intended as a compilation target for\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        /* eslint-disable max-len */ var ATTRIBUTE_NAME_START_CHAR = \":A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\n        /* eslint-enable max-len */ var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + \"\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\n        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp(\"^[\" + ATTRIBUTE_NAME_START_CHAR + \"][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        var illegalAttributeNameCache = {};\n        var validatedAttributeNameCache = {};\n        function isAttributeNameSafe(attributeName) {\n            if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {\n                return true;\n            }\n            if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {\n                return false;\n            }\n            if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {\n                validatedAttributeNameCache[attributeName] = true;\n                return true;\n            }\n            illegalAttributeNameCache[attributeName] = true;\n            {\n                error(\"Invalid attribute name: `%s`\", attributeName);\n            }\n            return false;\n        }\n        /**\n * CSS properties which accept numbers but are not in units of \"px\".\n */ var unitlessNumbers = new Set([\n            \"animationIterationCount\",\n            \"aspectRatio\",\n            \"borderImageOutset\",\n            \"borderImageSlice\",\n            \"borderImageWidth\",\n            \"boxFlex\",\n            \"boxFlexGroup\",\n            \"boxOrdinalGroup\",\n            \"columnCount\",\n            \"columns\",\n            \"flex\",\n            \"flexGrow\",\n            \"flexPositive\",\n            \"flexShrink\",\n            \"flexNegative\",\n            \"flexOrder\",\n            \"gridArea\",\n            \"gridRow\",\n            \"gridRowEnd\",\n            \"gridRowSpan\",\n            \"gridRowStart\",\n            \"gridColumn\",\n            \"gridColumnEnd\",\n            \"gridColumnSpan\",\n            \"gridColumnStart\",\n            \"fontWeight\",\n            \"lineClamp\",\n            \"lineHeight\",\n            \"opacity\",\n            \"order\",\n            \"orphans\",\n            \"scale\",\n            \"tabSize\",\n            \"widows\",\n            \"zIndex\",\n            \"zoom\",\n            \"fillOpacity\",\n            \"floodOpacity\",\n            \"stopOpacity\",\n            \"strokeDasharray\",\n            \"strokeDashoffset\",\n            \"strokeMiterlimit\",\n            \"strokeOpacity\",\n            \"strokeWidth\",\n            \"MozAnimationIterationCount\",\n            \"MozBoxFlex\",\n            \"MozBoxFlexGroup\",\n            \"MozLineClamp\",\n            \"msAnimationIterationCount\",\n            \"msFlex\",\n            \"msZoom\",\n            \"msFlexGrow\",\n            \"msFlexNegative\",\n            \"msFlexOrder\",\n            \"msFlexPositive\",\n            \"msFlexShrink\",\n            \"msGridColumn\",\n            \"msGridColumnSpan\",\n            \"msGridRow\",\n            \"msGridRowSpan\",\n            \"WebkitAnimationIterationCount\",\n            \"WebkitBoxFlex\",\n            \"WebKitBoxFlexGroup\",\n            \"WebkitBoxOrdinalGroup\",\n            \"WebkitColumnCount\",\n            \"WebkitColumns\",\n            \"WebkitFlex\",\n            \"WebkitFlexGrow\",\n            \"WebkitFlexPositive\",\n            \"WebkitFlexShrink\",\n            \"WebkitLineClamp\"\n        ]);\n        function isUnitlessNumber(name) {\n            return unitlessNumbers.has(name);\n        }\n        var aliases = new Map([\n            [\n                \"acceptCharset\",\n                \"accept-charset\"\n            ],\n            [\n                \"htmlFor\",\n                \"for\"\n            ],\n            [\n                \"httpEquiv\",\n                \"http-equiv\"\n            ],\n            [\n                \"crossOrigin\",\n                \"crossorigin\"\n            ],\n            // Regular attributes that just accept strings.],\n            [\n                \"accentHeight\",\n                \"accent-height\"\n            ],\n            [\n                \"alignmentBaseline\",\n                \"alignment-baseline\"\n            ],\n            [\n                \"arabicForm\",\n                \"arabic-form\"\n            ],\n            [\n                \"baselineShift\",\n                \"baseline-shift\"\n            ],\n            [\n                \"capHeight\",\n                \"cap-height\"\n            ],\n            [\n                \"clipPath\",\n                \"clip-path\"\n            ],\n            [\n                \"clipRule\",\n                \"clip-rule\"\n            ],\n            [\n                \"colorInterpolation\",\n                \"color-interpolation\"\n            ],\n            [\n                \"colorInterpolationFilters\",\n                \"color-interpolation-filters\"\n            ],\n            [\n                \"colorProfile\",\n                \"color-profile\"\n            ],\n            [\n                \"colorRendering\",\n                \"color-rendering\"\n            ],\n            [\n                \"dominantBaseline\",\n                \"dominant-baseline\"\n            ],\n            [\n                \"enableBackground\",\n                \"enable-background\"\n            ],\n            [\n                \"fillOpacity\",\n                \"fill-opacity\"\n            ],\n            [\n                \"fillRule\",\n                \"fill-rule\"\n            ],\n            [\n                \"floodColor\",\n                \"flood-color\"\n            ],\n            [\n                \"floodOpacity\",\n                \"flood-opacity\"\n            ],\n            [\n                \"fontFamily\",\n                \"font-family\"\n            ],\n            [\n                \"fontSize\",\n                \"font-size\"\n            ],\n            [\n                \"fontSizeAdjust\",\n                \"font-size-adjust\"\n            ],\n            [\n                \"fontStretch\",\n                \"font-stretch\"\n            ],\n            [\n                \"fontStyle\",\n                \"font-style\"\n            ],\n            [\n                \"fontVariant\",\n                \"font-variant\"\n            ],\n            [\n                \"fontWeight\",\n                \"font-weight\"\n            ],\n            [\n                \"glyphName\",\n                \"glyph-name\"\n            ],\n            [\n                \"glyphOrientationHorizontal\",\n                \"glyph-orientation-horizontal\"\n            ],\n            [\n                \"glyphOrientationVertical\",\n                \"glyph-orientation-vertical\"\n            ],\n            [\n                \"horizAdvX\",\n                \"horiz-adv-x\"\n            ],\n            [\n                \"horizOriginX\",\n                \"horiz-origin-x\"\n            ],\n            [\n                \"imageRendering\",\n                \"image-rendering\"\n            ],\n            [\n                \"letterSpacing\",\n                \"letter-spacing\"\n            ],\n            [\n                \"lightingColor\",\n                \"lighting-color\"\n            ],\n            [\n                \"markerEnd\",\n                \"marker-end\"\n            ],\n            [\n                \"markerMid\",\n                \"marker-mid\"\n            ],\n            [\n                \"markerStart\",\n                \"marker-start\"\n            ],\n            [\n                \"overlinePosition\",\n                \"overline-position\"\n            ],\n            [\n                \"overlineThickness\",\n                \"overline-thickness\"\n            ],\n            [\n                \"paintOrder\",\n                \"paint-order\"\n            ],\n            [\n                \"panose-1\",\n                \"panose-1\"\n            ],\n            [\n                \"pointerEvents\",\n                \"pointer-events\"\n            ],\n            [\n                \"renderingIntent\",\n                \"rendering-intent\"\n            ],\n            [\n                \"shapeRendering\",\n                \"shape-rendering\"\n            ],\n            [\n                \"stopColor\",\n                \"stop-color\"\n            ],\n            [\n                \"stopOpacity\",\n                \"stop-opacity\"\n            ],\n            [\n                \"strikethroughPosition\",\n                \"strikethrough-position\"\n            ],\n            [\n                \"strikethroughThickness\",\n                \"strikethrough-thickness\"\n            ],\n            [\n                \"strokeDasharray\",\n                \"stroke-dasharray\"\n            ],\n            [\n                \"strokeDashoffset\",\n                \"stroke-dashoffset\"\n            ],\n            [\n                \"strokeLinecap\",\n                \"stroke-linecap\"\n            ],\n            [\n                \"strokeLinejoin\",\n                \"stroke-linejoin\"\n            ],\n            [\n                \"strokeMiterlimit\",\n                \"stroke-miterlimit\"\n            ],\n            [\n                \"strokeOpacity\",\n                \"stroke-opacity\"\n            ],\n            [\n                \"strokeWidth\",\n                \"stroke-width\"\n            ],\n            [\n                \"textAnchor\",\n                \"text-anchor\"\n            ],\n            [\n                \"textDecoration\",\n                \"text-decoration\"\n            ],\n            [\n                \"textRendering\",\n                \"text-rendering\"\n            ],\n            [\n                \"transformOrigin\",\n                \"transform-origin\"\n            ],\n            [\n                \"underlinePosition\",\n                \"underline-position\"\n            ],\n            [\n                \"underlineThickness\",\n                \"underline-thickness\"\n            ],\n            [\n                \"unicodeBidi\",\n                \"unicode-bidi\"\n            ],\n            [\n                \"unicodeRange\",\n                \"unicode-range\"\n            ],\n            [\n                \"unitsPerEm\",\n                \"units-per-em\"\n            ],\n            [\n                \"vAlphabetic\",\n                \"v-alphabetic\"\n            ],\n            [\n                \"vHanging\",\n                \"v-hanging\"\n            ],\n            [\n                \"vIdeographic\",\n                \"v-ideographic\"\n            ],\n            [\n                \"vMathematical\",\n                \"v-mathematical\"\n            ],\n            [\n                \"vectorEffect\",\n                \"vector-effect\"\n            ],\n            [\n                \"vertAdvY\",\n                \"vert-adv-y\"\n            ],\n            [\n                \"vertOriginX\",\n                \"vert-origin-x\"\n            ],\n            [\n                \"vertOriginY\",\n                \"vert-origin-y\"\n            ],\n            [\n                \"wordSpacing\",\n                \"word-spacing\"\n            ],\n            [\n                \"writingMode\",\n                \"writing-mode\"\n            ],\n            [\n                \"xmlnsXlink\",\n                \"xmlns:xlink\"\n            ],\n            [\n                \"xHeight\",\n                \"x-height\"\n            ]\n        ]);\n        function getAttributeAlias(name) {\n            return aliases.get(name) || name;\n        }\n        var hasReadOnlyValue = {\n            button: true,\n            checkbox: true,\n            image: true,\n            hidden: true,\n            radio: true,\n            reset: true,\n            submit: true\n        };\n        function checkControlledValueProps(tagName, props) {\n            {\n                if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {\n                    error(\"You provided a `value` prop to a form field without an \" + \"`onChange` handler. This will render a read-only field. If \" + \"the field should be mutable use `defaultValue`. Otherwise, \" + \"set either `onChange` or `readOnly`.\");\n                }\n                if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {\n                    error(\"You provided a `checked` prop to a form field without an \" + \"`onChange` handler. This will render a read-only field. If \" + \"the field should be mutable use `defaultChecked`. Otherwise, \" + \"set either `onChange` or `readOnly`.\");\n                }\n            }\n        }\n        var ariaProperties = {\n            \"aria-current\": 0,\n            // state\n            \"aria-description\": 0,\n            \"aria-details\": 0,\n            \"aria-disabled\": 0,\n            // state\n            \"aria-hidden\": 0,\n            // state\n            \"aria-invalid\": 0,\n            // state\n            \"aria-keyshortcuts\": 0,\n            \"aria-label\": 0,\n            \"aria-roledescription\": 0,\n            // Widget Attributes\n            \"aria-autocomplete\": 0,\n            \"aria-checked\": 0,\n            \"aria-expanded\": 0,\n            \"aria-haspopup\": 0,\n            \"aria-level\": 0,\n            \"aria-modal\": 0,\n            \"aria-multiline\": 0,\n            \"aria-multiselectable\": 0,\n            \"aria-orientation\": 0,\n            \"aria-placeholder\": 0,\n            \"aria-pressed\": 0,\n            \"aria-readonly\": 0,\n            \"aria-required\": 0,\n            \"aria-selected\": 0,\n            \"aria-sort\": 0,\n            \"aria-valuemax\": 0,\n            \"aria-valuemin\": 0,\n            \"aria-valuenow\": 0,\n            \"aria-valuetext\": 0,\n            // Live Region Attributes\n            \"aria-atomic\": 0,\n            \"aria-busy\": 0,\n            \"aria-live\": 0,\n            \"aria-relevant\": 0,\n            // Drag-and-Drop Attributes\n            \"aria-dropeffect\": 0,\n            \"aria-grabbed\": 0,\n            // Relationship Attributes\n            \"aria-activedescendant\": 0,\n            \"aria-colcount\": 0,\n            \"aria-colindex\": 0,\n            \"aria-colspan\": 0,\n            \"aria-controls\": 0,\n            \"aria-describedby\": 0,\n            \"aria-errormessage\": 0,\n            \"aria-flowto\": 0,\n            \"aria-labelledby\": 0,\n            \"aria-owns\": 0,\n            \"aria-posinset\": 0,\n            \"aria-rowcount\": 0,\n            \"aria-rowindex\": 0,\n            \"aria-rowspan\": 0,\n            \"aria-setsize\": 0\n        };\n        var warnedProperties$1 = {};\n        var rARIA$1 = new RegExp(\"^(aria)-[\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        var rARIACamel$1 = new RegExp(\"^(aria)[A-Z][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        function validateProperty$1(tagName, name) {\n            {\n                if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {\n                    return true;\n                }\n                if (rARIACamel$1.test(name)) {\n                    var ariaName = \"aria-\" + name.slice(4).toLowerCase();\n                    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null; // If this is an aria-* attribute, but is not listed in the known DOM\n                    // DOM properties, then it is an invalid aria-* attribute.\n                    if (correctName == null) {\n                        error(\"Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.\", name);\n                        warnedProperties$1[name] = true;\n                        return true;\n                    } // aria-* attributes should be lowercase; suggest the lowercase version.\n                    if (name !== correctName) {\n                        error(\"Invalid ARIA attribute `%s`. Did you mean `%s`?\", name, correctName);\n                        warnedProperties$1[name] = true;\n                        return true;\n                    }\n                }\n                if (rARIA$1.test(name)) {\n                    var lowerCasedName = name.toLowerCase();\n                    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null; // If this is an aria-* attribute, but is not listed in the known DOM\n                    // DOM properties, then it is an invalid aria-* attribute.\n                    if (standardName == null) {\n                        warnedProperties$1[name] = true;\n                        return false;\n                    } // aria-* attributes should be lowercase; suggest the lowercase version.\n                    if (name !== standardName) {\n                        error(\"Unknown ARIA attribute `%s`. Did you mean `%s`?\", name, standardName);\n                        warnedProperties$1[name] = true;\n                        return true;\n                    }\n                }\n            }\n            return true;\n        }\n        function validateProperties$2(type, props) {\n            {\n                var invalidProps = [];\n                for(var key in props){\n                    var isValid = validateProperty$1(type, key);\n                    if (!isValid) {\n                        invalidProps.push(key);\n                    }\n                }\n                var unknownPropString = invalidProps.map(function(prop) {\n                    return \"`\" + prop + \"`\";\n                }).join(\", \");\n                if (invalidProps.length === 1) {\n                    error(\"Invalid aria prop %s on <%s> tag. \" + \"For details, see https://reactjs.org/link/invalid-aria-props\", unknownPropString, type);\n                } else if (invalidProps.length > 1) {\n                    error(\"Invalid aria props %s on <%s> tag. \" + \"For details, see https://reactjs.org/link/invalid-aria-props\", unknownPropString, type);\n                }\n            }\n        }\n        var didWarnValueNull = false;\n        function validateProperties$1(type, props) {\n            {\n                if (type !== \"input\" && type !== \"textarea\" && type !== \"select\") {\n                    return;\n                }\n                if (props != null && props.value === null && !didWarnValueNull) {\n                    didWarnValueNull = true;\n                    if (type === \"select\" && props.multiple) {\n                        error(\"`value` prop on `%s` should not be null. \" + \"Consider using an empty array when `multiple` is set to `true` \" + \"to clear the component or `undefined` for uncontrolled components.\", type);\n                    } else {\n                        error(\"`value` prop on `%s` should not be null. \" + \"Consider using an empty string to clear the component or `undefined` \" + \"for uncontrolled components.\", type);\n                    }\n                }\n            }\n        }\n        function isCustomElement(tagName, props) {\n            if (tagName.indexOf(\"-\") === -1) {\n                return false;\n            }\n            switch(tagName){\n                // These are reserved SVG and MathML elements.\n                // We don't mind this list too much because we expect it to never grow.\n                // The alternative is to track the namespace in a few places which is convoluted.\n                // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\n                case \"annotation-xml\":\n                case \"color-profile\":\n                case \"font-face\":\n                case \"font-face-src\":\n                case \"font-face-uri\":\n                case \"font-face-format\":\n                case \"font-face-name\":\n                case \"missing-glyph\":\n                    return false;\n                default:\n                    return true;\n            }\n        }\n        // When adding attributes to the HTML or SVG allowed attribute list, be sure to\n        // also add them to this module to ensure casing and incorrect name\n        // warnings.\n        var possibleStandardNames = {\n            // HTML\n            accept: \"accept\",\n            acceptcharset: \"acceptCharset\",\n            \"accept-charset\": \"acceptCharset\",\n            accesskey: \"accessKey\",\n            action: \"action\",\n            allowfullscreen: \"allowFullScreen\",\n            alt: \"alt\",\n            as: \"as\",\n            async: \"async\",\n            autocapitalize: \"autoCapitalize\",\n            autocomplete: \"autoComplete\",\n            autocorrect: \"autoCorrect\",\n            autofocus: \"autoFocus\",\n            autoplay: \"autoPlay\",\n            autosave: \"autoSave\",\n            capture: \"capture\",\n            cellpadding: \"cellPadding\",\n            cellspacing: \"cellSpacing\",\n            challenge: \"challenge\",\n            charset: \"charSet\",\n            checked: \"checked\",\n            children: \"children\",\n            cite: \"cite\",\n            class: \"className\",\n            classid: \"classID\",\n            classname: \"className\",\n            cols: \"cols\",\n            colspan: \"colSpan\",\n            content: \"content\",\n            contenteditable: \"contentEditable\",\n            contextmenu: \"contextMenu\",\n            controls: \"controls\",\n            controlslist: \"controlsList\",\n            coords: \"coords\",\n            crossorigin: \"crossOrigin\",\n            dangerouslysetinnerhtml: \"dangerouslySetInnerHTML\",\n            data: \"data\",\n            datetime: \"dateTime\",\n            default: \"default\",\n            defaultchecked: \"defaultChecked\",\n            defaultvalue: \"defaultValue\",\n            defer: \"defer\",\n            dir: \"dir\",\n            disabled: \"disabled\",\n            disablepictureinpicture: \"disablePictureInPicture\",\n            disableremoteplayback: \"disableRemotePlayback\",\n            download: \"download\",\n            draggable: \"draggable\",\n            enctype: \"encType\",\n            enterkeyhint: \"enterKeyHint\",\n            fetchpriority: \"fetchPriority\",\n            for: \"htmlFor\",\n            form: \"form\",\n            formmethod: \"formMethod\",\n            formaction: \"formAction\",\n            formenctype: \"formEncType\",\n            formnovalidate: \"formNoValidate\",\n            formtarget: \"formTarget\",\n            frameborder: \"frameBorder\",\n            headers: \"headers\",\n            height: \"height\",\n            hidden: \"hidden\",\n            high: \"high\",\n            href: \"href\",\n            hreflang: \"hrefLang\",\n            htmlfor: \"htmlFor\",\n            httpequiv: \"httpEquiv\",\n            \"http-equiv\": \"httpEquiv\",\n            icon: \"icon\",\n            id: \"id\",\n            imagesizes: \"imageSizes\",\n            imagesrcset: \"imageSrcSet\",\n            innerhtml: \"innerHTML\",\n            inputmode: \"inputMode\",\n            integrity: \"integrity\",\n            is: \"is\",\n            itemid: \"itemID\",\n            itemprop: \"itemProp\",\n            itemref: \"itemRef\",\n            itemscope: \"itemScope\",\n            itemtype: \"itemType\",\n            keyparams: \"keyParams\",\n            keytype: \"keyType\",\n            kind: \"kind\",\n            label: \"label\",\n            lang: \"lang\",\n            list: \"list\",\n            loop: \"loop\",\n            low: \"low\",\n            manifest: \"manifest\",\n            marginwidth: \"marginWidth\",\n            marginheight: \"marginHeight\",\n            max: \"max\",\n            maxlength: \"maxLength\",\n            media: \"media\",\n            mediagroup: \"mediaGroup\",\n            method: \"method\",\n            min: \"min\",\n            minlength: \"minLength\",\n            multiple: \"multiple\",\n            muted: \"muted\",\n            name: \"name\",\n            nomodule: \"noModule\",\n            nonce: \"nonce\",\n            novalidate: \"noValidate\",\n            open: \"open\",\n            optimum: \"optimum\",\n            pattern: \"pattern\",\n            placeholder: \"placeholder\",\n            playsinline: \"playsInline\",\n            poster: \"poster\",\n            preload: \"preload\",\n            profile: \"profile\",\n            radiogroup: \"radioGroup\",\n            readonly: \"readOnly\",\n            referrerpolicy: \"referrerPolicy\",\n            rel: \"rel\",\n            required: \"required\",\n            reversed: \"reversed\",\n            role: \"role\",\n            rows: \"rows\",\n            rowspan: \"rowSpan\",\n            sandbox: \"sandbox\",\n            scope: \"scope\",\n            scoped: \"scoped\",\n            scrolling: \"scrolling\",\n            seamless: \"seamless\",\n            selected: \"selected\",\n            shape: \"shape\",\n            size: \"size\",\n            sizes: \"sizes\",\n            span: \"span\",\n            spellcheck: \"spellCheck\",\n            src: \"src\",\n            srcdoc: \"srcDoc\",\n            srclang: \"srcLang\",\n            srcset: \"srcSet\",\n            start: \"start\",\n            step: \"step\",\n            style: \"style\",\n            summary: \"summary\",\n            tabindex: \"tabIndex\",\n            target: \"target\",\n            title: \"title\",\n            type: \"type\",\n            usemap: \"useMap\",\n            value: \"value\",\n            width: \"width\",\n            wmode: \"wmode\",\n            wrap: \"wrap\",\n            // SVG\n            about: \"about\",\n            accentheight: \"accentHeight\",\n            \"accent-height\": \"accentHeight\",\n            accumulate: \"accumulate\",\n            additive: \"additive\",\n            alignmentbaseline: \"alignmentBaseline\",\n            \"alignment-baseline\": \"alignmentBaseline\",\n            allowreorder: \"allowReorder\",\n            alphabetic: \"alphabetic\",\n            amplitude: \"amplitude\",\n            arabicform: \"arabicForm\",\n            \"arabic-form\": \"arabicForm\",\n            ascent: \"ascent\",\n            attributename: \"attributeName\",\n            attributetype: \"attributeType\",\n            autoreverse: \"autoReverse\",\n            azimuth: \"azimuth\",\n            basefrequency: \"baseFrequency\",\n            baselineshift: \"baselineShift\",\n            \"baseline-shift\": \"baselineShift\",\n            baseprofile: \"baseProfile\",\n            bbox: \"bbox\",\n            begin: \"begin\",\n            bias: \"bias\",\n            by: \"by\",\n            calcmode: \"calcMode\",\n            capheight: \"capHeight\",\n            \"cap-height\": \"capHeight\",\n            clip: \"clip\",\n            clippath: \"clipPath\",\n            \"clip-path\": \"clipPath\",\n            clippathunits: \"clipPathUnits\",\n            cliprule: \"clipRule\",\n            \"clip-rule\": \"clipRule\",\n            color: \"color\",\n            colorinterpolation: \"colorInterpolation\",\n            \"color-interpolation\": \"colorInterpolation\",\n            colorinterpolationfilters: \"colorInterpolationFilters\",\n            \"color-interpolation-filters\": \"colorInterpolationFilters\",\n            colorprofile: \"colorProfile\",\n            \"color-profile\": \"colorProfile\",\n            colorrendering: \"colorRendering\",\n            \"color-rendering\": \"colorRendering\",\n            contentscripttype: \"contentScriptType\",\n            contentstyletype: \"contentStyleType\",\n            cursor: \"cursor\",\n            cx: \"cx\",\n            cy: \"cy\",\n            d: \"d\",\n            datatype: \"datatype\",\n            decelerate: \"decelerate\",\n            descent: \"descent\",\n            diffuseconstant: \"diffuseConstant\",\n            direction: \"direction\",\n            display: \"display\",\n            divisor: \"divisor\",\n            dominantbaseline: \"dominantBaseline\",\n            \"dominant-baseline\": \"dominantBaseline\",\n            dur: \"dur\",\n            dx: \"dx\",\n            dy: \"dy\",\n            edgemode: \"edgeMode\",\n            elevation: \"elevation\",\n            enablebackground: \"enableBackground\",\n            \"enable-background\": \"enableBackground\",\n            end: \"end\",\n            exponent: \"exponent\",\n            externalresourcesrequired: \"externalResourcesRequired\",\n            fill: \"fill\",\n            fillopacity: \"fillOpacity\",\n            \"fill-opacity\": \"fillOpacity\",\n            fillrule: \"fillRule\",\n            \"fill-rule\": \"fillRule\",\n            filter: \"filter\",\n            filterres: \"filterRes\",\n            filterunits: \"filterUnits\",\n            floodopacity: \"floodOpacity\",\n            \"flood-opacity\": \"floodOpacity\",\n            floodcolor: \"floodColor\",\n            \"flood-color\": \"floodColor\",\n            focusable: \"focusable\",\n            fontfamily: \"fontFamily\",\n            \"font-family\": \"fontFamily\",\n            fontsize: \"fontSize\",\n            \"font-size\": \"fontSize\",\n            fontsizeadjust: \"fontSizeAdjust\",\n            \"font-size-adjust\": \"fontSizeAdjust\",\n            fontstretch: \"fontStretch\",\n            \"font-stretch\": \"fontStretch\",\n            fontstyle: \"fontStyle\",\n            \"font-style\": \"fontStyle\",\n            fontvariant: \"fontVariant\",\n            \"font-variant\": \"fontVariant\",\n            fontweight: \"fontWeight\",\n            \"font-weight\": \"fontWeight\",\n            format: \"format\",\n            from: \"from\",\n            fx: \"fx\",\n            fy: \"fy\",\n            g1: \"g1\",\n            g2: \"g2\",\n            glyphname: \"glyphName\",\n            \"glyph-name\": \"glyphName\",\n            glyphorientationhorizontal: \"glyphOrientationHorizontal\",\n            \"glyph-orientation-horizontal\": \"glyphOrientationHorizontal\",\n            glyphorientationvertical: \"glyphOrientationVertical\",\n            \"glyph-orientation-vertical\": \"glyphOrientationVertical\",\n            glyphref: \"glyphRef\",\n            gradienttransform: \"gradientTransform\",\n            gradientunits: \"gradientUnits\",\n            hanging: \"hanging\",\n            horizadvx: \"horizAdvX\",\n            \"horiz-adv-x\": \"horizAdvX\",\n            horizoriginx: \"horizOriginX\",\n            \"horiz-origin-x\": \"horizOriginX\",\n            ideographic: \"ideographic\",\n            imagerendering: \"imageRendering\",\n            \"image-rendering\": \"imageRendering\",\n            in2: \"in2\",\n            in: \"in\",\n            inlist: \"inlist\",\n            intercept: \"intercept\",\n            k1: \"k1\",\n            k2: \"k2\",\n            k3: \"k3\",\n            k4: \"k4\",\n            k: \"k\",\n            kernelmatrix: \"kernelMatrix\",\n            kernelunitlength: \"kernelUnitLength\",\n            kerning: \"kerning\",\n            keypoints: \"keyPoints\",\n            keysplines: \"keySplines\",\n            keytimes: \"keyTimes\",\n            lengthadjust: \"lengthAdjust\",\n            letterspacing: \"letterSpacing\",\n            \"letter-spacing\": \"letterSpacing\",\n            lightingcolor: \"lightingColor\",\n            \"lighting-color\": \"lightingColor\",\n            limitingconeangle: \"limitingConeAngle\",\n            local: \"local\",\n            markerend: \"markerEnd\",\n            \"marker-end\": \"markerEnd\",\n            markerheight: \"markerHeight\",\n            markermid: \"markerMid\",\n            \"marker-mid\": \"markerMid\",\n            markerstart: \"markerStart\",\n            \"marker-start\": \"markerStart\",\n            markerunits: \"markerUnits\",\n            markerwidth: \"markerWidth\",\n            mask: \"mask\",\n            maskcontentunits: \"maskContentUnits\",\n            maskunits: \"maskUnits\",\n            mathematical: \"mathematical\",\n            mode: \"mode\",\n            numoctaves: \"numOctaves\",\n            offset: \"offset\",\n            opacity: \"opacity\",\n            operator: \"operator\",\n            order: \"order\",\n            orient: \"orient\",\n            orientation: \"orientation\",\n            origin: \"origin\",\n            overflow: \"overflow\",\n            overlineposition: \"overlinePosition\",\n            \"overline-position\": \"overlinePosition\",\n            overlinethickness: \"overlineThickness\",\n            \"overline-thickness\": \"overlineThickness\",\n            paintorder: \"paintOrder\",\n            \"paint-order\": \"paintOrder\",\n            panose1: \"panose1\",\n            \"panose-1\": \"panose1\",\n            pathlength: \"pathLength\",\n            patterncontentunits: \"patternContentUnits\",\n            patterntransform: \"patternTransform\",\n            patternunits: \"patternUnits\",\n            pointerevents: \"pointerEvents\",\n            \"pointer-events\": \"pointerEvents\",\n            points: \"points\",\n            pointsatx: \"pointsAtX\",\n            pointsaty: \"pointsAtY\",\n            pointsatz: \"pointsAtZ\",\n            prefix: \"prefix\",\n            preservealpha: \"preserveAlpha\",\n            preserveaspectratio: \"preserveAspectRatio\",\n            primitiveunits: \"primitiveUnits\",\n            property: \"property\",\n            r: \"r\",\n            radius: \"radius\",\n            refx: \"refX\",\n            refy: \"refY\",\n            renderingintent: \"renderingIntent\",\n            \"rendering-intent\": \"renderingIntent\",\n            repeatcount: \"repeatCount\",\n            repeatdur: \"repeatDur\",\n            requiredextensions: \"requiredExtensions\",\n            requiredfeatures: \"requiredFeatures\",\n            resource: \"resource\",\n            restart: \"restart\",\n            result: \"result\",\n            results: \"results\",\n            rotate: \"rotate\",\n            rx: \"rx\",\n            ry: \"ry\",\n            scale: \"scale\",\n            security: \"security\",\n            seed: \"seed\",\n            shaperendering: \"shapeRendering\",\n            \"shape-rendering\": \"shapeRendering\",\n            slope: \"slope\",\n            spacing: \"spacing\",\n            specularconstant: \"specularConstant\",\n            specularexponent: \"specularExponent\",\n            speed: \"speed\",\n            spreadmethod: \"spreadMethod\",\n            startoffset: \"startOffset\",\n            stddeviation: \"stdDeviation\",\n            stemh: \"stemh\",\n            stemv: \"stemv\",\n            stitchtiles: \"stitchTiles\",\n            stopcolor: \"stopColor\",\n            \"stop-color\": \"stopColor\",\n            stopopacity: \"stopOpacity\",\n            \"stop-opacity\": \"stopOpacity\",\n            strikethroughposition: \"strikethroughPosition\",\n            \"strikethrough-position\": \"strikethroughPosition\",\n            strikethroughthickness: \"strikethroughThickness\",\n            \"strikethrough-thickness\": \"strikethroughThickness\",\n            string: \"string\",\n            stroke: \"stroke\",\n            strokedasharray: \"strokeDasharray\",\n            \"stroke-dasharray\": \"strokeDasharray\",\n            strokedashoffset: \"strokeDashoffset\",\n            \"stroke-dashoffset\": \"strokeDashoffset\",\n            strokelinecap: \"strokeLinecap\",\n            \"stroke-linecap\": \"strokeLinecap\",\n            strokelinejoin: \"strokeLinejoin\",\n            \"stroke-linejoin\": \"strokeLinejoin\",\n            strokemiterlimit: \"strokeMiterlimit\",\n            \"stroke-miterlimit\": \"strokeMiterlimit\",\n            strokewidth: \"strokeWidth\",\n            \"stroke-width\": \"strokeWidth\",\n            strokeopacity: \"strokeOpacity\",\n            \"stroke-opacity\": \"strokeOpacity\",\n            suppresscontenteditablewarning: \"suppressContentEditableWarning\",\n            suppresshydrationwarning: \"suppressHydrationWarning\",\n            surfacescale: \"surfaceScale\",\n            systemlanguage: \"systemLanguage\",\n            tablevalues: \"tableValues\",\n            targetx: \"targetX\",\n            targety: \"targetY\",\n            textanchor: \"textAnchor\",\n            \"text-anchor\": \"textAnchor\",\n            textdecoration: \"textDecoration\",\n            \"text-decoration\": \"textDecoration\",\n            textlength: \"textLength\",\n            textrendering: \"textRendering\",\n            \"text-rendering\": \"textRendering\",\n            to: \"to\",\n            transform: \"transform\",\n            transformorigin: \"transformOrigin\",\n            \"transform-origin\": \"transformOrigin\",\n            typeof: \"typeof\",\n            u1: \"u1\",\n            u2: \"u2\",\n            underlineposition: \"underlinePosition\",\n            \"underline-position\": \"underlinePosition\",\n            underlinethickness: \"underlineThickness\",\n            \"underline-thickness\": \"underlineThickness\",\n            unicode: \"unicode\",\n            unicodebidi: \"unicodeBidi\",\n            \"unicode-bidi\": \"unicodeBidi\",\n            unicoderange: \"unicodeRange\",\n            \"unicode-range\": \"unicodeRange\",\n            unitsperem: \"unitsPerEm\",\n            \"units-per-em\": \"unitsPerEm\",\n            unselectable: \"unselectable\",\n            valphabetic: \"vAlphabetic\",\n            \"v-alphabetic\": \"vAlphabetic\",\n            values: \"values\",\n            vectoreffect: \"vectorEffect\",\n            \"vector-effect\": \"vectorEffect\",\n            version: \"version\",\n            vertadvy: \"vertAdvY\",\n            \"vert-adv-y\": \"vertAdvY\",\n            vertoriginx: \"vertOriginX\",\n            \"vert-origin-x\": \"vertOriginX\",\n            vertoriginy: \"vertOriginY\",\n            \"vert-origin-y\": \"vertOriginY\",\n            vhanging: \"vHanging\",\n            \"v-hanging\": \"vHanging\",\n            videographic: \"vIdeographic\",\n            \"v-ideographic\": \"vIdeographic\",\n            viewbox: \"viewBox\",\n            viewtarget: \"viewTarget\",\n            visibility: \"visibility\",\n            vmathematical: \"vMathematical\",\n            \"v-mathematical\": \"vMathematical\",\n            vocab: \"vocab\",\n            widths: \"widths\",\n            wordspacing: \"wordSpacing\",\n            \"word-spacing\": \"wordSpacing\",\n            writingmode: \"writingMode\",\n            \"writing-mode\": \"writingMode\",\n            x1: \"x1\",\n            x2: \"x2\",\n            x: \"x\",\n            xchannelselector: \"xChannelSelector\",\n            xheight: \"xHeight\",\n            \"x-height\": \"xHeight\",\n            xlinkactuate: \"xlinkActuate\",\n            \"xlink:actuate\": \"xlinkActuate\",\n            xlinkarcrole: \"xlinkArcrole\",\n            \"xlink:arcrole\": \"xlinkArcrole\",\n            xlinkhref: \"xlinkHref\",\n            \"xlink:href\": \"xlinkHref\",\n            xlinkrole: \"xlinkRole\",\n            \"xlink:role\": \"xlinkRole\",\n            xlinkshow: \"xlinkShow\",\n            \"xlink:show\": \"xlinkShow\",\n            xlinktitle: \"xlinkTitle\",\n            \"xlink:title\": \"xlinkTitle\",\n            xlinktype: \"xlinkType\",\n            \"xlink:type\": \"xlinkType\",\n            xmlbase: \"xmlBase\",\n            \"xml:base\": \"xmlBase\",\n            xmllang: \"xmlLang\",\n            \"xml:lang\": \"xmlLang\",\n            xmlns: \"xmlns\",\n            \"xml:space\": \"xmlSpace\",\n            xmlnsxlink: \"xmlnsXlink\",\n            \"xmlns:xlink\": \"xmlnsXlink\",\n            xmlspace: \"xmlSpace\",\n            y1: \"y1\",\n            y2: \"y2\",\n            y: \"y\",\n            ychannelselector: \"yChannelSelector\",\n            z: \"z\",\n            zoomandpan: \"zoomAndPan\"\n        };\n        var warnedProperties = {};\n        var EVENT_NAME_REGEX = /^on./;\n        var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;\n        var rARIA = new RegExp(\"^(aria)-[\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        var rARIACamel = new RegExp(\"^(aria)[A-Z][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        function validateProperty(tagName, name, value, eventRegistry) {\n            {\n                if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {\n                    return true;\n                }\n                var lowerCasedName = name.toLowerCase();\n                if (lowerCasedName === \"onfocusin\" || lowerCasedName === \"onfocusout\") {\n                    error(\"React uses onFocus and onBlur instead of onFocusIn and onFocusOut. \" + \"All React events are normalized to bubble, so onFocusIn and onFocusOut \" + \"are not needed/supported by React.\");\n                    warnedProperties[name] = true;\n                    return true;\n                }\n                if (eventRegistry != null) {\n                    var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;\n                    if (registrationNameDependencies.hasOwnProperty(name)) {\n                        return true;\n                    }\n                    var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;\n                    if (registrationName != null) {\n                        error(\"Invalid event handler property `%s`. Did you mean `%s`?\", name, registrationName);\n                        warnedProperties[name] = true;\n                        return true;\n                    }\n                    if (EVENT_NAME_REGEX.test(name)) {\n                        error(\"Unknown event handler property `%s`. It will be ignored.\", name);\n                        warnedProperties[name] = true;\n                        return true;\n                    }\n                } else if (EVENT_NAME_REGEX.test(name)) {\n                    // If no event plugins have been injected, we are in a server environment.\n                    // So we can't tell if the event name is correct for sure, but we can filter\n                    // out known bad ones like `onclick`. We can't suggest a specific replacement though.\n                    if (INVALID_EVENT_NAME_REGEX.test(name)) {\n                        error(\"Invalid event handler property `%s`. \" + \"React events use the camelCase naming convention, for example `onClick`.\", name);\n                    }\n                    warnedProperties[name] = true;\n                    return true;\n                } // Let the ARIA attribute hook validate ARIA attributes\n                if (rARIA.test(name) || rARIACamel.test(name)) {\n                    return true;\n                }\n                if (lowerCasedName === \"innerhtml\") {\n                    error(\"Directly setting property `innerHTML` is not permitted. \" + \"For more information, lookup documentation on `dangerouslySetInnerHTML`.\");\n                    warnedProperties[name] = true;\n                    return true;\n                }\n                if (lowerCasedName === \"aria\") {\n                    error(\"The `aria` attribute is reserved for future use in React. \" + \"Pass individual `aria-` attributes instead.\");\n                    warnedProperties[name] = true;\n                    return true;\n                }\n                if (lowerCasedName === \"is\" && value !== null && value !== undefined && typeof value !== \"string\") {\n                    error(\"Received a `%s` for a string attribute `is`. If this is expected, cast \" + \"the value to a string.\", typeof value);\n                    warnedProperties[name] = true;\n                    return true;\n                }\n                if (typeof value === \"number\" && isNaN(value)) {\n                    error(\"Received NaN for the `%s` attribute. If this is expected, cast \" + \"the value to a string.\", name);\n                    warnedProperties[name] = true;\n                    return true;\n                } // Known attributes should match the casing specified in the property config.\n                if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n                    var standardName = possibleStandardNames[lowerCasedName];\n                    if (standardName !== name) {\n                        error(\"Invalid DOM property `%s`. Did you mean `%s`?\", name, standardName);\n                        warnedProperties[name] = true;\n                        return true;\n                    }\n                } else if (name !== lowerCasedName) {\n                    // Unknown attributes should have lowercase casing since that's how they\n                    // will be cased anyway with server rendering.\n                    error(\"React does not recognize the `%s` prop on a DOM element. If you \" + \"intentionally want it to appear in the DOM as a custom \" + \"attribute, spell it as lowercase `%s` instead. \" + \"If you accidentally passed it from a parent component, remove \" + \"it from the DOM element.\", name, lowerCasedName);\n                    warnedProperties[name] = true;\n                    return true;\n                } // Now that we've validated casing, do not validate\n                // data types for reserved props\n                switch(name){\n                    case \"dangerouslySetInnerHTML\":\n                    case \"children\":\n                    case \"style\":\n                    case \"suppressContentEditableWarning\":\n                    case \"suppressHydrationWarning\":\n                    case \"defaultValue\":\n                    case \"defaultChecked\":\n                    case \"innerHTML\":\n                        {\n                            return true;\n                        }\n                }\n                switch(typeof value){\n                    case \"boolean\":\n                        {\n                            switch(name){\n                                case \"autoFocus\":\n                                case \"checked\":\n                                case \"multiple\":\n                                case \"muted\":\n                                case \"selected\":\n                                case \"contentEditable\":\n                                case \"spellCheck\":\n                                case \"draggable\":\n                                case \"value\":\n                                case \"autoReverse\":\n                                case \"externalResourcesRequired\":\n                                case \"focusable\":\n                                case \"preserveAlpha\":\n                                case \"allowFullScreen\":\n                                case \"async\":\n                                case \"autoPlay\":\n                                case \"controls\":\n                                case \"default\":\n                                case \"defer\":\n                                case \"disabled\":\n                                case \"disablePictureInPicture\":\n                                case \"disableRemotePlayback\":\n                                case \"formNoValidate\":\n                                case \"hidden\":\n                                case \"loop\":\n                                case \"noModule\":\n                                case \"noValidate\":\n                                case \"open\":\n                                case \"playsInline\":\n                                case \"readOnly\":\n                                case \"required\":\n                                case \"reversed\":\n                                case \"scoped\":\n                                case \"seamless\":\n                                case \"itemScope\":\n                                case \"capture\":\n                                case \"download\":\n                                    {\n                                        // Boolean properties can accept boolean values\n                                        return true;\n                                    }\n                                default:\n                                    {\n                                        var prefix = name.toLowerCase().slice(0, 5);\n                                        if (prefix === \"data-\" || prefix === \"aria-\") {\n                                            return true;\n                                        }\n                                        if (value) {\n                                            error(\"Received `%s` for a non-boolean attribute `%s`.\\n\\n\" + \"If you want to write it to the DOM, pass a string instead: \" + '%s=\"%s\" or %s={value.toString()}.', value, name, name, value, name);\n                                        } else {\n                                            error(\"Received `%s` for a non-boolean attribute `%s`.\\n\\n\" + \"If you want to write it to the DOM, pass a string instead: \" + '%s=\"%s\" or %s={value.toString()}.\\n\\n' + \"If you used to conditionally omit it with %s={condition && value}, \" + \"pass %s={condition ? value : undefined} instead.\", value, name, name, value, name, name, name);\n                                        }\n                                        warnedProperties[name] = true;\n                                        return true;\n                                    }\n                            }\n                        }\n                    case \"function\":\n                    case \"symbol\":\n                        // eslint-disable-line\n                        // Warn when a known attribute is a bad type\n                        warnedProperties[name] = true;\n                        return false;\n                    case \"string\":\n                        {\n                            // Warn when passing the strings 'false' or 'true' into a boolean prop\n                            if (value === \"false\" || value === \"true\") {\n                                switch(name){\n                                    case \"checked\":\n                                    case \"selected\":\n                                    case \"multiple\":\n                                    case \"muted\":\n                                    case \"allowFullScreen\":\n                                    case \"async\":\n                                    case \"autoPlay\":\n                                    case \"controls\":\n                                    case \"default\":\n                                    case \"defer\":\n                                    case \"disabled\":\n                                    case \"disablePictureInPicture\":\n                                    case \"disableRemotePlayback\":\n                                    case \"formNoValidate\":\n                                    case \"hidden\":\n                                    case \"loop\":\n                                    case \"noModule\":\n                                    case \"noValidate\":\n                                    case \"open\":\n                                    case \"playsInline\":\n                                    case \"readOnly\":\n                                    case \"required\":\n                                    case \"reversed\":\n                                    case \"scoped\":\n                                    case \"seamless\":\n                                    case \"itemScope\":\n                                        {\n                                            break;\n                                        }\n                                    default:\n                                        {\n                                            return true;\n                                        }\n                                }\n                                error(\"Received the string `%s` for the boolean attribute `%s`. \" + \"%s \" + \"Did you mean %s={%s}?\", value, name, value === \"false\" ? \"The browser will interpret it as a truthy value.\" : 'Although this works, it will not work as expected if you pass the string \"false\".', name, value);\n                                warnedProperties[name] = true;\n                                return true;\n                            }\n                        }\n                }\n                return true;\n            }\n        }\n        function warnUnknownProperties(type, props, eventRegistry) {\n            {\n                var unknownProps = [];\n                for(var key in props){\n                    var isValid = validateProperty(type, key, props[key], eventRegistry);\n                    if (!isValid) {\n                        unknownProps.push(key);\n                    }\n                }\n                var unknownPropString = unknownProps.map(function(prop) {\n                    return \"`\" + prop + \"`\";\n                }).join(\", \");\n                if (unknownProps.length === 1) {\n                    error(\"Invalid value for prop %s on <%s> tag. Either remove it from the element, \" + \"or pass a string or number value to keep it in the DOM. \" + \"For details, see https://reactjs.org/link/attribute-behavior \", unknownPropString, type);\n                } else if (unknownProps.length > 1) {\n                    error(\"Invalid values for props %s on <%s> tag. Either remove them from the element, \" + \"or pass a string or number value to keep them in the DOM. \" + \"For details, see https://reactjs.org/link/attribute-behavior \", unknownPropString, type);\n                }\n            }\n        }\n        function validateProperties(type, props, eventRegistry) {\n            if (isCustomElement(type) || typeof props.is === \"string\") {\n                return;\n            }\n            warnUnknownProperties(type, props, eventRegistry);\n        }\n        // 'msTransform' is correct, but the other prefixes should be capitalized\n        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;\n        var msPattern$1 = /^-ms-/;\n        var hyphenPattern = /-(.)/g; // style values shouldn't contain a semicolon\n        var badStyleValueWithSemicolonPattern = /;\\s*$/;\n        var warnedStyleNames = {};\n        var warnedStyleValues = {};\n        var warnedForNaNValue = false;\n        var warnedForInfinityValue = false;\n        function camelize(string) {\n            return string.replace(hyphenPattern, function(_, character) {\n                return character.toUpperCase();\n            });\n        }\n        function warnHyphenatedStyleName(name) {\n            {\n                if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n                    return;\n                }\n                warnedStyleNames[name] = true;\n                error(\"Unsupported style property %s. Did you mean %s?\", name, // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n                // is converted to lowercase `ms`.\n                camelize(name.replace(msPattern$1, \"ms-\")));\n            }\n        }\n        function warnBadVendoredStyleName(name) {\n            {\n                if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n                    return;\n                }\n                warnedStyleNames[name] = true;\n                error(\"Unsupported vendor-prefixed style property %s. Did you mean %s?\", name, name.charAt(0).toUpperCase() + name.slice(1));\n            }\n        }\n        function warnStyleValueWithSemicolon(name, value) {\n            {\n                if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {\n                    return;\n                }\n                warnedStyleValues[value] = true;\n                error(\"Style property values shouldn't contain a semicolon. \" + 'Try \"%s: %s\" instead.', name, value.replace(badStyleValueWithSemicolonPattern, \"\"));\n            }\n        }\n        function warnStyleValueIsNaN(name, value) {\n            {\n                if (warnedForNaNValue) {\n                    return;\n                }\n                warnedForNaNValue = true;\n                error(\"`NaN` is an invalid value for the `%s` css style property.\", name);\n            }\n        }\n        function warnStyleValueIsInfinity(name, value) {\n            {\n                if (warnedForInfinityValue) {\n                    return;\n                }\n                warnedForInfinityValue = true;\n                error(\"`Infinity` is an invalid value for the `%s` css style property.\", name);\n            }\n        }\n        function warnValidStyle(name, value) {\n            {\n                if (name.indexOf(\"-\") > -1) {\n                    warnHyphenatedStyleName(name);\n                } else if (badVendoredStyleNamePattern.test(name)) {\n                    warnBadVendoredStyleName(name);\n                } else if (badStyleValueWithSemicolonPattern.test(value)) {\n                    warnStyleValueWithSemicolon(name, value);\n                }\n                if (typeof value === \"number\") {\n                    if (isNaN(value)) {\n                        warnStyleValueIsNaN(name);\n                    } else if (!isFinite(value)) {\n                        warnStyleValueIsInfinity(name);\n                    }\n                }\n            }\n        }\n        // code copied and modified from escape-html\n        var matchHtmlRegExp = /[\"'&<>]/;\n        /**\n * Escapes special characters and HTML entities in a given html string.\n *\n * @param  {string} string HTML string to escape for later insertion\n * @return {string}\n * @public\n */ function escapeHtml(string) {\n            {\n                checkHtmlStringCoercion(string);\n            }\n            var str = \"\" + string;\n            var match = matchHtmlRegExp.exec(str);\n            if (!match) {\n                return str;\n            }\n            var escape;\n            var html = \"\";\n            var index;\n            var lastIndex = 0;\n            for(index = match.index; index < str.length; index++){\n                switch(str.charCodeAt(index)){\n                    case 34:\n                        // \"\n                        escape = \"&quot;\";\n                        break;\n                    case 38:\n                        // &\n                        escape = \"&amp;\";\n                        break;\n                    case 39:\n                        // '\n                        escape = \"&#x27;\"; // modified from escape-html; used to be '&#39'\n                        break;\n                    case 60:\n                        // <\n                        escape = \"&lt;\";\n                        break;\n                    case 62:\n                        // >\n                        escape = \"&gt;\";\n                        break;\n                    default:\n                        continue;\n                }\n                if (lastIndex !== index) {\n                    html += str.slice(lastIndex, index);\n                }\n                lastIndex = index + 1;\n                html += escape;\n            }\n            return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\n        } // end code copied and modified from escape-html\n        /**\n * Escapes text to prevent scripting attacks.\n *\n * @param {*} text Text value to escape.\n * @return {string} An escaped string.\n */ function escapeTextForBrowser(text) {\n            if (typeof text === \"boolean\" || typeof text === \"number\") {\n                // this shortcircuit helps perf for types that we know will never have\n                // special characters, especially given that this function is used often\n                // for numeric dom ids.\n                return \"\" + text;\n            }\n            return escapeHtml(text);\n        }\n        var uppercasePattern = /([A-Z])/g;\n        var msPattern = /^ms-/;\n        /**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n */ function hyphenateStyleName(name) {\n            return name.replace(uppercasePattern, \"-$1\").toLowerCase().replace(msPattern, \"-ms-\");\n        }\n        // and any newline or tab are filtered out as if they're not part of the URL.\n        // https://url.spec.whatwg.org/#url-parsing\n        // Tab or newline are defined as \\r\\n\\t:\n        // https://infra.spec.whatwg.org/#ascii-tab-or-newline\n        // A C0 control is a code point in the range \\u0000 NULL to \\u001F\n        // INFORMATION SEPARATOR ONE, inclusive:\n        // https://infra.spec.whatwg.org/#c0-control-or-space\n        /* eslint-disable max-len */ var isJavaScriptProtocol = /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*\\:/i;\n        var didWarn = false;\n        function sanitizeURL(url) {\n            // We should never have symbols here because they get filtered out elsewhere.\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            var stringifiedURL = \"\" + url;\n            {\n                if (!didWarn && isJavaScriptProtocol.test(stringifiedURL)) {\n                    didWarn = true;\n                    error(\"A future version of React will block javascript: URLs as a security precaution. \" + \"Use event handlers instead if you can. If you need to generate unsafe HTML try \" + \"using dangerouslySetInnerHTML instead. React was passed %s.\", JSON.stringify(stringifiedURL));\n                }\n            }\n            return url;\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        // The build script is at scripts/rollup/generate-inline-fizz-runtime.js.\n        // Run `yarn generate-inline-fizz-runtime` to generate.\n        var clientRenderBoundary = '$RX=function(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data=\"$!\",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};';\n        var completeBoundary = '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data=\"$!\",a.setAttribute(\"data-dgst\",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if(\"/$\"===d)if(0===f)break;else f--;else\"$\"!==d&&\"$?\"!==d&&\"$!\"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data=\"$\"}b._reactRetry&&b._reactRetry()}};';\n        var completeBoundaryWithStyles = '$RM=new Map;\\n$RR=function(r,t,w){for(var u=$RC,n=$RM,p=new Map,q=document,g,b,h=q.querySelectorAll(\"link[data-precedence],style[data-precedence]\"),v=[],k=0;b=h[k++];)\"not all\"===b.getAttribute(\"media\")?v.push(b):(\"LINK\"===b.tagName&&n.set(b.getAttribute(\"href\"),b),p.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var f=w[b++];if(!f){k=!1;b=0;continue}var c=!1,m=0;var d=f[m++];if(a=n.get(d)){var e=a._p;c=!0}else{a=q.createElement(\"link\");a.href=d;a.rel=\"stylesheet\";for(a.dataset.precedence=\\nl=f[m++];e=f[m++];)a.setAttribute(e,f[m++]);e=a._p=new Promise(function(x,y){a.onload=x;a.onerror=y});n.set(d,a)}d=a.getAttribute(\"media\");!e||\"l\"===e.s||d&&!matchMedia(d).matches||h.push(e);if(c)continue}else{a=v[b++];if(!a)break;l=a.getAttribute(\"data-precedence\");a.removeAttribute(\"media\")}c=p.get(l)||g;c===g&&(g=a);p.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=q.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(u.bind(null,r,t,\"\"),u.bind(null,r,t,\"Resource failed to load\"))};';\n        var completeSegment = \"$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};\";\n        var formReplaying = 'addEventListener(\"submit\",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute(\"formAction\");null!=f&&(e=f,b=null)}\"javascript:throw new Error(\\'A React form was unexpectedly submitted.\\')\"===e&&(a.preventDefault(),b?(a=document.createElement(\"input\"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.getRootNode(),(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,\\nd,b))}});';\n        function getValueDescriptorExpectingObjectForWarning(thing) {\n            return thing === null ? \"`null`\" : thing === undefined ? \"`undefined`\" : thing === \"\" ? \"an empty string\" : 'something with type \"' + typeof thing + '\"';\n        }\n        function getValueDescriptorExpectingEnumForWarning(thing) {\n            return thing === null ? \"`null`\" : thing === undefined ? \"`undefined`\" : thing === \"\" ? \"an empty string\" : typeof thing === \"string\" ? JSON.stringify(thing) : 'something with type \"' + typeof thing + '\"';\n        }\n        function compareResourcePropsForWarning(newProps, currentProps) {\n            {\n                var propDiffs = null;\n                var allProps = Array.from(new Set(Object.keys(currentProps).concat(Object.keys(newProps))));\n                for(var i = 0; i < allProps.length; i++){\n                    var propName = allProps[i];\n                    var newValue = newProps[propName];\n                    var currentValue = currentProps[propName];\n                    if (newValue !== currentValue && !(newValue == null && currentValue == null)) {\n                        if (newValue == null) {\n                            if (propDiffs === null) {\n                                propDiffs = {\n                                    missing: {},\n                                    extra: {},\n                                    different: {}\n                                };\n                            }\n                            propDiffs.missing[propName] = currentValue;\n                        } else if (currentValue == null) {\n                            if (propDiffs === null) {\n                                propDiffs = {\n                                    missing: {},\n                                    extra: {},\n                                    different: {}\n                                };\n                            }\n                            propDiffs.extra[propName] = newValue;\n                        } else {\n                            if (propDiffs === null) {\n                                propDiffs = {\n                                    missing: {},\n                                    extra: {},\n                                    different: {}\n                                };\n                            }\n                            propDiffs.different[propName] = {\n                                original: currentValue,\n                                latest: newValue\n                            };\n                        }\n                    }\n                }\n                return propDiffs;\n            }\n        }\n        function describeDifferencesForStylesheets(newProps, currentProps) {\n            var diff = compareResourcePropsForWarning(newProps, currentProps);\n            if (!diff) return \"\";\n            var description = \"\";\n            for(var propName in diff.missing){\n                var propValue = diff.missing[propName];\n                if (propName === \"media\") {\n                    description += '\\n  \"' + propName + '\" missing for props, original value: ' + getValueDescriptorExpectingEnumForWarning(propValue);\n                }\n            }\n            for(var _propName in diff.extra){\n                var _propValue = diff.extra[_propName];\n                description += '\\n  \"' + _propName + '\" prop value: ' + getValueDescriptorExpectingEnumForWarning(_propValue) + \", missing from original props\";\n            }\n            for(var _propName2 in diff.different){\n                var latestValue = diff.different[_propName2].latest;\n                var originalValue = diff.different[_propName2].original;\n                description += '\\n  \"' + _propName2 + '\" prop value: ' + getValueDescriptorExpectingEnumForWarning(latestValue) + \", original value: \" + getValueDescriptorExpectingEnumForWarning(originalValue);\n            }\n            return description;\n        }\n        function describeDifferencesForStylesheetOverPreinit(newProps, currentProps) {\n            var diff = compareResourcePropsForWarning(newProps, currentProps);\n            if (!diff) return \"\";\n            var description = \"\";\n            for(var propName in diff.extra){\n                var propValue = diff.extra[propName];\n                if (propName === \"precedence\" || propName === \"crossOrigin\" || propName === \"integrity\") {\n                    description += '\\n  \"' + propName + '\" prop value: ' + getValueDescriptorExpectingEnumForWarning(propValue) + \", option missing\";\n                } else {\n                    description += '\\n  \"' + propName + '\" prop value: ' + getValueDescriptorExpectingEnumForWarning(propValue) + \", option not available with ReactDOM.preinit()\";\n                }\n            }\n            for(var _propName3 in diff.different){\n                var latestValue = diff.different[_propName3].latest;\n                var originalValue = diff.different[_propName3].original;\n                if (_propName3 === \"precedence\" && originalValue === \"default\") {\n                    description += '\\n  \"' + _propName3 + '\" prop value: ' + getValueDescriptorExpectingEnumForWarning(latestValue) + \", missing from options\";\n                } else {\n                    description += '\\n  \"' + _propName3 + '\" prop value: ' + getValueDescriptorExpectingEnumForWarning(latestValue) + \", option value: \" + getValueDescriptorExpectingEnumForWarning(originalValue);\n                }\n            }\n            return description;\n        }\n        function describeDifferencesForPreinitOverStylesheet(newProps, currentProps) {\n            var diff = compareResourcePropsForWarning(newProps, currentProps);\n            if (!diff) return \"\";\n            var description = \"\";\n            for(var propName in diff.missing){\n                var propValue = diff.missing[propName];\n                if (propName === \"precedence\" && propValue !== \"default\") {\n                    description += '\\n  \"' + propName + '\" missing from options, prop value: ' + getValueDescriptorExpectingEnumForWarning(propValue);\n                }\n            }\n            for(var _propName4 in diff.extra){\n                var _propValue2 = diff.extra[_propName4];\n                if (_propName4 === \"precedence\" || _propName4 === \"crossOrigin\" || _propName4 === \"integrity\") {\n                    description += '\\n  \"' + _propName4 + '\" option value: ' + getValueDescriptorExpectingEnumForWarning(_propValue2) + \", missing from props\";\n                }\n            }\n            for(var _propName5 in diff.different){\n                var latestValue = diff.different[_propName5].latest;\n                var originalValue = diff.different[_propName5].original;\n                description += '\\n  \"' + _propName5 + '\" option value: ' + getValueDescriptorExpectingEnumForWarning(latestValue) + \", prop value: \" + getValueDescriptorExpectingEnumForWarning(originalValue);\n            }\n            return description;\n        }\n        function describeDifferencesForPreinits(newProps, currentProps) {\n            var diff = compareResourcePropsForWarning(newProps, currentProps);\n            if (!diff) return \"\";\n            var description = \"\";\n            for(var propName in diff.missing){\n                var propValue = diff.missing[propName];\n                if (propName === \"precedence\" && propValue !== \"default\") {\n                    description += '\\n  \"' + propName + '\" missing from options, original option value: ' + getValueDescriptorExpectingEnumForWarning(propValue);\n                }\n            }\n            for(var _propName6 in diff.extra){\n                var _propValue3 = diff.extra[_propName6];\n                if (_propName6 === \"precedence\" && _propValue3 !== \"default\" || _propName6 === \"crossOrigin\" || _propName6 === \"integrity\") {\n                    description += '\\n  \"' + _propName6 + '\" option value: ' + getValueDescriptorExpectingEnumForWarning(_propValue3) + \", missing from original options\";\n                }\n            }\n            for(var _propName7 in diff.different){\n                var latestValue = diff.different[_propName7].latest;\n                var originalValue = diff.different[_propName7].original;\n                description += '\\n  \"' + _propName7 + '\" option value: ' + getValueDescriptorExpectingEnumForWarning(latestValue) + \", original option value: \" + getValueDescriptorExpectingEnumForWarning(originalValue);\n            }\n            return description;\n        }\n        var preloadOptionsForComparison = [\n            \"as\",\n            \"crossOrigin\",\n            \"integrity\",\n            \"media\"\n        ];\n        function describeDifferencesForPreloads(newProps, currentProps) {\n            var diff = compareResourcePropsForWarning(newProps, currentProps);\n            if (!diff) return \"\";\n            var description = \"\";\n            for(var propName in diff.missing){\n                var propValue = diff.missing[propName];\n                if (preloadOptionsForComparison.includes(propName)) {\n                    description += '\\n  \"' + propName + '\" missing from options, original option value: ' + getValueDescriptorExpectingEnumForWarning(propValue);\n                }\n            }\n            for(var _propName8 in diff.extra){\n                var _propValue4 = diff.extra[_propName8];\n                if (preloadOptionsForComparison.includes(_propName8)) {\n                    description += '\\n  \"' + _propName8 + '\" option value: ' + getValueDescriptorExpectingEnumForWarning(_propValue4) + \", missing from original options\";\n                }\n            }\n            for(var _propName9 in diff.different){\n                var latestValue = diff.different[_propName9].latest;\n                var originalValue = diff.different[_propName9].original;\n                if (preloadOptionsForComparison.includes(_propName9)) {\n                    description += '\\n  \"' + _propName9 + '\" option value: ' + getValueDescriptorExpectingEnumForWarning(latestValue) + \", original option value: \" + getValueDescriptorExpectingEnumForWarning(originalValue);\n                }\n            }\n            return description;\n        }\n        function describeDifferencesForPreloadOverImplicitPreload(newProps, currentProps) {\n            var diff = compareResourcePropsForWarning(newProps, currentProps);\n            if (!diff) return \"\";\n            var description = \"\";\n            for(var propName in diff.missing){\n                var propValue = diff.missing[propName];\n                if (preloadOptionsForComparison.includes(propName)) {\n                    description += '\\n  \"' + propName + '\" missing from options, underlying prop value: ' + getValueDescriptorExpectingEnumForWarning(propValue);\n                }\n            }\n            for(var _propName10 in diff.extra){\n                var _propValue5 = diff.extra[_propName10];\n                if (preloadOptionsForComparison.includes(_propName10)) {\n                    description += '\\n  \"' + _propName10 + '\" option value: ' + getValueDescriptorExpectingEnumForWarning(_propValue5) + \", missing from underlying props\";\n                }\n            }\n            for(var _propName11 in diff.different){\n                var latestValue = diff.different[_propName11].latest;\n                var originalValue = diff.different[_propName11].original;\n                if (preloadOptionsForComparison.includes(_propName11)) {\n                    description += '\\n  \"' + _propName11 + '\" option value: ' + getValueDescriptorExpectingEnumForWarning(latestValue) + \", underlying prop value: \" + getValueDescriptorExpectingEnumForWarning(originalValue);\n                }\n            }\n            return description;\n        }\n        function describeDifferencesForScripts(newProps, currentProps) {\n            var diff = compareResourcePropsForWarning(newProps, currentProps);\n            if (!diff) return \"\";\n            var description = \"\";\n            for(var propName in diff.missing){\n                var propValue = diff.missing[propName];\n                description += '\\n  \"' + propName + '\" missing for props, original value: ' + getValueDescriptorExpectingEnumForWarning(propValue);\n            }\n            for(var _propName12 in diff.extra){\n                var _propValue6 = diff.extra[_propName12];\n                description += '\\n  \"' + _propName12 + '\" prop value: ' + getValueDescriptorExpectingEnumForWarning(_propValue6) + \", missing from original props\";\n            }\n            for(var _propName13 in diff.different){\n                var latestValue = diff.different[_propName13].latest;\n                var originalValue = diff.different[_propName13].original;\n                description += '\\n  \"' + _propName13 + '\" prop value: ' + getValueDescriptorExpectingEnumForWarning(latestValue) + \", original value: \" + getValueDescriptorExpectingEnumForWarning(originalValue);\n            }\n            return description;\n        }\n        function describeDifferencesForScriptOverPreinit(newProps, currentProps) {\n            var diff = compareResourcePropsForWarning(newProps, currentProps);\n            if (!diff) return \"\";\n            var description = \"\";\n            for(var propName in diff.extra){\n                var propValue = diff.extra[propName];\n                if (propName === \"crossOrigin\" || propName === \"integrity\") {\n                    description += '\\n  \"' + propName + '\" prop value: ' + getValueDescriptorExpectingEnumForWarning(propValue) + \", option missing\";\n                } else {\n                    description += '\\n  \"' + propName + '\" prop value: ' + getValueDescriptorExpectingEnumForWarning(propValue) + \", option not available with ReactDOM.preinit()\";\n                }\n            }\n            for(var _propName14 in diff.different){\n                var latestValue = diff.different[_propName14].latest;\n                var originalValue = diff.different[_propName14].original;\n                description += '\\n  \"' + _propName14 + '\" prop value: ' + getValueDescriptorExpectingEnumForWarning(latestValue) + \", option value: \" + getValueDescriptorExpectingEnumForWarning(originalValue);\n            }\n            return description;\n        }\n        function describeDifferencesForPreinitOverScript(newProps, currentProps) {\n            var diff = compareResourcePropsForWarning(newProps, currentProps);\n            if (!diff) return \"\";\n            var description = \"\";\n            for(var propName in diff.extra){\n                var propValue = diff.extra[propName];\n                if (propName === \"crossOrigin\" || propName === \"integrity\") {\n                    description += '\\n  \"' + propName + '\" option value: ' + getValueDescriptorExpectingEnumForWarning(propValue) + \", missing from props\";\n                }\n            }\n            for(var _propName15 in diff.different){\n                var latestValue = diff.different[_propName15].latest;\n                var originalValue = diff.different[_propName15].original;\n                description += '\\n  \"' + _propName15 + '\" option value: ' + getValueDescriptorExpectingEnumForWarning(latestValue) + \", prop value: \" + getValueDescriptorExpectingEnumForWarning(originalValue);\n            }\n            return description;\n        }\n        var ReactDOMSharedInternals = ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        var ReactDOMCurrentDispatcher = ReactDOMSharedInternals.Dispatcher;\n        var ReactDOMServerDispatcher = {\n            prefetchDNS: prefetchDNS,\n            preconnect: preconnect,\n            preload: preload,\n            preinit: preinit\n        };\n        function prepareHostDispatcher() {\n            ReactDOMCurrentDispatcher.current = ReactDOMServerDispatcher;\n        } // Used to distinguish these contexts from ones used in other renderers.\n        var ScriptStreamingFormat = 0;\n        var DataStreamingFormat = 1;\n        var NothingSent = 0;\n        var SentCompleteSegmentFunction = 1;\n        var SentCompleteBoundaryFunction = 2;\n        var SentClientRenderFunction = 4;\n        var SentStyleInsertionFunction = 8;\n        var dataElementQuotedEnd = stringToPrecomputedChunk('\"></template>');\n        var startInlineScript = stringToPrecomputedChunk(\"<script>\");\n        var endInlineScript = stringToPrecomputedChunk(\"</script>\");\n        var startScriptSrc = stringToPrecomputedChunk('<script src=\"');\n        var startModuleSrc = stringToPrecomputedChunk('<script type=\"module\" src=\"');\n        var scriptNonce = stringToPrecomputedChunk('\" nonce=\"');\n        var scriptIntegirty = stringToPrecomputedChunk('\" integrity=\"');\n        var scriptCrossOrigin = stringToPrecomputedChunk('\" crossorigin=\"');\n        var endAsyncScript = stringToPrecomputedChunk('\" async=\"\"></script>');\n        /**\n * This escaping function is designed to work with bootstrapScriptContent only.\n * because we know we are escaping the entire script. We can avoid for instance\n * escaping html comment string sequences that are valid javascript as well because\n * if there are no sebsequent <script sequences the html parser will never enter\n * script data double escaped state (see: https://www.w3.org/TR/html53/syntax.html#script-data-double-escaped-state)\n *\n * While untrusted script content should be made safe before using this api it will\n * ensure that the script cannot be early terminated or never terminated state\n */ function escapeBootstrapScriptContent(scriptText) {\n            {\n                checkHtmlStringCoercion(scriptText);\n            }\n            return (\"\" + scriptText).replace(scriptRegex, scriptReplacer);\n        }\n        var scriptRegex = /(<\\/|<)(s)(cript)/gi;\n        var scriptReplacer = function(match, prefix, s, suffix) {\n            return \"\" + prefix + (s === \"s\" ? \"\\\\u0073\" : \"\\\\u0053\") + suffix;\n        }; // Allows us to keep track of what we've already written so we can refer back to it.\n        // if passed externalRuntimeConfig and the enableFizzExternalRuntime feature flag\n        // is set, the server will send instructions via data attributes (instead of inline scripts)\n        function createResponseState(resources, identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules, externalRuntimeConfig) {\n            var idPrefix = identifierPrefix === undefined ? \"\" : identifierPrefix;\n            var inlineScriptWithNonce = nonce === undefined ? startInlineScript : stringToPrecomputedChunk('<script nonce=\"' + escapeTextForBrowser(nonce) + '\">');\n            var bootstrapChunks = [];\n            var externalRuntimeScript = null;\n            var streamingFormat = ScriptStreamingFormat;\n            if (bootstrapScriptContent !== undefined) {\n                bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapScriptContent(bootstrapScriptContent)), endInlineScript);\n            }\n            {\n                if (externalRuntimeConfig !== undefined) {\n                    streamingFormat = DataStreamingFormat;\n                    if (typeof externalRuntimeConfig === \"string\") {\n                        externalRuntimeScript = {\n                            src: externalRuntimeConfig,\n                            chunks: []\n                        };\n                        pushScriptImpl(externalRuntimeScript.chunks, {\n                            src: externalRuntimeConfig,\n                            async: true,\n                            integrity: undefined,\n                            nonce: nonce\n                        });\n                    } else {\n                        externalRuntimeScript = {\n                            src: externalRuntimeConfig.src,\n                            chunks: []\n                        };\n                        pushScriptImpl(externalRuntimeScript.chunks, {\n                            src: externalRuntimeConfig.src,\n                            async: true,\n                            integrity: externalRuntimeConfig.integrity,\n                            nonce: nonce\n                        });\n                    }\n                }\n            }\n            if (bootstrapScripts !== undefined) {\n                for(var i = 0; i < bootstrapScripts.length; i++){\n                    var scriptConfig = bootstrapScripts[i];\n                    var src = typeof scriptConfig === \"string\" ? scriptConfig : scriptConfig.src;\n                    var integrity = typeof scriptConfig === \"string\" ? undefined : scriptConfig.integrity;\n                    var crossOrigin = typeof scriptConfig === \"string\" || scriptConfig.crossOrigin == null ? undefined : scriptConfig.crossOrigin === \"use-credentials\" ? \"use-credentials\" : \"\";\n                    preloadBootstrapScript(resources, src, nonce, integrity, crossOrigin);\n                    bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(src)));\n                    if (nonce) {\n                        bootstrapChunks.push(scriptNonce, stringToChunk(escapeTextForBrowser(nonce)));\n                    }\n                    if (integrity) {\n                        bootstrapChunks.push(scriptIntegirty, stringToChunk(escapeTextForBrowser(integrity)));\n                    }\n                    if (typeof crossOrigin === \"string\") {\n                        bootstrapChunks.push(scriptCrossOrigin, stringToChunk(escapeTextForBrowser(crossOrigin)));\n                    }\n                    bootstrapChunks.push(endAsyncScript);\n                }\n            }\n            if (bootstrapModules !== undefined) {\n                for(var _i = 0; _i < bootstrapModules.length; _i++){\n                    var _scriptConfig = bootstrapModules[_i];\n                    var _src = typeof _scriptConfig === \"string\" ? _scriptConfig : _scriptConfig.src;\n                    var _integrity = typeof _scriptConfig === \"string\" ? undefined : _scriptConfig.integrity;\n                    var _crossOrigin = typeof _scriptConfig === \"string\" || _scriptConfig.crossOrigin == null ? undefined : _scriptConfig.crossOrigin === \"use-credentials\" ? \"use-credentials\" : \"\";\n                    preloadBootstrapModule(resources, _src, nonce, _integrity, _crossOrigin);\n                    bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(_src)));\n                    if (nonce) {\n                        bootstrapChunks.push(scriptNonce, stringToChunk(escapeTextForBrowser(nonce)));\n                    }\n                    if (_integrity) {\n                        bootstrapChunks.push(scriptIntegirty, stringToChunk(escapeTextForBrowser(_integrity)));\n                    }\n                    if (typeof _crossOrigin === \"string\") {\n                        bootstrapChunks.push(scriptCrossOrigin, stringToChunk(escapeTextForBrowser(_crossOrigin)));\n                    }\n                    bootstrapChunks.push(endAsyncScript);\n                }\n            }\n            return {\n                bootstrapChunks: bootstrapChunks,\n                placeholderPrefix: stringToPrecomputedChunk(idPrefix + \"P:\"),\n                segmentPrefix: stringToPrecomputedChunk(idPrefix + \"S:\"),\n                boundaryPrefix: idPrefix + \"B:\",\n                idPrefix: idPrefix,\n                nextSuspenseID: 0,\n                streamingFormat: streamingFormat,\n                startInlineScript: inlineScriptWithNonce,\n                instructions: NothingSent,\n                externalRuntimeScript: externalRuntimeScript,\n                htmlChunks: null,\n                headChunks: null,\n                hasBody: false,\n                charsetChunks: [],\n                preconnectChunks: [],\n                preloadChunks: [],\n                hoistableChunks: [],\n                stylesToHoist: false,\n                nonce: nonce\n            };\n        } // Constants for the insertion mode we're currently writing in. We don't encode all HTML5 insertion\n        // modes. We only include the variants as they matter for the sake of our purposes.\n        // We don't actually provide the namespace therefore we use constants instead of the string.\n        var ROOT_HTML_MODE = 0; // Used for the root most element tag.\n        // We have a less than HTML_HTML_MODE check elsewhere. If you add more cases here, make sure it\n        // still makes sense\n        var HTML_HTML_MODE = 1; // Used for the <html> if it is at the top level.\n        var HTML_MODE = 2;\n        var SVG_MODE = 3;\n        var MATHML_MODE = 4;\n        var HTML_TABLE_MODE = 5;\n        var HTML_TABLE_BODY_MODE = 6;\n        var HTML_TABLE_ROW_MODE = 7;\n        var HTML_COLGROUP_MODE = 8; // We have a greater than HTML_TABLE_MODE check elsewhere. If you add more cases here, make sure it\n        // still makes sense\n        // Lets us keep track of contextual state and pick it back up after suspending.\n        function createFormatContext(insertionMode, selectedValue, noscriptTagInScope) {\n            return {\n                insertionMode: insertionMode,\n                selectedValue: selectedValue,\n                noscriptTagInScope: noscriptTagInScope\n            };\n        }\n        function createRootFormatContext(namespaceURI) {\n            var insertionMode = namespaceURI === \"http://www.w3.org/2000/svg\" ? SVG_MODE : namespaceURI === \"http://www.w3.org/1998/Math/MathML\" ? MATHML_MODE : ROOT_HTML_MODE;\n            return createFormatContext(insertionMode, null, false);\n        }\n        function getChildFormatContext(parentContext, type, props) {\n            switch(type){\n                case \"noscript\":\n                    return createFormatContext(HTML_MODE, null, true);\n                case \"select\":\n                    return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue, parentContext.noscriptTagInScope);\n                case \"svg\":\n                    return createFormatContext(SVG_MODE, null, parentContext.noscriptTagInScope);\n                case \"math\":\n                    return createFormatContext(MATHML_MODE, null, parentContext.noscriptTagInScope);\n                case \"foreignObject\":\n                    return createFormatContext(HTML_MODE, null, parentContext.noscriptTagInScope);\n                // Table parents are special in that their children can only be created at all if they're\n                // wrapped in a table parent. So we need to encode that we're entering this mode.\n                case \"table\":\n                    return createFormatContext(HTML_TABLE_MODE, null, parentContext.noscriptTagInScope);\n                case \"thead\":\n                case \"tbody\":\n                case \"tfoot\":\n                    return createFormatContext(HTML_TABLE_BODY_MODE, null, parentContext.noscriptTagInScope);\n                case \"colgroup\":\n                    return createFormatContext(HTML_COLGROUP_MODE, null, parentContext.noscriptTagInScope);\n                case \"tr\":\n                    return createFormatContext(HTML_TABLE_ROW_MODE, null, parentContext.noscriptTagInScope);\n            }\n            if (parentContext.insertionMode >= HTML_TABLE_MODE) {\n                // Whatever tag this was, it wasn't a table parent or other special parent, so we must have\n                // entered plain HTML again.\n                return createFormatContext(HTML_MODE, null, parentContext.noscriptTagInScope);\n            }\n            if (parentContext.insertionMode === ROOT_HTML_MODE) {\n                if (type === \"html\") {\n                    // We've emitted the root and is now in <html> mode.\n                    return createFormatContext(HTML_HTML_MODE, null, false);\n                } else {\n                    // We've emitted the root and is now in plain HTML mode.\n                    return createFormatContext(HTML_MODE, null, false);\n                }\n            } else if (parentContext.insertionMode === HTML_HTML_MODE) {\n                // We've emitted the document element and is now in plain HTML mode.\n                return createFormatContext(HTML_MODE, null, false);\n            }\n            return parentContext;\n        }\n        var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;\n        function assignSuspenseBoundaryID(responseState) {\n            var generatedID = responseState.nextSuspenseID++;\n            return stringToPrecomputedChunk(responseState.boundaryPrefix + generatedID.toString(16));\n        }\n        function makeId(responseState, treeId, localId) {\n            var idPrefix = responseState.idPrefix;\n            var id = \":\" + idPrefix + \"R\" + treeId; // Unless this is the first id at this level, append a number at the end\n            // that represents the position of this useId hook among all the useId\n            // hooks for this fiber.\n            if (localId > 0) {\n                id += \"H\" + localId.toString(32);\n            }\n            return id + \":\";\n        }\n        function encodeHTMLTextNode(text) {\n            return escapeTextForBrowser(text);\n        }\n        var textSeparator = stringToPrecomputedChunk(\"<!-- -->\");\n        function pushTextInstance(target, text, responseState, textEmbedded) {\n            if (text === \"\") {\n                // Empty text doesn't have a DOM node representation and the hydration is aware of this.\n                return textEmbedded;\n            }\n            if (textEmbedded) {\n                target.push(textSeparator);\n            }\n            target.push(stringToChunk(encodeHTMLTextNode(text)));\n            return true;\n        } // Called when Fizz is done with a Segment. Currently the only purpose is to conditionally\n        // emit a text separator when we don't know for sure it is safe to omit\n        function pushSegmentFinale(target, responseState, lastPushedText, textEmbedded) {\n            if (lastPushedText && textEmbedded) {\n                target.push(textSeparator);\n            }\n        }\n        var styleNameCache = new Map();\n        function processStyleName(styleName) {\n            var chunk = styleNameCache.get(styleName);\n            if (chunk !== undefined) {\n                return chunk;\n            }\n            var result = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));\n            styleNameCache.set(styleName, result);\n            return result;\n        }\n        var styleAttributeStart = stringToPrecomputedChunk(' style=\"');\n        var styleAssign = stringToPrecomputedChunk(\":\");\n        var styleSeparator = stringToPrecomputedChunk(\";\");\n        function pushStyleAttribute(target, style) {\n            if (typeof style !== \"object\") {\n                throw new Error(\"The `style` prop expects a mapping from style properties to values, \" + \"not a string. For example, style={{marginRight: spacing + 'em'}} when \" + \"using JSX.\");\n            }\n            var isFirst = true;\n            for(var styleName in style){\n                if (!hasOwnProperty.call(style, styleName)) {\n                    continue;\n                } // If you provide unsafe user data here they can inject arbitrary CSS\n                // which may be problematic (I couldn't repro this):\n                // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n                // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n                // This is not an XSS hole but instead a potential CSS injection issue\n                // which has lead to a greater discussion about how we're going to\n                // trust URLs moving forward. See #2115901\n                var styleValue = style[styleName];\n                if (styleValue == null || typeof styleValue === \"boolean\" || styleValue === \"\") {\n                    continue;\n                }\n                var nameChunk = void 0;\n                var valueChunk = void 0;\n                var isCustomProperty = styleName.indexOf(\"--\") === 0;\n                if (isCustomProperty) {\n                    nameChunk = stringToChunk(escapeTextForBrowser(styleName));\n                    {\n                        checkCSSPropertyStringCoercion(styleValue, styleName);\n                    }\n                    valueChunk = stringToChunk(escapeTextForBrowser((\"\" + styleValue).trim()));\n                } else {\n                    {\n                        warnValidStyle(styleName, styleValue);\n                    }\n                    nameChunk = processStyleName(styleName);\n                    if (typeof styleValue === \"number\") {\n                        if (styleValue !== 0 && !isUnitlessNumber(styleName)) {\n                            valueChunk = stringToChunk(styleValue + \"px\"); // Presumes implicit 'px' suffix for unitless numbers\n                        } else {\n                            valueChunk = stringToChunk(\"\" + styleValue);\n                        }\n                    } else {\n                        {\n                            checkCSSPropertyStringCoercion(styleValue, styleName);\n                        }\n                        valueChunk = stringToChunk(escapeTextForBrowser((\"\" + styleValue).trim()));\n                    }\n                }\n                if (isFirst) {\n                    isFirst = false; // If it's first, we don't need any separators prefixed.\n                    target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);\n                } else {\n                    target.push(styleSeparator, nameChunk, styleAssign, valueChunk);\n                }\n            }\n            if (!isFirst) {\n                target.push(attributeEnd);\n            }\n        }\n        var attributeSeparator = stringToPrecomputedChunk(\" \");\n        var attributeAssign = stringToPrecomputedChunk('=\"');\n        var attributeEnd = stringToPrecomputedChunk('\"');\n        var attributeEmptyString = stringToPrecomputedChunk('=\"\"');\n        function pushBooleanAttribute(target, name, value) {\n            if (value && typeof value !== \"function\" && typeof value !== \"symbol\") {\n                target.push(attributeSeparator, stringToChunk(name), attributeEmptyString);\n            }\n        }\n        function pushStringAttribute(target, name, value) {\n            if (typeof value !== \"function\" && typeof value !== \"symbol\" && typeof value !== \"boolean\") {\n                target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n            }\n        }\n        // than on the client and hopefully it's googleable.\n        stringToPrecomputedChunk(escapeTextForBrowser(\"javascript:throw new Error('A React form was unexpectedly submitted.')\"));\n        var startHiddenInputChunk = stringToPrecomputedChunk('<input type=\"hidden\"');\n        function pushAdditionalFormField(value, key) {\n            var target = this;\n            target.push(startHiddenInputChunk);\n            if (typeof value !== \"string\") {\n                throw new Error(\"File/Blob fields are not yet supported in progressive forms. \" + \"It probably means you are closing over binary data or FormData in a Server Action.\");\n            }\n            pushStringAttribute(target, \"name\", key);\n            pushStringAttribute(target, \"value\", value);\n            target.push(endOfStartTagSelfClosing);\n        }\n        function pushAdditionalFormFields(target, formData) {\n            if (formData !== null) {\n                // $FlowFixMe[prop-missing]: FormData has forEach.\n                formData.forEach(pushAdditionalFormField, target);\n            }\n        }\n        function pushFormActionAttribute(target, responseState, formAction, formEncType, formMethod, formTarget, name) {\n            var formData = null;\n            if (name != null) {\n                pushAttribute(target, \"name\", name);\n            }\n            if (formAction != null) {\n                pushAttribute(target, \"formAction\", formAction);\n            }\n            if (formEncType != null) {\n                pushAttribute(target, \"formEncType\", formEncType);\n            }\n            if (formMethod != null) {\n                pushAttribute(target, \"formMethod\", formMethod);\n            }\n            if (formTarget != null) {\n                pushAttribute(target, \"formTarget\", formTarget);\n            }\n            return formData;\n        }\n        function pushAttribute(target, name, value) {\n            switch(name){\n                // These are very common props and therefore are in the beginning of the switch.\n                // TODO: aria-label is a very common prop but allows booleans so is not like the others\n                // but should ideally go in this list too.\n                case \"className\":\n                    {\n                        pushStringAttribute(target, \"class\", value);\n                        break;\n                    }\n                case \"tabIndex\":\n                    {\n                        pushStringAttribute(target, \"tabindex\", value);\n                        break;\n                    }\n                case \"dir\":\n                case \"role\":\n                case \"viewBox\":\n                case \"width\":\n                case \"height\":\n                    {\n                        pushStringAttribute(target, name, value);\n                        break;\n                    }\n                case \"style\":\n                    {\n                        pushStyleAttribute(target, value);\n                        return;\n                    }\n                case \"src\":\n                case \"href\":\n                // Fall through to the last case which shouldn't remove empty strings.\n                case \"action\":\n                case \"formAction\":\n                    {\n                        // TODO: Consider only special casing these for each tag.\n                        if (value == null || typeof value === \"function\" || typeof value === \"symbol\" || typeof value === \"boolean\") {\n                            return;\n                        }\n                        {\n                            checkAttributeStringCoercion(value, name);\n                        }\n                        var sanitizedValue = sanitizeURL(\"\" + value);\n                        target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(sanitizedValue)), attributeEnd);\n                        return;\n                    }\n                case \"defaultValue\":\n                case \"defaultChecked\":\n                case \"innerHTML\":\n                case \"suppressContentEditableWarning\":\n                case \"suppressHydrationWarning\":\n                    // Ignored. These are built-in to React on the client.\n                    return;\n                case \"autoFocus\":\n                case \"multiple\":\n                case \"muted\":\n                    {\n                        pushBooleanAttribute(target, name.toLowerCase(), value);\n                        return;\n                    }\n                case \"xlinkHref\":\n                    {\n                        if (typeof value === \"function\" || typeof value === \"symbol\" || typeof value === \"boolean\") {\n                            return;\n                        }\n                        {\n                            checkAttributeStringCoercion(value, name);\n                        }\n                        var _sanitizedValue = sanitizeURL(\"\" + value);\n                        target.push(attributeSeparator, stringToChunk(\"xlink:href\"), attributeAssign, stringToChunk(escapeTextForBrowser(_sanitizedValue)), attributeEnd);\n                        return;\n                    }\n                case \"contentEditable\":\n                case \"spellCheck\":\n                case \"draggable\":\n                case \"value\":\n                case \"autoReverse\":\n                case \"externalResourcesRequired\":\n                case \"focusable\":\n                case \"preserveAlpha\":\n                    {\n                        // Booleanish String\n                        // These are \"enumerated\" attributes that accept \"true\" and \"false\".\n                        // In React, we let users pass `true` and `false` even though technically\n                        // these aren't boolean attributes (they are coerced to strings).\n                        if (typeof value !== \"function\" && typeof value !== \"symbol\") {\n                            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                        }\n                        return;\n                    }\n                case \"allowFullScreen\":\n                case \"async\":\n                case \"autoPlay\":\n                case \"controls\":\n                case \"default\":\n                case \"defer\":\n                case \"disabled\":\n                case \"disablePictureInPicture\":\n                case \"disableRemotePlayback\":\n                case \"formNoValidate\":\n                case \"hidden\":\n                case \"loop\":\n                case \"noModule\":\n                case \"noValidate\":\n                case \"open\":\n                case \"playsInline\":\n                case \"readOnly\":\n                case \"required\":\n                case \"reversed\":\n                case \"scoped\":\n                case \"seamless\":\n                case \"itemScope\":\n                    {\n                        // Boolean\n                        if (value && typeof value !== \"function\" && typeof value !== \"symbol\") {\n                            target.push(attributeSeparator, stringToChunk(name), attributeEmptyString);\n                        }\n                        return;\n                    }\n                case \"capture\":\n                case \"download\":\n                    {\n                        // Overloaded Boolean\n                        if (value === true) {\n                            target.push(attributeSeparator, stringToChunk(name), attributeEmptyString);\n                        } else if (value === false) ;\n                        else if (typeof value !== \"function\" && typeof value !== \"symbol\") {\n                            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                        }\n                        return;\n                    }\n                case \"cols\":\n                case \"rows\":\n                case \"size\":\n                case \"span\":\n                    {\n                        // These are HTML attributes that must be positive numbers.\n                        if (typeof value !== \"function\" && typeof value !== \"symbol\" && !isNaN(value) && value >= 1) {\n                            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                        }\n                        return;\n                    }\n                case \"rowSpan\":\n                case \"start\":\n                    {\n                        // These are HTML attributes that must be numbers.\n                        if (typeof value !== \"function\" && typeof value !== \"symbol\" && !isNaN(value)) {\n                            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                        }\n                        return;\n                    }\n                case \"xlinkActuate\":\n                    pushStringAttribute(target, \"xlink:actuate\", value);\n                    return;\n                case \"xlinkArcrole\":\n                    pushStringAttribute(target, \"xlink:arcrole\", value);\n                    return;\n                case \"xlinkRole\":\n                    pushStringAttribute(target, \"xlink:role\", value);\n                    return;\n                case \"xlinkShow\":\n                    pushStringAttribute(target, \"xlink:show\", value);\n                    return;\n                case \"xlinkTitle\":\n                    pushStringAttribute(target, \"xlink:title\", value);\n                    return;\n                case \"xlinkType\":\n                    pushStringAttribute(target, \"xlink:type\", value);\n                    return;\n                case \"xmlBase\":\n                    pushStringAttribute(target, \"xml:base\", value);\n                    return;\n                case \"xmlLang\":\n                    pushStringAttribute(target, \"xml:lang\", value);\n                    return;\n                case \"xmlSpace\":\n                    pushStringAttribute(target, \"xml:space\", value);\n                    return;\n                default:\n                    if (// We have already filtered out null/undefined and reserved words.\n                    name.length > 2 && (name[0] === \"o\" || name[0] === \"O\") && (name[1] === \"n\" || name[1] === \"N\")) {\n                        return;\n                    }\n                    var attributeName = getAttributeAlias(name);\n                    if (isAttributeNameSafe(attributeName)) {\n                        // shouldRemoveAttribute\n                        switch(typeof value){\n                            case \"function\":\n                            case \"symbol\":\n                                // eslint-disable-line\n                                return;\n                            case \"boolean\":\n                                {\n                                    var prefix = attributeName.toLowerCase().slice(0, 5);\n                                    if (prefix !== \"data-\" && prefix !== \"aria-\") {\n                                        return;\n                                    }\n                                }\n                        }\n                        target.push(attributeSeparator, stringToChunk(attributeName), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                    }\n            }\n        }\n        var endOfStartTag = stringToPrecomputedChunk(\">\");\n        var endOfStartTagSelfClosing = stringToPrecomputedChunk(\"/>\");\n        function pushInnerHTML(target, innerHTML, children) {\n            if (innerHTML != null) {\n                if (children != null) {\n                    throw new Error(\"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\");\n                }\n                if (typeof innerHTML !== \"object\" || !(\"__html\" in innerHTML)) {\n                    throw new Error(\"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. \" + \"Please visit https://reactjs.org/link/dangerously-set-inner-html \" + \"for more information.\");\n                }\n                var html = innerHTML.__html;\n                if (html !== null && html !== undefined) {\n                    {\n                        checkHtmlStringCoercion(html);\n                    }\n                    target.push(stringToChunk(\"\" + html));\n                }\n            }\n        } // TODO: Move these to ResponseState so that we warn for every request.\n        // It would help debugging in stateful servers (e.g. service worker).\n        var didWarnDefaultInputValue = false;\n        var didWarnDefaultChecked = false;\n        var didWarnDefaultSelectValue = false;\n        var didWarnDefaultTextareaValue = false;\n        var didWarnInvalidOptionChildren = false;\n        var didWarnInvalidOptionInnerHTML = false;\n        var didWarnSelectedSetOnOption = false;\n        var didWarnFormActionType = false;\n        function checkSelectProp(props, propName) {\n            {\n                var value = props[propName];\n                if (value != null) {\n                    var array = isArray(value);\n                    if (props.multiple && !array) {\n                        error(\"The `%s` prop supplied to <select> must be an array if \" + \"`multiple` is true.\", propName);\n                    } else if (!props.multiple && array) {\n                        error(\"The `%s` prop supplied to <select> must be a scalar \" + \"value if `multiple` is false.\", propName);\n                    }\n                }\n            }\n        }\n        function pushStartSelect(target, props) {\n            {\n                checkControlledValueProps(\"select\", props);\n                checkSelectProp(props, \"value\");\n                checkSelectProp(props, \"defaultValue\");\n                if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultSelectValue) {\n                    error(\"Select elements must be either controlled or uncontrolled \" + \"(specify either the value prop, or the defaultValue prop, but not \" + \"both). Decide between using a controlled or uncontrolled select \" + \"element and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\");\n                    didWarnDefaultSelectValue = true;\n                }\n            }\n            target.push(startChunkForTag(\"select\"));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            // TODO: This doesn't really make sense for select since it can't use the controlled\n                            // value in the innerHTML.\n                            innerHTML = propValue;\n                            break;\n                        case \"defaultValue\":\n                        case \"value\":\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            return children;\n        }\n        function flattenOptionChildren(children) {\n            var content = \"\"; // Flatten children and warn if they aren't strings or numbers;\n            // invalid types are ignored.\n            React.Children.forEach(children, function(child) {\n                if (child == null) {\n                    return;\n                }\n                content += child;\n                {\n                    if (!didWarnInvalidOptionChildren && typeof child !== \"string\" && typeof child !== \"number\") {\n                        didWarnInvalidOptionChildren = true;\n                        error(\"Cannot infer the option value of complex children. \" + \"Pass a `value` prop or use a plain string as children to <option>.\");\n                    }\n                }\n            });\n            return content;\n        }\n        var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=\"\"');\n        function pushStartOption(target, props, formatContext) {\n            var selectedValue = formatContext.selectedValue;\n            target.push(startChunkForTag(\"option\"));\n            var children = null;\n            var value = null;\n            var selected = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"selected\":\n                            // ignore\n                            selected = propValue;\n                            {\n                                // TODO: Remove support for `selected` in <option>.\n                                if (!didWarnSelectedSetOnOption) {\n                                    error(\"Use the `defaultValue` or `value` props on <select> instead of \" + \"setting `selected` on <option>.\");\n                                    didWarnSelectedSetOnOption = true;\n                                }\n                            }\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        case \"value\":\n                            value = propValue;\n                        // We intentionally fallthrough to also set the attribute on the node.\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            if (selectedValue != null) {\n                var stringValue;\n                if (value !== null) {\n                    {\n                        checkAttributeStringCoercion(value, \"value\");\n                    }\n                    stringValue = \"\" + value;\n                } else {\n                    {\n                        if (innerHTML !== null) {\n                            if (!didWarnInvalidOptionInnerHTML) {\n                                didWarnInvalidOptionInnerHTML = true;\n                                error(\"Pass a `value` prop if you set dangerouslyInnerHTML so React knows \" + \"which value should be selected.\");\n                            }\n                        }\n                    }\n                    stringValue = flattenOptionChildren(children);\n                }\n                if (isArray(selectedValue)) {\n                    // multiple\n                    for(var i = 0; i < selectedValue.length; i++){\n                        {\n                            checkAttributeStringCoercion(selectedValue[i], \"value\");\n                        }\n                        var v = \"\" + selectedValue[i];\n                        if (v === stringValue) {\n                            target.push(selectedMarkerAttribute);\n                            break;\n                        }\n                    }\n                } else {\n                    {\n                        checkAttributeStringCoercion(selectedValue, \"select.value\");\n                    }\n                    if (\"\" + selectedValue === stringValue) {\n                        target.push(selectedMarkerAttribute);\n                    }\n                }\n            } else if (selected) {\n                target.push(selectedMarkerAttribute);\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            return children;\n        }\n        stringToPrecomputedChunk(formReplaying);\n        function pushStartForm(target, props, responseState) {\n            target.push(startChunkForTag(\"form\"));\n            var children = null;\n            var innerHTML = null;\n            var formAction = null;\n            var formEncType = null;\n            var formMethod = null;\n            var formTarget = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        case \"action\":\n                            formAction = propValue;\n                            break;\n                        case \"encType\":\n                            formEncType = propValue;\n                            break;\n                        case \"method\":\n                            formMethod = propValue;\n                            break;\n                        case \"target\":\n                            formTarget = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            if (formAction != null) {\n                pushAttribute(target, \"action\", formAction);\n            }\n            if (formEncType != null) {\n                pushAttribute(target, \"encType\", formEncType);\n            }\n            if (formMethod != null) {\n                pushAttribute(target, \"method\", formMethod);\n            }\n            if (formTarget != null) {\n                pushAttribute(target, \"target\", formTarget);\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            if (typeof children === \"string\") {\n                // Special case children as a string to avoid the unnecessary comment.\n                // TODO: Remove this special case after the general optimization is in place.\n                target.push(stringToChunk(encodeHTMLTextNode(children)));\n                return null;\n            }\n            return children;\n        }\n        function pushInput(target, props, responseState) {\n            {\n                checkControlledValueProps(\"input\", props);\n            }\n            target.push(startChunkForTag(\"input\"));\n            var name = null;\n            var formAction = null;\n            var formEncType = null;\n            var formMethod = null;\n            var formTarget = null;\n            var value = null;\n            var defaultValue = null;\n            var checked = null;\n            var defaultChecked = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"input\" + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        case \"name\":\n                            name = propValue;\n                            break;\n                        case \"formAction\":\n                            formAction = propValue;\n                            break;\n                        case \"formEncType\":\n                            formEncType = propValue;\n                            break;\n                        case \"formMethod\":\n                            formMethod = propValue;\n                            break;\n                        case \"formTarget\":\n                            formTarget = propValue;\n                            break;\n                        case \"defaultChecked\":\n                            defaultChecked = propValue;\n                            break;\n                        case \"defaultValue\":\n                            defaultValue = propValue;\n                            break;\n                        case \"checked\":\n                            checked = propValue;\n                            break;\n                        case \"value\":\n                            value = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            {\n                if (formAction !== null && props.type !== \"image\" && props.type !== \"submit\" && !didWarnFormActionType) {\n                    didWarnFormActionType = true;\n                    error('An input can only specify a formAction along with type=\"submit\" or type=\"image\".');\n                }\n            }\n            var formData = pushFormActionAttribute(target, responseState, formAction, formEncType, formMethod, formTarget, name);\n            {\n                if (checked !== null && defaultChecked !== null && !didWarnDefaultChecked) {\n                    error(\"%s contains an input of type %s with both checked and defaultChecked props. \" + \"Input elements must be either controlled or uncontrolled \" + \"(specify either the checked prop, or the defaultChecked prop, but not \" + \"both). Decide between using a controlled or uncontrolled input \" + \"element and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\", \"A component\", props.type);\n                    didWarnDefaultChecked = true;\n                }\n                if (value !== null && defaultValue !== null && !didWarnDefaultInputValue) {\n                    error(\"%s contains an input of type %s with both value and defaultValue props. \" + \"Input elements must be either controlled or uncontrolled \" + \"(specify either the value prop, or the defaultValue prop, but not \" + \"both). Decide between using a controlled or uncontrolled input \" + \"element and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\", \"A component\", props.type);\n                    didWarnDefaultInputValue = true;\n                }\n            }\n            if (checked !== null) {\n                pushBooleanAttribute(target, \"checked\", checked);\n            } else if (defaultChecked !== null) {\n                pushBooleanAttribute(target, \"checked\", defaultChecked);\n            }\n            if (value !== null) {\n                pushAttribute(target, \"value\", value);\n            } else if (defaultValue !== null) {\n                pushAttribute(target, \"value\", defaultValue);\n            }\n            target.push(endOfStartTagSelfClosing); // We place any additional hidden form fields after the input.\n            pushAdditionalFormFields(target, formData);\n            return null;\n        }\n        function pushStartButton(target, props, responseState) {\n            target.push(startChunkForTag(\"button\"));\n            var children = null;\n            var innerHTML = null;\n            var name = null;\n            var formAction = null;\n            var formEncType = null;\n            var formMethod = null;\n            var formTarget = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        case \"name\":\n                            name = propValue;\n                            break;\n                        case \"formAction\":\n                            formAction = propValue;\n                            break;\n                        case \"formEncType\":\n                            formEncType = propValue;\n                            break;\n                        case \"formMethod\":\n                            formMethod = propValue;\n                            break;\n                        case \"formTarget\":\n                            formTarget = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            {\n                if (formAction !== null && props.type != null && props.type !== \"submit\" && !didWarnFormActionType) {\n                    didWarnFormActionType = true;\n                    error('A button can only specify a formAction along with type=\"submit\" or no type.');\n                }\n            }\n            var formData = pushFormActionAttribute(target, responseState, formAction, formEncType, formMethod, formTarget, name);\n            target.push(endOfStartTag); // We place any additional hidden form fields we need to include inside the button itself.\n            pushAdditionalFormFields(target, formData);\n            pushInnerHTML(target, innerHTML, children);\n            if (typeof children === \"string\") {\n                // Special case children as a string to avoid the unnecessary comment.\n                // TODO: Remove this special case after the general optimization is in place.\n                target.push(stringToChunk(encodeHTMLTextNode(children)));\n                return null;\n            }\n            return children;\n        }\n        function pushStartTextArea(target, props) {\n            {\n                checkControlledValueProps(\"textarea\", props);\n                if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultTextareaValue) {\n                    error(\"Textarea elements must be either controlled or uncontrolled \" + \"(specify either the value prop, or the defaultValue prop, but not \" + \"both). Decide between using a controlled or uncontrolled textarea \" + \"and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\");\n                    didWarnDefaultTextareaValue = true;\n                }\n            }\n            target.push(startChunkForTag(\"textarea\"));\n            var value = null;\n            var defaultValue = null;\n            var children = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"value\":\n                            value = propValue;\n                            break;\n                        case \"defaultValue\":\n                            defaultValue = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"`dangerouslySetInnerHTML` does not make sense on <textarea>.\");\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            if (value === null && defaultValue !== null) {\n                value = defaultValue;\n            }\n            target.push(endOfStartTag); // TODO (yungsters): Remove support for children content in <textarea>.\n            if (children != null) {\n                {\n                    error(\"Use the `defaultValue` or `value` props instead of setting \" + \"children on <textarea>.\");\n                }\n                if (value != null) {\n                    throw new Error(\"If you supply `defaultValue` on a <textarea>, do not pass children.\");\n                }\n                if (isArray(children)) {\n                    if (children.length > 1) {\n                        throw new Error(\"<textarea> can only have at most one child.\");\n                    } // TODO: remove the coercion and the DEV check below because it will\n                    // always be overwritten by the coercion several lines below it. #22309\n                    {\n                        checkHtmlStringCoercion(children[0]);\n                    }\n                    value = \"\" + children[0];\n                }\n                {\n                    checkHtmlStringCoercion(children);\n                }\n                value = \"\" + children;\n            }\n            if (typeof value === \"string\" && value[0] === \"\\n\") {\n                // text/html ignores the first character in these tags if it's a newline\n                // Prefer to break application/xml over text/html (for now) by adding\n                // a newline specifically to get eaten by the parser. (Alternately for\n                // textareas, replacing \"^\\n\" with \"\\r\\n\" doesn't get eaten, and the first\n                // \\r is normalized out by HTMLTextAreaElement#value.)\n                // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>\n                // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>\n                // See: <http://www.w3.org/TR/html5/syntax.html#newlines>\n                // See: Parsing of \"textarea\" \"listing\" and \"pre\" elements\n                //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>\n                target.push(leadingNewline);\n            } // ToString and push directly instead of recurse over children.\n            // We don't really support complex children in the value anyway.\n            // This also currently avoids a trailing comment node which breaks textarea.\n            if (value !== null) {\n                {\n                    checkAttributeStringCoercion(value, \"value\");\n                }\n                target.push(stringToChunk(encodeHTMLTextNode(\"\" + value)));\n            }\n            return null;\n        }\n        function pushMeta(target, props, responseState, textEmbedded, insertionMode, noscriptTagInScope) {\n            {\n                if (insertionMode === SVG_MODE || noscriptTagInScope || props.itemProp != null) {\n                    return pushSelfClosing(target, props, \"meta\");\n                } else {\n                    if (textEmbedded) {\n                        // This link follows text but we aren't writing a tag. while not as efficient as possible we need\n                        // to be safe and assume text will follow by inserting a textSeparator\n                        target.push(textSeparator);\n                    }\n                    if (typeof props.charSet === \"string\") {\n                        return pushSelfClosing(responseState.charsetChunks, props, \"meta\");\n                    } else if (props.name === \"viewport\") {\n                        // \"viewport\" isn't related to preconnect but it has the right priority\n                        return pushSelfClosing(responseState.preconnectChunks, props, \"meta\");\n                    } else {\n                        return pushSelfClosing(responseState.hoistableChunks, props, \"meta\");\n                    }\n                }\n            }\n        }\n        function pushLink(target, props, responseState, resources, textEmbedded, insertionMode, noscriptTagInScope) {\n            {\n                var rel = props.rel;\n                var href = props.href;\n                var precedence = props.precedence;\n                if (insertionMode === SVG_MODE || noscriptTagInScope || props.itemProp != null || typeof rel !== \"string\" || typeof href !== \"string\" || href === \"\") {\n                    {\n                        if (rel === \"stylesheet\" && typeof props.precedence === \"string\") {\n                            if (typeof href !== \"string\" || !href) {\n                                error('React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and expected the `href` prop to be a non-empty string but ecountered %s instead. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop ensure there is a non-empty string `href` prop as well, otherwise remove the `precedence` prop.', getValueDescriptorExpectingObjectForWarning(href));\n                            }\n                        }\n                    }\n                    pushLinkImpl(target, props);\n                    return null;\n                }\n                if (props.rel === \"stylesheet\") {\n                    // This <link> may hoistable as a Stylesheet Resource, otherwise it will emit in place\n                    var key = getResourceKey(\"style\", href);\n                    if (typeof precedence !== \"string\" || props.disabled != null || props.onLoad || props.onError) {\n                        // This stylesheet is either not opted into Resource semantics or has conflicting properties which\n                        // disqualify it for such. We can still create a preload resource to help it load faster on the\n                        // client\n                        {\n                            if (typeof precedence === \"string\") {\n                                if (props.disabled != null) {\n                                    error('React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and a `disabled` prop. The presence of the `disabled` prop indicates an intent to manage the stylesheet active state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the `disabled` prop, otherwise remove the `precedence` prop.');\n                                } else if (props.onLoad || props.onError) {\n                                    var propDescription = props.onLoad && props.onError ? \"`onLoad` and `onError` props\" : props.onLoad ? \"`onLoad` prop\" : \"`onError` prop\";\n                                    error('React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.', propDescription, propDescription);\n                                }\n                            }\n                        }\n                        return pushLinkImpl(target, props);\n                    } else {\n                        // This stylesheet refers to a Resource and we create a new one if necessary\n                        var resource = resources.stylesMap.get(key);\n                        {\n                            var devResource = getAsResourceDEV(resource);\n                            if (devResource) {\n                                switch(devResource.__provenance){\n                                    case \"rendered\":\n                                        {\n                                            var differenceDescription = describeDifferencesForStylesheets(props, devResource.__originalProps);\n                                            if (differenceDescription) {\n                                                error('React encountered a <link rel=\"stylesheet\" href=\"%s\" .../> with a `precedence` prop that has props that conflict' + ' with another hoistable stylesheet with the same `href`. When using `precedence` with <link rel=\"stylsheet\" .../>' + \" the props from the first encountered instance will be used and props from later instances will be ignored.\" + ' Update the props on either <link rel=\"stylesheet\" .../> instance so they agree.%s', href, differenceDescription);\n                                            }\n                                            break;\n                                        }\n                                    case \"preinit\":\n                                        {\n                                            var _differenceDescription = describeDifferencesForStylesheetOverPreinit(props, devResource.__propsEquivalent);\n                                            if (_differenceDescription) {\n                                                error('React encountered a <link rel=\"stylesheet\" precedence=\"%s\" href=\"%s\" .../> with props that conflict' + ' with the options provided to `ReactDOM.preinit(\"%s\", { as: \"style\", ... })`. React will use the first props or preinitialization' + \" options encountered when rendering a hoistable stylesheet with a particular `href` and will ignore any newer props or\" + \" options. The first instance of this stylesheet resource was created using the `ReactDOM.preinit()` function.\" + \" Please note, `ReactDOM.preinit()` is modeled off of module import assertions capabilities and does not support\" + \" arbitrary props. If you need to have props not included with the preinit options you will need to rely on rendering\" + \" <link> tags only.%s\", precedence, href, href, _differenceDescription);\n                                            }\n                                            break;\n                                        }\n                                }\n                            }\n                        }\n                        if (!resource) {\n                            var resourceProps = stylesheetPropsFromRawProps(props);\n                            var preloadResource = resources.preloadsMap.get(key);\n                            var state = NoState;\n                            if (preloadResource) {\n                                // If we already had a preload we don't want that resource to flush directly.\n                                // We let the newly created resource govern flushing.\n                                preloadResource.state |= Blocked;\n                                adoptPreloadPropsForStylesheetProps(resourceProps, preloadResource.props);\n                                if (preloadResource.state & Flushed) {\n                                    state = PreloadFlushed;\n                                }\n                            }\n                            resource = {\n                                type: \"stylesheet\",\n                                chunks: [],\n                                state: state,\n                                props: resourceProps\n                            };\n                            resources.stylesMap.set(key, resource);\n                            {\n                                markAsRenderedResourceDEV(resource, props);\n                            }\n                            var precedenceSet = resources.precedences.get(precedence);\n                            if (!precedenceSet) {\n                                precedenceSet = new Set();\n                                resources.precedences.set(precedence, precedenceSet);\n                                var emptyStyleResource = {\n                                    type: \"style\",\n                                    chunks: [],\n                                    state: NoState,\n                                    props: {\n                                        precedence: precedence,\n                                        hrefs: []\n                                    }\n                                };\n                                precedenceSet.add(emptyStyleResource);\n                                {\n                                    if (resources.stylePrecedences.has(precedence)) {\n                                        error('React constructed an empty style resource when a style resource already exists for this precedence: \"%s\". This is a bug in React.', precedence);\n                                    }\n                                }\n                                resources.stylePrecedences.set(precedence, emptyStyleResource);\n                            }\n                            precedenceSet.add(resource);\n                        }\n                        if (resources.boundaryResources) {\n                            resources.boundaryResources.add(resource);\n                        }\n                        if (textEmbedded) {\n                            // This link follows text but we aren't writing a tag. while not as efficient as possible we need\n                            // to be safe and assume text will follow by inserting a textSeparator\n                            target.push(textSeparator);\n                        }\n                        return null;\n                    }\n                } else if (props.onLoad || props.onError) {\n                    // When using load handlers we cannot hoist and need to emit links in place\n                    return pushLinkImpl(target, props);\n                } else {\n                    // We can hoist this link so we may need to emit a text separator.\n                    // @TODO refactor text separators so we don't have to defensively add\n                    // them when we don't end up emitting a tag as a result of pushStartInstance\n                    if (textEmbedded) {\n                        // This link follows text but we aren't writing a tag. while not as efficient as possible we need\n                        // to be safe and assume text will follow by inserting a textSeparator\n                        target.push(textSeparator);\n                    }\n                    switch(props.rel){\n                        case \"preconnect\":\n                        case \"dns-prefetch\":\n                            return pushLinkImpl(responseState.preconnectChunks, props);\n                        case \"preload\":\n                            return pushLinkImpl(responseState.preloadChunks, props);\n                        default:\n                            return pushLinkImpl(responseState.hoistableChunks, props);\n                    }\n                }\n            }\n        }\n        function pushLinkImpl(target, props) {\n            target.push(startChunkForTag(\"link\"));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"link\" + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTagSelfClosing);\n            return null;\n        }\n        function pushStyle(target, props, resources, textEmbedded, insertionMode, noscriptTagInScope) {\n            {\n                if (hasOwnProperty.call(props, \"children\")) {\n                    var children = props.children;\n                    var child = Array.isArray(children) ? children.length < 2 ? children[0] : null : children;\n                    if (typeof child === \"function\" || typeof child === \"symbol\" || Array.isArray(child)) {\n                        var childType = typeof child === \"function\" ? \"a Function\" : typeof child === \"symbol\" ? \"a Sybmol\" : \"an Array\";\n                        error(\"React expect children of <style> tags to be a string, number, or object with a `toString` method but found %s instead. \" + \"In browsers style Elements can only have `Text` Nodes as children.\", childType);\n                    }\n                }\n            }\n            {\n                var precedence = props.precedence;\n                var href = props.href;\n                if (insertionMode === SVG_MODE || noscriptTagInScope || props.itemProp != null || typeof precedence !== \"string\" || typeof href !== \"string\" || href === \"\") {\n                    // This style tag is not able to be turned into a Style Resource\n                    return pushStyleImpl(target, props);\n                }\n                {\n                    if (href.includes(\" \")) {\n                        error('React expected the `href` prop for a <style> tag opting into hoisting semantics using the `precedence` prop to not have any spaces but ecountered spaces instead. using spaces in this prop will cause hydration of this style to fail on the client. The href for the <style> where this ocurred is \"%s\".', href);\n                    }\n                }\n                var key = getResourceKey(\"style\", href);\n                var resource = resources.stylesMap.get(key);\n                if (!resource) {\n                    resource = resources.stylePrecedences.get(precedence);\n                    if (!resource) {\n                        resource = {\n                            type: \"style\",\n                            chunks: [],\n                            state: NoState,\n                            props: {\n                                precedence: precedence,\n                                hrefs: [\n                                    href\n                                ]\n                            }\n                        };\n                        resources.stylePrecedences.set(precedence, resource);\n                        var precedenceSet = new Set();\n                        precedenceSet.add(resource);\n                        {\n                            if (resources.precedences.has(precedence)) {\n                                error('React constructed a new style precedence set when one already exists for this precedence: \"%s\". This is a bug in React.', precedence);\n                            }\n                        }\n                        resources.precedences.set(precedence, precedenceSet);\n                    } else {\n                        resource.props.hrefs.push(href);\n                    }\n                    resources.stylesMap.set(key, resource);\n                    if (resources.boundaryResources) {\n                        resources.boundaryResources.add(resource);\n                    }\n                    pushStyleContents(resource.chunks, props);\n                }\n                if (textEmbedded) {\n                    // This link follows text but we aren't writing a tag. while not as efficient as possible we need\n                    // to be safe and assume text will follow by inserting a textSeparator\n                    target.push(textSeparator);\n                }\n            }\n        }\n        function pushStyleImpl(target, props) {\n            target.push(startChunkForTag(\"style\"));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            var child = Array.isArray(children) ? children.length < 2 ? children[0] : null : children;\n            if (typeof child !== \"function\" && typeof child !== \"symbol\" && child !== null && child !== undefined) {\n                // eslint-disable-next-line react-internal/safe-string-coercion\n                target.push(stringToChunk(escapeTextForBrowser(\"\" + child)));\n            }\n            pushInnerHTML(target, innerHTML, children);\n            target.push(endTag1, stringToChunk(\"style\"), endTag2);\n            return null;\n        }\n        function pushStyleContents(target, props) {\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                    }\n                }\n            }\n            var child = Array.isArray(children) ? children.length < 2 ? children[0] : null : children;\n            if (typeof child !== \"function\" && typeof child !== \"symbol\" && child !== null && child !== undefined) {\n                // eslint-disable-next-line react-internal/safe-string-coercion\n                target.push(stringToChunk(escapeTextForBrowser(\"\" + child)));\n            }\n            pushInnerHTML(target, innerHTML, children);\n            return;\n        }\n        function getImagePreloadKey(href, imageSrcSet, imageSizes) {\n            var uniquePart = \"\";\n            if (typeof imageSrcSet === \"string\" && imageSrcSet !== \"\") {\n                uniquePart += \"[\" + imageSrcSet + \"]\";\n                if (typeof imageSizes === \"string\") {\n                    uniquePart += \"[\" + imageSizes + \"]\";\n                }\n            } else {\n                uniquePart += \"[][]\" + href;\n            }\n            return getResourceKey(\"image\", uniquePart);\n        }\n        function pushImg(target, props, resources) {\n            var src = props.src, srcSet = props.srcSet;\n            if (props.loading !== \"lazy\" && (typeof src === \"string\" || typeof srcSet === \"string\") && props.fetchPriority !== \"low\" && // We exclude data URIs in src and srcSet since these should not be preloaded\n            !(typeof src === \"string\" && src[4] === \":\" && (src[0] === \"d\" || src[0] === \"D\") && (src[1] === \"a\" || src[1] === \"A\") && (src[2] === \"t\" || src[2] === \"T\") && (src[3] === \"a\" || src[3] === \"A\")) && !(typeof srcSet === \"string\" && srcSet[4] === \":\" && (srcSet[0] === \"d\" || srcSet[0] === \"D\") && (srcSet[1] === \"a\" || srcSet[1] === \"A\") && (srcSet[2] === \"t\" || srcSet[2] === \"T\") && (srcSet[3] === \"a\" || srcSet[3] === \"A\"))) {\n                // We have a suspensey image and ought to preload it to optimize the loading of display blocking\n                // resources.\n                var sizes = props.sizes;\n                var key = getImagePreloadKey(src, srcSet, sizes);\n                var resource = resources.preloadsMap.get(key);\n                if (!resource) {\n                    resource = {\n                        type: \"preload\",\n                        chunks: [],\n                        state: NoState,\n                        props: {\n                            rel: \"preload\",\n                            as: \"image\",\n                            // There is a bug in Safari where imageSrcSet is not respected on preload links\n                            // so we omit the href here if we have imageSrcSet b/c safari will load the wrong image.\n                            // This harms older browers that do not support imageSrcSet by making their preloads not work\n                            // but this population is shrinking fast and is already small so we accept this tradeoff.\n                            href: srcSet ? undefined : src,\n                            imageSrcSet: srcSet,\n                            imageSizes: sizes,\n                            crossOrigin: props.crossOrigin,\n                            integrity: props.integrity,\n                            type: props.type,\n                            fetchPriority: props.fetchPriority,\n                            referrerPolicy: props.referrerPolicy\n                        }\n                    };\n                    resources.preloadsMap.set(key, resource);\n                    {\n                        markAsRenderedResourceDEV(resource, props);\n                    }\n                    pushLinkImpl(resource.chunks, resource.props);\n                }\n                if (props.fetchPriority === \"high\" || resources.highImagePreloads.size < 10) {\n                    resources.highImagePreloads.add(resource);\n                } else {\n                    resources.bulkPreloads.add(resource);\n                }\n            }\n            return pushSelfClosing(target, props, \"img\");\n        }\n        function pushSelfClosing(target, props, tag) {\n            target.push(startChunkForTag(tag));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(tag + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTagSelfClosing);\n            return null;\n        }\n        function pushStartMenuItem(target, props) {\n            target.push(startChunkForTag(\"menuitem\"));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"menuitems cannot have `children` nor `dangerouslySetInnerHTML`.\");\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            return null;\n        }\n        function pushTitle(target, props, responseState, insertionMode, noscriptTagInScope) {\n            {\n                if (hasOwnProperty.call(props, \"children\")) {\n                    var children = props.children;\n                    var child = Array.isArray(children) ? children.length < 2 ? children[0] : null : children;\n                    if (Array.isArray(children) && children.length > 1) {\n                        error(\"React expects the `children` prop of <title> tags to be a string, number, or object with a novel `toString` method but found an Array with length %s instead.\" + \" Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert `children` of <title> tags to a single string value\" + \" which is why Arrays of length greater than 1 are not supported. When using JSX it can be commong to combine text nodes and value nodes.\" + \" For example: <title>hello {nameOfUser}</title>. While not immediately apparent, `children` in this case is an Array with length 2. If your `children` prop\" + \" is using this form try rewriting it using a template string: <title>{`hello ${nameOfUser}`}</title>.\", children.length);\n                    } else if (typeof child === \"function\" || typeof child === \"symbol\") {\n                        var childType = typeof child === \"function\" ? \"a Function\" : \"a Sybmol\";\n                        error(\"React expect children of <title> tags to be a string, number, or object with a novel `toString` method but found %s instead.\" + \" Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title>\" + \" tags to a single string value.\", childType);\n                    } else if (child && child.toString === ({}).toString) {\n                        if (child.$$typeof != null) {\n                            error(\"React expects the `children` prop of <title> tags to be a string, number, or object with a novel `toString` method but found an object that appears to be\" + \" a React element which never implements a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to\" + \" be able to convert children of <title> tags to a single string value which is why rendering React elements is not supported. If the `children` of <title> is\" + \" a React Component try moving the <title> tag into that component. If the `children` of <title> is some HTML markup change it to be Text only to be valid HTML.\");\n                        } else {\n                            error(\"React expects the `children` prop of <title> tags to be a string, number, or object with a novel `toString` method but found an object that does not implement\" + \" a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags\" + \" to a single string value. Using the default `toString` method available on every object is almost certainly an error. Consider whether the `children` of this <title>\" + \" is an object in error and change it to a string or number value if so. Otherwise implement a `toString` method that React can use to produce a valid <title>.\");\n                        }\n                    }\n                }\n            }\n            {\n                if (insertionMode !== SVG_MODE && !noscriptTagInScope && props.itemProp == null) {\n                    pushTitleImpl(responseState.hoistableChunks, props);\n                    return null;\n                } else {\n                    return pushTitleImpl(target, props);\n                }\n            }\n        }\n        function pushTitleImpl(target, props) {\n            target.push(startChunkForTag(\"title\"));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            var child = Array.isArray(children) ? children.length < 2 ? children[0] : null : children;\n            if (typeof child !== \"function\" && typeof child !== \"symbol\" && child !== null && child !== undefined) {\n                // eslint-disable-next-line react-internal/safe-string-coercion\n                target.push(stringToChunk(escapeTextForBrowser(\"\" + child)));\n            }\n            pushInnerHTML(target, innerHTML, children);\n            target.push(endTag1, stringToChunk(\"title\"), endTag2);\n            return null;\n        }\n        function pushStartHead(target, props, responseState, insertionMode) {\n            {\n                if (insertionMode < HTML_MODE && responseState.headChunks === null) {\n                    // This <head> is the Document.head and should be part of the preamble\n                    responseState.headChunks = [];\n                    return pushStartGenericElement(responseState.headChunks, props, \"head\");\n                } else {\n                    // This <head> is deep and is likely just an error. we emit it inline though.\n                    // Validation should warn that this tag is the the wrong spot.\n                    return pushStartGenericElement(target, props, \"head\");\n                }\n            }\n        }\n        function pushStartHtml(target, props, responseState, insertionMode) {\n            {\n                if (insertionMode === ROOT_HTML_MODE && responseState.htmlChunks === null) {\n                    // This <html> is the Document.documentElement and should be part of the preamble\n                    responseState.htmlChunks = [\n                        DOCTYPE\n                    ];\n                    return pushStartGenericElement(responseState.htmlChunks, props, \"html\");\n                } else {\n                    // This <html> is deep and is likely just an error. we emit it inline though.\n                    // Validation should warn that this tag is the the wrong spot.\n                    return pushStartGenericElement(target, props, \"html\");\n                }\n            }\n        }\n        function pushScript(target, props, resources, textEmbedded, insertionMode, noscriptTagInScope) {\n            {\n                var asyncProp = props.async;\n                if (typeof props.src !== \"string\" || !props.src || !(asyncProp && typeof asyncProp !== \"function\" && typeof asyncProp !== \"symbol\") || props.onLoad || props.onError || insertionMode === SVG_MODE || noscriptTagInScope || props.itemProp != null) {\n                    // This script will not be a resource, we bailout early and emit it in place.\n                    return pushScriptImpl(target, props);\n                }\n                var src = props.src;\n                var key = getResourceKey(\"script\", src); // We can make this <script> into a ScriptResource\n                var resource = resources.scriptsMap.get(key);\n                {\n                    var devResource = getAsResourceDEV(resource);\n                    if (devResource) {\n                        switch(devResource.__provenance){\n                            case \"rendered\":\n                                {\n                                    var differenceDescription = describeDifferencesForScripts(props, devResource.__originalProps);\n                                    if (differenceDescription) {\n                                        error('React encountered a <script async={true} src=\"%s\" .../> that has props that conflict' + \" with another hoistable script with the same `src`. When rendering hoistable scripts (async scripts without any loading handlers)\" + \" the props from the first encountered instance will be used and props from later instances will be ignored.\" + \" Update the props on both <script async={true} .../> instance so they agree.%s\", src, differenceDescription);\n                                    }\n                                    break;\n                                }\n                            case \"preinit\":\n                                {\n                                    var _differenceDescription2 = describeDifferencesForScriptOverPreinit(props, devResource.__propsEquivalent);\n                                    if (_differenceDescription2) {\n                                        error('React encountered a <script async={true} src=\"%s\" .../> with props that conflict' + ' with the options provided to `ReactDOM.preinit(\"%s\", { as: \"script\", ... })`. React will use the first props or preinitialization' + \" options encountered when rendering a hoistable script with a particular `src` and will ignore any newer props or\" + \" options. The first instance of this script resource was created using the `ReactDOM.preinit()` function.\" + \" Please note, `ReactDOM.preinit()` is modeled off of module import assertions capabilities and does not support\" + \" arbitrary props. If you need to have props not included with the preinit options you will need to rely on rendering\" + \" <script> tags only.%s\", src, src, _differenceDescription2);\n                                    }\n                                    break;\n                                }\n                        }\n                    }\n                }\n                if (!resource) {\n                    resource = {\n                        type: \"script\",\n                        chunks: [],\n                        state: NoState,\n                        props: null\n                    };\n                    resources.scriptsMap.set(key, resource);\n                    {\n                        markAsRenderedResourceDEV(resource, props);\n                    }\n                    resources.scripts.add(resource);\n                    var scriptProps = props;\n                    var preloadResource = resources.preloadsMap.get(key);\n                    if (preloadResource) {\n                        // If we already had a preload we don't want that resource to flush directly.\n                        // We let the newly created resource govern flushing.\n                        preloadResource.state |= Blocked;\n                        scriptProps = assign({}, props);\n                        adoptPreloadPropsForScriptProps(scriptProps, preloadResource.props);\n                    } // encode the tag as Chunks\n                    pushScriptImpl(resource.chunks, scriptProps);\n                }\n                if (textEmbedded) {\n                    // This script follows text but we aren't writing a tag. while not as efficient as possible we need\n                    // to be safe and assume text will follow by inserting a textSeparator\n                    target.push(textSeparator);\n                }\n                return null;\n            }\n        }\n        function pushScriptImpl(target, props) {\n            target.push(startChunkForTag(\"script\"));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            {\n                if (children != null && typeof children !== \"string\") {\n                    var descriptiveStatement = typeof children === \"number\" ? \"a number for children\" : Array.isArray(children) ? \"an array for children\" : \"something unexpected for children\";\n                    error(\"A script element was rendered with %s. If script element has children it must be a single string.\" + \" Consider using dangerouslySetInnerHTML or passing a plain string as children.\", descriptiveStatement);\n                }\n            }\n            pushInnerHTML(target, innerHTML, children);\n            if (typeof children === \"string\") {\n                target.push(stringToChunk(encodeHTMLTextNode(children)));\n            }\n            target.push(endTag1, stringToChunk(\"script\"), endTag2);\n            return null;\n        }\n        function pushStartGenericElement(target, props, tag) {\n            target.push(startChunkForTag(tag));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            if (typeof children === \"string\") {\n                // Special case children as a string to avoid the unnecessary comment.\n                // TODO: Remove this special case after the general optimization is in place.\n                target.push(stringToChunk(encodeHTMLTextNode(children)));\n                return null;\n            }\n            return children;\n        }\n        function pushStartCustomElement(target, props, tag) {\n            target.push(startChunkForTag(tag));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        case \"style\":\n                            pushStyleAttribute(target, propValue);\n                            break;\n                        case \"suppressContentEditableWarning\":\n                        case \"suppressHydrationWarning\":\n                            break;\n                        default:\n                            if (isAttributeNameSafe(propKey) && typeof propValue !== \"function\" && typeof propValue !== \"symbol\") {\n                                target.push(attributeSeparator, stringToChunk(propKey), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);\n                            }\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            return children;\n        }\n        var leadingNewline = stringToPrecomputedChunk(\"\\n\");\n        function pushStartPreformattedElement(target, props, tag) {\n            target.push(startChunkForTag(tag));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag); // text/html ignores the first character in these tags if it's a newline\n            // Prefer to break application/xml over text/html (for now) by adding\n            // a newline specifically to get eaten by the parser. (Alternately for\n            // textareas, replacing \"^\\n\" with \"\\r\\n\" doesn't get eaten, and the first\n            // \\r is normalized out by HTMLTextAreaElement#value.)\n            // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>\n            // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>\n            // See: <http://www.w3.org/TR/html5/syntax.html#newlines>\n            // See: Parsing of \"textarea\" \"listing\" and \"pre\" elements\n            //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>\n            // TODO: This doesn't deal with the case where the child is an array\n            // or component that returns a string.\n            if (innerHTML != null) {\n                if (children != null) {\n                    throw new Error(\"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\");\n                }\n                if (typeof innerHTML !== \"object\" || !(\"__html\" in innerHTML)) {\n                    throw new Error(\"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. \" + \"Please visit https://reactjs.org/link/dangerously-set-inner-html \" + \"for more information.\");\n                }\n                var html = innerHTML.__html;\n                if (html !== null && html !== undefined) {\n                    if (typeof html === \"string\" && html.length > 0 && html[0] === \"\\n\") {\n                        target.push(leadingNewline, stringToChunk(html));\n                    } else {\n                        {\n                            checkHtmlStringCoercion(html);\n                        }\n                        target.push(stringToChunk(\"\" + html));\n                    }\n                }\n            }\n            if (typeof children === \"string\" && children[0] === \"\\n\") {\n                target.push(leadingNewline);\n            }\n            return children;\n        } // We accept any tag to be rendered but since this gets injected into arbitrary\n        // HTML, we want to make sure that it's a safe tag.\n        // http://www.w3.org/TR/REC-xml/#NT-Name\n        var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\\.\\-\\d]*$/; // Simplified subset\n        var validatedTagCache = new Map();\n        function startChunkForTag(tag) {\n            var tagStartChunk = validatedTagCache.get(tag);\n            if (tagStartChunk === undefined) {\n                if (!VALID_TAG_REGEX.test(tag)) {\n                    throw new Error(\"Invalid tag: \" + tag);\n                }\n                tagStartChunk = stringToPrecomputedChunk(\"<\" + tag);\n                validatedTagCache.set(tag, tagStartChunk);\n            }\n            return tagStartChunk;\n        }\n        var DOCTYPE = stringToPrecomputedChunk(\"<!DOCTYPE html>\");\n        function pushStartInstance(target, type, props, resources, responseState, formatContext, textEmbedded) {\n            {\n                validateProperties$2(type, props);\n                validateProperties$1(type, props);\n                validateProperties(type, props, null);\n                if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {\n                    error(\"A component is `contentEditable` and contains `children` managed by \" + \"React. It is now your responsibility to guarantee that none of \" + \"those nodes are unexpectedly modified or duplicated. This is \" + \"probably not intentional.\");\n                }\n                if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {\n                    if (type.indexOf(\"-\") === -1 && type.toLowerCase() !== type) {\n                        error(\"<%s /> is using incorrect casing. \" + \"Use PascalCase for React components, \" + \"or lowercase for HTML elements.\", type);\n                    }\n                }\n            }\n            switch(type){\n                case \"div\":\n                case \"span\":\n                case \"svg\":\n                case \"path\":\n                case \"a\":\n                case \"g\":\n                case \"p\":\n                case \"li\":\n                    break;\n                // Special tags\n                case \"select\":\n                    return pushStartSelect(target, props);\n                case \"option\":\n                    return pushStartOption(target, props, formatContext);\n                case \"textarea\":\n                    return pushStartTextArea(target, props);\n                case \"input\":\n                    return pushInput(target, props, responseState);\n                case \"button\":\n                    return pushStartButton(target, props, responseState);\n                case \"form\":\n                    return pushStartForm(target, props);\n                case \"menuitem\":\n                    return pushStartMenuItem(target, props);\n                case \"title\":\n                    return pushTitle(target, props, responseState, formatContext.insertionMode, formatContext.noscriptTagInScope);\n                case \"link\":\n                    return pushLink(target, props, responseState, resources, textEmbedded, formatContext.insertionMode, formatContext.noscriptTagInScope);\n                case \"script\":\n                    return pushScript(target, props, resources, textEmbedded, formatContext.insertionMode, formatContext.noscriptTagInScope);\n                case \"style\":\n                    return pushStyle(target, props, resources, textEmbedded, formatContext.insertionMode, formatContext.noscriptTagInScope);\n                case \"meta\":\n                    return pushMeta(target, props, responseState, textEmbedded, formatContext.insertionMode, formatContext.noscriptTagInScope);\n                // Newline eating tags\n                case \"listing\":\n                case \"pre\":\n                    {\n                        return pushStartPreformattedElement(target, props, type);\n                    }\n                case \"img\":\n                    {\n                        return pushImg(target, props, resources);\n                    }\n                // Omitted close tags\n                case \"base\":\n                case \"area\":\n                case \"br\":\n                case \"col\":\n                case \"embed\":\n                case \"hr\":\n                case \"keygen\":\n                case \"param\":\n                case \"source\":\n                case \"track\":\n                case \"wbr\":\n                    {\n                        return pushSelfClosing(target, props, type);\n                    }\n                // These are reserved SVG and MathML elements, that are never custom elements.\n                // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\n                case \"annotation-xml\":\n                case \"color-profile\":\n                case \"font-face\":\n                case \"font-face-src\":\n                case \"font-face-uri\":\n                case \"font-face-format\":\n                case \"font-face-name\":\n                case \"missing-glyph\":\n                    {\n                        break;\n                    }\n                // Preamble start tags\n                case \"head\":\n                    return pushStartHead(target, props, responseState, formatContext.insertionMode);\n                case \"html\":\n                    {\n                        return pushStartHtml(target, props, responseState, formatContext.insertionMode);\n                    }\n                default:\n                    {\n                        if (type.indexOf(\"-\") !== -1) {\n                            // Custom element\n                            return pushStartCustomElement(target, props, type);\n                        }\n                    }\n            } // Generic element\n            return pushStartGenericElement(target, props, type);\n        }\n        var endTag1 = stringToPrecomputedChunk(\"</\");\n        var endTag2 = stringToPrecomputedChunk(\">\");\n        function pushEndInstance(target, type, props, responseState, formatContext) {\n            switch(type){\n                // When float is on we expect title and script tags to always be pushed in\n                // a unit and never return children. when we end up pushing the end tag we\n                // want to ensure there is no extra closing tag pushed\n                case \"title\":\n                case \"style\":\n                case \"script\":\n                // Omitted close tags\n                // TODO: Instead of repeating this switch we could try to pass a flag from above.\n                // That would require returning a tuple. Which might be ok if it gets inlined.\n                case \"area\":\n                case \"base\":\n                case \"br\":\n                case \"col\":\n                case \"embed\":\n                case \"hr\":\n                case \"img\":\n                case \"input\":\n                case \"keygen\":\n                case \"link\":\n                case \"meta\":\n                case \"param\":\n                case \"source\":\n                case \"track\":\n                case \"wbr\":\n                    {\n                        // No close tag needed.\n                        return;\n                    }\n                // Postamble end tags\n                // When float is enabled we omit the end tags for body and html when\n                // they represent the Document.body and Document.documentElement Nodes.\n                // This is so we can withhold them until the postamble when we know\n                // we won't emit any more tags\n                case \"body\":\n                    {\n                        if (formatContext.insertionMode <= HTML_HTML_MODE) {\n                            responseState.hasBody = true;\n                            return;\n                        }\n                        break;\n                    }\n                case \"html\":\n                    if (formatContext.insertionMode === ROOT_HTML_MODE) {\n                        return;\n                    }\n                    break;\n            }\n            target.push(endTag1, stringToChunk(type), endTag2);\n        }\n        function writeBootstrap(destination, responseState) {\n            var bootstrapChunks = responseState.bootstrapChunks;\n            var i = 0;\n            for(; i < bootstrapChunks.length - 1; i++){\n                writeChunk(destination, bootstrapChunks[i]);\n            }\n            if (i < bootstrapChunks.length) {\n                var lastChunk = bootstrapChunks[i];\n                bootstrapChunks.length = 0;\n                return writeChunkAndReturn(destination, lastChunk);\n            }\n            return true;\n        }\n        function writeCompletedRoot(destination, responseState) {\n            return writeBootstrap(destination, responseState);\n        } // Structural Nodes\n        // A placeholder is a node inside a hidden partial tree that can be filled in later, but before\n        // display. It's never visible to users. We use the template tag because it can be used in every\n        // type of parent. <script> tags also work in every other tag except <colgroup>.\n        var placeholder1 = stringToPrecomputedChunk('<template id=\"');\n        var placeholder2 = stringToPrecomputedChunk('\"></template>');\n        function writePlaceholder(destination, responseState, id) {\n            writeChunk(destination, placeholder1);\n            writeChunk(destination, responseState.placeholderPrefix);\n            var formattedID = stringToChunk(id.toString(16));\n            writeChunk(destination, formattedID);\n            return writeChunkAndReturn(destination, placeholder2);\n        } // Suspense boundaries are encoded as comments.\n        var startCompletedSuspenseBoundary = stringToPrecomputedChunk(\"<!--$-->\");\n        var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id=\"');\n        var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('\"></template>');\n        var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk(\"<!--$!-->\");\n        var endSuspenseBoundary = stringToPrecomputedChunk(\"<!--/$-->\");\n        var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk(\"<template\");\n        var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('\"');\n        var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst=\"');\n        var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg=\"');\n        var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck=\"');\n        var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk(\"></template>\");\n        function writeStartCompletedSuspenseBoundary(destination, responseState) {\n            return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);\n        }\n        function writeStartPendingSuspenseBoundary(destination, responseState, id) {\n            writeChunk(destination, startPendingSuspenseBoundary1);\n            if (id === null) {\n                throw new Error(\"An ID must have been assigned before we can complete the boundary.\");\n            }\n            writeChunk(destination, id);\n            return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);\n        }\n        function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {\n            var result;\n            result = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);\n            writeChunk(destination, clientRenderedSuspenseBoundaryError1);\n            if (errorDigest) {\n                writeChunk(destination, clientRenderedSuspenseBoundaryError1A);\n                writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));\n                writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);\n            }\n            {\n                if (errorMesssage) {\n                    writeChunk(destination, clientRenderedSuspenseBoundaryError1B);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));\n                    writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);\n                }\n                if (errorComponentStack) {\n                    writeChunk(destination, clientRenderedSuspenseBoundaryError1C);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));\n                    writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);\n                }\n            }\n            result = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);\n            return result;\n        }\n        function writeEndCompletedSuspenseBoundary(destination, responseState) {\n            return writeChunkAndReturn(destination, endSuspenseBoundary);\n        }\n        function writeEndPendingSuspenseBoundary(destination, responseState) {\n            return writeChunkAndReturn(destination, endSuspenseBoundary);\n        }\n        function writeEndClientRenderedSuspenseBoundary(destination, responseState) {\n            return writeChunkAndReturn(destination, endSuspenseBoundary);\n        }\n        var startSegmentHTML = stringToPrecomputedChunk('<div hidden id=\"');\n        var startSegmentHTML2 = stringToPrecomputedChunk('\">');\n        var endSegmentHTML = stringToPrecomputedChunk(\"</div>\");\n        var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden=\"true\" style=\"display:none\" id=\"');\n        var startSegmentSVG2 = stringToPrecomputedChunk('\">');\n        var endSegmentSVG = stringToPrecomputedChunk(\"</svg>\");\n        var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden=\"true\" style=\"display:none\" id=\"');\n        var startSegmentMathML2 = stringToPrecomputedChunk('\">');\n        var endSegmentMathML = stringToPrecomputedChunk(\"</math>\");\n        var startSegmentTable = stringToPrecomputedChunk('<table hidden id=\"');\n        var startSegmentTable2 = stringToPrecomputedChunk('\">');\n        var endSegmentTable = stringToPrecomputedChunk(\"</table>\");\n        var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id=\"');\n        var startSegmentTableBody2 = stringToPrecomputedChunk('\">');\n        var endSegmentTableBody = stringToPrecomputedChunk(\"</tbody></table>\");\n        var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id=\"');\n        var startSegmentTableRow2 = stringToPrecomputedChunk('\">');\n        var endSegmentTableRow = stringToPrecomputedChunk(\"</tr></table>\");\n        var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id=\"');\n        var startSegmentColGroup2 = stringToPrecomputedChunk('\">');\n        var endSegmentColGroup = stringToPrecomputedChunk(\"</colgroup></table>\");\n        function writeStartSegment(destination, responseState, formatContext, id) {\n            switch(formatContext.insertionMode){\n                case ROOT_HTML_MODE:\n                case HTML_HTML_MODE:\n                case HTML_MODE:\n                    {\n                        writeChunk(destination, startSegmentHTML);\n                        writeChunk(destination, responseState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentHTML2);\n                    }\n                case SVG_MODE:\n                    {\n                        writeChunk(destination, startSegmentSVG);\n                        writeChunk(destination, responseState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentSVG2);\n                    }\n                case MATHML_MODE:\n                    {\n                        writeChunk(destination, startSegmentMathML);\n                        writeChunk(destination, responseState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentMathML2);\n                    }\n                case HTML_TABLE_MODE:\n                    {\n                        writeChunk(destination, startSegmentTable);\n                        writeChunk(destination, responseState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentTable2);\n                    }\n                // TODO: For the rest of these, there will be extra wrapper nodes that never\n                // get deleted from the document. We need to delete the table too as part\n                // of the injected scripts. They are invisible though so it's not too terrible\n                // and it's kind of an edge case to suspend in a table. Totally supported though.\n                case HTML_TABLE_BODY_MODE:\n                    {\n                        writeChunk(destination, startSegmentTableBody);\n                        writeChunk(destination, responseState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentTableBody2);\n                    }\n                case HTML_TABLE_ROW_MODE:\n                    {\n                        writeChunk(destination, startSegmentTableRow);\n                        writeChunk(destination, responseState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentTableRow2);\n                    }\n                case HTML_COLGROUP_MODE:\n                    {\n                        writeChunk(destination, startSegmentColGroup);\n                        writeChunk(destination, responseState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentColGroup2);\n                    }\n                default:\n                    {\n                        throw new Error(\"Unknown insertion mode. This is a bug in React.\");\n                    }\n            }\n        }\n        function writeEndSegment(destination, formatContext) {\n            switch(formatContext.insertionMode){\n                case ROOT_HTML_MODE:\n                case HTML_HTML_MODE:\n                case HTML_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentHTML);\n                    }\n                case SVG_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentSVG);\n                    }\n                case MATHML_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentMathML);\n                    }\n                case HTML_TABLE_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentTable);\n                    }\n                case HTML_TABLE_BODY_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentTableBody);\n                    }\n                case HTML_TABLE_ROW_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentTableRow);\n                    }\n                case HTML_COLGROUP_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentColGroup);\n                    }\n                default:\n                    {\n                        throw new Error(\"Unknown insertion mode. This is a bug in React.\");\n                    }\n            }\n        }\n        var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegment + ';$RS(\"');\n        var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS(\"');\n        var completeSegmentScript2 = stringToPrecomputedChunk('\",\"');\n        var completeSegmentScriptEnd = stringToPrecomputedChunk('\")</script>');\n        var completeSegmentData1 = stringToPrecomputedChunk('<template data-rsi=\"\" data-sid=\"');\n        var completeSegmentData2 = stringToPrecomputedChunk('\" data-pid=\"');\n        var completeSegmentDataEnd = dataElementQuotedEnd;\n        function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {\n            var scriptFormat = responseState.streamingFormat === ScriptStreamingFormat;\n            if (scriptFormat) {\n                writeChunk(destination, responseState.startInlineScript);\n                if ((responseState.instructions & SentCompleteSegmentFunction) === NothingSent) {\n                    // The first time we write this, we'll need to include the full implementation.\n                    responseState.instructions |= SentCompleteSegmentFunction;\n                    writeChunk(destination, completeSegmentScript1Full);\n                } else {\n                    // Future calls can just reuse the same function.\n                    writeChunk(destination, completeSegmentScript1Partial);\n                }\n            } else {\n                writeChunk(destination, completeSegmentData1);\n            } // Write function arguments, which are string literals\n            writeChunk(destination, responseState.segmentPrefix);\n            var formattedID = stringToChunk(contentSegmentID.toString(16));\n            writeChunk(destination, formattedID);\n            if (scriptFormat) {\n                writeChunk(destination, completeSegmentScript2);\n            } else {\n                writeChunk(destination, completeSegmentData2);\n            }\n            writeChunk(destination, responseState.placeholderPrefix);\n            writeChunk(destination, formattedID);\n            if (scriptFormat) {\n                return writeChunkAndReturn(destination, completeSegmentScriptEnd);\n            } else {\n                return writeChunkAndReturn(destination, completeSegmentDataEnd);\n            }\n        }\n        var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundary + '$RC(\"');\n        var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC(\"');\n        var completeBoundaryWithStylesScript1FullBoth = stringToPrecomputedChunk(completeBoundary + completeBoundaryWithStyles + '$RR(\"');\n        var completeBoundaryWithStylesScript1FullPartial = stringToPrecomputedChunk(completeBoundaryWithStyles + '$RR(\"');\n        var completeBoundaryWithStylesScript1Partial = stringToPrecomputedChunk('$RR(\"');\n        var completeBoundaryScript2 = stringToPrecomputedChunk('\",\"');\n        var completeBoundaryScript3a = stringToPrecomputedChunk('\",');\n        var completeBoundaryScript3b = stringToPrecomputedChunk('\"');\n        var completeBoundaryScriptEnd = stringToPrecomputedChunk(\")</script>\");\n        var completeBoundaryData1 = stringToPrecomputedChunk('<template data-rci=\"\" data-bid=\"');\n        var completeBoundaryWithStylesData1 = stringToPrecomputedChunk('<template data-rri=\"\" data-bid=\"');\n        var completeBoundaryData2 = stringToPrecomputedChunk('\" data-sid=\"');\n        var completeBoundaryData3a = stringToPrecomputedChunk('\" data-sty=\"');\n        var completeBoundaryDataEnd = dataElementQuotedEnd;\n        function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID, boundaryResources) {\n            var requiresStyleInsertion;\n            {\n                requiresStyleInsertion = responseState.stylesToHoist; // If necessary stylesheets will be flushed with this instruction.\n                // Any style tags not yet hoisted in the Document will also be hoisted.\n                // We reset this state since after this instruction executes all styles\n                // up to this point will have been hoisted\n                responseState.stylesToHoist = false;\n            }\n            var scriptFormat = responseState.streamingFormat === ScriptStreamingFormat;\n            if (scriptFormat) {\n                writeChunk(destination, responseState.startInlineScript);\n                if (requiresStyleInsertion) {\n                    if ((responseState.instructions & SentCompleteBoundaryFunction) === NothingSent) {\n                        responseState.instructions |= SentStyleInsertionFunction | SentCompleteBoundaryFunction;\n                        writeChunk(destination, clonePrecomputedChunk(completeBoundaryWithStylesScript1FullBoth));\n                    } else if ((responseState.instructions & SentStyleInsertionFunction) === NothingSent) {\n                        responseState.instructions |= SentStyleInsertionFunction;\n                        writeChunk(destination, completeBoundaryWithStylesScript1FullPartial);\n                    } else {\n                        writeChunk(destination, completeBoundaryWithStylesScript1Partial);\n                    }\n                } else {\n                    if ((responseState.instructions & SentCompleteBoundaryFunction) === NothingSent) {\n                        responseState.instructions |= SentCompleteBoundaryFunction;\n                        writeChunk(destination, completeBoundaryScript1Full);\n                    } else {\n                        writeChunk(destination, completeBoundaryScript1Partial);\n                    }\n                }\n            } else {\n                if (requiresStyleInsertion) {\n                    writeChunk(destination, completeBoundaryWithStylesData1);\n                } else {\n                    writeChunk(destination, completeBoundaryData1);\n                }\n            }\n            if (boundaryID === null) {\n                throw new Error(\"An ID must have been assigned before we can complete the boundary.\");\n            } // Write function arguments, which are string and array literals\n            var formattedContentID = stringToChunk(contentSegmentID.toString(16));\n            writeChunk(destination, boundaryID);\n            if (scriptFormat) {\n                writeChunk(destination, completeBoundaryScript2);\n            } else {\n                writeChunk(destination, completeBoundaryData2);\n            }\n            writeChunk(destination, responseState.segmentPrefix);\n            writeChunk(destination, formattedContentID);\n            if (requiresStyleInsertion) {\n                // Script and data writers must format this differently:\n                //  - script writer emits an array literal, whose string elements are\n                //    escaped for javascript  e.g. [\"A\", \"B\"]\n                //  - data writer emits a string literal, which is escaped as html\n                //    e.g. [&#34;A&#34;, &#34;B&#34;]\n                if (scriptFormat) {\n                    writeChunk(destination, completeBoundaryScript3a); // boundaryResources encodes an array literal\n                    writeStyleResourceDependenciesInJS(destination, boundaryResources);\n                } else {\n                    writeChunk(destination, completeBoundaryData3a);\n                    writeStyleResourceDependenciesInAttr(destination, boundaryResources);\n                }\n            } else {\n                if (scriptFormat) {\n                    writeChunk(destination, completeBoundaryScript3b);\n                }\n            }\n            var writeMore;\n            if (scriptFormat) {\n                writeMore = writeChunkAndReturn(destination, completeBoundaryScriptEnd);\n            } else {\n                writeMore = writeChunkAndReturn(destination, completeBoundaryDataEnd);\n            }\n            return writeBootstrap(destination, responseState) && writeMore;\n        }\n        var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderBoundary + ';$RX(\"');\n        var clientRenderScript1Partial = stringToPrecomputedChunk('$RX(\"');\n        var clientRenderScript1A = stringToPrecomputedChunk('\"');\n        var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(\",\");\n        var clientRenderScriptEnd = stringToPrecomputedChunk(\")</script>\");\n        var clientRenderData1 = stringToPrecomputedChunk('<template data-rxi=\"\" data-bid=\"');\n        var clientRenderData2 = stringToPrecomputedChunk('\" data-dgst=\"');\n        var clientRenderData3 = stringToPrecomputedChunk('\" data-msg=\"');\n        var clientRenderData4 = stringToPrecomputedChunk('\" data-stck=\"');\n        var clientRenderDataEnd = dataElementQuotedEnd;\n        function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {\n            var scriptFormat = responseState.streamingFormat === ScriptStreamingFormat;\n            if (scriptFormat) {\n                writeChunk(destination, responseState.startInlineScript);\n                if ((responseState.instructions & SentClientRenderFunction) === NothingSent) {\n                    // The first time we write this, we'll need to include the full implementation.\n                    responseState.instructions |= SentClientRenderFunction;\n                    writeChunk(destination, clientRenderScript1Full);\n                } else {\n                    // Future calls can just reuse the same function.\n                    writeChunk(destination, clientRenderScript1Partial);\n                }\n            } else {\n                // <template data-rxi=\"\" data-bid=\"\n                writeChunk(destination, clientRenderData1);\n            }\n            if (boundaryID === null) {\n                throw new Error(\"An ID must have been assigned before we can complete the boundary.\");\n            }\n            writeChunk(destination, boundaryID);\n            if (scriptFormat) {\n                // \" needs to be inserted for scripts, since ArgInterstitual does not contain\n                // leading or trailing quotes\n                writeChunk(destination, clientRenderScript1A);\n            }\n            if (errorDigest || errorMessage || errorComponentStack) {\n                if (scriptFormat) {\n                    // ,\"JSONString\"\n                    writeChunk(destination, clientRenderErrorScriptArgInterstitial);\n                    writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || \"\")));\n                } else {\n                    // \" data-dgst=\"HTMLString\n                    writeChunk(destination, clientRenderData2);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest || \"\")));\n                }\n            }\n            if (errorMessage || errorComponentStack) {\n                if (scriptFormat) {\n                    // ,\"JSONString\"\n                    writeChunk(destination, clientRenderErrorScriptArgInterstitial);\n                    writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || \"\")));\n                } else {\n                    // \" data-msg=\"HTMLString\n                    writeChunk(destination, clientRenderData3);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMessage || \"\")));\n                }\n            }\n            if (errorComponentStack) {\n                // ,\"JSONString\"\n                if (scriptFormat) {\n                    writeChunk(destination, clientRenderErrorScriptArgInterstitial);\n                    writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));\n                } else {\n                    // \" data-stck=\"HTMLString\n                    writeChunk(destination, clientRenderData4);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));\n                }\n            }\n            if (scriptFormat) {\n                // ></script>\n                return writeChunkAndReturn(destination, clientRenderScriptEnd);\n            } else {\n                // \"></template>\n                return writeChunkAndReturn(destination, clientRenderDataEnd);\n            }\n        }\n        var regexForJSStringsInInstructionScripts = /[<\\u2028\\u2029]/g;\n        function escapeJSStringsForInstructionScripts(input) {\n            var escaped = JSON.stringify(input);\n            return escaped.replace(regexForJSStringsInInstructionScripts, function(match) {\n                switch(match){\n                    // santizing breaking out of strings and script tags\n                    case \"<\":\n                        return \"\\\\u003c\";\n                    case \"\\u2028\":\n                        return \"\\\\u2028\";\n                    case \"\\u2029\":\n                        return \"\\\\u2029\";\n                    default:\n                        {\n                            // eslint-disable-next-line react-internal/prod-error-codes\n                            throw new Error(\"escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\");\n                        }\n                }\n            });\n        }\n        var regexForJSStringsInScripts = /[&><\\u2028\\u2029]/g;\n        function escapeJSObjectForInstructionScripts(input) {\n            var escaped = JSON.stringify(input);\n            return escaped.replace(regexForJSStringsInScripts, function(match) {\n                switch(match){\n                    // santizing breaking out of strings and script tags\n                    case \"&\":\n                        return \"\\\\u0026\";\n                    case \">\":\n                        return \"\\\\u003e\";\n                    case \"<\":\n                        return \"\\\\u003c\";\n                    case \"\\u2028\":\n                        return \"\\\\u2028\";\n                    case \"\\u2029\":\n                        return \"\\\\u2029\";\n                    default:\n                        {\n                            // eslint-disable-next-line react-internal/prod-error-codes\n                            throw new Error(\"escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\");\n                        }\n                }\n            });\n        }\n        var lateStyleTagResourceOpen1 = stringToPrecomputedChunk('<style media=\"not all\" data-precedence=\"');\n        var lateStyleTagResourceOpen2 = stringToPrecomputedChunk('\" data-href=\"');\n        var lateStyleTagResourceOpen3 = stringToPrecomputedChunk('\">');\n        var lateStyleTagTemplateClose = stringToPrecomputedChunk(\"</style>\"); // Tracks whether the boundary currently flushing is flushign style tags or has any\n        // stylesheet dependencies not flushed in the Preamble.\n        var currentlyRenderingBoundaryHasStylesToHoist = false; // Acts as a return value for the forEach execution of style tag flushing.\n        var destinationHasCapacity = true;\n        function flushStyleTagsLateForBoundary(resource) {\n            if (resource.type === \"stylesheet\" && (resource.state & FlushedInPreamble) === NoState) {\n                currentlyRenderingBoundaryHasStylesToHoist = true;\n            } else if (resource.type === \"style\") {\n                var chunks = resource.chunks;\n                var hrefs = resource.props.hrefs;\n                var i = 0;\n                if (chunks.length) {\n                    writeChunk(this, lateStyleTagResourceOpen1);\n                    writeChunk(this, stringToChunk(escapeTextForBrowser(resource.props.precedence)));\n                    if (hrefs.length) {\n                        writeChunk(this, lateStyleTagResourceOpen2);\n                        for(; i < hrefs.length - 1; i++){\n                            writeChunk(this, stringToChunk(escapeTextForBrowser(hrefs[i])));\n                            writeChunk(this, spaceSeparator);\n                        }\n                        writeChunk(this, stringToChunk(escapeTextForBrowser(hrefs[i])));\n                    }\n                    writeChunk(this, lateStyleTagResourceOpen3);\n                    for(i = 0; i < chunks.length; i++){\n                        writeChunk(this, chunks[i]);\n                    }\n                    destinationHasCapacity = writeChunkAndReturn(this, lateStyleTagTemplateClose); // We wrote style tags for this boundary and we may need to emit a script\n                    // to hoist them.\n                    currentlyRenderingBoundaryHasStylesToHoist = true; // style resources can flush continuously since more rules may be written into\n                    // them with new hrefs. Instead of marking it flushed, we simply reset the chunks\n                    // and hrefs\n                    chunks.length = 0;\n                    hrefs.length = 0;\n                }\n            }\n        }\n        function writeResourcesForBoundary(destination, boundaryResources, responseState) {\n            // Reset these on each invocation, they are only safe to read in this function\n            currentlyRenderingBoundaryHasStylesToHoist = false;\n            destinationHasCapacity = true; // Flush each Boundary resource\n            boundaryResources.forEach(flushStyleTagsLateForBoundary, destination);\n            if (currentlyRenderingBoundaryHasStylesToHoist) {\n                responseState.stylesToHoist = true;\n            }\n            return destinationHasCapacity;\n        }\n        function flushResourceInPreamble(resource) {\n            if ((resource.state & (Flushed | Blocked)) === NoState) {\n                var chunks = resource.chunks;\n                for(var i = 0; i < chunks.length; i++){\n                    writeChunk(this, chunks[i]);\n                }\n                resource.state |= FlushedInPreamble;\n            }\n        }\n        function flushResourceLate(resource) {\n            if ((resource.state & (Flushed | Blocked)) === NoState) {\n                var chunks = resource.chunks;\n                for(var i = 0; i < chunks.length; i++){\n                    writeChunk(this, chunks[i]);\n                }\n                resource.state |= FlushedLate;\n            }\n        } // This must always be read after flushing stylesheet styles. we know we will encounter a style resource\n        // per precedence and it will be set before ready so we cast this to avoid an extra check at runtime\n        var precedenceStyleTagResource = null; // This flags let's us opt out of flushing a placeholder style tag to emit the precedence in the right order.\n        // If a stylesheet was flushed then we have the precedence order preserved and only need to emit <style> tags\n        // if there are actual chunks to flush\n        var didFlushPrecedence = false;\n        function flushStyleInPreamble(resource, key, set) {\n            var chunks = resource.chunks;\n            if (resource.state & Flushed) {\n                // In theory this should never happen because we clear from the\n                // Set on flush but to ensure correct semantics we don't emit\n                // anything if we are in this state.\n                set.delete(resource);\n            } else {\n                // We can emit this style or stylesheet as is.\n                if (resource.type === \"style\") {\n                    precedenceStyleTagResource = resource;\n                    return;\n                } // We still need to encode stylesheet chunks\n                // because unlike most Hoistables and Resources we do not eagerly encode\n                // them during render. This is because if we flush late we have to send a\n                // different encoding and we don't want to encode multiple times\n                pushLinkImpl(chunks, resource.props);\n                for(var i = 0; i < chunks.length; i++){\n                    writeChunk(this, chunks[i]);\n                }\n                resource.state |= FlushedInPreamble;\n                didFlushPrecedence = true;\n            }\n        }\n        var styleTagResourceOpen1 = stringToPrecomputedChunk('<style data-precedence=\"');\n        var styleTagResourceOpen2 = stringToPrecomputedChunk('\" data-href=\"');\n        var spaceSeparator = stringToPrecomputedChunk(\" \");\n        var styleTagResourceOpen3 = stringToPrecomputedChunk('\">');\n        var styleTagResourceClose = stringToPrecomputedChunk(\"</style>\");\n        function flushAllStylesInPreamble(set, precedence) {\n            didFlushPrecedence = false;\n            set.forEach(flushStyleInPreamble, this);\n            set.clear();\n            var chunks = precedenceStyleTagResource.chunks;\n            var hrefs = precedenceStyleTagResource.props.hrefs;\n            if (didFlushPrecedence === false || chunks.length) {\n                writeChunk(this, styleTagResourceOpen1);\n                writeChunk(this, stringToChunk(escapeTextForBrowser(precedence)));\n                var i = 0;\n                if (hrefs.length) {\n                    writeChunk(this, styleTagResourceOpen2);\n                    for(; i < hrefs.length - 1; i++){\n                        writeChunk(this, stringToChunk(escapeTextForBrowser(hrefs[i])));\n                        writeChunk(this, spaceSeparator);\n                    }\n                    writeChunk(this, stringToChunk(escapeTextForBrowser(hrefs[i])));\n                }\n                writeChunk(this, styleTagResourceOpen3);\n                for(i = 0; i < chunks.length; i++){\n                    writeChunk(this, chunks[i]);\n                }\n                writeChunk(this, styleTagResourceClose); // style resources can flush continuously since more rules may be written into\n                // them with new hrefs. Instead of marking it flushed, we simply reset the chunks\n                // and hrefs\n                chunks.length = 0;\n                hrefs.length = 0;\n            }\n        }\n        function preloadLateStyle(resource) {\n            if (resource.state & PreloadFlushed) {\n                // This resource has already had a preload flushed\n                return;\n            }\n            if (resource.type === \"style\") {\n                // <style> tags do not need to be preloaded\n                return;\n            }\n            var chunks = resource.chunks;\n            var preloadProps = preloadAsStylePropsFromProps(resource.props.href, resource.props);\n            pushLinkImpl(chunks, preloadProps);\n            for(var i = 0; i < chunks.length; i++){\n                writeChunk(this, chunks[i]);\n            }\n            resource.state |= PreloadFlushed;\n            chunks.length = 0;\n        }\n        function preloadLateStyles(set, precedence) {\n            set.forEach(preloadLateStyle, this);\n            set.clear();\n        } // We don't bother reporting backpressure at the moment because we expect to\n        // flush the entire preamble in a single pass. This probably should be modified\n        // in the future to be backpressure sensitive but that requires a larger refactor\n        // of the flushing code in Fizz.\n        function writePreamble(destination, resources, responseState, willFlushAllSegments) {\n            // This function must be called exactly once on every request\n            if (!willFlushAllSegments && responseState.externalRuntimeScript) {\n                // If the root segment is incomplete due to suspended tasks\n                // (e.g. willFlushAllSegments = false) and we are using data\n                // streaming format, ensure the external runtime is sent.\n                // (User code could choose to send this even earlier by calling\n                //  preinit(...), if they know they will suspend).\n                var _responseState$extern = responseState.externalRuntimeScript, src = _responseState$extern.src, chunks = _responseState$extern.chunks;\n                internalPreinitScript(resources, src, chunks);\n            }\n            var htmlChunks = responseState.htmlChunks;\n            var headChunks = responseState.headChunks;\n            var i = 0; // Emit open tags before Hoistables and Resources\n            if (htmlChunks) {\n                // We have an <html> to emit as part of the preamble\n                for(i = 0; i < htmlChunks.length; i++){\n                    writeChunk(destination, htmlChunks[i]);\n                }\n                if (headChunks) {\n                    for(i = 0; i < headChunks.length; i++){\n                        writeChunk(destination, headChunks[i]);\n                    }\n                } else {\n                    // We did not render a head but we emitted an <html> so we emit one now\n                    writeChunk(destination, startChunkForTag(\"head\"));\n                    writeChunk(destination, endOfStartTag);\n                }\n            } else if (headChunks) {\n                // We do not have an <html> but we do have a <head>\n                for(i = 0; i < headChunks.length; i++){\n                    writeChunk(destination, headChunks[i]);\n                }\n            } // Emit high priority Hoistables\n            var charsetChunks = responseState.charsetChunks;\n            for(i = 0; i < charsetChunks.length; i++){\n                writeChunk(destination, charsetChunks[i]);\n            }\n            charsetChunks.length = 0; // emit preconnect resources\n            resources.preconnects.forEach(flushResourceInPreamble, destination);\n            resources.preconnects.clear();\n            var preconnectChunks = responseState.preconnectChunks;\n            for(i = 0; i < preconnectChunks.length; i++){\n                writeChunk(destination, preconnectChunks[i]);\n            }\n            preconnectChunks.length = 0;\n            resources.fontPreloads.forEach(flushResourceInPreamble, destination);\n            resources.fontPreloads.clear();\n            resources.highImagePreloads.forEach(flushResourceInPreamble, destination);\n            resources.highImagePreloads.clear(); // Flush unblocked stylesheets by precedence\n            resources.precedences.forEach(flushAllStylesInPreamble, destination);\n            resources.bootstrapScripts.forEach(flushResourceInPreamble, destination);\n            resources.scripts.forEach(flushResourceInPreamble, destination);\n            resources.scripts.clear();\n            resources.bulkPreloads.forEach(flushResourceInPreamble, destination);\n            resources.bulkPreloads.clear(); // Write embedding preloadChunks\n            var preloadChunks = responseState.preloadChunks;\n            for(i = 0; i < preloadChunks.length; i++){\n                writeChunk(destination, preloadChunks[i]);\n            }\n            preloadChunks.length = 0; // Write embedding hoistableChunks\n            var hoistableChunks = responseState.hoistableChunks;\n            for(i = 0; i < hoistableChunks.length; i++){\n                writeChunk(destination, hoistableChunks[i]);\n            }\n            hoistableChunks.length = 0; // Flush closing head if necessary\n            if (htmlChunks && headChunks === null) {\n                // We have an <html> rendered but no <head> rendered. We however inserted\n                // a <head> up above so we need to emit the </head> now. This is safe because\n                // if the main content contained the </head> it would also have provided a\n                // <head>. This means that all the content inside <html> is either <body> or\n                // invalid HTML\n                writeChunk(destination, endTag1);\n                writeChunk(destination, stringToChunk(\"head\"));\n                writeChunk(destination, endTag2);\n            }\n        } // We don't bother reporting backpressure at the moment because we expect to\n        // flush the entire preamble in a single pass. This probably should be modified\n        // in the future to be backpressure sensitive but that requires a larger refactor\n        // of the flushing code in Fizz.\n        function writeHoistables(destination, resources, responseState) {\n            var i = 0; // Emit high priority Hoistables\n            // We omit charsetChunks because we have already sent the shell and if it wasn't\n            // already sent it is too late now.\n            resources.preconnects.forEach(flushResourceLate, destination);\n            resources.preconnects.clear();\n            var preconnectChunks = responseState.preconnectChunks;\n            for(i = 0; i < preconnectChunks.length; i++){\n                writeChunk(destination, preconnectChunks[i]);\n            }\n            preconnectChunks.length = 0;\n            resources.fontPreloads.forEach(flushResourceLate, destination);\n            resources.fontPreloads.clear();\n            resources.highImagePreloads.forEach(flushResourceInPreamble, destination);\n            resources.highImagePreloads.clear(); // Preload any stylesheets. these will emit in a render instruction that follows this\n            // but we want to kick off preloading as soon as possible\n            resources.precedences.forEach(preloadLateStyles, destination); // bootstrap scripts should flush above script priority but these can only flush in the preamble\n            // so we elide the code here for performance\n            resources.scripts.forEach(flushResourceLate, destination);\n            resources.scripts.clear();\n            resources.bulkPreloads.forEach(flushResourceLate, destination);\n            resources.bulkPreloads.clear(); // Write embedding preloadChunks\n            var preloadChunks = responseState.preloadChunks;\n            for(i = 0; i < preloadChunks.length; i++){\n                writeChunk(destination, preloadChunks[i]);\n            }\n            preloadChunks.length = 0; // Write embedding hoistableChunks\n            var hoistableChunks = responseState.hoistableChunks;\n            for(i = 0; i < hoistableChunks.length; i++){\n                writeChunk(destination, hoistableChunks[i]);\n            }\n            hoistableChunks.length = 0;\n        }\n        function writePostamble(destination, responseState) {\n            if (responseState.hasBody) {\n                writeChunk(destination, endTag1);\n                writeChunk(destination, stringToChunk(\"body\"));\n                writeChunk(destination, endTag2);\n            }\n            if (responseState.htmlChunks) {\n                writeChunk(destination, endTag1);\n                writeChunk(destination, stringToChunk(\"html\"));\n                writeChunk(destination, endTag2);\n            }\n        }\n        var arrayFirstOpenBracket = stringToPrecomputedChunk(\"[\");\n        var arraySubsequentOpenBracket = stringToPrecomputedChunk(\",[\");\n        var arrayInterstitial = stringToPrecomputedChunk(\",\");\n        var arrayCloseBracket = stringToPrecomputedChunk(\"]\"); // This function writes a 2D array of strings to be embedded in javascript.\n        // E.g.\n        //  [[\"JS_escaped_string1\", \"JS_escaped_string2\"]]\n        function writeStyleResourceDependenciesInJS(destination, boundaryResources) {\n            writeChunk(destination, arrayFirstOpenBracket);\n            var nextArrayOpenBrackChunk = arrayFirstOpenBracket;\n            boundaryResources.forEach(function(resource) {\n                if (resource.type === \"style\") ;\n                else if (resource.state & FlushedInPreamble) ;\n                else if (resource.state & Flushed) {\n                    // We only need to emit the href because this resource flushed in an earlier\n                    // boundary already which encoded the attributes necessary to construct\n                    // the resource instance on the client.\n                    writeChunk(destination, nextArrayOpenBrackChunk);\n                    writeStyleResourceDependencyHrefOnlyInJS(destination, resource.props.href);\n                    writeChunk(destination, arrayCloseBracket);\n                    nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n                } else if (resource.type === \"stylesheet\") {\n                    // We need to emit the whole resource for insertion on the client\n                    writeChunk(destination, nextArrayOpenBrackChunk);\n                    writeStyleResourceDependencyInJS(destination, resource.props.href, resource.props[\"data-precedence\"], resource.props);\n                    writeChunk(destination, arrayCloseBracket);\n                    nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n                    resource.state |= FlushedLate;\n                }\n            });\n            writeChunk(destination, arrayCloseBracket);\n        }\n        /* Helper functions */ function writeStyleResourceDependencyHrefOnlyInJS(destination, href) {\n            // We should actually enforce this earlier when the resource is created but for\n            // now we make sure we are actually dealing with a string here.\n            {\n                checkAttributeStringCoercion(href, \"href\");\n            }\n            var coercedHref = \"\" + href;\n            writeChunk(destination, stringToChunk(escapeJSObjectForInstructionScripts(coercedHref)));\n        }\n        function writeStyleResourceDependencyInJS(destination, href, precedence, props) {\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            var coercedHref = sanitizeURL(\"\" + href);\n            writeChunk(destination, stringToChunk(escapeJSObjectForInstructionScripts(coercedHref)));\n            {\n                checkAttributeStringCoercion(precedence, \"precedence\");\n            }\n            var coercedPrecedence = \"\" + precedence;\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeJSObjectForInstructionScripts(coercedPrecedence)));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"href\":\n                        case \"rel\":\n                        case \"precedence\":\n                        case \"data-precedence\":\n                            {\n                                break;\n                            }\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"link\" + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        default:\n                            writeStyleResourceAttributeInJS(destination, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            return null;\n        }\n        function writeStyleResourceAttributeInJS(destination, name, value) {\n            var attributeName = name.toLowerCase();\n            var attributeValue;\n            switch(typeof value){\n                case \"function\":\n                case \"symbol\":\n                    return;\n            }\n            switch(name){\n                // Reserved names\n                case \"innerHTML\":\n                case \"dangerouslySetInnerHTML\":\n                case \"suppressContentEditableWarning\":\n                case \"suppressHydrationWarning\":\n                case \"style\":\n                    // Ignored\n                    return;\n                // Attribute renames\n                case \"className\":\n                    {\n                        attributeName = \"class\";\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                        break;\n                    }\n                // Booleans\n                case \"hidden\":\n                    {\n                        if (value === false) {\n                            return;\n                        }\n                        attributeValue = \"\";\n                        break;\n                    }\n                // Santized URLs\n                case \"src\":\n                case \"href\":\n                    {\n                        value = sanitizeURL(value);\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                        break;\n                    }\n                default:\n                    {\n                        if (// use on* as hueristic for these handler props\n                        name.length > 2 && (name[0] === \"o\" || name[0] === \"O\") && (name[1] === \"n\" || name[1] === \"N\")) {\n                            return;\n                        }\n                        if (!isAttributeNameSafe(name)) {\n                            return;\n                        }\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                    }\n            }\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeJSObjectForInstructionScripts(attributeName)));\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeJSObjectForInstructionScripts(attributeValue)));\n        } // This function writes a 2D array of strings to be embedded in an attribute\n        // value and read with JSON.parse in ReactDOMServerExternalRuntime.js\n        // E.g.\n        //  [[&quot;JSON_escaped_string1&quot;, &quot;JSON_escaped_string2&quot;]]\n        function writeStyleResourceDependenciesInAttr(destination, boundaryResources) {\n            writeChunk(destination, arrayFirstOpenBracket);\n            var nextArrayOpenBrackChunk = arrayFirstOpenBracket;\n            boundaryResources.forEach(function(resource) {\n                if (resource.type === \"style\") ;\n                else if (resource.state & FlushedInPreamble) ;\n                else if (resource.state & Flushed) {\n                    // We only need to emit the href because this resource flushed in an earlier\n                    // boundary already which encoded the attributes necessary to construct\n                    // the resource instance on the client.\n                    writeChunk(destination, nextArrayOpenBrackChunk);\n                    writeStyleResourceDependencyHrefOnlyInAttr(destination, resource.props.href);\n                    writeChunk(destination, arrayCloseBracket);\n                    nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n                } else if (resource.type === \"stylesheet\") {\n                    // We need to emit the whole resource for insertion on the client\n                    writeChunk(destination, nextArrayOpenBrackChunk);\n                    writeStyleResourceDependencyInAttr(destination, resource.props.href, resource.props[\"data-precedence\"], resource.props);\n                    writeChunk(destination, arrayCloseBracket);\n                    nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n                    resource.state |= FlushedLate;\n                }\n            });\n            writeChunk(destination, arrayCloseBracket);\n        }\n        /* Helper functions */ function writeStyleResourceDependencyHrefOnlyInAttr(destination, href) {\n            // We should actually enforce this earlier when the resource is created but for\n            // now we make sure we are actually dealing with a string here.\n            {\n                checkAttributeStringCoercion(href, \"href\");\n            }\n            var coercedHref = \"\" + href;\n            writeChunk(destination, stringToChunk(escapeTextForBrowser(JSON.stringify(coercedHref))));\n        }\n        function writeStyleResourceDependencyInAttr(destination, href, precedence, props) {\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            var coercedHref = sanitizeURL(\"\" + href);\n            writeChunk(destination, stringToChunk(escapeTextForBrowser(JSON.stringify(coercedHref))));\n            {\n                checkAttributeStringCoercion(precedence, \"precedence\");\n            }\n            var coercedPrecedence = \"\" + precedence;\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeTextForBrowser(JSON.stringify(coercedPrecedence))));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"href\":\n                        case \"rel\":\n                        case \"precedence\":\n                        case \"data-precedence\":\n                            {\n                                break;\n                            }\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"link\" + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        default:\n                            writeStyleResourceAttributeInAttr(destination, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            return null;\n        }\n        function writeStyleResourceAttributeInAttr(destination, name, value) {\n            var attributeName = name.toLowerCase();\n            var attributeValue;\n            switch(typeof value){\n                case \"function\":\n                case \"symbol\":\n                    return;\n            }\n            switch(name){\n                // Reserved names\n                case \"innerHTML\":\n                case \"dangerouslySetInnerHTML\":\n                case \"suppressContentEditableWarning\":\n                case \"suppressHydrationWarning\":\n                case \"style\":\n                    // Ignored\n                    return;\n                // Attribute renames\n                case \"className\":\n                    {\n                        attributeName = \"class\";\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                        break;\n                    }\n                // Booleans\n                case \"hidden\":\n                    {\n                        if (value === false) {\n                            return;\n                        }\n                        attributeValue = \"\";\n                        break;\n                    }\n                // Santized URLs\n                case \"src\":\n                case \"href\":\n                    {\n                        value = sanitizeURL(value);\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                        break;\n                    }\n                default:\n                    {\n                        if (// use on* as hueristic for these handler props\n                        name.length > 2 && (name[0] === \"o\" || name[0] === \"O\") && (name[1] === \"n\" || name[1] === \"N\")) {\n                            return;\n                        }\n                        if (!isAttributeNameSafe(name)) {\n                            return;\n                        }\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                    }\n            }\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeTextForBrowser(JSON.stringify(attributeName))));\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeTextForBrowser(JSON.stringify(attributeValue))));\n        }\n        /**\n * Resources\n */ var NoState = 0; // These tags indicate whether the Resource was flushed and in which phase\n        var FlushedInPreamble = 1;\n        var FlushedLate = 2;\n        var Flushed = 3; // This tag indicates whether this Resource is blocked from flushing.\n        // This currently is only used with stylesheets that are blocked by a Boundary\n        var Blocked = 4; // This tag indicates whether this Resource has been preloaded.\n        // This generally only makes sense for Resources other than PreloadResource\n        var PreloadFlushed = 8; // Dev extensions.\n        // Stylesheets and Scripts rendered with jsx\n        // Preloads, Stylesheets, and Scripts from ReactDOM.preload or ReactDOM.preinit\n        // Preloads created for normal components we rendered but know we can preload early such as\n        // sync Scripts and stylesheets without precedence or with onLoad/onError handlers\n        // @TODO add bootstrap script to implicit preloads\n        function createResources() {\n            return {\n                // persistent\n                preloadsMap: new Map(),\n                preconnectsMap: new Map(),\n                stylesMap: new Map(),\n                scriptsMap: new Map(),\n                // cleared on flush\n                preconnects: new Set(),\n                fontPreloads: new Set(),\n                highImagePreloads: new Set(),\n                // usedImagePreloads: new Set(),\n                precedences: new Map(),\n                stylePrecedences: new Map(),\n                bootstrapScripts: new Set(),\n                scripts: new Set(),\n                bulkPreloads: new Set(),\n                // like a module global for currently rendering boundary\n                boundaryResources: null\n            };\n        }\n        function createBoundaryResources() {\n            return new Set();\n        }\n        function setCurrentlyRenderingBoundaryResourcesTarget(resources, boundaryResources) {\n            resources.boundaryResources = boundaryResources;\n        }\n        function getResourceKey(as, href) {\n            return \"[\" + as + \"]\" + href;\n        }\n        function prefetchDNS(href, options) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resources = getResources(request);\n            {\n                if (typeof href !== \"string\" || !href) {\n                    error(\"ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.\", getValueDescriptorExpectingObjectForWarning(href));\n                } else if (options != null) {\n                    if (typeof options === \"object\" && options.hasOwnProperty(\"crossOrigin\")) {\n                        error(\"ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.\", getValueDescriptorExpectingEnumForWarning(options));\n                    } else {\n                        error(\"ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.\", getValueDescriptorExpectingEnumForWarning(options));\n                    }\n                }\n            }\n            if (typeof href === \"string\" && href) {\n                var key = getResourceKey(\"prefetchDNS\", href);\n                var resource = resources.preconnectsMap.get(key);\n                if (!resource) {\n                    resource = {\n                        type: \"preconnect\",\n                        chunks: [],\n                        state: NoState,\n                        props: null\n                    };\n                    resources.preconnectsMap.set(key, resource);\n                    pushLinkImpl(resource.chunks, {\n                        href: href,\n                        rel: \"dns-prefetch\"\n                    });\n                }\n                resources.preconnects.add(resource);\n                flushResources(request);\n            }\n        }\n        function preconnect(href, options) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resources = getResources(request);\n            {\n                if (typeof href !== \"string\" || !href) {\n                    error(\"ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.\", getValueDescriptorExpectingObjectForWarning(href));\n                } else if (options != null && typeof options !== \"object\") {\n                    error(\"ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.\", getValueDescriptorExpectingEnumForWarning(options));\n                } else if (options != null && typeof options.crossOrigin !== \"string\") {\n                    error(\"ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.\", getValueDescriptorExpectingObjectForWarning(options.crossOrigin));\n                }\n            }\n            if (typeof href === \"string\" && href) {\n                var crossOrigin = options == null || typeof options.crossOrigin !== \"string\" ? null : options.crossOrigin === \"use-credentials\" ? \"use-credentials\" : \"\";\n                var key = \"[preconnect][\" + (crossOrigin === null ? \"null\" : crossOrigin) + \"]\" + href;\n                var resource = resources.preconnectsMap.get(key);\n                if (!resource) {\n                    resource = {\n                        type: \"preconnect\",\n                        chunks: [],\n                        state: NoState,\n                        props: null\n                    };\n                    resources.preconnectsMap.set(key, resource);\n                    pushLinkImpl(resource.chunks, {\n                        rel: \"preconnect\",\n                        href: href,\n                        crossOrigin: crossOrigin\n                    });\n                }\n                resources.preconnects.add(resource);\n                flushResources(request);\n            }\n        }\n        function preload(href, options) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resources = getResources(request);\n            {\n                var encountered = \"\";\n                if (typeof href !== \"string\" || !href) {\n                    encountered += \" The `href` argument encountered was \" + getValueDescriptorExpectingObjectForWarning(href) + \".\";\n                }\n                if (options == null || typeof options !== \"object\") {\n                    encountered += \" The `options` argument encountered was \" + getValueDescriptorExpectingObjectForWarning(options) + \".\";\n                } else if (typeof options.as !== \"string\" || !options.as) {\n                    encountered += \" The `as` option encountered was \" + getValueDescriptorExpectingObjectForWarning(options.as) + \".\";\n                }\n                if (encountered) {\n                    error('ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel=\"preload\" as=\"...\" />` tag.%s', encountered);\n                }\n            }\n            if (typeof href === \"string\" && href && typeof options === \"object\" && options !== null && typeof options.as === \"string\" && options.as) {\n                var as = options.as;\n                var key;\n                if (as === \"image\") {\n                    // For image preloads the key contains either the imageSrcSet + imageSizes or the href but not\n                    // both. This is to prevent identical calls with the same srcSet and sizes to be duplicated\n                    // by varying the href. this is an edge case but it is the most correct behavior.\n                    var imageSrcSet = options.imageSrcSet, imageSizes = options.imageSizes;\n                    key = getImagePreloadKey(href, imageSrcSet, imageSizes);\n                } else {\n                    key = getResourceKey(as, href);\n                }\n                var resource = resources.preloadsMap.get(key);\n                {\n                    var devResource = getAsResourceDEV(resource);\n                    if (devResource) {\n                        switch(devResource.__provenance){\n                            case \"preload\":\n                                {\n                                    var differenceDescription = describeDifferencesForPreloads(options, devResource.__originalOptions);\n                                    if (differenceDescription) {\n                                        error('ReactDOM.preload(): The options provided conflict with another call to `ReactDOM.preload(\"%s\", { as: \"%s\", ...})`.' + \" React will always use the options it first encounters when preloading a resource for a given `href` and `as` type, and any later options will be ignored if different.\" + \" Try updating all calls to `ReactDOM.preload()` with the same `href` and `as` type to use the same options, or eliminate one of the calls.%s\", href, as, differenceDescription);\n                                    }\n                                    break;\n                                }\n                            case \"implicit\":\n                                {\n                                    var _differenceDescription3 = describeDifferencesForPreloadOverImplicitPreload(options, devResource.__impliedProps);\n                                    if (_differenceDescription3) {\n                                        var elementDescription = as === \"style\" ? '<link rel=\"stylesheet\" ... />' : as === \"script\" ? \"<script ... />\" : null;\n                                        if (elementDescription) {\n                                            error('ReactDOM.preload(): For `href` \"%s\", The options provided conflict with props on a matching %s element. When the preload' + \" options disagree with the underlying resource it usually means the browser will not be able to use the preload when the resource\" + \" is fetched, negating any benefit the preload would provide. React will preload the resource using props derived from the resource instead\" + \" and ignore the options provided to the `ReactDOM.preload()` call. In general, preloading is useful when you expect to\" + \" render a resource soon but have not yet done so. In this case since the underlying resource was already rendered the preload call\" + \" may be extraneous. Try removing the call, otherwise try adjusting both the props on the %s and the options\" + \" passed to `ReactDOM.preload()` to agree.%s\", href, elementDescription, elementDescription, _differenceDescription3);\n                                        }\n                                    }\n                                    break;\n                                }\n                        }\n                    }\n                }\n                if (!resource) {\n                    resource = {\n                        type: \"preload\",\n                        chunks: [],\n                        state: NoState,\n                        props: preloadPropsFromPreloadOptions(href, as, options)\n                    };\n                    resources.preloadsMap.set(key, resource);\n                    {\n                        markAsImperativeResourceDEV(resource, \"preload\", href, options, resource.props);\n                    }\n                    pushLinkImpl(resource.chunks, resource.props);\n                }\n                if (as === \"font\") {\n                    resources.fontPreloads.add(resource);\n                } else if (as === \"image\" && options.fetchPriority === \"high\") {\n                    resources.highImagePreloads.add(resource);\n                } else {\n                    resources.bulkPreloads.add(resource);\n                }\n                flushResources(request);\n            }\n        }\n        function preinit(href, options) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resources = getResources(request);\n            {\n                if (typeof href !== \"string\" || !href) {\n                    error(\"ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.\", getValueDescriptorExpectingObjectForWarning(href));\n                } else if (options == null || typeof options !== \"object\") {\n                    error(\"ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.\", getValueDescriptorExpectingEnumForWarning(options));\n                } else if (options.as !== \"style\" && options.as !== \"script\") {\n                    error('ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are \"style\" and \"script\".', getValueDescriptorExpectingEnumForWarning(options.as));\n                }\n            }\n            if (typeof href === \"string\" && href && typeof options === \"object\" && options !== null) {\n                var as = options.as;\n                switch(as){\n                    case \"style\":\n                        {\n                            var key = getResourceKey(as, href);\n                            var resource = resources.stylesMap.get(key);\n                            var precedence = options.precedence || \"default\";\n                            {\n                                var devResource = getAsResourceDEV(resource);\n                                if (devResource) {\n                                    var resourceProps = stylesheetPropsFromPreinitOptions(href, precedence, options);\n                                    var propsEquivalent = assign({}, resourceProps, _defineProperty({\n                                        precedence: options.precedence\n                                    }, \"data-precedence\", null));\n                                    switch(devResource.__provenance){\n                                        case \"rendered\":\n                                            {\n                                                var differenceDescription = describeDifferencesForPreinitOverStylesheet(propsEquivalent, devResource.__originalProps);\n                                                if (differenceDescription) {\n                                                    error('ReactDOM.preinit(): For `href` \"%s\", the options provided conflict with props found on a <link rel=\"stylesheet\" precedence=\"%s\" href=\"%s\" .../> that was already rendered.' + \" React will always use the props or options it first encounters for a hoistable stylesheet for a given `href` and any later props or options will be ignored if different.\" + \" Generally, ReactDOM.preinit() is useful when you are not yet rendering a stylesheet but you anticipate it will be used soon.\" + \" In this case the stylesheet was already rendered so preinitializing it does not provide any additional benefit.\" + ' To resolve, try making the props and options agree between the <link rel=\"stylesheet\" .../> and the `ReactDOM.preinit()` call or' + \" remove the `ReactDOM.preinit()` call.%s\", href, devResource.__originalProps.precedence, href, differenceDescription);\n                                                }\n                                                break;\n                                            }\n                                        case \"preinit\":\n                                            {\n                                                var _differenceDescription4 = describeDifferencesForPreinits(propsEquivalent, devResource.__propsEquivalent);\n                                                if (_differenceDescription4) {\n                                                    error('ReactDOM.preinit(): For `href` \"%s\", the options provided conflict with another call to `ReactDOM.preinit(\"%s\", { as: \"style\", ... })`.' + \" React will always use the options it first encounters when preinitializing a hoistable stylesheet for a given `href` and any later options will be ignored if different.\" + \" Try updating all calls to `ReactDOM.preinit()` for a given `href` to use the same options, or only call `ReactDOM.preinit()` once per `href`.%s\", href, href, _differenceDescription4);\n                                                }\n                                                break;\n                                            }\n                                    }\n                                }\n                            }\n                            if (!resource) {\n                                var state = NoState;\n                                var preloadResource = resources.preloadsMap.get(key);\n                                if (preloadResource && preloadResource.state & Flushed) {\n                                    state = PreloadFlushed;\n                                }\n                                resource = {\n                                    type: \"stylesheet\",\n                                    chunks: [],\n                                    state: state,\n                                    props: stylesheetPropsFromPreinitOptions(href, precedence, options)\n                                };\n                                resources.stylesMap.set(key, resource);\n                                {\n                                    markAsImperativeResourceDEV(resource, \"preinit\", href, options, assign({}, resource.props, _defineProperty({\n                                        precedence: precedence\n                                    }, \"data-precedence\", undefined)));\n                                }\n                                var precedenceSet = resources.precedences.get(precedence);\n                                if (!precedenceSet) {\n                                    precedenceSet = new Set();\n                                    resources.precedences.set(precedence, precedenceSet);\n                                    var emptyStyleResource = {\n                                        type: \"style\",\n                                        chunks: [],\n                                        state: NoState,\n                                        props: {\n                                            precedence: precedence,\n                                            hrefs: []\n                                        }\n                                    };\n                                    precedenceSet.add(emptyStyleResource);\n                                    {\n                                        if (resources.stylePrecedences.has(precedence)) {\n                                            error('React constructed an empty style resource when a style resource already exists for this precedence: \"%s\". This is a bug in React.', precedence);\n                                        }\n                                    }\n                                    resources.stylePrecedences.set(precedence, emptyStyleResource);\n                                }\n                                precedenceSet.add(resource);\n                                flushResources(request);\n                            }\n                            return;\n                        }\n                    case \"script\":\n                        {\n                            var src = href;\n                            var _key = getResourceKey(as, src);\n                            var _resource = resources.scriptsMap.get(_key);\n                            {\n                                var _devResource = getAsResourceDEV(_resource);\n                                if (_devResource) {\n                                    var _propsEquivalent = scriptPropsFromPreinitOptions(src, options);\n                                    switch(_devResource.__provenance){\n                                        case \"rendered\":\n                                            {\n                                                var _differenceDescription5 = describeDifferencesForPreinitOverScript(_propsEquivalent, _devResource.__originalProps);\n                                                if (_differenceDescription5) {\n                                                    error('ReactDOM.preinit(): For `href` \"%s\", the options provided conflict with props found on a <script async={true} src=\"%s\" .../> that was already rendered.' + \" React will always use the props or options it first encounters for a hoistable script for a given `href` and any later props or options will be ignored if different.\" + \" Generally, ReactDOM.preinit() is useful when you are not yet rendering a script but you anticipate it will be used soon and want to go beyond preloading it and have it\" + \" execute early. In this case the script was already rendered so preinitializing it does not provide any additional benefit.\" + \" To resolve, try making the props and options agree between the <script .../> and the `ReactDOM.preinit()` call or remove the `ReactDOM.preinit()` call.%s\", href, href, _differenceDescription5);\n                                                }\n                                                break;\n                                            }\n                                        case \"preinit\":\n                                            {\n                                                var _differenceDescription6 = describeDifferencesForPreinits(_propsEquivalent, _devResource.__propsEquivalent);\n                                                if (_differenceDescription6) {\n                                                    error('ReactDOM.preinit(): For `href` \"%s\", the options provided conflict with another call to `ReactDOM.preinit(\"%s\", { as: \"script\", ... })`.' + \" React will always use the options it first encounters when preinitializing a hoistable script for a given `href` and any later options will be ignored if different.\" + \" Try updating all calls to `ReactDOM.preinit()` for a given `href` to use the same options, or only call `ReactDOM.preinit()` once per `href`.%s\", href, href, _differenceDescription6);\n                                                }\n                                                break;\n                                            }\n                                    }\n                                }\n                            }\n                            if (!_resource) {\n                                _resource = {\n                                    type: \"script\",\n                                    chunks: [],\n                                    state: NoState,\n                                    props: null\n                                };\n                                resources.scriptsMap.set(_key, _resource);\n                                var _resourceProps = scriptPropsFromPreinitOptions(src, options);\n                                {\n                                    markAsImperativeResourceDEV(_resource, \"preinit\", href, options, _resourceProps);\n                                }\n                                resources.scripts.add(_resource);\n                                pushScriptImpl(_resource.chunks, _resourceProps);\n                                flushResources(request);\n                            }\n                            return;\n                        }\n                }\n            }\n        } // This function is only safe to call at Request start time since it assumes\n        // that each script has not already been preloaded. If we find a need to preload\n        // scripts at any other point in time we will need to check whether the preload\n        // already exists and not assume it\n        function preloadBootstrapScript(resources, src, nonce, integrity, crossOrigin) {\n            var key = getResourceKey(\"script\", src);\n            {\n                if (resources.preloadsMap.has(key)) {\n                    // This is coded as a React error because it should be impossible for a userspace preload to preempt this call\n                    // If a userspace preload can preempt it then this assumption is broken and we need to reconsider this strategy\n                    // rather than instruct the user to not preload their bootstrap scripts themselves\n                    error('Internal React Error: React expected bootstrap script with src \"%s\" to not have been preloaded already. please file an issue', src);\n                }\n            }\n            var props = {\n                rel: \"preload\",\n                href: src,\n                as: \"script\",\n                fetchPriority: \"low\",\n                nonce: nonce,\n                integrity: integrity,\n                crossOrigin: crossOrigin\n            };\n            var resource = {\n                type: \"preload\",\n                chunks: [],\n                state: NoState,\n                props: props\n            };\n            resources.preloadsMap.set(key, resource);\n            resources.bootstrapScripts.add(resource);\n            pushLinkImpl(resource.chunks, props);\n        } // This function is only safe to call at Request start time since it assumes\n        // that each module has not already been preloaded. If we find a need to preload\n        // scripts at any other point in time we will need to check whether the preload\n        // already exists and not assume it\n        function preloadBootstrapModule(resources, src, nonce, integrity, crossOrigin) {\n            var key = getResourceKey(\"script\", src);\n            {\n                if (resources.preloadsMap.has(key)) {\n                    // This is coded as a React error because it should be impossible for a userspace preload to preempt this call\n                    // If a userspace preload can preempt it then this assumption is broken and we need to reconsider this strategy\n                    // rather than instruct the user to not preload their bootstrap scripts themselves\n                    error('Internal React Error: React expected bootstrap module with src \"%s\" to not have been preloaded already. please file an issue', src);\n                }\n            }\n            var props = {\n                rel: \"modulepreload\",\n                href: src,\n                fetchPriority: \"low\",\n                nonce: nonce,\n                integrity: integrity,\n                crossOrigin: crossOrigin\n            };\n            var resource = {\n                type: \"preload\",\n                chunks: [],\n                state: NoState,\n                props: props\n            };\n            resources.preloadsMap.set(key, resource);\n            resources.bootstrapScripts.add(resource);\n            pushLinkImpl(resource.chunks, props);\n            return;\n        }\n        function internalPreinitScript(resources, src, chunks) {\n            var key = getResourceKey(\"script\", src);\n            var resource = resources.scriptsMap.get(key);\n            if (!resource) {\n                resource = {\n                    type: \"script\",\n                    chunks: chunks,\n                    state: NoState,\n                    props: null\n                };\n                resources.scriptsMap.set(key, resource);\n                resources.scripts.add(resource);\n            }\n            return;\n        }\n        function preloadPropsFromPreloadOptions(href, as, options) {\n            return {\n                rel: \"preload\",\n                as: as,\n                // There is a bug in Safari where imageSrcSet is not respected on preload links\n                // so we omit the href here if we have imageSrcSet b/c safari will load the wrong image.\n                // This harms older browers that do not support imageSrcSet by making their preloads not work\n                // but this population is shrinking fast and is already small so we accept this tradeoff.\n                href: as === \"image\" && options.imageSrcSet ? undefined : href,\n                crossOrigin: as === \"font\" ? \"\" : options.crossOrigin,\n                integrity: options.integrity,\n                type: options.type,\n                nonce: options.nonce,\n                fetchPriority: options.fetchPriority,\n                imageSrcSet: options.imageSrcSet,\n                imageSizes: options.imageSizes,\n                referrerPolicy: options.referrerPolicy\n            };\n        }\n        function preloadAsStylePropsFromProps(href, props) {\n            return {\n                rel: \"preload\",\n                as: \"style\",\n                href: href,\n                crossOrigin: props.crossOrigin,\n                fetchPriority: props.fetchPriority,\n                integrity: props.integrity,\n                media: props.media,\n                hrefLang: props.hrefLang,\n                referrerPolicy: props.referrerPolicy\n            };\n        }\n        function stylesheetPropsFromPreinitOptions(href, precedence, options) {\n            return {\n                rel: \"stylesheet\",\n                href: href,\n                \"data-precedence\": precedence,\n                crossOrigin: options.crossOrigin,\n                integrity: options.integrity,\n                fetchPriority: options.fetchPriority\n            };\n        }\n        function stylesheetPropsFromRawProps(rawProps) {\n            return assign({}, rawProps, {\n                \"data-precedence\": rawProps.precedence,\n                precedence: null\n            });\n        }\n        function adoptPreloadPropsForStylesheetProps(resourceProps, preloadProps) {\n            if (resourceProps.crossOrigin == null) resourceProps.crossOrigin = preloadProps.crossOrigin;\n            if (resourceProps.integrity == null) resourceProps.integrity = preloadProps.integrity;\n        }\n        function scriptPropsFromPreinitOptions(src, options) {\n            return {\n                src: src,\n                async: true,\n                crossOrigin: options.crossOrigin,\n                integrity: options.integrity,\n                nonce: options.nonce,\n                fetchPriority: options.fetchPriority\n            };\n        }\n        function adoptPreloadPropsForScriptProps(resourceProps, preloadProps) {\n            if (resourceProps.crossOrigin == null) resourceProps.crossOrigin = preloadProps.crossOrigin;\n            if (resourceProps.integrity == null) resourceProps.integrity = preloadProps.integrity;\n        }\n        function hoistStyleResource(resource) {\n            this.add(resource);\n        }\n        function hoistResources(resources, source) {\n            var currentBoundaryResources = resources.boundaryResources;\n            if (currentBoundaryResources) {\n                source.forEach(hoistStyleResource, currentBoundaryResources);\n            }\n        }\n        function markAsRenderedResourceDEV(resource, originalProps) {\n            {\n                var devResource = resource;\n                if (typeof devResource.__provenance === \"string\") {\n                    error(\"Resource already marked for DEV type. This is a bug in React.\");\n                }\n                devResource.__provenance = \"rendered\";\n                devResource.__originalProps = originalProps;\n            }\n        }\n        function markAsImperativeResourceDEV(resource, provenance, originalHref, originalOptions, propsEquivalent) {\n            {\n                var devResource = resource;\n                if (typeof devResource.__provenance === \"string\") {\n                    error(\"Resource already marked for DEV type. This is a bug in React.\");\n                }\n                devResource.__provenance = provenance;\n                devResource.__originalHref = originalHref;\n                devResource.__originalOptions = originalOptions;\n                devResource.__propsEquivalent = propsEquivalent;\n            }\n        }\n        function getAsResourceDEV(resource) {\n            {\n                if (resource) {\n                    if (typeof resource.__provenance === \"string\") {\n                        return resource;\n                    }\n                    error(\"Resource was not marked for DEV type. This is a bug in React.\");\n                }\n                return null;\n            }\n        }\n        var requestStorage = new async_hooks.AsyncLocalStorage();\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_SERVER_CONTEXT_TYPE = Symbol.for(\"react.server_context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_SCOPE_TYPE = Symbol.for(\"react.scope\");\n        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for(\"react.debug_trace_mode\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for(\"react.legacy_hidden\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for(\"react.default_value\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            {\n                if (typeof type.tag === \"number\") {\n                    error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                }\n            }\n            if (typeof type === \"function\") {\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                    case REACT_SERVER_CONTEXT_TYPE:\n                        {\n                            var context2 = type;\n                            return (context2.displayName || context2._globalName) + \".Provider\";\n                        }\n                }\n            }\n            return null;\n        }\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            var control;\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher$1.current = null;\n                disableLogs();\n            }\n            try {\n                // This should throw.\n                if (construct) {\n                    // Something should be setting the props in the constructor.\n                    var Fake = function() {\n                        throw Error();\n                    }; // $FlowFixMe[prop-missing]\n                    Object.defineProperty(Fake.prototype, \"props\", {\n                        set: function() {\n                            // We use a throwing setter instead of frozen or non-writable props\n                            // because that won't throw in a non-strict mode function.\n                            throw Error();\n                        }\n                    });\n                    if (typeof Reflect === \"object\" && Reflect.construct) {\n                        // We construct a different control for this case to include any extra\n                        // frames added by the construct call.\n                        try {\n                            Reflect.construct(Fake, []);\n                        } catch (x) {\n                            control = x;\n                        }\n                        Reflect.construct(fn, [], Fake);\n                    } else {\n                        try {\n                            Fake.call();\n                        } catch (x) {\n                            control = x;\n                        } // $FlowFixMe[prop-missing] found when upgrading Flow\n                        fn.call(Fake.prototype);\n                    }\n                } else {\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        control = x;\n                    } // TODO(luna): This will currently only throw if the function component\n                    // tries to access React/ReactDOM/props. We should probably make this throw\n                    // in simple components too\n                    var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                    // component, which we don't yet support. Attach a noop catch handler to\n                    // silence the error.\n                    // TODO: Implement component stacks for async client components?\n                    if (maybePromise && typeof maybePromise.catch === \"function\") {\n                        maybePromise.catch(function() {});\n                    }\n                }\n            } catch (sample) {\n                // This is inlined manually because closure doesn't do it for us.\n                if (sample && control && typeof sample.stack === \"string\") {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sample.stack.split(\"\\n\");\n                    var controlLines = control.stack.split(\"\\n\");\n                    var s = sampleLines.length - 1;\n                    var c = controlLines.length - 1;\n                    while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                        // We expect at least one stack frame to be shared.\n                        // Typically this will be the root most one. However, stack frames may be\n                        // cut off due to maximum stack limits. In this case, one maybe cut off\n                        // earlier than the other. We assume that the sample is longer or the same\n                        // and there for cut off earlier. So we should find the root most frame in\n                        // the sample somewhere in the control.\n                        c--;\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        }\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher$1.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeClassComponentFrame(ctor, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(ctor, true);\n            }\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct$1(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct$1(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement(null);\n                        }\n                    }\n                }\n            }\n        }\n        var warnedAboutMissingGetChildContext;\n        {\n            warnedAboutMissingGetChildContext = {};\n        }\n        var emptyContextObject = {};\n        {\n            Object.freeze(emptyContextObject);\n        }\n        function getMaskedContext(type, unmaskedContext) {\n            {\n                var contextTypes = type.contextTypes;\n                if (!contextTypes) {\n                    return emptyContextObject;\n                }\n                var context = {};\n                for(var key in contextTypes){\n                    context[key] = unmaskedContext[key];\n                }\n                {\n                    var name = getComponentNameFromType(type) || \"Unknown\";\n                    checkPropTypes(contextTypes, context, \"context\", name);\n                }\n                return context;\n            }\n        }\n        function processChildContext(instance, type, parentContext, childContextTypes) {\n            {\n                // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n                // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n                if (typeof instance.getChildContext !== \"function\") {\n                    {\n                        var componentName = getComponentNameFromType(type) || \"Unknown\";\n                        if (!warnedAboutMissingGetChildContext[componentName]) {\n                            warnedAboutMissingGetChildContext[componentName] = true;\n                            error(\"%s.childContextTypes is specified but there is no getChildContext() method \" + \"on the instance. You can either define getChildContext() on %s or remove \" + \"childContextTypes from it.\", componentName, componentName);\n                        }\n                    }\n                    return parentContext;\n                }\n                var childContext = instance.getChildContext();\n                for(var contextKey in childContext){\n                    if (!(contextKey in childContextTypes)) {\n                        throw new Error((getComponentNameFromType(type) || \"Unknown\") + '.getChildContext(): key \"' + contextKey + '\" is not defined in childContextTypes.');\n                    }\n                }\n                {\n                    var name = getComponentNameFromType(type) || \"Unknown\";\n                    checkPropTypes(childContextTypes, childContext, \"child context\", name);\n                }\n                return assign({}, parentContext, childContext);\n            }\n        }\n        var rendererSigil;\n        {\n            // Use this to detect multiple renderers using the same context\n            rendererSigil = {};\n        }\n        // Forming a reverse tree.\n        // The structure of a context snapshot is an implementation of this file.\n        // Currently, it's implemented as tracking the current active node.\n        var rootContextSnapshot = null; // We assume that this runtime owns the \"current\" field on all ReactContext instances.\n        // This global (actually thread local) state represents what state all those \"current\",\n        // fields are currently in.\n        var currentActiveSnapshot = null;\n        function popNode(prev) {\n            {\n                prev.context._currentValue = prev.parentValue;\n            }\n        }\n        function pushNode(next) {\n            {\n                next.context._currentValue = next.value;\n            }\n        }\n        function popToNearestCommonAncestor(prev, next) {\n            if (prev === next) ;\n            else {\n                popNode(prev);\n                var parentPrev = prev.parent;\n                var parentNext = next.parent;\n                if (parentPrev === null) {\n                    if (parentNext !== null) {\n                        throw new Error(\"The stacks must reach the root at the same time. This is a bug in React.\");\n                    }\n                } else {\n                    if (parentNext === null) {\n                        throw new Error(\"The stacks must reach the root at the same time. This is a bug in React.\");\n                    }\n                    popToNearestCommonAncestor(parentPrev, parentNext);\n                } // On the way back, we push the new ones that weren't common.\n                pushNode(next);\n            }\n        }\n        function popAllPrevious(prev) {\n            popNode(prev);\n            var parentPrev = prev.parent;\n            if (parentPrev !== null) {\n                popAllPrevious(parentPrev);\n            }\n        }\n        function pushAllNext(next) {\n            var parentNext = next.parent;\n            if (parentNext !== null) {\n                pushAllNext(parentNext);\n            }\n            pushNode(next);\n        }\n        function popPreviousToCommonLevel(prev, next) {\n            popNode(prev);\n            var parentPrev = prev.parent;\n            if (parentPrev === null) {\n                throw new Error(\"The depth must equal at least at zero before reaching the root. This is a bug in React.\");\n            }\n            if (parentPrev.depth === next.depth) {\n                // We found the same level. Now we just need to find a shared ancestor.\n                popToNearestCommonAncestor(parentPrev, next);\n            } else {\n                // We must still be deeper.\n                popPreviousToCommonLevel(parentPrev, next);\n            }\n        }\n        function popNextToCommonLevel(prev, next) {\n            var parentNext = next.parent;\n            if (parentNext === null) {\n                throw new Error(\"The depth must equal at least at zero before reaching the root. This is a bug in React.\");\n            }\n            if (prev.depth === parentNext.depth) {\n                // We found the same level. Now we just need to find a shared ancestor.\n                popToNearestCommonAncestor(prev, parentNext);\n            } else {\n                // We must still be deeper.\n                popNextToCommonLevel(prev, parentNext);\n            }\n            pushNode(next);\n        } // Perform context switching to the new snapshot.\n        // To make it cheap to read many contexts, while not suspending, we make the switch eagerly by\n        // updating all the context's current values. That way reads, always just read the current value.\n        // At the cost of updating contexts even if they're never read by this subtree.\n        function switchContext(newSnapshot) {\n            // The basic algorithm we need to do is to pop back any contexts that are no longer on the stack.\n            // We also need to update any new contexts that are now on the stack with the deepest value.\n            // The easiest way to update new contexts is to just reapply them in reverse order from the\n            // perspective of the backpointers. To avoid allocating a lot when switching, we use the stack\n            // for that. Therefore this algorithm is recursive.\n            // 1) First we pop which ever snapshot tree was deepest. Popping old contexts as we go.\n            // 2) Then we find the nearest common ancestor from there. Popping old contexts as we go.\n            // 3) Then we reapply new contexts on the way back up the stack.\n            var prev = currentActiveSnapshot;\n            var next = newSnapshot;\n            if (prev !== next) {\n                if (prev === null) {\n                    // $FlowFixMe[incompatible-call]: This has to be non-null since it's not equal to prev.\n                    pushAllNext(next);\n                } else if (next === null) {\n                    popAllPrevious(prev);\n                } else if (prev.depth === next.depth) {\n                    popToNearestCommonAncestor(prev, next);\n                } else if (prev.depth > next.depth) {\n                    popPreviousToCommonLevel(prev, next);\n                } else {\n                    popNextToCommonLevel(prev, next);\n                }\n                currentActiveSnapshot = next;\n            }\n        }\n        function pushProvider(context, nextValue) {\n            var prevValue;\n            {\n                prevValue = context._currentValue;\n                context._currentValue = nextValue;\n                {\n                    if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {\n                        error(\"Detected multiple renderers concurrently rendering the \" + \"same context provider. This is currently unsupported.\");\n                    }\n                    context._currentRenderer = rendererSigil;\n                }\n            }\n            var prevNode = currentActiveSnapshot;\n            var newNode = {\n                parent: prevNode,\n                depth: prevNode === null ? 0 : prevNode.depth + 1,\n                context: context,\n                parentValue: prevValue,\n                value: nextValue\n            };\n            currentActiveSnapshot = newNode;\n            return newNode;\n        }\n        function popProvider(context) {\n            var prevSnapshot = currentActiveSnapshot;\n            if (prevSnapshot === null) {\n                throw new Error(\"Tried to pop a Context at the root of the app. This is a bug in React.\");\n            }\n            {\n                if (prevSnapshot.context !== context) {\n                    error(\"The parent context is not the expected context. This is probably a bug in React.\");\n                }\n            }\n            {\n                var value = prevSnapshot.parentValue;\n                if (value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {\n                    prevSnapshot.context._currentValue = prevSnapshot.context._defaultValue;\n                } else {\n                    prevSnapshot.context._currentValue = value;\n                }\n                {\n                    if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {\n                        error(\"Detected multiple renderers concurrently rendering the \" + \"same context provider. This is currently unsupported.\");\n                    }\n                    context._currentRenderer = rendererSigil;\n                }\n            }\n            return currentActiveSnapshot = prevSnapshot.parent;\n        }\n        function getActiveContext() {\n            return currentActiveSnapshot;\n        }\n        function readContext$1(context) {\n            var value = context._currentValue;\n            return value;\n        }\n        /**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */ function get(key) {\n            return key._reactInternals;\n        }\n        function set(key, value) {\n            key._reactInternals = value;\n        }\n        var didWarnAboutNoopUpdateForComponent = {};\n        var didWarnAboutDeprecatedWillMount = {};\n        var didWarnAboutUninitializedState;\n        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\n        var didWarnAboutLegacyLifecyclesAndDerivedState;\n        var didWarnAboutUndefinedDerivedState;\n        var didWarnAboutDirectlyAssigningPropsToState;\n        var didWarnAboutContextTypeAndContextTypes;\n        var didWarnAboutInvalidateContextType;\n        var didWarnOnInvalidCallback;\n        {\n            didWarnAboutUninitializedState = new Set();\n            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n            didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n            didWarnAboutDirectlyAssigningPropsToState = new Set();\n            didWarnAboutUndefinedDerivedState = new Set();\n            didWarnAboutContextTypeAndContextTypes = new Set();\n            didWarnAboutInvalidateContextType = new Set();\n            didWarnOnInvalidCallback = new Set();\n        }\n        function warnOnInvalidCallback(callback, callerName) {\n            {\n                if (callback === null || typeof callback === \"function\") {\n                    return;\n                }\n                var key = callerName + \"_\" + callback;\n                if (!didWarnOnInvalidCallback.has(key)) {\n                    didWarnOnInvalidCallback.add(key);\n                    error(\"%s(...): Expected the last optional `callback` argument to be a \" + \"function. Instead received: %s.\", callerName, callback);\n                }\n            }\n        }\n        function warnOnUndefinedDerivedState(type, partialState) {\n            {\n                if (partialState === undefined) {\n                    var componentName = getComponentNameFromType(type) || \"Component\";\n                    if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n                        didWarnAboutUndefinedDerivedState.add(componentName);\n                        error(\"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. \" + \"You have returned undefined.\", componentName);\n                    }\n                }\n            }\n        }\n        function warnNoop(publicInstance, callerName) {\n            {\n                var _constructor = publicInstance.constructor;\n                var componentName = _constructor && getComponentNameFromType(_constructor) || \"ReactClass\";\n                var warningKey = componentName + \".\" + callerName;\n                if (didWarnAboutNoopUpdateForComponent[warningKey]) {\n                    return;\n                }\n                error(\"%s(...): Can only update a mounting component. \" + \"This usually means you called %s() outside componentWillMount() on the server. \" + \"This is a no-op.\\n\\nPlease check the code for the %s component.\", callerName, callerName, componentName);\n                didWarnAboutNoopUpdateForComponent[warningKey] = true;\n            }\n        }\n        var classComponentUpdater = {\n            isMounted: function(inst) {\n                return false;\n            },\n            // $FlowFixMe[missing-local-annot]\n            enqueueSetState: function(inst, payload, callback) {\n                var internals = get(inst);\n                if (internals.queue === null) {\n                    warnNoop(inst, \"setState\");\n                } else {\n                    internals.queue.push(payload);\n                    {\n                        if (callback !== undefined && callback !== null) {\n                            warnOnInvalidCallback(callback, \"setState\");\n                        }\n                    }\n                }\n            },\n            enqueueReplaceState: function(inst, payload, callback) {\n                var internals = get(inst);\n                internals.replace = true;\n                internals.queue = [\n                    payload\n                ];\n                {\n                    if (callback !== undefined && callback !== null) {\n                        warnOnInvalidCallback(callback, \"setState\");\n                    }\n                }\n            },\n            // $FlowFixMe[missing-local-annot]\n            enqueueForceUpdate: function(inst, callback) {\n                var internals = get(inst);\n                if (internals.queue === null) {\n                    warnNoop(inst, \"forceUpdate\");\n                } else {\n                    {\n                        if (callback !== undefined && callback !== null) {\n                            warnOnInvalidCallback(callback, \"setState\");\n                        }\n                    }\n                }\n            }\n        };\n        function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {\n            var partialState = getDerivedStateFromProps(nextProps, prevState);\n            {\n                warnOnUndefinedDerivedState(ctor, partialState);\n            }\n            var newState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);\n            return newState;\n        }\n        function constructClassInstance(ctor, props, maskedLegacyContext) {\n            var context = emptyContextObject;\n            var contextType = ctor.contextType;\n            {\n                if (\"contextType\" in ctor) {\n                    var isValid = contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>\n                    if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n                        didWarnAboutInvalidateContextType.add(ctor);\n                        var addendum = \"\";\n                        if (contextType === undefined) {\n                            addendum = \" However, it is set to undefined. \" + \"This can be caused by a typo or by mixing up named and default imports. \" + \"This can also happen due to a circular dependency, so \" + \"try moving the createContext() call to a separate file.\";\n                        } else if (typeof contextType !== \"object\") {\n                            addendum = \" However, it is set to a \" + typeof contextType + \".\";\n                        } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {\n                            addendum = \" Did you accidentally pass the Context.Provider instead?\";\n                        } else if (contextType._context !== undefined) {\n                            // <Context.Consumer>\n                            addendum = \" Did you accidentally pass the Context.Consumer instead?\";\n                        } else {\n                            addendum = \" However, it is set to an object with keys {\" + Object.keys(contextType).join(\", \") + \"}.\";\n                        }\n                        error(\"%s defines an invalid contextType. \" + \"contextType should point to the Context object returned by React.createContext().%s\", getComponentNameFromType(ctor) || \"Component\", addendum);\n                    }\n                }\n            }\n            if (typeof contextType === \"object\" && contextType !== null) {\n                context = readContext$1(contextType);\n            } else {\n                context = maskedLegacyContext;\n            }\n            var instance = new ctor(props, context);\n            {\n                if (typeof ctor.getDerivedStateFromProps === \"function\" && (instance.state === null || instance.state === undefined)) {\n                    var componentName = getComponentNameFromType(ctor) || \"Component\";\n                    if (!didWarnAboutUninitializedState.has(componentName)) {\n                        didWarnAboutUninitializedState.add(componentName);\n                        error(\"`%s` uses `getDerivedStateFromProps` but its initial state is \" + \"%s. This is not recommended. Instead, define the initial state by \" + \"assigning an object to `this.state` in the constructor of `%s`. \" + \"This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\", componentName, instance.state === null ? \"null\" : \"undefined\", componentName);\n                    }\n                } // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n                // Warn about these lifecycles if they are present.\n                // Don't warn about react-lifecycles-compat polyfilled methods though.\n                if (typeof ctor.getDerivedStateFromProps === \"function\" || typeof instance.getSnapshotBeforeUpdate === \"function\") {\n                    var foundWillMountName = null;\n                    var foundWillReceivePropsName = null;\n                    var foundWillUpdateName = null;\n                    if (typeof instance.componentWillMount === \"function\" && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                        foundWillMountName = \"componentWillMount\";\n                    } else if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n                        foundWillMountName = \"UNSAFE_componentWillMount\";\n                    }\n                    if (typeof instance.componentWillReceiveProps === \"function\" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n                        foundWillReceivePropsName = \"componentWillReceiveProps\";\n                    } else if (typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n                        foundWillReceivePropsName = \"UNSAFE_componentWillReceiveProps\";\n                    }\n                    if (typeof instance.componentWillUpdate === \"function\" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n                        foundWillUpdateName = \"componentWillUpdate\";\n                    } else if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n                        foundWillUpdateName = \"UNSAFE_componentWillUpdate\";\n                    }\n                    if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n                        var _componentName = getComponentNameFromType(ctor) || \"Component\";\n                        var newApiName = typeof ctor.getDerivedStateFromProps === \"function\" ? \"getDerivedStateFromProps()\" : \"getSnapshotBeforeUpdate()\";\n                        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n                            didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n                            error(\"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n\" + \"%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n\" + \"The above lifecycles should be removed. Learn more about this warning here:\\n\" + \"https://reactjs.org/link/unsafe-component-lifecycles\", _componentName, newApiName, foundWillMountName !== null ? \"\\n  \" + foundWillMountName : \"\", foundWillReceivePropsName !== null ? \"\\n  \" + foundWillReceivePropsName : \"\", foundWillUpdateName !== null ? \"\\n  \" + foundWillUpdateName : \"\");\n                        }\n                    }\n                }\n            }\n            return instance;\n        }\n        function checkClassInstance(instance, ctor, newProps) {\n            {\n                var name = getComponentNameFromType(ctor) || \"Component\";\n                var renderPresent = instance.render;\n                if (!renderPresent) {\n                    if (ctor.prototype && typeof ctor.prototype.render === \"function\") {\n                        error(\"%s(...): No `render` method found on the returned component \" + \"instance: did you accidentally return an object from the constructor?\", name);\n                    } else {\n                        error(\"%s(...): No `render` method found on the returned component \" + \"instance: you may have forgotten to define `render`.\", name);\n                    }\n                }\n                if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {\n                    error(\"getInitialState was defined on %s, a plain JavaScript class. \" + \"This is only supported for classes created using React.createClass. \" + \"Did you mean to define a state property instead?\", name);\n                }\n                if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps was defined on %s, a plain JavaScript class. \" + \"This is only supported for classes created using React.createClass. \" + \"Use a static property to define defaultProps instead.\", name);\n                }\n                if (instance.propTypes) {\n                    error(\"propTypes was defined as an instance property on %s. Use a static \" + \"property to define propTypes instead.\", name);\n                }\n                if (instance.contextType) {\n                    error(\"contextType was defined as an instance property on %s. Use a static \" + \"property to define contextType instead.\", name);\n                }\n                {\n                    if (instance.contextTypes) {\n                        error(\"contextTypes was defined as an instance property on %s. Use a static \" + \"property to define contextTypes instead.\", name);\n                    }\n                    if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {\n                        didWarnAboutContextTypeAndContextTypes.add(ctor);\n                        error(\"%s declares both contextTypes and contextType static properties. \" + \"The legacy contextTypes property will be ignored.\", name);\n                    }\n                }\n                if (typeof instance.componentShouldUpdate === \"function\") {\n                    error(\"%s has a method called \" + \"componentShouldUpdate(). Did you mean shouldComponentUpdate()? \" + \"The name is phrased as a question because the function is \" + \"expected to return a value.\", name);\n                }\n                if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== \"undefined\") {\n                    error(\"%s has a method called shouldComponentUpdate(). \" + \"shouldComponentUpdate should not be used when extending React.PureComponent. \" + \"Please extend React.Component if shouldComponentUpdate is used.\", getComponentNameFromType(ctor) || \"A pure component\");\n                }\n                if (typeof instance.componentDidUnmount === \"function\") {\n                    error(\"%s has a method called \" + \"componentDidUnmount(). But there is no such lifecycle method. \" + \"Did you mean componentWillUnmount()?\", name);\n                }\n                if (typeof instance.componentDidReceiveProps === \"function\") {\n                    error(\"%s has a method called \" + \"componentDidReceiveProps(). But there is no such lifecycle method. \" + \"If you meant to update the state in response to changing props, \" + \"use componentWillReceiveProps(). If you meant to fetch data or \" + \"run side-effects or mutations after React has updated the UI, use componentDidUpdate().\", name);\n                }\n                if (typeof instance.componentWillRecieveProps === \"function\") {\n                    error(\"%s has a method called \" + \"componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\", name);\n                }\n                if (typeof instance.UNSAFE_componentWillRecieveProps === \"function\") {\n                    error(\"%s has a method called \" + \"UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\", name);\n                }\n                var hasMutatedProps = instance.props !== newProps;\n                if (instance.props !== undefined && hasMutatedProps) {\n                    error(\"%s(...): When calling super() in `%s`, make sure to pass \" + \"up the same props that your component's constructor was passed.\", name, name);\n                }\n                if (instance.defaultProps) {\n                    error(\"Setting defaultProps as an instance property on %s is not supported and will be ignored.\" + \" Instead, define defaultProps as a static property on %s.\", name, name);\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === \"function\" && typeof instance.componentDidUpdate !== \"function\" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {\n                    didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n                    error(\"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). \" + \"This component defines getSnapshotBeforeUpdate() only.\", getComponentNameFromType(ctor));\n                }\n                if (typeof instance.getDerivedStateFromProps === \"function\") {\n                    error(\"%s: getDerivedStateFromProps() is defined as an instance method \" + \"and will be ignored. Instead, declare it as a static method.\", name);\n                }\n                if (typeof instance.getDerivedStateFromError === \"function\") {\n                    error(\"%s: getDerivedStateFromError() is defined as an instance method \" + \"and will be ignored. Instead, declare it as a static method.\", name);\n                }\n                if (typeof ctor.getSnapshotBeforeUpdate === \"function\") {\n                    error(\"%s: getSnapshotBeforeUpdate() is defined as a static method \" + \"and will be ignored. Instead, declare it as an instance method.\", name);\n                }\n                var state = instance.state;\n                if (state && (typeof state !== \"object\" || isArray(state))) {\n                    error(\"%s.state: must be set to an object or null\", name);\n                }\n                if (typeof instance.getChildContext === \"function\" && typeof ctor.childContextTypes !== \"object\") {\n                    error(\"%s.getChildContext(): childContextTypes must be defined in order to \" + \"use getChildContext().\", name);\n                }\n            }\n        }\n        function callComponentWillMount(type, instance) {\n            var oldState = instance.state;\n            if (typeof instance.componentWillMount === \"function\") {\n                {\n                    if (instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                        var componentName = getComponentNameFromType(type) || \"Unknown\";\n                        if (!didWarnAboutDeprecatedWillMount[componentName]) {\n                            warn(\"componentWillMount has been renamed, and is not recommended for use. \" + \"See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n\" + \"* Move code from componentWillMount to componentDidMount (preferred in most cases) \" + \"or the constructor.\\n\" + \"\\nPlease update the following components: %s\", componentName);\n                            didWarnAboutDeprecatedWillMount[componentName] = true;\n                        }\n                    }\n                }\n                instance.componentWillMount();\n            }\n            if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n                instance.UNSAFE_componentWillMount();\n            }\n            if (oldState !== instance.state) {\n                {\n                    error(\"%s.componentWillMount(): Assigning directly to this.state is \" + \"deprecated (except inside a component's \" + \"constructor). Use setState instead.\", getComponentNameFromType(type) || \"Component\");\n                }\n                classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n            }\n        }\n        function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {\n            if (internalInstance.queue !== null && internalInstance.queue.length > 0) {\n                var oldQueue = internalInstance.queue;\n                var oldReplace = internalInstance.replace;\n                internalInstance.queue = null;\n                internalInstance.replace = false;\n                if (oldReplace && oldQueue.length === 1) {\n                    inst.state = oldQueue[0];\n                } else {\n                    var nextState = oldReplace ? oldQueue[0] : inst.state;\n                    var dontMutate = true;\n                    for(var i = oldReplace ? 1 : 0; i < oldQueue.length; i++){\n                        var partial = oldQueue[i];\n                        var partialState = typeof partial === \"function\" ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;\n                        if (partialState != null) {\n                            if (dontMutate) {\n                                dontMutate = false;\n                                nextState = assign({}, nextState, partialState);\n                            } else {\n                                assign(nextState, partialState);\n                            }\n                        }\n                    }\n                    inst.state = nextState;\n                }\n            } else {\n                internalInstance.queue = null;\n            }\n        } // Invokes the mount life-cycles on a previously never rendered instance.\n        function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {\n            {\n                checkClassInstance(instance, ctor, newProps);\n            }\n            var initialState = instance.state !== undefined ? instance.state : null;\n            instance.updater = classComponentUpdater;\n            instance.props = newProps;\n            instance.state = initialState; // We don't bother initializing the refs object on the server, since we're not going to resolve them anyway.\n            // The internal instance will be used to manage updates that happen during this mount.\n            var internalInstance = {\n                queue: [],\n                replace: false\n            };\n            set(instance, internalInstance);\n            var contextType = ctor.contextType;\n            if (typeof contextType === \"object\" && contextType !== null) {\n                instance.context = readContext$1(contextType);\n            } else {\n                instance.context = maskedLegacyContext;\n            }\n            {\n                if (instance.state === newProps) {\n                    var componentName = getComponentNameFromType(ctor) || \"Component\";\n                    if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n                        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n                        error(\"%s: It is not recommended to assign props directly to state \" + \"because updates to props won't be reflected in state. \" + \"In most cases, it is better to use props directly.\", componentName);\n                    }\n                }\n            }\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n            if (typeof getDerivedStateFromProps === \"function\") {\n                instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);\n            } // In order to support react-lifecycles-compat polyfilled components,\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\n            if (typeof ctor.getDerivedStateFromProps !== \"function\" && typeof instance.getSnapshotBeforeUpdate !== \"function\" && (typeof instance.UNSAFE_componentWillMount === \"function\" || typeof instance.componentWillMount === \"function\")) {\n                callComponentWillMount(ctor, instance); // If we had additional state updates during this life-cycle, let's\n                // process them now.\n                processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);\n            }\n        }\n        // Ids are base 32 strings whose binary representation corresponds to the\n        // position of a node in a tree.\n        // Every time the tree forks into multiple children, we add additional bits to\n        // the left of the sequence that represent the position of the child within the\n        // current level of children.\n        //\n        //      00101       00010001011010101\n        //      ╰─┬─╯       ╰───────┬───────╯\n        //   Fork 5 of 20       Parent id\n        //\n        // The leading 0s are important. In the above example, you only need 3 bits to\n        // represent slot 5. However, you need 5 bits to represent all the forks at\n        // the current level, so we must account for the empty bits at the end.\n        //\n        // For this same reason, slots are 1-indexed instead of 0-indexed. Otherwise,\n        // the zeroth id at a level would be indistinguishable from its parent.\n        //\n        // If a node has only one child, and does not materialize an id (i.e. does not\n        // contain a useId hook), then we don't need to allocate any space in the\n        // sequence. It's treated as a transparent indirection. For example, these two\n        // trees produce the same ids:\n        //\n        // <>                          <>\n        //   <Indirection>               <A />\n        //     <A />                     <B />\n        //   </Indirection>            </>\n        //   <B />\n        // </>\n        //\n        // However, we cannot skip any node that materializes an id. Otherwise, a parent\n        // id that does not fork would be indistinguishable from its child id. For\n        // example, this tree does not fork, but the parent and child must have\n        // different ids.\n        //\n        // <Parent>\n        //   <Child />\n        // </Parent>\n        //\n        // To handle this scenario, every time we materialize an id, we allocate a\n        // new level with a single slot. You can think of this as a fork with only one\n        // prong, or an array of children with length 1.\n        //\n        // It's possible for the size of the sequence to exceed 32 bits, the max\n        // size for bitwise operations. When this happens, we make more room by\n        // converting the right part of the id to a string and storing it in an overflow\n        // variable. We use a base 32 string representation, because 32 is the largest\n        // power of 2 that is supported by toString(). We want the base to be large so\n        // that the resulting ids are compact, and we want the base to be a power of 2\n        // because every log2(base) bits corresponds to a single character, i.e. every\n        // log2(32) = 5 bits. That means we can lop bits off the end 5 at a time without\n        // affecting the final result.\n        var emptyTreeContext = {\n            id: 1,\n            overflow: \"\"\n        };\n        function getTreeId(context) {\n            var overflow = context.overflow;\n            var idWithLeadingBit = context.id;\n            var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);\n            return id.toString(32) + overflow;\n        }\n        function pushTreeContext(baseContext, totalChildren, index) {\n            var baseIdWithLeadingBit = baseContext.id;\n            var baseOverflow = baseContext.overflow; // The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n            // of the id; we use it to account for leading 0s.\n            var baseLength = getBitLength(baseIdWithLeadingBit) - 1;\n            var baseId = baseIdWithLeadingBit & ~(1 << baseLength);\n            var slot = index + 1;\n            var length = getBitLength(totalChildren) + baseLength; // 30 is the max length we can store without overflowing, taking into\n            // consideration the leading 1 we use to mark the end of the sequence.\n            if (length > 30) {\n                // We overflowed the bitwise-safe range. Fall back to slower algorithm.\n                // This branch assumes the length of the base id is greater than 5; it won't\n                // work for smaller ids, because you need 5 bits per character.\n                //\n                // We encode the id in multiple steps: first the base id, then the\n                // remaining digits.\n                //\n                // Each 5 bit sequence corresponds to a single base 32 character. So for\n                // example, if the current id is 23 bits long, we can convert 20 of those\n                // bits into a string of 4 characters, with 3 bits left over.\n                //\n                // First calculate how many bits in the base id represent a complete\n                // sequence of characters.\n                var numberOfOverflowBits = baseLength - baseLength % 5; // Then create a bitmask that selects only those bits.\n                var newOverflowBits = (1 << numberOfOverflowBits) - 1; // Select the bits, and convert them to a base 32 string.\n                var newOverflow = (baseId & newOverflowBits).toString(32); // Now we can remove those bits from the base id.\n                var restOfBaseId = baseId >> numberOfOverflowBits;\n                var restOfBaseLength = baseLength - numberOfOverflowBits; // Finally, encode the rest of the bits using the normal algorithm. Because\n                // we made more room, this time it won't overflow.\n                var restOfLength = getBitLength(totalChildren) + restOfBaseLength;\n                var restOfNewBits = slot << restOfBaseLength;\n                var id = restOfNewBits | restOfBaseId;\n                var overflow = newOverflow + baseOverflow;\n                return {\n                    id: 1 << restOfLength | id,\n                    overflow: overflow\n                };\n            } else {\n                // Normal path\n                var newBits = slot << baseLength;\n                var _id = newBits | baseId;\n                var _overflow = baseOverflow;\n                return {\n                    id: 1 << length | _id,\n                    overflow: _overflow\n                };\n            }\n        }\n        function getBitLength(number) {\n            return 32 - clz32(number);\n        }\n        function getLeadingBit(id) {\n            return 1 << getBitLength(id) - 1;\n        } // TODO: Math.clz32 is supported in Node 12+. Maybe we can drop the fallback.\n        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros.\n        // Based on:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n        var log = Math.log;\n        var LN2 = Math.LN2;\n        function clz32Fallback(x) {\n            var asUint = x >>> 0;\n            if (asUint === 0) {\n                return 32;\n            }\n            return 31 - (log(asUint) / LN2 | 0) | 0;\n        }\n        // Corresponds to ReactFiberWakeable and ReactFlightWakeable modules. Generally,\n        // changes to one module should be reflected in the others.\n        // TODO: Rename this module and the corresponding Fiber one to \"Thenable\"\n        // instead of \"Wakeable\". Or some other more appropriate name.\n        // An error that is thrown (e.g. by `use`) to trigger Suspense. If we\n        // detect this is caught by userspace, we'll log a warning in development.\n        var SuspenseException = new Error(\"Suspense Exception: This is not a real error! It's an implementation \" + \"detail of `use` to interrupt the current render. You must either \" + \"rethrow it immediately, or move the `use` call outside of the \" + \"`try/catch` block. Capturing without rethrowing will lead to \" + \"unexpected behavior.\\n\\n\" + \"To handle async errors, wrap your component in an error boundary, or \" + \"call the promise's `.catch` method and pass the result to `use`\");\n        function createThenableState() {\n            // The ThenableState is created the first time a component suspends. If it\n            // suspends again, we'll reuse the same state.\n            return [];\n        }\n        function noop$2() {}\n        function trackUsedThenable(thenableState, thenable, index) {\n            var previous = thenableState[index];\n            if (previous === undefined) {\n                thenableState.push(thenable);\n            } else {\n                if (previous !== thenable) {\n                    // Reuse the previous thenable, and drop the new one. We can assume\n                    // they represent the same value, because components are idempotent.\n                    // Avoid an unhandled rejection errors for the Promises that we'll\n                    // intentionally ignore.\n                    thenable.then(noop$2, noop$2);\n                    thenable = previous;\n                }\n            } // We use an expando to track the status and result of a thenable so that we\n            // can synchronously unwrap the value. Think of this as an extension of the\n            // Promise API, or a custom interface that is a superset of Thenable.\n            //\n            // If the thenable doesn't have a status, set it to \"pending\" and attach\n            // a listener that will update its status and result when it resolves.\n            switch(thenable.status){\n                case \"fulfilled\":\n                    {\n                        var fulfilledValue = thenable.value;\n                        return fulfilledValue;\n                    }\n                case \"rejected\":\n                    {\n                        var rejectedError = thenable.reason;\n                        throw rejectedError;\n                    }\n                default:\n                    {\n                        if (typeof thenable.status === \"string\") ;\n                        else {\n                            var pendingThenable = thenable;\n                            pendingThenable.status = \"pending\";\n                            pendingThenable.then(function(fulfilledValue) {\n                                if (thenable.status === \"pending\") {\n                                    var fulfilledThenable = thenable;\n                                    fulfilledThenable.status = \"fulfilled\";\n                                    fulfilledThenable.value = fulfilledValue;\n                                }\n                            }, function(error) {\n                                if (thenable.status === \"pending\") {\n                                    var rejectedThenable = thenable;\n                                    rejectedThenable.status = \"rejected\";\n                                    rejectedThenable.reason = error;\n                                }\n                            }); // Check one more time in case the thenable resolved synchronously\n                            switch(thenable.status){\n                                case \"fulfilled\":\n                                    {\n                                        var fulfilledThenable = thenable;\n                                        return fulfilledThenable.value;\n                                    }\n                                case \"rejected\":\n                                    {\n                                        var rejectedThenable = thenable;\n                                        throw rejectedThenable.reason;\n                                    }\n                            }\n                        } // Suspend.\n                        //\n                        // Throwing here is an implementation detail that allows us to unwind the\n                        // call stack. But we shouldn't allow it to leak into userspace. Throw an\n                        // opaque placeholder value instead of the actual thenable. If it doesn't\n                        // get captured by the work loop, log a warning, because that means\n                        // something in userspace must have caught it.\n                        suspendedThenable = thenable;\n                        throw SuspenseException;\n                    }\n            }\n        } // This is used to track the actual thenable that suspended so it can be\n        // passed to the rest of the Suspense implementation — which, for historical\n        // reasons, expects to receive a thenable.\n        var suspendedThenable = null;\n        function getSuspendedThenable() {\n            // This is called right after `use` suspends by throwing an exception. `use`\n            // throws an opaque value instead of the thenable itself so that it can't be\n            // caught in userspace. Then the work loop accesses the actual thenable using\n            // this function.\n            if (suspendedThenable === null) {\n                throw new Error(\"Expected a suspended thenable. This is a bug in React. Please file \" + \"an issue.\");\n            }\n            var thenable = suspendedThenable;\n            suspendedThenable = null;\n            return thenable;\n        }\n        /**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */ function is(x, y) {\n            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n            ;\n        }\n        var objectIs = typeof Object.is === \"function\" ? Object.is : is;\n        var currentlyRenderingComponent = null;\n        var currentlyRenderingTask = null;\n        var firstWorkInProgressHook = null;\n        var workInProgressHook = null; // Whether the work-in-progress hook is a re-rendered hook\n        var isReRender = false; // Whether an update was scheduled during the currently executing render pass.\n        var didScheduleRenderPhaseUpdate = false; // Counts the number of useId hooks in this component\n        var localIdCounter = 0; // Counts the number of use(thenable) calls in this component\n        var thenableIndexCounter = 0;\n        var thenableState = null; // Lazily created map of render-phase updates\n        var renderPhaseUpdates = null; // Counter to prevent infinite loops.\n        var numberOfReRenders = 0;\n        var RE_RENDER_LIMIT = 25;\n        var isInHookUserCodeInDev = false; // In DEV, this is the name of the currently executing primitive hook\n        var currentHookNameInDev;\n        function resolveCurrentlyRenderingComponent() {\n            if (currentlyRenderingComponent === null) {\n                throw new Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for\" + \" one of the following reasons:\\n\" + \"1. You might have mismatching versions of React and the renderer (such as React DOM)\\n\" + \"2. You might be breaking the Rules of Hooks\\n\" + \"3. You might have more than one copy of React in the same app\\n\" + \"See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.\");\n            }\n            {\n                if (isInHookUserCodeInDev) {\n                    error(\"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. \" + \"You can only call Hooks at the top level of your React function. \" + \"For more information, see \" + \"https://reactjs.org/link/rules-of-hooks\");\n                }\n            }\n            return currentlyRenderingComponent;\n        }\n        function areHookInputsEqual(nextDeps, prevDeps) {\n            if (prevDeps === null) {\n                {\n                    error(\"%s received a final argument during this render, but not during \" + \"the previous render. Even though the final argument is optional, \" + \"its type cannot change between renders.\", currentHookNameInDev);\n                }\n                return false;\n            }\n            {\n                // Don't bother comparing lengths in prod because these arrays should be\n                // passed inline.\n                if (nextDeps.length !== prevDeps.length) {\n                    error(\"The final argument passed to %s changed size between renders. The \" + \"order and size of this array must remain constant.\\n\\n\" + \"Previous: %s\\n\" + \"Incoming: %s\", currentHookNameInDev, \"[\" + nextDeps.join(\", \") + \"]\", \"[\" + prevDeps.join(\", \") + \"]\");\n                }\n            }\n            for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++){\n                // $FlowFixMe[incompatible-use] found when upgrading Flow\n                if (objectIs(nextDeps[i], prevDeps[i])) {\n                    continue;\n                }\n                return false;\n            }\n            return true;\n        }\n        function createHook() {\n            if (numberOfReRenders > 0) {\n                throw new Error(\"Rendered more hooks than during the previous render\");\n            }\n            return {\n                memoizedState: null,\n                queue: null,\n                next: null\n            };\n        }\n        function createWorkInProgressHook() {\n            if (workInProgressHook === null) {\n                // This is the first hook in the list\n                if (firstWorkInProgressHook === null) {\n                    isReRender = false;\n                    firstWorkInProgressHook = workInProgressHook = createHook();\n                } else {\n                    // There's already a work-in-progress. Reuse it.\n                    isReRender = true;\n                    workInProgressHook = firstWorkInProgressHook;\n                }\n            } else {\n                if (workInProgressHook.next === null) {\n                    isReRender = false; // Append to the end of the list\n                    workInProgressHook = workInProgressHook.next = createHook();\n                } else {\n                    // There's already a work-in-progress. Reuse it.\n                    isReRender = true;\n                    workInProgressHook = workInProgressHook.next;\n                }\n            }\n            return workInProgressHook;\n        }\n        function prepareToUseHooks(task, componentIdentity, prevThenableState) {\n            currentlyRenderingComponent = componentIdentity;\n            currentlyRenderingTask = task;\n            {\n                isInHookUserCodeInDev = false;\n            }\n            // didScheduleRenderPhaseUpdate = false;\n            // firstWorkInProgressHook = null;\n            // numberOfReRenders = 0;\n            // renderPhaseUpdates = null;\n            // workInProgressHook = null;\n            localIdCounter = 0;\n            thenableIndexCounter = 0;\n            thenableState = prevThenableState;\n        }\n        function finishHooks(Component, props, children, refOrContext) {\n            // This must be called after every function component to prevent hooks from\n            // being used in classes.\n            while(didScheduleRenderPhaseUpdate){\n                // Updates were scheduled during the render phase. They are stored in\n                // the `renderPhaseUpdates` map. Call the component again, reusing the\n                // work-in-progress hooks and applying the additional updates on top. Keep\n                // restarting until no more updates are scheduled.\n                didScheduleRenderPhaseUpdate = false;\n                localIdCounter = 0;\n                thenableIndexCounter = 0;\n                numberOfReRenders += 1; // Start over from the beginning of the list\n                workInProgressHook = null;\n                children = Component(props, refOrContext);\n            }\n            resetHooksState();\n            return children;\n        }\n        function getThenableStateAfterSuspending() {\n            var state = thenableState;\n            thenableState = null;\n            return state;\n        }\n        function checkDidRenderIdHook() {\n            // This should be called immediately after every finishHooks call.\n            // Conceptually, it's part of the return value of finishHooks; it's only a\n            // separate function to avoid using an array tuple.\n            var didRenderIdHook = localIdCounter !== 0;\n            return didRenderIdHook;\n        } // Reset the internal hooks state if an error occurs while rendering a component\n        function resetHooksState() {\n            {\n                isInHookUserCodeInDev = false;\n            }\n            currentlyRenderingComponent = null;\n            currentlyRenderingTask = null;\n            didScheduleRenderPhaseUpdate = false;\n            firstWorkInProgressHook = null;\n            numberOfReRenders = 0;\n            renderPhaseUpdates = null;\n            workInProgressHook = null;\n        }\n        function readContext(context) {\n            {\n                if (isInHookUserCodeInDev) {\n                    error(\"Context can only be read while React is rendering. \" + \"In classes, you can read it in the render method or getDerivedStateFromProps. \" + \"In function components, you can read it directly in the function body, but not \" + \"inside Hooks like useReducer() or useMemo().\");\n                }\n            }\n            return readContext$1(context);\n        }\n        function useContext(context) {\n            {\n                currentHookNameInDev = \"useContext\";\n            }\n            resolveCurrentlyRenderingComponent();\n            return readContext$1(context);\n        }\n        function basicStateReducer(state, action) {\n            // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types\n            return typeof action === \"function\" ? action(state) : action;\n        }\n        function useState(initialState) {\n            {\n                currentHookNameInDev = \"useState\";\n            }\n            return useReducer(basicStateReducer, initialState);\n        }\n        function useReducer(reducer, initialArg, init) {\n            {\n                if (reducer !== basicStateReducer) {\n                    currentHookNameInDev = \"useReducer\";\n                }\n            }\n            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n            workInProgressHook = createWorkInProgressHook();\n            if (isReRender) {\n                // This is a re-render. Apply the new render phase updates to the previous\n                // current hook.\n                var queue = workInProgressHook.queue;\n                var dispatch = queue.dispatch;\n                if (renderPhaseUpdates !== null) {\n                    // Render phase updates are stored in a map of queue -> linked list\n                    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n                    if (firstRenderPhaseUpdate !== undefined) {\n                        // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        renderPhaseUpdates.delete(queue); // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        var newState = workInProgressHook.memoizedState;\n                        var update = firstRenderPhaseUpdate;\n                        do {\n                            // Process this render phase update. We don't have to check the\n                            // priority because it will always be the same as the current\n                            // render's.\n                            var action = update.action;\n                            {\n                                isInHookUserCodeInDev = true;\n                            }\n                            newState = reducer(newState, action);\n                            {\n                                isInHookUserCodeInDev = false;\n                            }\n                            update = update.next;\n                        }while (update !== null); // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        workInProgressHook.memoizedState = newState;\n                        return [\n                            newState,\n                            dispatch\n                        ];\n                    }\n                } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                return [\n                    workInProgressHook.memoizedState,\n                    dispatch\n                ];\n            } else {\n                {\n                    isInHookUserCodeInDev = true;\n                }\n                var initialState;\n                if (reducer === basicStateReducer) {\n                    // Special case for `useState`.\n                    initialState = typeof initialArg === \"function\" ? initialArg() : initialArg;\n                } else {\n                    initialState = init !== undefined ? init(initialArg) : initialArg;\n                }\n                {\n                    isInHookUserCodeInDev = false;\n                }\n                workInProgressHook.memoizedState = initialState; // $FlowFixMe[incompatible-use] found when upgrading Flow\n                var _queue = workInProgressHook.queue = {\n                    last: null,\n                    dispatch: null\n                };\n                var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue); // $FlowFixMe[incompatible-use] found when upgrading Flow\n                return [\n                    workInProgressHook.memoizedState,\n                    _dispatch\n                ];\n            }\n        }\n        function useMemo(nextCreate, deps) {\n            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n            workInProgressHook = createWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            if (workInProgressHook !== null) {\n                var prevState = workInProgressHook.memoizedState;\n                if (prevState !== null) {\n                    if (nextDeps !== null) {\n                        var prevDeps = prevState[1];\n                        if (areHookInputsEqual(nextDeps, prevDeps)) {\n                            return prevState[0];\n                        }\n                    }\n                }\n            }\n            {\n                isInHookUserCodeInDev = true;\n            }\n            var nextValue = nextCreate();\n            {\n                isInHookUserCodeInDev = false;\n            }\n            workInProgressHook.memoizedState = [\n                nextValue,\n                nextDeps\n            ];\n            return nextValue;\n        }\n        function useRef(initialValue) {\n            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n            workInProgressHook = createWorkInProgressHook();\n            var previousRef = workInProgressHook.memoizedState;\n            if (previousRef === null) {\n                var ref = {\n                    current: initialValue\n                };\n                {\n                    Object.seal(ref);\n                }\n                workInProgressHook.memoizedState = ref;\n                return ref;\n            } else {\n                return previousRef;\n            }\n        }\n        function dispatchAction(componentIdentity, queue, action) {\n            if (numberOfReRenders >= RE_RENDER_LIMIT) {\n                throw new Error(\"Too many re-renders. React limits the number of renders to prevent \" + \"an infinite loop.\");\n            }\n            if (componentIdentity === currentlyRenderingComponent) {\n                // This is a render phase update. Stash it in a lazily-created map of\n                // queue -> linked list of updates. After this render pass, we'll restart\n                // and apply the stashed updates on top of the work-in-progress hook.\n                didScheduleRenderPhaseUpdate = true;\n                var update = {\n                    action: action,\n                    next: null\n                };\n                if (renderPhaseUpdates === null) {\n                    renderPhaseUpdates = new Map();\n                }\n                var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n                if (firstRenderPhaseUpdate === undefined) {\n                    // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    renderPhaseUpdates.set(queue, update);\n                } else {\n                    // Append the update to the end of the list.\n                    var lastRenderPhaseUpdate = firstRenderPhaseUpdate;\n                    while(lastRenderPhaseUpdate.next !== null){\n                        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n                    }\n                    lastRenderPhaseUpdate.next = update;\n                }\n            }\n        }\n        function useCallback(callback, deps) {\n            return useMemo(function() {\n                return callback;\n            }, deps);\n        }\n        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n            if (getServerSnapshot === undefined) {\n                throw new Error(\"Missing getServerSnapshot, which is required for \" + \"server-rendered content. Will revert to client rendering.\");\n            }\n            return getServerSnapshot();\n        }\n        function useDeferredValue(value) {\n            resolveCurrentlyRenderingComponent();\n            return value;\n        }\n        function unsupportedStartTransition() {\n            throw new Error(\"startTransition cannot be called during server rendering.\");\n        }\n        function useTransition() {\n            resolveCurrentlyRenderingComponent();\n            return [\n                false,\n                unsupportedStartTransition\n            ];\n        }\n        function useId() {\n            var task = currentlyRenderingTask;\n            var treeId = getTreeId(task.treeContext);\n            var responseState = currentResponseState;\n            if (responseState === null) {\n                throw new Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component.\");\n            }\n            var localId = localIdCounter++;\n            return makeId(responseState, treeId, localId);\n        }\n        function use(usable) {\n            if (usable !== null && typeof usable === \"object\") {\n                // $FlowFixMe[method-unbinding]\n                if (typeof usable.then === \"function\") {\n                    // This is a thenable.\n                    var thenable = usable;\n                    return unwrapThenable(thenable);\n                } else if (usable.$$typeof === REACT_CONTEXT_TYPE || usable.$$typeof === REACT_SERVER_CONTEXT_TYPE) {\n                    var context = usable;\n                    return readContext(context);\n                }\n            } // eslint-disable-next-line react-internal/safe-string-coercion\n            throw new Error(\"An unsupported type was passed to use(): \" + String(usable));\n        }\n        function unwrapThenable(thenable) {\n            var index = thenableIndexCounter;\n            thenableIndexCounter += 1;\n            if (thenableState === null) {\n                thenableState = createThenableState();\n            }\n            return trackUsedThenable(thenableState, thenable, index);\n        }\n        function unsupportedRefresh() {\n            throw new Error(\"Cache cannot be refreshed during server rendering.\");\n        }\n        function useCacheRefresh() {\n            return unsupportedRefresh;\n        }\n        function noop$1() {}\n        var HooksDispatcher = {\n            readContext: readContext,\n            use: use,\n            useContext: useContext,\n            useMemo: useMemo,\n            useReducer: useReducer,\n            useRef: useRef,\n            useState: useState,\n            useInsertionEffect: noop$1,\n            useLayoutEffect: noop$1,\n            useCallback: useCallback,\n            // useImperativeHandle is not run in the server environment\n            useImperativeHandle: noop$1,\n            // Effects are not run in the server environment.\n            useEffect: noop$1,\n            // Debugging effect\n            useDebugValue: noop$1,\n            useDeferredValue: useDeferredValue,\n            useTransition: useTransition,\n            useId: useId,\n            // Subscriptions are not setup in a server environment.\n            useSyncExternalStore: useSyncExternalStore\n        };\n        {\n            HooksDispatcher.useCacheRefresh = useCacheRefresh;\n        }\n        var currentResponseState = null;\n        function setCurrentResponseState(responseState) {\n            currentResponseState = responseState;\n        }\n        function getCacheSignal() {\n            throw new Error(\"Not implemented.\");\n        }\n        function getCacheForType(resourceType) {\n            throw new Error(\"Not implemented.\");\n        }\n        var DefaultCacheDispatcher = {\n            getCacheSignal: getCacheSignal,\n            getCacheForType: getCacheForType\n        };\n        function getStackByComponentStackNode(componentStack) {\n            try {\n                var info = \"\";\n                var node = componentStack;\n                do {\n                    switch(node.tag){\n                        case 0:\n                            info += describeBuiltInComponentFrame(node.type, null, null);\n                            break;\n                        case 1:\n                            info += describeFunctionComponentFrame(node.type, null, null);\n                            break;\n                        case 2:\n                            info += describeClassComponentFrame(node.type, null, null);\n                            break;\n                    } // $FlowFixMe[incompatible-type] we bail out when we get a null\n                    node = node.parent;\n                }while (node);\n                return info;\n            } catch (x) {\n                return \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var ReactCurrentCache = ReactSharedInternals.ReactCurrentCache;\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var PENDING = 0;\n        var COMPLETED = 1;\n        var FLUSHED = 2;\n        var ABORTED = 3;\n        var ERRORED = 4;\n        var OPEN = 0;\n        var CLOSING = 1;\n        var CLOSED = 2; // This is a default heuristic for how to split up the HTML content into progressive\n        // loading. Our goal is to be able to display additional new content about every 500ms.\n        // Faster than that is unnecessary and should be throttled on the client. It also\n        // adds unnecessary overhead to do more splits. We don't know if it's a higher or lower\n        // end device but higher end suffer less from the overhead than lower end does from\n        // not getting small enough pieces. We error on the side of low end.\n        // We base this on low end 3G speeds which is about 500kbits per second. We assume\n        // that there can be a reasonable drop off from max bandwidth which leaves you with\n        // as little as 80%. We can receive half of that each 500ms - at best. In practice,\n        // a little bandwidth is lost to processing and contention - e.g. CSS and images that\n        // are downloaded along with the main content. So we estimate about half of that to be\n        // the lower end throughput. In other words, we expect that you can at least show\n        // about 12.5kb of content per 500ms. Not counting starting latency for the first\n        // paint.\n        // 500 * 1024 / 8 * .8 * 0.5 / 2\n        var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;\n        function defaultErrorHandler(error) {\n            console[\"error\"](error); // Don't transform to our wrapper\n            return null;\n        }\n        function noop() {}\n        function createRequest(children, resources, responseState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError) {\n            prepareHostDispatcher();\n            var pingedTasks = [];\n            var abortSet = new Set();\n            var request = {\n                destination: null,\n                flushScheduled: false,\n                responseState: responseState,\n                progressiveChunkSize: progressiveChunkSize === undefined ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,\n                status: OPEN,\n                fatalError: null,\n                nextSegmentId: 0,\n                allPendingTasks: 0,\n                pendingRootTasks: 0,\n                resources: resources,\n                completedRootSegment: null,\n                abortableTasks: abortSet,\n                pingedTasks: pingedTasks,\n                clientRenderedBoundaries: [],\n                completedBoundaries: [],\n                partialBoundaries: [],\n                onError: onError === undefined ? defaultErrorHandler : onError,\n                onAllReady: onAllReady === undefined ? noop : onAllReady,\n                onShellReady: onShellReady === undefined ? noop : onShellReady,\n                onShellError: onShellError === undefined ? noop : onShellError,\n                onFatalError: onFatalError === undefined ? noop : onFatalError\n            }; // This segment represents the root fallback.\n            var rootSegment = createPendingSegment(request, 0, null, rootFormatContext, false, false); // There is no parent so conceptually, we're unblocked to flush this segment.\n            rootSegment.parentFlushed = true;\n            var rootTask = createTask(request, null, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);\n            pingedTasks.push(rootTask);\n            return request;\n        }\n        var currentRequest = null;\n        function resolveRequest() {\n            if (currentRequest) return currentRequest;\n            {\n                var store = requestStorage.getStore();\n                if (store) return store;\n            }\n            return null;\n        }\n        function pingTask(request, task) {\n            var pingedTasks = request.pingedTasks;\n            pingedTasks.push(task);\n            if (request.pingedTasks.length === 1) {\n                request.flushScheduled = request.destination !== null;\n                scheduleWork(function() {\n                    return performWork(request);\n                });\n            }\n        }\n        function createSuspenseBoundary(request, fallbackAbortableTasks) {\n            return {\n                id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,\n                rootSegmentID: -1,\n                parentFlushed: false,\n                pendingTasks: 0,\n                forceClientRender: false,\n                completedSegments: [],\n                byteSize: 0,\n                fallbackAbortableTasks: fallbackAbortableTasks,\n                errorDigest: null,\n                resources: createBoundaryResources()\n            };\n        }\n        function createTask(request, thenableState, node, blockedBoundary, blockedSegment, abortSet, legacyContext, context, treeContext) {\n            request.allPendingTasks++;\n            if (blockedBoundary === null) {\n                request.pendingRootTasks++;\n            } else {\n                blockedBoundary.pendingTasks++;\n            }\n            var task = {\n                node: node,\n                ping: function() {\n                    return pingTask(request, task);\n                },\n                blockedBoundary: blockedBoundary,\n                blockedSegment: blockedSegment,\n                abortSet: abortSet,\n                legacyContext: legacyContext,\n                context: context,\n                treeContext: treeContext,\n                thenableState: thenableState\n            };\n            {\n                task.componentStack = null;\n            }\n            abortSet.add(task);\n            return task;\n        }\n        function createPendingSegment(request, index, boundary, formatContext, lastPushedText, textEmbedded) {\n            return {\n                status: PENDING,\n                id: -1,\n                // lazily assigned later\n                index: index,\n                parentFlushed: false,\n                chunks: [],\n                children: [],\n                formatContext: formatContext,\n                boundary: boundary,\n                lastPushedText: lastPushedText,\n                textEmbedded: textEmbedded\n            };\n        } // DEV-only global reference to the currently executing task\n        var currentTaskInDEV = null;\n        function getCurrentStackInDEV() {\n            {\n                if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {\n                    return \"\";\n                }\n                return getStackByComponentStackNode(currentTaskInDEV.componentStack);\n            }\n        }\n        function pushBuiltInComponentStackInDEV(task, type) {\n            {\n                task.componentStack = {\n                    tag: 0,\n                    parent: task.componentStack,\n                    type: type\n                };\n            }\n        }\n        function pushFunctionComponentStackInDEV(task, type) {\n            {\n                task.componentStack = {\n                    tag: 1,\n                    parent: task.componentStack,\n                    type: type\n                };\n            }\n        }\n        function pushClassComponentStackInDEV(task, type) {\n            {\n                task.componentStack = {\n                    tag: 2,\n                    parent: task.componentStack,\n                    type: type\n                };\n            }\n        }\n        function popComponentStackInDEV(task) {\n            {\n                if (task.componentStack === null) {\n                    error(\"Unexpectedly popped too many stack frames. This is a bug in React.\");\n                } else {\n                    task.componentStack = task.componentStack.parent;\n                }\n            }\n        } // stash the component stack of an unwinding error until it is processed\n        var lastBoundaryErrorComponentStackDev = null;\n        function captureBoundaryErrorDetailsDev(boundary, error) {\n            {\n                var errorMessage;\n                if (typeof error === \"string\") {\n                    errorMessage = error;\n                } else if (error && typeof error.message === \"string\") {\n                    errorMessage = error.message;\n                } else {\n                    // eslint-disable-next-line react-internal/safe-string-coercion\n                    errorMessage = String(error);\n                }\n                var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();\n                lastBoundaryErrorComponentStackDev = null;\n                boundary.errorMessage = errorMessage;\n                boundary.errorComponentStack = errorComponentStack;\n            }\n        }\n        function logRecoverableError(request, error) {\n            // If this callback errors, we intentionally let that error bubble up to become a fatal error\n            // so that someone fixes the error reporting instead of hiding it.\n            var errorDigest = request.onError(error);\n            if (errorDigest != null && typeof errorDigest !== \"string\") {\n                // eslint-disable-next-line react-internal/prod-error-codes\n                throw new Error('onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"' + typeof errorDigest + '\" instead');\n            }\n            return errorDigest;\n        }\n        function fatalError(request, error) {\n            // This is called outside error handling code such as if the root errors outside\n            // a suspense boundary or if the root suspense boundary's fallback errors.\n            // It's also called if React itself or its host configs errors.\n            var onShellError = request.onShellError;\n            onShellError(error);\n            var onFatalError = request.onFatalError;\n            onFatalError(error);\n            if (request.destination !== null) {\n                request.status = CLOSED;\n                closeWithError(request.destination, error);\n            } else {\n                request.status = CLOSING;\n                request.fatalError = error;\n            }\n        }\n        function renderSuspenseBoundary(request, task, props) {\n            pushBuiltInComponentStackInDEV(task, \"Suspense\");\n            var parentBoundary = task.blockedBoundary;\n            var parentSegment = task.blockedSegment; // Each time we enter a suspense boundary, we split out into a new segment for\n            // the fallback so that we can later replace that segment with the content.\n            // This also lets us split out the main content even if it doesn't suspend,\n            // in case it ends up generating a large subtree of content.\n            var fallback = props.fallback;\n            var content = props.children;\n            var fallbackAbortSet = new Set();\n            var newBoundary = createSuspenseBoundary(request, fallbackAbortSet);\n            var insertionIndex = parentSegment.chunks.length; // The children of the boundary segment is actually the fallback.\n            var boundarySegment = createPendingSegment(request, insertionIndex, newBoundary, parentSegment.formatContext, false, false);\n            parentSegment.children.push(boundarySegment); // The parentSegment has a child Segment at this index so we reset the lastPushedText marker on the parent\n            parentSegment.lastPushedText = false; // This segment is the actual child content. We can start rendering that immediately.\n            var contentRootSegment = createPendingSegment(request, 0, null, parentSegment.formatContext, false, false); // We mark the root segment as having its parent flushed. It's not really flushed but there is\n            // no parent segment so there's nothing to wait on.\n            contentRootSegment.parentFlushed = true; // Currently this is running synchronously. We could instead schedule this to pingedTasks.\n            // I suspect that there might be some efficiency benefits from not creating the suspended task\n            // and instead just using the stack if possible.\n            // TODO: Call this directly instead of messing with saving and restoring contexts.\n            // We can reuse the current context and task to render the content immediately without\n            // context switching. We just need to temporarily switch which boundary and which segment\n            // we're writing to. If something suspends, it'll spawn new suspended task with that context.\n            task.blockedBoundary = newBoundary;\n            task.blockedSegment = contentRootSegment;\n            {\n                setCurrentlyRenderingBoundaryResourcesTarget(request.resources, newBoundary.resources);\n            }\n            try {\n                // We use the safe form because we don't handle suspending here. Only error handling.\n                renderNode(request, task, content);\n                pushSegmentFinale(contentRootSegment.chunks, request.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);\n                contentRootSegment.status = COMPLETED;\n                queueCompletedSegment(newBoundary, contentRootSegment);\n                if (newBoundary.pendingTasks === 0) {\n                    // This must have been the last segment we were waiting on. This boundary is now complete.\n                    // Therefore we won't need the fallback. We early return so that we don't have to create\n                    // the fallback.\n                    popComponentStackInDEV(task);\n                    return;\n                }\n            } catch (error) {\n                contentRootSegment.status = ERRORED;\n                newBoundary.forceClientRender = true;\n                newBoundary.errorDigest = logRecoverableError(request, error);\n                {\n                    captureBoundaryErrorDetailsDev(newBoundary, error);\n                }\n            // We don't need to schedule any task because we know the parent has written yet.\n            // We do need to fallthrough to create the fallback though.\n            } finally{\n                {\n                    setCurrentlyRenderingBoundaryResourcesTarget(request.resources, parentBoundary ? parentBoundary.resources : null);\n                }\n                task.blockedBoundary = parentBoundary;\n                task.blockedSegment = parentSegment;\n            } // We create suspended task for the fallback because we don't want to actually work\n            // on it yet in case we finish the main content, so we queue for later.\n            var suspendedFallbackTask = createTask(request, null, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);\n            {\n                suspendedFallbackTask.componentStack = task.componentStack;\n            }\n            // on preparing fallbacks if we don't have any more main content to task on.\n            request.pingedTasks.push(suspendedFallbackTask);\n            popComponentStackInDEV(task);\n        }\n        function renderHostElement(request, task, type, props) {\n            pushBuiltInComponentStackInDEV(task, type);\n            var segment = task.blockedSegment;\n            var children = pushStartInstance(segment.chunks, type, props, request.resources, request.responseState, segment.formatContext, segment.lastPushedText);\n            segment.lastPushedText = false;\n            var prevContext = segment.formatContext;\n            segment.formatContext = getChildFormatContext(prevContext, type, props); // We use the non-destructive form because if something suspends, we still\n            // need to pop back up and finish this subtree of HTML.\n            renderNode(request, task, children); // We expect that errors will fatal the whole task and that we don't need\n            // the correct context. Therefore this is not in a finally.\n            segment.formatContext = prevContext;\n            pushEndInstance(segment.chunks, type, props, request.responseState, prevContext);\n            segment.lastPushedText = false;\n            popComponentStackInDEV(task);\n        }\n        function shouldConstruct(Component) {\n            return Component.prototype && Component.prototype.isReactComponent;\n        }\n        function renderWithHooks(request, task, prevThenableState, Component, props, secondArg) {\n            var componentIdentity = {};\n            prepareToUseHooks(task, componentIdentity, prevThenableState);\n            var result = Component(props, secondArg);\n            return finishHooks(Component, props, result, secondArg);\n        }\n        function finishClassComponent(request, task, instance, Component, props) {\n            var nextChildren = instance.render();\n            {\n                if (instance.props !== props) {\n                    if (!didWarnAboutReassigningProps) {\n                        error(\"It looks like %s is reassigning its own `this.props` while rendering. \" + \"This is not supported and can lead to confusing bugs.\", getComponentNameFromType(Component) || \"a component\");\n                    }\n                    didWarnAboutReassigningProps = true;\n                }\n            }\n            {\n                var childContextTypes = Component.childContextTypes;\n                if (childContextTypes !== null && childContextTypes !== undefined) {\n                    var previousContext = task.legacyContext;\n                    var mergedContext = processChildContext(instance, Component, previousContext, childContextTypes);\n                    task.legacyContext = mergedContext;\n                    renderNodeDestructive(request, task, null, nextChildren);\n                    task.legacyContext = previousContext;\n                    return;\n                }\n            }\n            renderNodeDestructive(request, task, null, nextChildren);\n        }\n        function renderClassComponent(request, task, Component, props) {\n            pushClassComponentStackInDEV(task, Component);\n            var maskedContext = getMaskedContext(Component, task.legacyContext);\n            var instance = constructClassInstance(Component, props, maskedContext);\n            mountClassInstance(instance, Component, props, maskedContext);\n            finishClassComponent(request, task, instance, Component, props);\n            popComponentStackInDEV(task);\n        }\n        var didWarnAboutBadClass = {};\n        var didWarnAboutModulePatternComponent = {};\n        var didWarnAboutContextTypeOnFunctionComponent = {};\n        var didWarnAboutGetDerivedStateOnFunctionComponent = {};\n        var didWarnAboutReassigningProps = false;\n        var didWarnAboutDefaultPropsOnFunctionComponent = {};\n        var didWarnAboutGenerators = false;\n        var didWarnAboutMaps = false;\n        var hasWarnedAboutUsingContextAsConsumer = false; // This would typically be a function component but we still support module pattern\n        // components for some reason.\n        function renderIndeterminateComponent(request, task, prevThenableState, Component, props) {\n            var legacyContext;\n            {\n                legacyContext = getMaskedContext(Component, task.legacyContext);\n            }\n            pushFunctionComponentStackInDEV(task, Component);\n            {\n                if (Component.prototype && typeof Component.prototype.render === \"function\") {\n                    var componentName = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutBadClass[componentName]) {\n                        error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + \"This is likely to cause errors. Change %s to extend React.Component instead.\", componentName, componentName);\n                        didWarnAboutBadClass[componentName] = true;\n                    }\n                }\n            }\n            var value = renderWithHooks(request, task, prevThenableState, Component, props, legacyContext);\n            var hasId = checkDidRenderIdHook();\n            {\n                // Support for module components is deprecated and is removed behind a flag.\n                // Whether or not it would crash later, we want to show a good message in DEV first.\n                if (typeof value === \"object\" && value !== null && typeof value.render === \"function\" && value.$$typeof === undefined) {\n                    var _componentName = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutModulePatternComponent[_componentName]) {\n                        error(\"The <%s /> component appears to be a function component that returns a class instance. \" + \"Change %s to a class that extends React.Component instead. \" + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + \"cannot be called with `new` by React.\", _componentName, _componentName, _componentName);\n                        didWarnAboutModulePatternComponent[_componentName] = true;\n                    }\n                }\n            }\n            if (// Eventually we'll delete this branch altogether.\n            typeof value === \"object\" && value !== null && typeof value.render === \"function\" && value.$$typeof === undefined) {\n                {\n                    var _componentName2 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutModulePatternComponent[_componentName2]) {\n                        error(\"The <%s /> component appears to be a function component that returns a class instance. \" + \"Change %s to a class that extends React.Component instead. \" + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + \"cannot be called with `new` by React.\", _componentName2, _componentName2, _componentName2);\n                        didWarnAboutModulePatternComponent[_componentName2] = true;\n                    }\n                }\n                mountClassInstance(value, Component, props, legacyContext);\n                finishClassComponent(request, task, value, Component, props);\n            } else {\n                {\n                    validateFunctionComponentInDev(Component);\n                }\n                // the previous task every again, so we can use the destructive recursive form.\n                if (hasId) {\n                    // This component materialized an id. We treat this as its own level, with\n                    // a single \"child\" slot.\n                    var prevTreeContext = task.treeContext;\n                    var totalChildren = 1;\n                    var index = 0;\n                    task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);\n                    try {\n                        renderNodeDestructive(request, task, null, value);\n                    } finally{\n                        task.treeContext = prevTreeContext;\n                    }\n                } else {\n                    renderNodeDestructive(request, task, null, value);\n                }\n            }\n            popComponentStackInDEV(task);\n        }\n        function validateFunctionComponentInDev(Component) {\n            {\n                if (Component) {\n                    if (Component.childContextTypes) {\n                        error(\"%s(...): childContextTypes cannot be defined on a function component.\", Component.displayName || Component.name || \"Component\");\n                    }\n                }\n                if (Component.defaultProps !== undefined) {\n                    var componentName = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {\n                        error(\"%s: Support for defaultProps will be removed from function components \" + \"in a future major release. Use JavaScript default parameters instead.\", componentName);\n                        didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;\n                    }\n                }\n                if (typeof Component.getDerivedStateFromProps === \"function\") {\n                    var _componentName3 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {\n                        error(\"%s: Function components do not support getDerivedStateFromProps.\", _componentName3);\n                        didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;\n                    }\n                }\n                if (typeof Component.contextType === \"object\" && Component.contextType !== null) {\n                    var _componentName4 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {\n                        error(\"%s: Function components do not support contextType.\", _componentName4);\n                        didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;\n                    }\n                }\n            }\n        }\n        function resolveDefaultProps(Component, baseProps) {\n            if (Component && Component.defaultProps) {\n                // Resolve default props. Taken from ReactElement\n                var props = assign({}, baseProps);\n                var defaultProps = Component.defaultProps;\n                for(var propName in defaultProps){\n                    if (props[propName] === undefined) {\n                        props[propName] = defaultProps[propName];\n                    }\n                }\n                return props;\n            }\n            return baseProps;\n        }\n        function renderForwardRef(request, task, prevThenableState, type, props, ref) {\n            pushFunctionComponentStackInDEV(task, type.render);\n            var children = renderWithHooks(request, task, prevThenableState, type.render, props, ref);\n            var hasId = checkDidRenderIdHook();\n            if (hasId) {\n                // This component materialized an id. We treat this as its own level, with\n                // a single \"child\" slot.\n                var prevTreeContext = task.treeContext;\n                var totalChildren = 1;\n                var index = 0;\n                task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);\n                try {\n                    renderNodeDestructive(request, task, null, children);\n                } finally{\n                    task.treeContext = prevTreeContext;\n                }\n            } else {\n                renderNodeDestructive(request, task, null, children);\n            }\n            popComponentStackInDEV(task);\n        }\n        function renderMemo(request, task, prevThenableState, type, props, ref) {\n            var innerType = type.type;\n            var resolvedProps = resolveDefaultProps(innerType, props);\n            renderElement(request, task, prevThenableState, innerType, resolvedProps, ref);\n        }\n        function renderContextConsumer(request, task, context, props) {\n            // The logic below for Context differs depending on PROD or DEV mode. In\n            // DEV mode, we create a separate object for Context.Consumer that acts\n            // like a proxy to Context. This proxy object adds unnecessary code in PROD\n            // so we use the old behaviour (Context.Consumer references Context) to\n            // reduce size and overhead. The separate object references context via\n            // a property called \"_context\", which also gives us the ability to check\n            // in DEV mode if this property exists or not and warn if it does not.\n            {\n                if (context._context === undefined) {\n                    // This may be because it's a Context (rather than a Consumer).\n                    // Or it may be because it's older React where they're the same thing.\n                    // We only want to warn if we're sure it's a new React.\n                    if (context !== context.Consumer) {\n                        if (!hasWarnedAboutUsingContextAsConsumer) {\n                            hasWarnedAboutUsingContextAsConsumer = true;\n                            error(\"Rendering <Context> directly is not supported and will be removed in \" + \"a future major release. Did you mean to render <Context.Consumer> instead?\");\n                        }\n                    }\n                } else {\n                    context = context._context;\n                }\n            }\n            var render = props.children;\n            {\n                if (typeof render !== \"function\") {\n                    error(\"A context consumer was rendered with multiple children, or a child \" + \"that isn't a function. A context consumer expects a single child \" + \"that is a function. If you did pass a function, make sure there \" + \"is no trailing or leading whitespace around it.\");\n                }\n            }\n            var newValue = readContext$1(context);\n            var newChildren = render(newValue);\n            renderNodeDestructive(request, task, null, newChildren);\n        }\n        function renderContextProvider(request, task, type, props) {\n            var context = type._context;\n            var value = props.value;\n            var children = props.children;\n            var prevSnapshot;\n            {\n                prevSnapshot = task.context;\n            }\n            task.context = pushProvider(context, value);\n            renderNodeDestructive(request, task, null, children);\n            task.context = popProvider(context);\n            {\n                if (prevSnapshot !== task.context) {\n                    error(\"Popping the context provider did not return back to the original snapshot. This is a bug in React.\");\n                }\n            }\n        }\n        function renderLazyComponent(request, task, prevThenableState, lazyComponent, props, ref) {\n            pushBuiltInComponentStackInDEV(task, \"Lazy\");\n            var payload = lazyComponent._payload;\n            var init = lazyComponent._init;\n            var Component = init(payload);\n            var resolvedProps = resolveDefaultProps(Component, props);\n            renderElement(request, task, prevThenableState, Component, resolvedProps, ref);\n            popComponentStackInDEV(task);\n        }\n        function renderOffscreen(request, task, props) {\n            var mode = props.mode;\n            if (mode === \"hidden\") ;\n            else {\n                // A visible Offscreen boundary is treated exactly like a fragment: a\n                // pure indirection.\n                renderNodeDestructive(request, task, null, props.children);\n            }\n        }\n        function renderElement(request, task, prevThenableState, type, props, ref) {\n            if (typeof type === \"function\") {\n                if (shouldConstruct(type)) {\n                    renderClassComponent(request, task, type, props);\n                    return;\n                } else {\n                    renderIndeterminateComponent(request, task, prevThenableState, type, props);\n                    return;\n                }\n            }\n            if (typeof type === \"string\") {\n                renderHostElement(request, task, type, props);\n                return;\n            }\n            switch(type){\n                // LegacyHidden acts the same as a fragment. This only works because we\n                // currently assume that every instance of LegacyHidden is accompanied by a\n                // host component wrapper. In the hidden mode, the host component is given a\n                // `hidden` attribute, which ensures that the initial HTML is not visible.\n                // To support the use of LegacyHidden as a true fragment, without an extra\n                // DOM node, we would have to hide the initial HTML in some other way.\n                // TODO: Delete in LegacyHidden. It's an unstable API only used in the\n                // www build. As a migration step, we could add a special prop to Offscreen\n                // that simulates the old behavior (no hiding, no change to effects).\n                case REACT_LEGACY_HIDDEN_TYPE:\n                case REACT_DEBUG_TRACING_MODE_TYPE:\n                case REACT_STRICT_MODE_TYPE:\n                case REACT_PROFILER_TYPE:\n                case REACT_FRAGMENT_TYPE:\n                    {\n                        renderNodeDestructive(request, task, null, props.children);\n                        return;\n                    }\n                case REACT_OFFSCREEN_TYPE:\n                    {\n                        renderOffscreen(request, task, props);\n                        return;\n                    }\n                case REACT_SUSPENSE_LIST_TYPE:\n                    {\n                        pushBuiltInComponentStackInDEV(task, \"SuspenseList\"); // TODO: SuspenseList should control the boundaries.\n                        renderNodeDestructive(request, task, null, props.children);\n                        popComponentStackInDEV(task);\n                        return;\n                    }\n                case REACT_SCOPE_TYPE:\n                    {\n                        throw new Error(\"ReactDOMServer does not yet support scope components.\");\n                    }\n                case REACT_SUSPENSE_TYPE:\n                    {\n                        {\n                            renderSuspenseBoundary(request, task, props);\n                        }\n                        return;\n                    }\n            }\n            if (typeof type === \"object\" && type !== null) {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        {\n                            renderForwardRef(request, task, prevThenableState, type, props, ref);\n                            return;\n                        }\n                    case REACT_MEMO_TYPE:\n                        {\n                            renderMemo(request, task, prevThenableState, type, props, ref);\n                            return;\n                        }\n                    case REACT_PROVIDER_TYPE:\n                        {\n                            renderContextProvider(request, task, type, props);\n                            return;\n                        }\n                    case REACT_CONTEXT_TYPE:\n                        {\n                            renderContextConsumer(request, task, type, props);\n                            return;\n                        }\n                    case REACT_LAZY_TYPE:\n                        {\n                            renderLazyComponent(request, task, prevThenableState, type, props);\n                            return;\n                        }\n                }\n            }\n            var info = \"\";\n            {\n                if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                    info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and \" + \"named imports.\";\n                }\n            }\n            throw new Error(\"Element type is invalid: expected a string (for built-in \" + \"components) or a class/function (for composite components) \" + (\"but got: \" + (type == null ? type : typeof type) + \".\" + info));\n        } // $FlowFixMe[missing-local-annot]\n        function validateIterable(iterable, iteratorFn) {\n            {\n                // We don't support rendering Generators because it's a mutation.\n                // See https://github.com/facebook/react/issues/12995\n                if (typeof Symbol === \"function\" && iterable[Symbol.toStringTag] === \"Generator\") {\n                    if (!didWarnAboutGenerators) {\n                        error(\"Using Generators as children is unsupported and will likely yield \" + \"unexpected results because enumerating a generator mutates it. \" + \"You may convert it to an array with `Array.from()` or the \" + \"`[...spread]` operator before rendering. Keep in mind \" + \"you might need to polyfill these features for older browsers.\");\n                    }\n                    didWarnAboutGenerators = true;\n                } // Warn about using Maps as children\n                if (iterable.entries === iteratorFn) {\n                    if (!didWarnAboutMaps) {\n                        error(\"Using Maps as children is not supported. \" + \"Use an array of keyed ReactElements instead.\");\n                    }\n                    didWarnAboutMaps = true;\n                }\n            }\n        }\n        function renderNodeDestructive(request, task, // always null, except when called by retryTask.\n        prevThenableState, node) {\n            {\n                // In Dev we wrap renderNodeDestructiveImpl in a try / catch so we can capture\n                // a component stack at the right place in the tree. We don't do this in renderNode\n                // becuase it is not called at every layer of the tree and we may lose frames\n                try {\n                    return renderNodeDestructiveImpl(request, task, prevThenableState, node);\n                } catch (x) {\n                    if (typeof x === \"object\" && x !== null && typeof x.then === \"function\") ;\n                    else {\n                        // This is an error, stash the component stack if it is null.\n                        lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV();\n                    } // rethrow so normal suspense logic can handle thrown value accordingly\n                    throw x;\n                }\n            }\n        } // This function by it self renders a node and consumes the task by mutating it\n        // to update the current execution state.\n        function renderNodeDestructiveImpl(request, task, prevThenableState, node) {\n            // Stash the node we're working on. We'll pick up from this task in case\n            // something suspends.\n            task.node = node; // Handle object types\n            if (typeof node === \"object\" && node !== null) {\n                switch(node.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        {\n                            var element = node;\n                            var type = element.type;\n                            var props = element.props;\n                            var ref = element.ref;\n                            renderElement(request, task, prevThenableState, type, props, ref);\n                            return;\n                        }\n                    case REACT_PORTAL_TYPE:\n                        throw new Error(\"Portals are not currently supported by the server renderer. \" + \"Render them conditionally so that they only appear on the client render.\");\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyNode = node;\n                            var payload = lazyNode._payload;\n                            var init = lazyNode._init;\n                            var resolvedNode;\n                            {\n                                try {\n                                    resolvedNode = init(payload);\n                                } catch (x) {\n                                    if (typeof x === \"object\" && x !== null && typeof x.then === \"function\") {\n                                        // this Lazy initializer is suspending. push a temporary frame onto the stack so it can be\n                                        // popped off in spawnNewSuspendedTask. This aligns stack behavior between Lazy in element position\n                                        // vs Component position. We do not want the frame for Errors so we exclusively do this in\n                                        // the wakeable branch\n                                        pushBuiltInComponentStackInDEV(task, \"Lazy\");\n                                    }\n                                    throw x;\n                                }\n                            }\n                            renderNodeDestructive(request, task, null, resolvedNode);\n                            return;\n                        }\n                }\n                if (isArray(node)) {\n                    renderChildrenArray(request, task, node);\n                    return;\n                }\n                var iteratorFn = getIteratorFn(node);\n                if (iteratorFn) {\n                    {\n                        validateIterable(node, iteratorFn);\n                    }\n                    var iterator = iteratorFn.call(node);\n                    if (iterator) {\n                        // We need to know how many total children are in this set, so that we\n                        // can allocate enough id slots to acommodate them. So we must exhaust\n                        // the iterator before we start recursively rendering the children.\n                        // TODO: This is not great but I think it's inherent to the id\n                        // generation algorithm.\n                        var step = iterator.next(); // If there are not entries, we need to push an empty so we start by checking that.\n                        if (!step.done) {\n                            var children = [];\n                            do {\n                                children.push(step.value);\n                                step = iterator.next();\n                            }while (!step.done);\n                            renderChildrenArray(request, task, children);\n                            return;\n                        }\n                        return;\n                    }\n                } // Usables are a valid React node type. When React encounters a Usable in\n                // a child position, it unwraps it using the same algorithm as `use`. For\n                // example, for promises, React will throw an exception to unwind the\n                // stack, then replay the component once the promise resolves.\n                //\n                // A difference from `use` is that React will keep unwrapping the value\n                // until it reaches a non-Usable type.\n                //\n                // e.g. Usable<Usable<Usable<T>>> should resolve to T\n                var maybeUsable = node;\n                if (typeof maybeUsable.then === \"function\") {\n                    var thenable = maybeUsable;\n                    return renderNodeDestructiveImpl(request, task, null, unwrapThenable(thenable));\n                }\n                if (maybeUsable.$$typeof === REACT_CONTEXT_TYPE || maybeUsable.$$typeof === REACT_SERVER_CONTEXT_TYPE) {\n                    var context = maybeUsable;\n                    return renderNodeDestructiveImpl(request, task, null, readContext$1(context));\n                } // $FlowFixMe[method-unbinding]\n                var childString = Object.prototype.toString.call(node);\n                throw new Error(\"Objects are not valid as a React child (found: \" + (childString === \"[object Object]\" ? \"object with keys {\" + Object.keys(node).join(\", \") + \"}\" : childString) + \"). \" + \"If you meant to render a collection of children, use an array \" + \"instead.\");\n            }\n            if (typeof node === \"string\") {\n                var segment = task.blockedSegment;\n                segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, node, request.responseState, segment.lastPushedText);\n                return;\n            }\n            if (typeof node === \"number\") {\n                var _segment = task.blockedSegment;\n                _segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, \"\" + node, request.responseState, _segment.lastPushedText);\n                return;\n            }\n            {\n                if (typeof node === \"function\") {\n                    error(\"Functions are not valid as a React child. This may happen if \" + \"you return a Component instead of <Component /> from render. \" + \"Or maybe you meant to call this function rather than return it.\");\n                }\n            }\n        }\n        function renderChildrenArray(request, task, children) {\n            var totalChildren = children.length;\n            for(var i = 0; i < totalChildren; i++){\n                var prevTreeContext = task.treeContext;\n                task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i);\n                try {\n                    // We need to use the non-destructive form so that we can safely pop back\n                    // up and render the sibling if something suspends.\n                    renderNode(request, task, children[i]);\n                } finally{\n                    task.treeContext = prevTreeContext;\n                }\n            }\n        }\n        function spawnNewSuspendedTask(request, task, thenableState, x) {\n            // Something suspended, we'll need to create a new segment and resolve it later.\n            var segment = task.blockedSegment;\n            var insertionIndex = segment.chunks.length;\n            var newSegment = createPendingSegment(request, insertionIndex, null, segment.formatContext, segment.lastPushedText, true);\n            segment.children.push(newSegment); // Reset lastPushedText for current Segment since the new Segment \"consumed\" it\n            segment.lastPushedText = false;\n            var newTask = createTask(request, thenableState, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);\n            {\n                if (task.componentStack !== null) {\n                    // We pop one task off the stack because the node that suspended will be tried again,\n                    // which will add it back onto the stack.\n                    newTask.componentStack = task.componentStack.parent;\n                }\n            }\n            var ping = newTask.ping;\n            x.then(ping, ping);\n        } // This is a non-destructive form of rendering a node. If it suspends it spawns\n        // a new task and restores the context of this task to what it was before.\n        function renderNode(request, task, node) {\n            // Store how much we've pushed at this point so we can reset it in case something\n            // suspended partially through writing something.\n            var segment = task.blockedSegment;\n            var childrenLength = segment.children.length;\n            var chunkLength = segment.chunks.length; // Snapshot the current context in case something throws to interrupt the\n            // process.\n            var previousFormatContext = task.blockedSegment.formatContext;\n            var previousLegacyContext = task.legacyContext;\n            var previousContext = task.context;\n            var previousComponentStack = null;\n            {\n                previousComponentStack = task.componentStack;\n            }\n            try {\n                return renderNodeDestructive(request, task, null, node);\n            } catch (thrownValue) {\n                resetHooksState(); // Reset the write pointers to where we started.\n                segment.children.length = childrenLength;\n                segment.chunks.length = chunkLength;\n                var x = thrownValue === SuspenseException ? // reasons, the rest of the Suspense implementation expects the thrown\n                // value to be a thenable, because before `use` existed that was the\n                // (unstable) API for suspending. This implementation detail can change\n                // later, once we deprecate the old API in favor of `use`.\n                getSuspendedThenable() : thrownValue; // $FlowFixMe[method-unbinding]\n                if (typeof x === \"object\" && x !== null && typeof x.then === \"function\") {\n                    var wakeable = x;\n                    var thenableState = getThenableStateAfterSuspending();\n                    spawnNewSuspendedTask(request, task, thenableState, wakeable); // Restore the context. We assume that this will be restored by the inner\n                    // functions in case nothing throws so we don't use \"finally\" here.\n                    task.blockedSegment.formatContext = previousFormatContext;\n                    task.legacyContext = previousLegacyContext;\n                    task.context = previousContext; // Restore all active ReactContexts to what they were before.\n                    switchContext(previousContext);\n                    {\n                        task.componentStack = previousComponentStack;\n                    }\n                    return;\n                } else {\n                    // Restore the context. We assume that this will be restored by the inner\n                    // functions in case nothing throws so we don't use \"finally\" here.\n                    task.blockedSegment.formatContext = previousFormatContext;\n                    task.legacyContext = previousLegacyContext;\n                    task.context = previousContext; // Restore all active ReactContexts to what they were before.\n                    switchContext(previousContext);\n                    {\n                        task.componentStack = previousComponentStack;\n                    }\n                    // Let's terminate the rest of the tree and don't render any siblings.\n                    throw x;\n                }\n            }\n        }\n        function erroredTask(request, boundary, segment, error) {\n            // Report the error to a global handler.\n            var errorDigest = logRecoverableError(request, error);\n            if (boundary === null) {\n                fatalError(request, error);\n            } else {\n                boundary.pendingTasks--;\n                if (!boundary.forceClientRender) {\n                    boundary.forceClientRender = true;\n                    boundary.errorDigest = errorDigest;\n                    {\n                        captureBoundaryErrorDetailsDev(boundary, error);\n                    }\n                    // so we can flush it, if the parent already flushed.\n                    if (boundary.parentFlushed) {\n                        // We don't have a preference where in the queue this goes since it's likely\n                        // to error on the client anyway. However, intentionally client-rendered\n                        // boundaries should be flushed earlier so that they can start on the client.\n                        // We reuse the same queue for errors.\n                        request.clientRenderedBoundaries.push(boundary);\n                    }\n                }\n            }\n            request.allPendingTasks--;\n            if (request.allPendingTasks === 0) {\n                var onAllReady = request.onAllReady;\n                onAllReady();\n            }\n        }\n        function abortTaskSoft(task) {\n            // This aborts task without aborting the parent boundary that it blocks.\n            // It's used for when we didn't need this task to complete the tree.\n            // If task was needed, then it should use abortTask instead.\n            var request = this;\n            var boundary = task.blockedBoundary;\n            var segment = task.blockedSegment;\n            segment.status = ABORTED;\n            finishedTask(request, boundary, segment);\n        }\n        function abortTask(task, request, error) {\n            // This aborts the task and aborts the parent that it blocks, putting it into\n            // client rendered mode.\n            var boundary = task.blockedBoundary;\n            var segment = task.blockedSegment;\n            segment.status = ABORTED;\n            if (boundary === null) {\n                request.allPendingTasks--; // We didn't complete the root so we have nothing to show. We can close\n                // the request;\n                if (request.status !== CLOSING && request.status !== CLOSED) {\n                    logRecoverableError(request, error);\n                    fatalError(request, error);\n                }\n            } else {\n                boundary.pendingTasks--;\n                if (!boundary.forceClientRender) {\n                    boundary.forceClientRender = true;\n                    boundary.errorDigest = request.onError(error);\n                    {\n                        var errorPrefix = \"The server did not finish this Suspense boundary: \";\n                        var errorMessage;\n                        if (error && typeof error.message === \"string\") {\n                            errorMessage = errorPrefix + error.message;\n                        } else {\n                            // eslint-disable-next-line react-internal/safe-string-coercion\n                            errorMessage = errorPrefix + String(error);\n                        }\n                        var previousTaskInDev = currentTaskInDEV;\n                        currentTaskInDEV = task;\n                        try {\n                            captureBoundaryErrorDetailsDev(boundary, errorMessage);\n                        } finally{\n                            currentTaskInDEV = previousTaskInDev;\n                        }\n                    }\n                    if (boundary.parentFlushed) {\n                        request.clientRenderedBoundaries.push(boundary);\n                    }\n                } // If this boundary was still pending then we haven't already cancelled its fallbacks.\n                // We'll need to abort the fallbacks, which will also error that parent boundary.\n                boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {\n                    return abortTask(fallbackTask, request, error);\n                });\n                boundary.fallbackAbortableTasks.clear();\n                request.allPendingTasks--;\n                if (request.allPendingTasks === 0) {\n                    var onAllReady = request.onAllReady;\n                    onAllReady();\n                }\n            }\n        }\n        function queueCompletedSegment(boundary, segment) {\n            if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {\n                // This is an empty segment. There's nothing to write, so we can instead transfer the ID\n                // to the child. That way any existing references point to the child.\n                var childSegment = segment.children[0];\n                childSegment.id = segment.id;\n                childSegment.parentFlushed = true;\n                if (childSegment.status === COMPLETED) {\n                    queueCompletedSegment(boundary, childSegment);\n                }\n            } else {\n                var completedSegments = boundary.completedSegments;\n                completedSegments.push(segment);\n            }\n        }\n        function finishedTask(request, boundary, segment) {\n            if (boundary === null) {\n                if (segment.parentFlushed) {\n                    if (request.completedRootSegment !== null) {\n                        throw new Error(\"There can only be one root segment. This is a bug in React.\");\n                    }\n                    request.completedRootSegment = segment;\n                }\n                request.pendingRootTasks--;\n                if (request.pendingRootTasks === 0) {\n                    // We have completed the shell so the shell can't error anymore.\n                    request.onShellError = noop;\n                    var onShellReady = request.onShellReady;\n                    onShellReady();\n                }\n            } else {\n                boundary.pendingTasks--;\n                if (boundary.forceClientRender) ;\n                else if (boundary.pendingTasks === 0) {\n                    // This must have been the last segment we were waiting on. This boundary is now complete.\n                    if (segment.parentFlushed) {\n                        // Our parent segment already flushed, so we need to schedule this segment to be emitted.\n                        // If it is a segment that was aborted, we'll write other content instead so we don't need\n                        // to emit it.\n                        if (segment.status === COMPLETED) {\n                            queueCompletedSegment(boundary, segment);\n                        }\n                    }\n                    if (boundary.parentFlushed) {\n                        // The segment might be part of a segment that didn't flush yet, but if the boundary's\n                        // parent flushed, we need to schedule the boundary to be emitted.\n                        request.completedBoundaries.push(boundary);\n                    } // We can now cancel any pending task on the fallback since we won't need to show it anymore.\n                    // This needs to happen after we read the parentFlushed flags because aborting can finish\n                    // work which can trigger user code, which can start flushing, which can change those flags.\n                    boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request);\n                    boundary.fallbackAbortableTasks.clear();\n                } else {\n                    if (segment.parentFlushed) {\n                        // Our parent already flushed, so we need to schedule this segment to be emitted.\n                        // If it is a segment that was aborted, we'll write other content instead so we don't need\n                        // to emit it.\n                        if (segment.status === COMPLETED) {\n                            queueCompletedSegment(boundary, segment);\n                            var completedSegments = boundary.completedSegments;\n                            if (completedSegments.length === 1) {\n                                // This is the first time since we last flushed that we completed anything.\n                                // We can schedule this boundary to emit its partially completed segments early\n                                // in case the parent has already been flushed.\n                                if (boundary.parentFlushed) {\n                                    request.partialBoundaries.push(boundary);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            request.allPendingTasks--;\n            if (request.allPendingTasks === 0) {\n                // This needs to be called at the very end so that we can synchronously write the result\n                // in the callback if needed.\n                var onAllReady = request.onAllReady;\n                onAllReady();\n            }\n        }\n        function retryTask(request, task) {\n            {\n                var blockedBoundary = task.blockedBoundary;\n                setCurrentlyRenderingBoundaryResourcesTarget(request.resources, blockedBoundary ? blockedBoundary.resources : null);\n            }\n            var segment = task.blockedSegment;\n            if (segment.status !== PENDING) {\n                // We completed this by other means before we had a chance to retry it.\n                return;\n            } // We restore the context to what it was when we suspended.\n            // We don't restore it after we leave because it's likely that we'll end up\n            // needing a very similar context soon again.\n            switchContext(task.context);\n            var prevTaskInDEV = null;\n            {\n                prevTaskInDEV = currentTaskInDEV;\n                currentTaskInDEV = task;\n            }\n            var childrenLength = segment.children.length;\n            var chunkLength = segment.chunks.length;\n            try {\n                // We call the destructive form that mutates this task. That way if something\n                // suspends again, we can reuse the same task instead of spawning a new one.\n                // Reset the task's thenable state before continuing, so that if a later\n                // component suspends we can reuse the same task object. If the same\n                // component suspends again, the thenable state will be restored.\n                var prevThenableState = task.thenableState;\n                task.thenableState = null;\n                renderNodeDestructive(request, task, prevThenableState, task.node);\n                pushSegmentFinale(segment.chunks, request.responseState, segment.lastPushedText, segment.textEmbedded);\n                task.abortSet.delete(task);\n                segment.status = COMPLETED;\n                finishedTask(request, task.blockedBoundary, segment);\n            } catch (thrownValue) {\n                resetHooksState(); // Reset the write pointers to where we started.\n                segment.children.length = childrenLength;\n                segment.chunks.length = chunkLength;\n                var x = thrownValue === SuspenseException ? // reasons, the rest of the Suspense implementation expects the thrown\n                // value to be a thenable, because before `use` existed that was the\n                // (unstable) API for suspending. This implementation detail can change\n                // later, once we deprecate the old API in favor of `use`.\n                getSuspendedThenable() : thrownValue; // $FlowFixMe[method-unbinding]\n                if (typeof x === \"object\" && x !== null && typeof x.then === \"function\") {\n                    // Something suspended again, let's pick it back up later.\n                    var ping = task.ping;\n                    x.then(ping, ping);\n                    task.thenableState = getThenableStateAfterSuspending();\n                } else {\n                    task.abortSet.delete(task);\n                    segment.status = ERRORED;\n                    erroredTask(request, task.blockedBoundary, segment, x);\n                }\n            } finally{\n                {\n                    setCurrentlyRenderingBoundaryResourcesTarget(request.resources, null);\n                }\n                {\n                    currentTaskInDEV = prevTaskInDEV;\n                }\n            }\n        }\n        function performWork(request) {\n            if (request.status === CLOSED) {\n                return;\n            }\n            var prevContext = getActiveContext();\n            var prevDispatcher = ReactCurrentDispatcher.current;\n            ReactCurrentDispatcher.current = HooksDispatcher;\n            var prevCacheDispatcher;\n            {\n                prevCacheDispatcher = ReactCurrentCache.current;\n                ReactCurrentCache.current = DefaultCacheDispatcher;\n            }\n            var prevRequest = currentRequest;\n            currentRequest = request;\n            var prevGetCurrentStackImpl;\n            {\n                prevGetCurrentStackImpl = ReactDebugCurrentFrame.getCurrentStack;\n                ReactDebugCurrentFrame.getCurrentStack = getCurrentStackInDEV;\n            }\n            var prevResponseState = currentResponseState;\n            setCurrentResponseState(request.responseState);\n            try {\n                var pingedTasks = request.pingedTasks;\n                var i;\n                for(i = 0; i < pingedTasks.length; i++){\n                    var task = pingedTasks[i];\n                    retryTask(request, task);\n                }\n                pingedTasks.splice(0, i);\n                if (request.destination !== null) {\n                    flushCompletedQueues(request, request.destination);\n                }\n            } catch (error) {\n                logRecoverableError(request, error);\n                fatalError(request, error);\n            } finally{\n                setCurrentResponseState(prevResponseState);\n                ReactCurrentDispatcher.current = prevDispatcher;\n                {\n                    ReactCurrentCache.current = prevCacheDispatcher;\n                }\n                {\n                    ReactDebugCurrentFrame.getCurrentStack = prevGetCurrentStackImpl;\n                }\n                if (prevDispatcher === HooksDispatcher) {\n                    // This means that we were in a reentrant work loop. This could happen\n                    // in a renderer that supports synchronous work like renderToString,\n                    // when it's called from within another renderer.\n                    // Normally we don't bother switching the contexts to their root/default\n                    // values when leaving because we'll likely need the same or similar\n                    // context again. However, when we're inside a synchronous loop like this\n                    // we'll to restore the context to what it was before returning.\n                    switchContext(prevContext);\n                }\n                currentRequest = prevRequest;\n            }\n        }\n        function flushSubtree(request, destination, segment) {\n            segment.parentFlushed = true;\n            switch(segment.status){\n                case PENDING:\n                    {\n                        // We're emitting a placeholder for this segment to be filled in later.\n                        // Therefore we'll need to assign it an ID - to refer to it by.\n                        var segmentID = segment.id = request.nextSegmentId++; // When this segment finally completes it won't be embedded in text since it will flush separately\n                        segment.lastPushedText = false;\n                        segment.textEmbedded = false;\n                        return writePlaceholder(destination, request.responseState, segmentID);\n                    }\n                case COMPLETED:\n                    {\n                        segment.status = FLUSHED;\n                        var r = true;\n                        var chunks = segment.chunks;\n                        var chunkIdx = 0;\n                        var children = segment.children;\n                        for(var childIdx = 0; childIdx < children.length; childIdx++){\n                            var nextChild = children[childIdx]; // Write all the chunks up until the next child.\n                            for(; chunkIdx < nextChild.index; chunkIdx++){\n                                writeChunk(destination, chunks[chunkIdx]);\n                            }\n                            r = flushSegment(request, destination, nextChild);\n                        } // Finally just write all the remaining chunks\n                        for(; chunkIdx < chunks.length - 1; chunkIdx++){\n                            writeChunk(destination, chunks[chunkIdx]);\n                        }\n                        if (chunkIdx < chunks.length) {\n                            r = writeChunkAndReturn(destination, chunks[chunkIdx]);\n                        }\n                        return r;\n                    }\n                default:\n                    {\n                        throw new Error(\"Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.\");\n                    }\n            }\n        }\n        function flushSegment(request, destination, segment) {\n            var boundary = segment.boundary;\n            if (boundary === null) {\n                // Not a suspense boundary.\n                return flushSubtree(request, destination, segment);\n            }\n            boundary.parentFlushed = true; // This segment is a Suspense boundary. We need to decide whether to\n            // emit the content or the fallback now.\n            if (boundary.forceClientRender) {\n                // Emit a client rendered suspense boundary wrapper.\n                // We never queue the inner boundary so we'll never emit its content or partial segments.\n                writeStartClientRenderedSuspenseBoundary(destination, request.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack); // Flush the fallback.\n                flushSubtree(request, destination, segment);\n                return writeEndClientRenderedSuspenseBoundary(destination);\n            } else if (boundary.pendingTasks > 0) {\n                // This boundary is still loading. Emit a pending suspense boundary wrapper.\n                // Assign an ID to refer to the future content by.\n                boundary.rootSegmentID = request.nextSegmentId++;\n                if (boundary.completedSegments.length > 0) {\n                    // If this is at least partially complete, we can queue it to be partially emitted early.\n                    request.partialBoundaries.push(boundary);\n                } /// This is the first time we should have referenced this ID.\n                var id = boundary.id = assignSuspenseBoundaryID(request.responseState);\n                writeStartPendingSuspenseBoundary(destination, request.responseState, id); // Flush the fallback.\n                flushSubtree(request, destination, segment);\n                return writeEndPendingSuspenseBoundary(destination);\n            } else if (boundary.byteSize > request.progressiveChunkSize) {\n                // This boundary is large and will be emitted separately so that we can progressively show\n                // other content. We add it to the queue during the flush because we have to ensure that\n                // the parent flushes first so that there's something to inject it into.\n                // We also have to make sure that it's emitted into the queue in a deterministic slot.\n                // I.e. we can't insert it here when it completes.\n                // Assign an ID to refer to the future content by.\n                boundary.rootSegmentID = request.nextSegmentId++;\n                request.completedBoundaries.push(boundary); // Emit a pending rendered suspense boundary wrapper.\n                writeStartPendingSuspenseBoundary(destination, request.responseState, boundary.id); // Flush the fallback.\n                flushSubtree(request, destination, segment);\n                return writeEndPendingSuspenseBoundary(destination);\n            } else {\n                {\n                    hoistResources(request.resources, boundary.resources);\n                }\n                writeStartCompletedSuspenseBoundary(destination);\n                var completedSegments = boundary.completedSegments;\n                if (completedSegments.length !== 1) {\n                    throw new Error(\"A previously unvisited boundary must have exactly one root segment. This is a bug in React.\");\n                }\n                var contentSegment = completedSegments[0];\n                flushSegment(request, destination, contentSegment);\n                return writeEndCompletedSuspenseBoundary(destination);\n            }\n        }\n        function flushClientRenderedBoundary(request, destination, boundary) {\n            return writeClientRenderBoundaryInstruction(destination, request.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);\n        }\n        function flushSegmentContainer(request, destination, segment) {\n            writeStartSegment(destination, request.responseState, segment.formatContext, segment.id);\n            flushSegment(request, destination, segment);\n            return writeEndSegment(destination, segment.formatContext);\n        }\n        function flushCompletedBoundary(request, destination, boundary) {\n            {\n                setCurrentlyRenderingBoundaryResourcesTarget(request.resources, boundary.resources);\n            }\n            var completedSegments = boundary.completedSegments;\n            var i = 0;\n            for(; i < completedSegments.length; i++){\n                var segment = completedSegments[i];\n                flushPartiallyCompletedSegment(request, destination, boundary, segment);\n            }\n            completedSegments.length = 0;\n            {\n                writeResourcesForBoundary(destination, boundary.resources, request.responseState);\n            }\n            return writeCompletedBoundaryInstruction(destination, request.responseState, boundary.id, boundary.rootSegmentID, boundary.resources);\n        }\n        function flushPartialBoundary(request, destination, boundary) {\n            {\n                setCurrentlyRenderingBoundaryResourcesTarget(request.resources, boundary.resources);\n            }\n            var completedSegments = boundary.completedSegments;\n            var i = 0;\n            for(; i < completedSegments.length; i++){\n                var segment = completedSegments[i];\n                if (!flushPartiallyCompletedSegment(request, destination, boundary, segment)) {\n                    i++;\n                    completedSegments.splice(0, i); // Only write as much as the buffer wants. Something higher priority\n                    // might want to write later.\n                    return false;\n                }\n            }\n            completedSegments.splice(0, i);\n            {\n                // The way this is structured we only write resources for partial boundaries\n                // if there is no backpressure. Later before we complete the boundary we\n                // will write resources regardless of backpressure before we emit the\n                // completion instruction\n                return writeResourcesForBoundary(destination, boundary.resources, request.responseState);\n            }\n        }\n        function flushPartiallyCompletedSegment(request, destination, boundary, segment) {\n            if (segment.status === FLUSHED) {\n                // We've already flushed this inline.\n                return true;\n            }\n            var segmentID = segment.id;\n            if (segmentID === -1) {\n                // This segment wasn't previously referred to. This happens at the root of\n                // a boundary. We make kind of a leap here and assume this is the root.\n                var rootSegmentID = segment.id = boundary.rootSegmentID;\n                if (rootSegmentID === -1) {\n                    throw new Error(\"A root segment ID must have been assigned by now. This is a bug in React.\");\n                }\n                return flushSegmentContainer(request, destination, segment);\n            } else {\n                flushSegmentContainer(request, destination, segment);\n                return writeCompletedSegmentInstruction(destination, request.responseState, segmentID);\n            }\n        }\n        function flushCompletedQueues(request, destination) {\n            beginWriting();\n            try {\n                // The structure of this is to go through each queue one by one and write\n                // until the sink tells us to stop. When we should stop, we still finish writing\n                // that item fully and then yield. At that point we remove the already completed\n                // items up until the point we completed them.\n                var i;\n                var completedRootSegment = request.completedRootSegment;\n                if (completedRootSegment !== null) {\n                    if (request.pendingRootTasks === 0) {\n                        if (enableFloat) {\n                            writePreamble(destination, request.resources, request.responseState, request.allPendingTasks === 0);\n                        }\n                        flushSegment(request, destination, completedRootSegment);\n                        request.completedRootSegment = null;\n                        writeCompletedRoot(destination, request.responseState);\n                    } else {\n                        // We haven't flushed the root yet so we don't need to check any other branches further down\n                        return;\n                    }\n                } else if (request.pendingRootTasks > 0) {\n                    // We have not yet flushed the root segment so we early return\n                    return;\n                }\n                if (enableFloat) {\n                    writeHoistables(destination, request.resources, request.responseState);\n                } // We emit client rendering instructions for already emitted boundaries first.\n                // This is so that we can signal to the client to start client rendering them as\n                // soon as possible.\n                var clientRenderedBoundaries = request.clientRenderedBoundaries;\n                for(i = 0; i < clientRenderedBoundaries.length; i++){\n                    var boundary = clientRenderedBoundaries[i];\n                    if (!flushClientRenderedBoundary(request, destination, boundary)) {\n                        request.destination = null;\n                        i++;\n                        clientRenderedBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                clientRenderedBoundaries.splice(0, i); // Next we emit any complete boundaries. It's better to favor boundaries\n                // that are completely done since we can actually show them, than it is to emit\n                // any individual segments from a partially complete boundary.\n                var completedBoundaries = request.completedBoundaries;\n                for(i = 0; i < completedBoundaries.length; i++){\n                    var _boundary = completedBoundaries[i];\n                    if (!flushCompletedBoundary(request, destination, _boundary)) {\n                        request.destination = null;\n                        i++;\n                        completedBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                completedBoundaries.splice(0, i); // Allow anything written so far to flush to the underlying sink before\n                // we continue with lower priorities.\n                completeWriting(destination);\n                beginWriting(destination); // TODO: Here we'll emit data used by hydration.\n                // Next we emit any segments of any boundaries that are partially complete\n                // but not deeply complete.\n                var partialBoundaries = request.partialBoundaries;\n                for(i = 0; i < partialBoundaries.length; i++){\n                    var _boundary2 = partialBoundaries[i];\n                    if (!flushPartialBoundary(request, destination, _boundary2)) {\n                        request.destination = null;\n                        i++;\n                        partialBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                partialBoundaries.splice(0, i); // Next we check the completed boundaries again. This may have had\n                // boundaries added to it in case they were too larged to be inlined.\n                // New ones might be added in this loop.\n                var largeBoundaries = request.completedBoundaries;\n                for(i = 0; i < largeBoundaries.length; i++){\n                    var _boundary3 = largeBoundaries[i];\n                    if (!flushCompletedBoundary(request, destination, _boundary3)) {\n                        request.destination = null;\n                        i++;\n                        largeBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                largeBoundaries.splice(0, i);\n            } finally{\n                if (request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0 // We don't need to check any partially completed segments because\n                ) {\n                    request.flushScheduled = false;\n                    {\n                        writePostamble(destination, request.responseState);\n                    }\n                    completeWriting(destination);\n                    flushBuffered(destination);\n                    {\n                        if (request.abortableTasks.size !== 0) {\n                            error(\"There was still abortable task at the root when we closed. This is a bug in React.\");\n                        }\n                    }\n                    close(destination);\n                } else {\n                    completeWriting(destination);\n                    flushBuffered(destination);\n                }\n            }\n        }\n        function startWork(request) {\n            request.flushScheduled = request.destination !== null;\n            {\n                scheduleWork(function() {\n                    return requestStorage.run(request, performWork, request);\n                });\n            }\n        }\n        function enqueueFlush(request) {\n            if (request.flushScheduled === false && // If there are pinged tasks we are going to flush anyway after work completes\n            request.pingedTasks.length === 0 && // If there is no destination there is nothing we can flush to. A flush will\n            // happen when we start flowing again\n            request.destination !== null) {\n                var destination = request.destination;\n                request.flushScheduled = true;\n                scheduleWork(function() {\n                    return flushCompletedQueues(request, destination);\n                });\n            }\n        }\n        function startFlowing(request, destination) {\n            if (request.status === CLOSING) {\n                request.status = CLOSED;\n                closeWithError(destination, request.fatalError);\n                return;\n            }\n            if (request.status === CLOSED) {\n                return;\n            }\n            if (request.destination !== null) {\n                // We're already flowing.\n                return;\n            }\n            request.destination = destination;\n            try {\n                flushCompletedQueues(request, destination);\n            } catch (error) {\n                logRecoverableError(request, error);\n                fatalError(request, error);\n            }\n        } // This is called to early terminate a request. It puts all pending boundaries in client rendered state.\n        function abort(request, reason) {\n            try {\n                var abortableTasks = request.abortableTasks;\n                if (abortableTasks.size > 0) {\n                    var error = reason === undefined ? new Error(\"The render was aborted by the server without a reason.\") : reason;\n                    abortableTasks.forEach(function(task) {\n                        return abortTask(task, request, error);\n                    });\n                    abortableTasks.clear();\n                }\n                if (request.destination !== null) {\n                    flushCompletedQueues(request, request.destination);\n                }\n            } catch (error) {\n                logRecoverableError(request, error);\n                fatalError(request, error);\n            }\n        }\n        function flushResources(request) {\n            enqueueFlush(request);\n        }\n        function getResources(request) {\n            return request.resources;\n        }\n        function createDrainHandler(destination, request) {\n            return function() {\n                return startFlowing(request, destination);\n            };\n        }\n        function createAbortHandler(request, reason) {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            return function() {\n                return abort(request, new Error(reason));\n            };\n        }\n        function createRequestImpl(children, options) {\n            var resources = createResources();\n            return createRequest(children, resources, createResponseState(resources, options ? options.identifierPrefix : undefined, options ? options.nonce : undefined, options ? options.bootstrapScriptContent : undefined, options ? options.bootstrapScripts : undefined, options ? options.bootstrapModules : undefined, options ? options.unstable_externalRuntimeSrc : undefined), createRootFormatContext(options ? options.namespaceURI : undefined), options ? options.progressiveChunkSize : undefined, options ? options.onError : undefined, options ? options.onAllReady : undefined, options ? options.onShellReady : undefined, options ? options.onShellError : undefined, undefined);\n        }\n        function renderToPipeableStream(children, options) {\n            var request = createRequestImpl(children, options);\n            var hasStartedFlowing = false;\n            startWork(request);\n            return {\n                pipe: function(destination) {\n                    if (hasStartedFlowing) {\n                        throw new Error(\"React currently only supports piping to one writable stream.\");\n                    }\n                    hasStartedFlowing = true;\n                    startFlowing(request, destination);\n                    destination.on(\"drain\", createDrainHandler(destination, request));\n                    destination.on(\"error\", createAbortHandler(request, \"The destination stream errored while writing data.\"));\n                    destination.on(\"close\", createAbortHandler(request, \"The destination stream closed early.\"));\n                    return destination;\n                },\n                abort: function(reason) {\n                    abort(request, reason);\n                }\n            };\n        }\n        exports.renderToPipeableStream = renderToPipeableStream;\n        exports.version = ReactVersion;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLXNlcnZlci5ub2RlLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztDQVFDLEdBRUQ7QUFFQSxJQUFJQSxJQUFxQyxFQUFFO0lBQ3hDO1FBQ0g7UUFFQSxJQUFJQyxRQUFRQyxtQkFBT0EsQ0FBQyx3RkFBMEI7UUFDOUMsSUFBSUMsT0FBT0QsbUJBQU9BLENBQUM7UUFDbkIsSUFBSUUsY0FBY0YsbUJBQU9BLENBQUM7UUFDMUIsSUFBSUcsV0FBV0gsbUJBQU9BLENBQUM7UUFFdkIsSUFBSUksZUFBZTtRQUVuQixJQUFJQyx1QkFBdUJOLE1BQU1PLGtEQUFrRDtRQUVuRiwrQ0FBK0M7UUFDL0MsRUFBRTtRQUNGLDhEQUE4RDtRQUM5RCxxQ0FBcUM7UUFFckMsU0FBU0MsS0FBS0MsTUFBTTtZQUNsQjtnQkFDRTtvQkFDRSxJQUFLLElBQUlDLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsT0FBTyxJQUFJQyxNQUFNSixPQUFPLElBQUlBLE9BQU8sSUFBSSxJQUFJSyxPQUFPLEdBQUdBLE9BQU9MLE1BQU1LLE9BQVE7d0JBQzFHRixJQUFJLENBQUNFLE9BQU8sRUFBRSxHQUFHSixTQUFTLENBQUNJLEtBQUs7b0JBQ2xDO29CQUVBQyxhQUFhLFFBQVFQLFFBQVFJO2dCQUMvQjtZQUNGO1FBQ0Y7UUFDQSxTQUFTSSxNQUFNUixNQUFNO1lBQ25CO2dCQUNFO29CQUNFLElBQUssSUFBSVMsUUFBUVAsVUFBVUMsTUFBTSxFQUFFQyxPQUFPLElBQUlDLE1BQU1JLFFBQVEsSUFBSUEsUUFBUSxJQUFJLElBQUlDLFFBQVEsR0FBR0EsUUFBUUQsT0FBT0MsUUFBUzt3QkFDakhOLElBQUksQ0FBQ00sUUFBUSxFQUFFLEdBQUdSLFNBQVMsQ0FBQ1EsTUFBTTtvQkFDcEM7b0JBRUFILGFBQWEsU0FBU1AsUUFBUUk7Z0JBQ2hDO1lBQ0Y7UUFDRjtRQUVBLFNBQVNHLGFBQWFJLEtBQUssRUFBRVgsTUFBTSxFQUFFSSxJQUFJO1lBQ3ZDLG1EQUFtRDtZQUNuRCw2Q0FBNkM7WUFDN0M7Z0JBQ0UsSUFBSVEseUJBQXlCZixxQkFBcUJlLHNCQUFzQjtnQkFDeEUsSUFBSUMsUUFBUUQsdUJBQXVCRSxnQkFBZ0I7Z0JBRW5ELElBQUlELFVBQVUsSUFBSTtvQkFDaEJiLFVBQVU7b0JBQ1ZJLE9BQU9BLEtBQUtXLE1BQU0sQ0FBQzt3QkFBQ0Y7cUJBQU07Z0JBQzVCLEVBQUUsK0RBQStEO2dCQUdqRSxJQUFJRyxpQkFBaUJaLEtBQUthLEdBQUcsQ0FBQyxTQUFVQyxJQUFJO29CQUMxQyxPQUFPQyxPQUFPRDtnQkFDaEIsSUFBSSwrQ0FBK0M7Z0JBRW5ERixlQUFlSSxPQUFPLENBQUMsY0FBY3BCLFNBQVMsb0VBQW9FO2dCQUNsSCw2REFBNkQ7Z0JBQzdELGdFQUFnRTtnQkFFaEVxQixTQUFTQyxTQUFTLENBQUNDLEtBQUssQ0FBQ0MsSUFBSSxDQUFDQyxPQUFPLENBQUNkLE1BQU0sRUFBRWMsU0FBU1Q7WUFDekQ7UUFDRjtRQUVBLFNBQVNVLGFBQWFDLFFBQVE7WUFDNUJDLGFBQWFEO1FBQ2Y7UUFDQSxTQUFTRSxjQUFjQyxXQUFXO1lBQ2hDLG9EQUFvRDtZQUNwRCwrQ0FBK0M7WUFDL0MsSUFBSSxPQUFPQSxZQUFZQyxLQUFLLEtBQUssWUFBWTtnQkFDM0MsNEVBQTRFO2dCQUM1RSx3REFBd0Q7Z0JBQ3hERCxZQUFZQyxLQUFLO1lBQ25CO1FBQ0Y7UUFDQSxJQUFJQyxZQUFZO1FBQ2hCLElBQUlDLGNBQWM7UUFDbEIsSUFBSUMsZUFBZTtRQUNuQixJQUFJQywyQkFBMkI7UUFDL0IsU0FBU0MsYUFBYU4sV0FBVztZQUMvQkcsY0FBYyxJQUFJSSxXQUFXTDtZQUM3QkUsZUFBZTtZQUNmQywyQkFBMkI7UUFDN0I7UUFFQSxTQUFTRyxpQkFBaUJSLFdBQVcsRUFBRVMsV0FBVztZQUNoRCxJQUFJQSxZQUFZcEMsTUFBTSxLQUFLLEdBQUc7Z0JBQzVCO1lBQ0YsRUFBRSx1REFBdUQ7WUFHekQsSUFBSW9DLFlBQVlwQyxNQUFNLEdBQUcsSUFBSTZCLFdBQVc7Z0JBQ3RDLElBQUlFLGVBQWUsR0FBRztvQkFDcEJNLG1CQUFtQlYsYUFBYUcsWUFBWVEsUUFBUSxDQUFDLEdBQUdQO29CQUN4REQsY0FBYyxJQUFJSSxXQUFXTDtvQkFDN0JFLGVBQWU7Z0JBQ2pCO2dCQUVBTSxtQkFBbUJWLGFBQWFZLFlBQVlDLE1BQU0sQ0FBQ0o7Z0JBQ25EO1lBQ0Y7WUFFQSxJQUFJSyxTQUFTWDtZQUViLElBQUlDLGVBQWUsR0FBRztnQkFDcEJVLFNBQVNYLFlBQVlRLFFBQVEsQ0FBQ1A7WUFDaEM7WUFFQSxJQUFJVyx3QkFBd0JILFlBQVlJLFVBQVUsQ0FBQ1AsYUFBYUssU0FDNURHLE9BQU9GLHNCQUFzQkUsSUFBSSxFQUNqQ0MsVUFBVUgsc0JBQXNCRyxPQUFPO1lBRTNDZCxnQkFBZ0JjO1lBRWhCLElBQUlELE9BQU9SLFlBQVlwQyxNQUFNLEVBQUU7Z0JBQzdCcUMsbUJBQW1CVixhQUFhRyxZQUFZUSxRQUFRLENBQUMsR0FBR1A7Z0JBQ3hERCxjQUFjLElBQUlJLFdBQVdMO2dCQUM3QkUsZUFBZVEsWUFBWUksVUFBVSxDQUFDUCxZQUFZVSxLQUFLLENBQUNGLE9BQU9kLGFBQWFlLE9BQU87WUFDckY7WUFFQSxJQUFJZCxpQkFBaUJGLFdBQVc7Z0JBQzlCUSxtQkFBbUJWLGFBQWFHO2dCQUNoQ0EsY0FBYyxJQUFJSSxXQUFXTDtnQkFDN0JFLGVBQWU7WUFDakI7UUFDRjtRQUVBLFNBQVNnQixlQUFlcEIsV0FBVyxFQUFFcUIsS0FBSztZQUN4QyxJQUFJQSxNQUFNQyxVQUFVLEtBQUssR0FBRztnQkFDMUI7WUFDRjtZQUVBLElBQUlELE1BQU1DLFVBQVUsR0FBR3BCLFdBQVc7Z0JBQ2hDO29CQUNFLElBQUlxQix1QkFBdUJBLG9CQUFvQkMsR0FBRyxDQUFDSCxRQUFRO3dCQUN6RDNDLE1BQU0sNkVBQTZFLHNLQUFzSztvQkFDM1A7Z0JBQ0Y7Z0JBQ0EsK0RBQStEO2dCQUMvRCwyQ0FBMkM7Z0JBRzNDLElBQUkwQixlQUFlLEdBQUc7b0JBQ3BCTSxtQkFBbUJWLGFBQWFHLFlBQVlRLFFBQVEsQ0FBQyxHQUFHUDtvQkFDeERELGNBQWMsSUFBSUksV0FBV0w7b0JBQzdCRSxlQUFlO2dCQUNqQjtnQkFFQU0sbUJBQW1CVixhQUFhcUI7Z0JBQ2hDO1lBQ0Y7WUFFQSxJQUFJSSxlQUFlSjtZQUNuQixJQUFJSyxpQkFBaUJ2QixZQUFZOUIsTUFBTSxHQUFHK0I7WUFFMUMsSUFBSXNCLGlCQUFpQkQsYUFBYUgsVUFBVSxFQUFFO2dCQUM1QyxxRUFBcUU7Z0JBQ3JFLGdEQUFnRDtnQkFDaEQsSUFBSUksbUJBQW1CLEdBQUc7b0JBQ3hCLDRDQUE0QztvQkFDNUNoQixtQkFBbUJWLGFBQWFHO2dCQUNsQyxPQUFPO29CQUNMLCtEQUErRDtvQkFDL0QsaUJBQWlCO29CQUNqQkEsWUFBWXdCLEdBQUcsQ0FBQ0YsYUFBYWQsUUFBUSxDQUFDLEdBQUdlLGlCQUFpQnRCO29CQUMxREEsZ0JBQWdCc0I7b0JBQ2hCaEIsbUJBQW1CVixhQUFhRztvQkFDaENzQixlQUFlQSxhQUFhZCxRQUFRLENBQUNlO2dCQUN2QztnQkFFQXZCLGNBQWMsSUFBSUksV0FBV0w7Z0JBQzdCRSxlQUFlO1lBQ2pCO1lBRUFELFlBQVl3QixHQUFHLENBQUNGLGNBQWNyQjtZQUM5QkEsZ0JBQWdCcUIsYUFBYUgsVUFBVTtZQUV2QyxJQUFJbEIsaUJBQWlCRixXQUFXO2dCQUM5QlEsbUJBQW1CVixhQUFhRztnQkFDaENBLGNBQWMsSUFBSUksV0FBV0w7Z0JBQzdCRSxlQUFlO1lBQ2pCO1FBQ0Y7UUFFQSxTQUFTd0IsV0FBVzVCLFdBQVcsRUFBRXFCLEtBQUs7WUFDcEMsSUFBSSxPQUFPQSxVQUFVLFVBQVU7Z0JBQzdCYixpQkFBaUJSLGFBQWFxQjtZQUNoQyxPQUFPO2dCQUNMRCxlQUFlcEIsYUFBYXFCO1lBQzlCO1FBQ0Y7UUFFQSxTQUFTWCxtQkFBbUJWLFdBQVcsRUFBRTZCLElBQUk7WUFDM0MsSUFBSUMscUJBQXFCOUIsWUFBWStCLEtBQUssQ0FBQ0Y7WUFDM0N4QiwyQkFBMkJBLDRCQUE0QnlCO1FBQ3pEO1FBRUEsU0FBU0Usb0JBQW9CaEMsV0FBVyxFQUFFcUIsS0FBSztZQUM3Q08sV0FBVzVCLGFBQWFxQjtZQUN4QixPQUFPaEI7UUFDVDtRQUNBLFNBQVM0QixnQkFBZ0JqQyxXQUFXO1lBQ2xDLElBQUlHLGVBQWVDLGVBQWUsR0FBRztnQkFDbkNKLFlBQVkrQixLQUFLLENBQUM1QixZQUFZUSxRQUFRLENBQUMsR0FBR1A7WUFDNUM7WUFFQUQsY0FBYztZQUNkQyxlQUFlO1lBQ2ZDLDJCQUEyQjtRQUM3QjtRQUNBLFNBQVM2QixNQUFNbEMsV0FBVztZQUN4QkEsWUFBWW1DLEdBQUc7UUFDakI7UUFDQSxJQUFJdkIsY0FBYyxJQUFJakQsS0FBS3lFLFdBQVc7UUFDdEMsU0FBU0MsY0FBY0MsT0FBTztZQUM1QixPQUFPQTtRQUNUO1FBQ0EsSUFBSWYsc0JBQXNCLElBQUlnQjtRQUM5QixTQUFTQyx5QkFBeUJGLE9BQU87WUFDdkMsSUFBSUcsbUJBQW1CN0IsWUFBWUMsTUFBTSxDQUFDeUI7WUFFMUM7Z0JBQ0UsSUFBSWYscUJBQXFCO29CQUN2QkEsb0JBQW9CbUIsR0FBRyxDQUFDRDtnQkFDMUI7WUFDRjtZQUVBLE9BQU9BO1FBQ1Q7UUFDQSxTQUFTRSxzQkFBc0JGLGdCQUFnQjtZQUM3QyxPQUFPQSxpQkFBaUJwRSxNQUFNLEdBQUc2QixZQUFZdUMsaUJBQWlCdEIsS0FBSyxLQUFLc0I7UUFDMUU7UUFDQSxTQUFTRyxlQUFlNUMsV0FBVyxFQUFFdEIsS0FBSztZQUN4QyxpR0FBaUc7WUFDakdzQixZQUFZNkMsT0FBTyxDQUFDbkU7UUFDdEI7UUFFQSxTQUFTb0UsZ0JBQWdCQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsS0FBSztZQUN0QyxJQUFJRCxPQUFPRCxLQUFLO2dCQUNkRyxPQUFPQyxjQUFjLENBQUNKLEtBQUtDLEtBQUs7b0JBQzlCQyxPQUFPQTtvQkFDUEcsWUFBWTtvQkFDWkMsY0FBYztvQkFDZEMsVUFBVTtnQkFDWjtZQUNGLE9BQU87Z0JBQ0xQLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHQztZQUNiO1lBRUEsT0FBT0Y7UUFDVDtRQUVBLElBQUlRLFNBQVNMLE9BQU9LLE1BQU07UUFFMUI7Ozs7Ozs7O0NBUUMsR0FDRCxzRkFBc0Y7UUFDdEYsU0FBU0MsU0FBU1AsS0FBSztZQUNyQjtnQkFDRSxtRUFBbUU7Z0JBQ25FLElBQUlRLGlCQUFpQixPQUFPQyxXQUFXLGNBQWNBLE9BQU9DLFdBQVc7Z0JBQ3ZFLElBQUlDLE9BQU9ILGtCQUFrQlIsS0FBSyxDQUFDUyxPQUFPQyxXQUFXLENBQUMsSUFBSVYsTUFBTVksV0FBVyxDQUFDQyxJQUFJLElBQUksVUFBVSxrQ0FBa0M7Z0JBRWhJLE9BQU9GO1lBQ1Q7UUFDRixFQUFFLHNGQUFzRjtRQUd4RixTQUFTRyxrQkFBa0JkLEtBQUs7WUFDOUI7Z0JBQ0UsSUFBSTtvQkFDRmUsbUJBQW1CZjtvQkFDbkIsT0FBTztnQkFDVCxFQUFFLE9BQU9nQixHQUFHO29CQUNWLE9BQU87Z0JBQ1Q7WUFDRjtRQUNGO1FBRUEsU0FBU0QsbUJBQW1CZixLQUFLO1lBQy9CLDJFQUEyRTtZQUMzRSw2RUFBNkU7WUFDN0UseUVBQXlFO1lBQ3pFLHFFQUFxRTtZQUNyRSxFQUFFO1lBQ0YsOEVBQThFO1lBQzlFLDBFQUEwRTtZQUMxRSw4RUFBOEU7WUFDOUUsMkVBQTJFO1lBQzNFLDhFQUE4RTtZQUM5RSxvRUFBb0U7WUFDcEUsRUFBRTtZQUNGLDRFQUE0RTtZQUM1RSx5RUFBeUU7WUFDekUsRUFBRTtZQUNGLDBFQUEwRTtZQUMxRSwyRUFBMkU7WUFDM0UseUVBQXlFO1lBQ3pFLDZFQUE2RTtZQUM3RSxzRUFBc0U7WUFDdEUsb0RBQW9EO1lBQ3BELEVBQUU7WUFDRiwrREFBK0Q7WUFDL0QsT0FBTyxLQUFLQTtRQUNkO1FBRUEsU0FBU2lCLDZCQUE2QmpCLEtBQUssRUFBRWtCLGFBQWE7WUFDeEQ7Z0JBQ0UsSUFBSUosa0JBQWtCZCxRQUFRO29CQUM1QnZFLE1BQU0sMkRBQTJELHdFQUF3RXlGLGVBQWVYLFNBQVNQO29CQUVqSyxPQUFPZSxtQkFBbUJmLFFBQVEsd0RBQXdEO2dCQUM1RjtZQUNGO1FBQ0Y7UUFDQSxTQUFTbUIsK0JBQStCbkIsS0FBSyxFQUFFb0IsUUFBUTtZQUNyRDtnQkFDRSxJQUFJTixrQkFBa0JkLFFBQVE7b0JBQzVCdkUsTUFBTSw4REFBOEQsd0VBQXdFMkYsVUFBVWIsU0FBU1A7b0JBRS9KLE9BQU9lLG1CQUFtQmYsUUFBUSx3REFBd0Q7Z0JBQzVGO1lBQ0Y7UUFDRjtRQUNBLFNBQVNxQix3QkFBd0JyQixLQUFLO1lBQ3BDO2dCQUNFLElBQUljLGtCQUFrQmQsUUFBUTtvQkFDNUJ2RSxNQUFNLGtFQUFrRSx3RUFBd0U4RSxTQUFTUDtvQkFFekosT0FBT2UsbUJBQW1CZixRQUFRLHdEQUF3RDtnQkFDNUY7WUFDRjtRQUNGO1FBRUEsZ0ZBQWdGO1FBQ2hGLElBQUlzQixjQUFjLE1BQU0sMkVBQTJFO1FBRW5HLCtCQUErQjtRQUMvQixJQUFJQyxpQkFBaUJ0QixPQUFPMUQsU0FBUyxDQUFDZ0YsY0FBYztRQUVwRCwwQkFBMEIsR0FFMUIsSUFBSUMsNEJBQTRCO1FBQ2hDLHlCQUF5QixHQUV6QixJQUFJQyxzQkFBc0JELDRCQUE0QjtRQUN0RCxJQUFJRSw2QkFBNkIsSUFBSUMsT0FBTyxPQUFPSCw0QkFBNEIsT0FBT0Msc0JBQXNCO1FBQzVHLElBQUlHLDRCQUE0QixDQUFDO1FBQ2pDLElBQUlDLDhCQUE4QixDQUFDO1FBQ25DLFNBQVNDLG9CQUFvQlosYUFBYTtZQUN4QyxJQUFJSyxlQUFlOUUsSUFBSSxDQUFDb0YsNkJBQTZCWCxnQkFBZ0I7Z0JBQ25FLE9BQU87WUFDVDtZQUVBLElBQUlLLGVBQWU5RSxJQUFJLENBQUNtRiwyQkFBMkJWLGdCQUFnQjtnQkFDakUsT0FBTztZQUNUO1lBRUEsSUFBSVEsMkJBQTJCSyxJQUFJLENBQUNiLGdCQUFnQjtnQkFDbERXLDJCQUEyQixDQUFDWCxjQUFjLEdBQUc7Z0JBQzdDLE9BQU87WUFDVDtZQUVBVSx5QkFBeUIsQ0FBQ1YsY0FBYyxHQUFHO1lBRTNDO2dCQUNFekYsTUFBTSxnQ0FBZ0N5RjtZQUN4QztZQUVBLE9BQU87UUFDVDtRQUVBOztDQUVDLEdBQ0QsSUFBSWMsa0JBQWtCLElBQUkxQyxJQUFJO1lBQUM7WUFBMkI7WUFBZTtZQUFxQjtZQUFvQjtZQUFvQjtZQUFXO1lBQWdCO1lBQW1CO1lBQWU7WUFBVztZQUFRO1lBQVk7WUFBZ0I7WUFBYztZQUFnQjtZQUFhO1lBQVk7WUFBVztZQUFjO1lBQWU7WUFBZ0I7WUFBYztZQUFpQjtZQUFrQjtZQUFtQjtZQUFjO1lBQWE7WUFBYztZQUFXO1lBQVM7WUFBVztZQUFTO1lBQVc7WUFBVTtZQUFVO1lBQVE7WUFDN2hCO1lBQWdCO1lBQWU7WUFBbUI7WUFBb0I7WUFBb0I7WUFBaUI7WUFBZTtZQUMxSDtZQUNBO1lBQW1CO1lBQWdCO1lBQTZCO1lBQVU7WUFBVTtZQUFjO1lBQWtCO1lBQWU7WUFBa0I7WUFBZ0I7WUFBZ0I7WUFBb0I7WUFBYTtZQUFpQjtZQUFpQztZQUFpQjtZQUFzQjtZQUF5QjtZQUFxQjtZQUFpQjtZQUFjO1lBQWtCO1lBQXNCO1lBQW9CO1NBQWtCO1FBQzFjLFNBQVMyQyxpQkFBa0JwQixJQUFJO1lBQzdCLE9BQU9tQixnQkFBZ0J6RCxHQUFHLENBQUNzQztRQUM3QjtRQUVBLElBQUlxQixVQUFVLElBQUlDLElBQUk7WUFBQztnQkFBQztnQkFBaUI7YUFBaUI7WUFBRTtnQkFBQztnQkFBVzthQUFNO1lBQUU7Z0JBQUM7Z0JBQWE7YUFBYTtZQUMzRztnQkFBQztnQkFBZTthQUFjO1lBQzlCLGlEQUFpRDtZQUNqRDtnQkFBQztnQkFBZ0I7YUFBZ0I7WUFBRTtnQkFBQztnQkFBcUI7YUFBcUI7WUFBRTtnQkFBQztnQkFBYzthQUFjO1lBQUU7Z0JBQUM7Z0JBQWlCO2FBQWlCO1lBQUU7Z0JBQUM7Z0JBQWE7YUFBYTtZQUFFO2dCQUFDO2dCQUFZO2FBQVk7WUFBRTtnQkFBQztnQkFBWTthQUFZO1lBQUU7Z0JBQUM7Z0JBQXNCO2FBQXNCO1lBQUU7Z0JBQUM7Z0JBQTZCO2FBQThCO1lBQUU7Z0JBQUM7Z0JBQWdCO2FBQWdCO1lBQUU7Z0JBQUM7Z0JBQWtCO2FBQWtCO1lBQUU7Z0JBQUM7Z0JBQW9CO2FBQW9CO1lBQUU7Z0JBQUM7Z0JBQW9CO2FBQW9CO1lBQUU7Z0JBQUM7Z0JBQWU7YUFBZTtZQUFFO2dCQUFDO2dCQUFZO2FBQVk7WUFBRTtnQkFBQztnQkFBYzthQUFjO1lBQUU7Z0JBQUM7Z0JBQWdCO2FBQWdCO1lBQUU7Z0JBQUM7Z0JBQWM7YUFBYztZQUFFO2dCQUFDO2dCQUFZO2FBQVk7WUFBRTtnQkFBQztnQkFBa0I7YUFBbUI7WUFBRTtnQkFBQztnQkFBZTthQUFlO1lBQUU7Z0JBQUM7Z0JBQWE7YUFBYTtZQUFFO2dCQUFDO2dCQUFlO2FBQWU7WUFBRTtnQkFBQztnQkFBYzthQUFjO1lBQUU7Z0JBQUM7Z0JBQWE7YUFBYTtZQUFFO2dCQUFDO2dCQUE4QjthQUErQjtZQUFFO2dCQUFDO2dCQUE0QjthQUE2QjtZQUFFO2dCQUFDO2dCQUFhO2FBQWM7WUFBRTtnQkFBQztnQkFBZ0I7YUFBaUI7WUFBRTtnQkFBQztnQkFBa0I7YUFBa0I7WUFBRTtnQkFBQztnQkFBaUI7YUFBaUI7WUFBRTtnQkFBQztnQkFBaUI7YUFBaUI7WUFBRTtnQkFBQztnQkFBYTthQUFhO1lBQUU7Z0JBQUM7Z0JBQWE7YUFBYTtZQUFFO2dCQUFDO2dCQUFlO2FBQWU7WUFBRTtnQkFBQztnQkFBb0I7YUFBb0I7WUFBRTtnQkFBQztnQkFBcUI7YUFBcUI7WUFBRTtnQkFBQztnQkFBYzthQUFjO1lBQUU7Z0JBQUM7Z0JBQVk7YUFBVztZQUFFO2dCQUFDO2dCQUFpQjthQUFpQjtZQUFFO2dCQUFDO2dCQUFtQjthQUFtQjtZQUFFO2dCQUFDO2dCQUFrQjthQUFrQjtZQUFFO2dCQUFDO2dCQUFhO2FBQWE7WUFBRTtnQkFBQztnQkFBZTthQUFlO1lBQUU7Z0JBQUM7Z0JBQXlCO2FBQXlCO1lBQUU7Z0JBQUM7Z0JBQTBCO2FBQTBCO1lBQUU7Z0JBQUM7Z0JBQW1CO2FBQW1CO1lBQUU7Z0JBQUM7Z0JBQW9CO2FBQW9CO1lBQUU7Z0JB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d0JBQXdCMlQsVUFBVUEsUUFBUTFULFlBQVksR0FBRy9MLFlBQVl5ZixVQUFVQSxRQUFRZ2Esb0JBQW9CLEdBQUd6NUIsV0FBV3lmLFVBQVVBLFFBQVE5TixPQUFPLEdBQUczUixXQUFXeWYsVUFBVUEsUUFBUWlhLFVBQVUsR0FBRzE1QixXQUFXeWYsVUFBVUEsUUFBUWthLFlBQVksR0FBRzM1QixXQUFXeWYsVUFBVUEsUUFBUW1hLFlBQVksR0FBRzU1QixXQUFXQTtRQUNwcEI7UUFFQSxTQUFTK2pDLHVCQUF1Qjc3QyxRQUFRLEVBQUV1M0IsT0FBTztZQUMvQyxJQUFJQyxVQUFVbWtCLGtCQUFrQjM3QyxVQUFVdTNCO1lBQzFDLElBQUl1a0Isb0JBQW9CO1lBQ3hCVixVQUFVNWpCO1lBQ1YsT0FBTztnQkFDTHVrQixNQUFNLFNBQVVobEQsV0FBVztvQkFDekIsSUFBSStrRCxtQkFBbUI7d0JBQ3JCLE1BQU0sSUFBSXgyQixNQUFNO29CQUNsQjtvQkFFQXcyQixvQkFBb0I7b0JBQ3BCUCxhQUFhL2pCLFNBQVN6Z0M7b0JBQ3RCQSxZQUFZaWxELEVBQUUsQ0FBQyxTQUFTUCxtQkFBbUIxa0QsYUFBYXlnQztvQkFDeER6Z0MsWUFBWWlsRCxFQUFFLENBQUMsU0FBU04sbUJBQW1CbGtCLFNBQVM7b0JBQ3BEemdDLFlBQVlpbEQsRUFBRSxDQUFDLFNBQVNOLG1CQUFtQmxrQixTQUFTO29CQUNwRCxPQUFPemdDO2dCQUNUO2dCQUNBeWtELE9BQU8sU0FBVTFRLE1BQU07b0JBQ3JCMFEsTUFBTWhrQixTQUFTc1Q7Z0JBQ2pCO1lBQ0Y7UUFDRjtRQUVBbVIsOEJBQThCLEdBQUdKO1FBQ2pDSSxlQUFlLEdBQUdwbkQ7SUFDaEI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3dhaGVndXJ1LXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLXNlcnZlci5ub2RlLmRldmVsb3BtZW50LmpzP2RiNTciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtZG9tLXNlcnZlci5ub2RlLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgYXN5bmNfaG9va3MgPSByZXF1aXJlKCdhc3luY19ob29rcycpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTguMy4wLWNhbmFyeS0xYTAwMWRhYzYtMjAyMzA4MTInO1xuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuLy8gYnkgY2FsbHMgdG8gdGhlc2UgbWV0aG9kcyBieSBhIEJhYmVsIHBsdWdpbi5cbi8vXG4vLyBJbiBQUk9EIChvciBpbiBwYWNrYWdlcyB3aXRob3V0IGFjY2VzcyB0byBSZWFjdCBpbnRlcm5hbHMpLFxuLy8gdGhleSBhcmUgbGVmdCBhcyB0aGV5IGFyZSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiB3YXJuKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCd3YXJuJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVXb3JrKGNhbGxiYWNrKSB7XG4gIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG59XG5mdW5jdGlvbiBmbHVzaEJ1ZmZlcmVkKGRlc3RpbmF0aW9uKSB7XG4gIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZGF0YSB0byBzZW5kIHJpZ2h0IG5vdy5cbiAgLy8gRmx1c2ggd2hhdGV2ZXIgaXMgaW4gdGhlIGJ1ZmZlciB0byB0aGUgd2lyZS5cbiAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbi5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEJ5IGNvbnZlbnRpb24gdGhlIFpsaWIgc3RyZWFtcyBwcm92aWRlIGEgZmx1c2ggZnVuY3Rpb24gZm9yIHRoaXMgcHVycG9zZS5cbiAgICAvLyBGb3IgRXhwcmVzcywgY29tcHJlc3Npb24gbWlkZGxld2FyZSBhZGRzIHRoaXMgbWV0aG9kLlxuICAgIGRlc3RpbmF0aW9uLmZsdXNoKCk7XG4gIH1cbn1cbnZhciBWSUVXX1NJWkUgPSAyMDQ4O1xudmFyIGN1cnJlbnRWaWV3ID0gbnVsbDtcbnZhciB3cml0dGVuQnl0ZXMgPSAwO1xudmFyIGRlc3RpbmF0aW9uSGFzQ2FwYWNpdHkkMSA9IHRydWU7XG5mdW5jdGlvbiBiZWdpbldyaXRpbmcoZGVzdGluYXRpb24pIHtcbiAgY3VycmVudFZpZXcgPSBuZXcgVWludDhBcnJheShWSUVXX1NJWkUpO1xuICB3cml0dGVuQnl0ZXMgPSAwO1xuICBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5JDEgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiB3cml0ZVN0cmluZ0NodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdDaHVuaykge1xuICBpZiAoc3RyaW5nQ2h1bmsubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIG1heGltdW0gcG9zc2libGUgdmlldyBuZWVkZWQgdG8gZW5jb2RlIGVudGlyZSBzdHJpbmdcblxuXG4gIGlmIChzdHJpbmdDaHVuay5sZW5ndGggKiAzID4gVklFV19TSVpFKSB7XG4gICAgaWYgKHdyaXR0ZW5CeXRlcyA+IDApIHtcbiAgICAgIHdyaXRlVG9EZXN0aW5hdGlvbihkZXN0aW5hdGlvbiwgY3VycmVudFZpZXcuc3ViYXJyYXkoMCwgd3JpdHRlbkJ5dGVzKSk7XG4gICAgICBjdXJyZW50VmlldyA9IG5ldyBVaW50OEFycmF5KFZJRVdfU0laRSk7XG4gICAgICB3cml0dGVuQnl0ZXMgPSAwO1xuICAgIH1cblxuICAgIHdyaXRlVG9EZXN0aW5hdGlvbihkZXN0aW5hdGlvbiwgdGV4dEVuY29kZXIuZW5jb2RlKHN0cmluZ0NodW5rKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHRhcmdldCA9IGN1cnJlbnRWaWV3O1xuXG4gIGlmICh3cml0dGVuQnl0ZXMgPiAwKSB7XG4gICAgdGFyZ2V0ID0gY3VycmVudFZpZXcuc3ViYXJyYXkod3JpdHRlbkJ5dGVzKTtcbiAgfVxuXG4gIHZhciBfdGV4dEVuY29kZXIkZW5jb2RlSW4gPSB0ZXh0RW5jb2Rlci5lbmNvZGVJbnRvKHN0cmluZ0NodW5rLCB0YXJnZXQpLFxuICAgICAgcmVhZCA9IF90ZXh0RW5jb2RlciRlbmNvZGVJbi5yZWFkLFxuICAgICAgd3JpdHRlbiA9IF90ZXh0RW5jb2RlciRlbmNvZGVJbi53cml0dGVuO1xuXG4gIHdyaXR0ZW5CeXRlcyArPSB3cml0dGVuO1xuXG4gIGlmIChyZWFkIDwgc3RyaW5nQ2h1bmsubGVuZ3RoKSB7XG4gICAgd3JpdGVUb0Rlc3RpbmF0aW9uKGRlc3RpbmF0aW9uLCBjdXJyZW50Vmlldy5zdWJhcnJheSgwLCB3cml0dGVuQnl0ZXMpKTtcbiAgICBjdXJyZW50VmlldyA9IG5ldyBVaW50OEFycmF5KFZJRVdfU0laRSk7XG4gICAgd3JpdHRlbkJ5dGVzID0gdGV4dEVuY29kZXIuZW5jb2RlSW50byhzdHJpbmdDaHVuay5zbGljZShyZWFkKSwgY3VycmVudFZpZXcpLndyaXR0ZW47XG4gIH1cblxuICBpZiAod3JpdHRlbkJ5dGVzID09PSBWSUVXX1NJWkUpIHtcbiAgICB3cml0ZVRvRGVzdGluYXRpb24oZGVzdGluYXRpb24sIGN1cnJlbnRWaWV3KTtcbiAgICBjdXJyZW50VmlldyA9IG5ldyBVaW50OEFycmF5KFZJRVdfU0laRSk7XG4gICAgd3JpdHRlbkJ5dGVzID0gMDtcbiAgfVxufVxuXG5mdW5jdGlvbiB3cml0ZVZpZXdDaHVuayhkZXN0aW5hdGlvbiwgY2h1bmspIHtcbiAgaWYgKGNodW5rLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY2h1bmsuYnl0ZUxlbmd0aCA+IFZJRVdfU0laRSkge1xuICAgIHtcbiAgICAgIGlmIChwcmVjb21wdXRlZENodW5rU2V0ICYmIHByZWNvbXB1dGVkQ2h1bmtTZXQuaGFzKGNodW5rKSkge1xuICAgICAgICBlcnJvcignQSBsYXJnZSBwcmVjb21wdXRlZCBjaHVuayB3YXMgcGFzc2VkIHRvIHdyaXRlQ2h1bmsgd2l0aG91dCBiZWluZyBjb3BpZWQuJyArICcgTGFyZ2UgY2h1bmtzIGdldCBlbnF1ZXVlZCBkaXJlY3RseSBhbmQgYXJlIG5vdCBjb3BpZWQuIFRoaXMgaXMgaW5jb21wYXRpYmxlIHdpdGggcHJlY29tcHV0ZWQgY2h1bmtzIGJlY2F1c2UgeW91IGNhbm5vdCBlbnF1ZXVlIHRoZSBzYW1lIHByZWNvbXB1dGVkIGNodW5rIHR3aWNlLicgKyAnIFVzZSBcImNsb25lQ2h1bmtcIiB0byBtYWtlIGEgY29weSBvZiB0aGlzIGxhcmdlIHByZWNvbXB1dGVkIGNodW5rIGJlZm9yZSB3cml0aW5nIGl0LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfVxuICAgIH0gLy8gdGhpcyBjaHVuayBtYXkgb3ZlcmZsb3cgYSBzaW5nbGUgdmlldyB3aGljaCBpbXBsaWVzIGl0IHdhcyBub3RcbiAgICAvLyBvbmUgdGhhdCBpcyBjYWNoZWQgYnkgdGhlIHN0cmVhbWluZyByZW5kZXJlci4gV2Ugd2lsbCBlbnF1ZXVcbiAgICAvLyBpdCBkaXJlY3RseSBhbmQgZXhwZWN0IGl0IGlzIG5vdCByZS11c2VkXG5cblxuICAgIGlmICh3cml0dGVuQnl0ZXMgPiAwKSB7XG4gICAgICB3cml0ZVRvRGVzdGluYXRpb24oZGVzdGluYXRpb24sIGN1cnJlbnRWaWV3LnN1YmFycmF5KDAsIHdyaXR0ZW5CeXRlcykpO1xuICAgICAgY3VycmVudFZpZXcgPSBuZXcgVWludDhBcnJheShWSUVXX1NJWkUpO1xuICAgICAgd3JpdHRlbkJ5dGVzID0gMDtcbiAgICB9XG5cbiAgICB3cml0ZVRvRGVzdGluYXRpb24oZGVzdGluYXRpb24sIGNodW5rKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYnl0ZXNUb1dyaXRlID0gY2h1bms7XG4gIHZhciBhbGxvd2FibGVCeXRlcyA9IGN1cnJlbnRWaWV3Lmxlbmd0aCAtIHdyaXR0ZW5CeXRlcztcblxuICBpZiAoYWxsb3dhYmxlQnl0ZXMgPCBieXRlc1RvV3JpdGUuYnl0ZUxlbmd0aCkge1xuICAgIC8vIHRoaXMgY2h1bmsgd291bGQgb3ZlcmZsb3cgdGhlIGN1cnJlbnQgdmlldy4gV2UgZW5xdWV1ZSBhIGZ1bGwgdmlld1xuICAgIC8vIGFuZCBzdGFydCBhIG5ldyB2aWV3IHdpdGggdGhlIHJlbWFpbmluZyBjaHVua1xuICAgIGlmIChhbGxvd2FibGVCeXRlcyA9PT0gMCkge1xuICAgICAgLy8gdGhlIGN1cnJlbnQgdmlldyBpcyBhbHJlYWR5IGZ1bGwsIHNlbmQgaXRcbiAgICAgIHdyaXRlVG9EZXN0aW5hdGlvbihkZXN0aW5hdGlvbiwgY3VycmVudFZpZXcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmaWxsIHVwIHRoZSBjdXJyZW50IHZpZXcgYW5kIGFwcGx5IHRoZSByZW1haW5pbmcgY2h1bmsgYnl0ZXNcbiAgICAgIC8vIHRvIGEgbmV3IHZpZXcuXG4gICAgICBjdXJyZW50Vmlldy5zZXQoYnl0ZXNUb1dyaXRlLnN1YmFycmF5KDAsIGFsbG93YWJsZUJ5dGVzKSwgd3JpdHRlbkJ5dGVzKTtcbiAgICAgIHdyaXR0ZW5CeXRlcyArPSBhbGxvd2FibGVCeXRlcztcbiAgICAgIHdyaXRlVG9EZXN0aW5hdGlvbihkZXN0aW5hdGlvbiwgY3VycmVudFZpZXcpO1xuICAgICAgYnl0ZXNUb1dyaXRlID0gYnl0ZXNUb1dyaXRlLnN1YmFycmF5KGFsbG93YWJsZUJ5dGVzKTtcbiAgICB9XG5cbiAgICBjdXJyZW50VmlldyA9IG5ldyBVaW50OEFycmF5KFZJRVdfU0laRSk7XG4gICAgd3JpdHRlbkJ5dGVzID0gMDtcbiAgfVxuXG4gIGN1cnJlbnRWaWV3LnNldChieXRlc1RvV3JpdGUsIHdyaXR0ZW5CeXRlcyk7XG4gIHdyaXR0ZW5CeXRlcyArPSBieXRlc1RvV3JpdGUuYnl0ZUxlbmd0aDtcblxuICBpZiAod3JpdHRlbkJ5dGVzID09PSBWSUVXX1NJWkUpIHtcbiAgICB3cml0ZVRvRGVzdGluYXRpb24oZGVzdGluYXRpb24sIGN1cnJlbnRWaWV3KTtcbiAgICBjdXJyZW50VmlldyA9IG5ldyBVaW50OEFycmF5KFZJRVdfU0laRSk7XG4gICAgd3JpdHRlbkJ5dGVzID0gMDtcbiAgfVxufVxuXG5mdW5jdGlvbiB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjaHVuaykge1xuICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIHdyaXRlU3RyaW5nQ2h1bmsoZGVzdGluYXRpb24sIGNodW5rKTtcbiAgfSBlbHNlIHtcbiAgICB3cml0ZVZpZXdDaHVuayhkZXN0aW5hdGlvbiwgY2h1bmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdyaXRlVG9EZXN0aW5hdGlvbihkZXN0aW5hdGlvbiwgdmlldykge1xuICB2YXIgY3VycmVudEhhc0NhcGFjaXR5ID0gZGVzdGluYXRpb24ud3JpdGUodmlldyk7XG4gIGRlc3RpbmF0aW9uSGFzQ2FwYWNpdHkkMSA9IGRlc3RpbmF0aW9uSGFzQ2FwYWNpdHkkMSAmJiBjdXJyZW50SGFzQ2FwYWNpdHk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGNodW5rKSB7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNodW5rKTtcbiAgcmV0dXJuIGRlc3RpbmF0aW9uSGFzQ2FwYWNpdHkkMTtcbn1cbmZ1bmN0aW9uIGNvbXBsZXRlV3JpdGluZyhkZXN0aW5hdGlvbikge1xuICBpZiAoY3VycmVudFZpZXcgJiYgd3JpdHRlbkJ5dGVzID4gMCkge1xuICAgIGRlc3RpbmF0aW9uLndyaXRlKGN1cnJlbnRWaWV3LnN1YmFycmF5KDAsIHdyaXR0ZW5CeXRlcykpO1xuICB9XG5cbiAgY3VycmVudFZpZXcgPSBudWxsO1xuICB3cml0dGVuQnl0ZXMgPSAwO1xuICBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5JDEgPSB0cnVlO1xufVxuZnVuY3Rpb24gY2xvc2UoZGVzdGluYXRpb24pIHtcbiAgZGVzdGluYXRpb24uZW5kKCk7XG59XG52YXIgdGV4dEVuY29kZXIgPSBuZXcgdXRpbC5UZXh0RW5jb2RlcigpO1xuZnVuY3Rpb24gc3RyaW5nVG9DaHVuayhjb250ZW50KSB7XG4gIHJldHVybiBjb250ZW50O1xufVxudmFyIHByZWNvbXB1dGVkQ2h1bmtTZXQgPSBuZXcgU2V0KCkgO1xuZnVuY3Rpb24gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGNvbnRlbnQpIHtcbiAgdmFyIHByZWNvbXB1dGVkQ2h1bmsgPSB0ZXh0RW5jb2Rlci5lbmNvZGUoY29udGVudCk7XG5cbiAge1xuICAgIGlmIChwcmVjb21wdXRlZENodW5rU2V0KSB7XG4gICAgICBwcmVjb21wdXRlZENodW5rU2V0LmFkZChwcmVjb21wdXRlZENodW5rKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJlY29tcHV0ZWRDaHVuaztcbn1cbmZ1bmN0aW9uIGNsb25lUHJlY29tcHV0ZWRDaHVuayhwcmVjb21wdXRlZENodW5rKSB7XG4gIHJldHVybiBwcmVjb21wdXRlZENodW5rLmxlbmd0aCA+IFZJRVdfU0laRSA/IHByZWNvbXB1dGVkQ2h1bmsuc2xpY2UoKSA6IHByZWNvbXB1dGVkQ2h1bms7XG59XG5mdW5jdGlvbiBjbG9zZVdpdGhFcnJvcihkZXN0aW5hdGlvbiwgZXJyb3IpIHtcbiAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IFRoaXMgaXMgYW4gRXJyb3Igb2JqZWN0IG9yIHRoZSBkZXN0aW5hdGlvbiBhY2NlcHRzIG90aGVyIHR5cGVzLlxuICBkZXN0aW5hdGlvbi5kZXN0cm95KGVycm9yKTtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vKlxuICogVGhlIGAnJyArIHZhbHVlYCBwYXR0ZXJuICh1c2VkIGluIHBlcmYtc2Vuc2l0aXZlIGNvZGUpIHRocm93cyBmb3IgU3ltYm9sXG4gKiBhbmQgVGVtcG9yYWwuKiB0eXBlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIyMDY0LlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgd2lsbCB0aHJvdyBhbiBlYXNpZXItdG8tdW5kZXJzdGFuZCxcbiAqIGVhc2llci10by1kZWJ1ZyBleGNlcHRpb24gd2l0aCBhIGNsZWFyIGVycm9ycyBtZXNzYWdlIG1lc3NhZ2UgZXhwbGFpbmluZyB0aGVcbiAqIHByb2JsZW0uIChJbnN0ZWFkIG9mIGEgY29uZnVzaW5nIGV4Y2VwdGlvbiB0aHJvd24gaW5zaWRlIHRoZSBpbXBsZW1lbnRhdGlvblxuICogb2YgdGhlIGB2YWx1ZWAgb2JqZWN0KS5cbiAqL1xuLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cbmZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XG4gIHtcbiAgICAvLyB0b1N0cmluZ1RhZyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZWQgdHlwZXMgbGlrZSBUZW1wb3JhbC5JbnN0YW50XG4gICAgdmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWc7XG4gICAgdmFyIHR5cGUgPSBoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ09iamVjdCc7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cblxuICAgIHJldHVybiB0eXBlO1xuICB9XG59IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5cblxuZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcbiAge1xuICAgIHRyeSB7XG4gICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgLy8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXG4gIC8vIGhhcHBlbmVkOiB5b3Ugc3VwcGxpZWQgYW4gb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBSZWFjdCAoYXMgYSBwcm9wLCBrZXksXG4gIC8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cbiAgLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4gIC8vXG4gIC8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xuICAvLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxuICAvLyBgdmFsdWVPZmAgb3IgYFtTeW1ib2wudG9QcmltaXRpdmVdYCBtZXRob2QgdGhhdCB0aHJvd3Mgd2lsbCBhbHNvIGNhdXNlIHRoaXNcbiAgLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXG4gIC8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxuICAvLyBtZXRob2RzIGFyZSBuZWVkZWQgdG8gcGVyZm9ybSBhY2N1cmF0ZSBhcml0aG1ldGljIG9yIGNvbXBhcmlzb24uKVxuICAvL1xuICAvLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXG4gIC8vIHBhc3NpbmcgaXQgdG8gUmVhY3QuIFRoZSBtb3N0IHJlbGlhYmxlIHdheSBpcyB1c3VhbGx5IGBTdHJpbmcodmFsdWUpYC5cbiAgLy9cbiAgLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cbiAgLy8gQmVmb3JlIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlIHNob3VsZCBiZSBgY29uc29sZS5lcnJvcmAgb3V0cHV0XG4gIC8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcbiAgLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBjb25zb2xlIG91dHB1dCBhbHNvIHNob3dzIHRoZSBjb21wb25lbnQgYW5kIGl0c1xuICAvLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXG4gIC8vXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICByZXR1cm4gJycgKyB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgYXR0cmlidXRlTmFtZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBgJXNgIGF0dHJpYnV0ZSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCBhdHRyaWJ1dGVOYW1lLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrQ1NTUHJvcGVydHlTdHJpbmdDb2VyY2lvbih2YWx1ZSwgcHJvcE5hbWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQgYCVzYCBDU1MgcHJvcGVydHkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgcHJvcE5hbWUsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQgSFRNTCBtYXJrdXAgdXNlcyBhIHZhbHVlIG9mIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIGVuYWJsZUZsb2F0ID0gdHJ1ZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV91c2VNZW1vQ2FjaGUgaG9vaywgaW50ZW5kZWQgYXMgYSBjb21waWxhdGlvbiB0YXJnZXQgZm9yXG5cbi8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxudmFyIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgPSBcIjpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcIjtcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG52YXIgQVRUUklCVVRFX05BTUVfQ0hBUiA9IEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyBcIlxcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXCI7XG52YXIgVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVggPSBuZXcgUmVnRXhwKCdeWycgKyBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgJ11bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuZnVuY3Rpb24gaXNBdHRyaWJ1dGVOYW1lU2FmZShhdHRyaWJ1dGVOYW1lKSB7XG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSwgYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUsIGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYLnRlc3QoYXR0cmlidXRlTmFtZSkpIHtcbiAgICB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG5cbiAge1xuICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgJywgYXR0cmlidXRlTmFtZSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ1NTIHByb3BlcnRpZXMgd2hpY2ggYWNjZXB0IG51bWJlcnMgYnV0IGFyZSBub3QgaW4gdW5pdHMgb2YgXCJweFwiLlxuICovXG52YXIgdW5pdGxlc3NOdW1iZXJzID0gbmV3IFNldChbJ2FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50JywgJ2FzcGVjdFJhdGlvJywgJ2JvcmRlckltYWdlT3V0c2V0JywgJ2JvcmRlckltYWdlU2xpY2UnLCAnYm9yZGVySW1hZ2VXaWR0aCcsICdib3hGbGV4JywgJ2JveEZsZXhHcm91cCcsICdib3hPcmRpbmFsR3JvdXAnLCAnY29sdW1uQ291bnQnLCAnY29sdW1ucycsICdmbGV4JywgJ2ZsZXhHcm93JywgJ2ZsZXhQb3NpdGl2ZScsICdmbGV4U2hyaW5rJywgJ2ZsZXhOZWdhdGl2ZScsICdmbGV4T3JkZXInLCAnZ3JpZEFyZWEnLCAnZ3JpZFJvdycsICdncmlkUm93RW5kJywgJ2dyaWRSb3dTcGFuJywgJ2dyaWRSb3dTdGFydCcsICdncmlkQ29sdW1uJywgJ2dyaWRDb2x1bW5FbmQnLCAnZ3JpZENvbHVtblNwYW4nLCAnZ3JpZENvbHVtblN0YXJ0JywgJ2ZvbnRXZWlnaHQnLCAnbGluZUNsYW1wJywgJ2xpbmVIZWlnaHQnLCAnb3BhY2l0eScsICdvcmRlcicsICdvcnBoYW5zJywgJ3NjYWxlJywgJ3RhYlNpemUnLCAnd2lkb3dzJywgJ3pJbmRleCcsICd6b29tJywgJ2ZpbGxPcGFjaXR5JywgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuJ2Zsb29kT3BhY2l0eScsICdzdG9wT3BhY2l0eScsICdzdHJva2VEYXNoYXJyYXknLCAnc3Ryb2tlRGFzaG9mZnNldCcsICdzdHJva2VNaXRlcmxpbWl0JywgJ3N0cm9rZU9wYWNpdHknLCAnc3Ryb2tlV2lkdGgnLCAnTW96QW5pbWF0aW9uSXRlcmF0aW9uQ291bnQnLCAvLyBLbm93biBQcmVmaXhlZCBQcm9wZXJ0aWVzXG4nTW96Qm94RmxleCcsIC8vIFRPRE86IFJlbW92ZSB0aGVzZSBzaW5jZSB0aGV5IHNob3VsZG4ndCBiZSB1c2VkIGluIG1vZGVybiBjb2RlXG4nTW96Qm94RmxleEdyb3VwJywgJ01vekxpbmVDbGFtcCcsICdtc0FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50JywgJ21zRmxleCcsICdtc1pvb20nLCAnbXNGbGV4R3JvdycsICdtc0ZsZXhOZWdhdGl2ZScsICdtc0ZsZXhPcmRlcicsICdtc0ZsZXhQb3NpdGl2ZScsICdtc0ZsZXhTaHJpbmsnLCAnbXNHcmlkQ29sdW1uJywgJ21zR3JpZENvbHVtblNwYW4nLCAnbXNHcmlkUm93JywgJ21zR3JpZFJvd1NwYW4nLCAnV2Via2l0QW5pbWF0aW9uSXRlcmF0aW9uQ291bnQnLCAnV2Via2l0Qm94RmxleCcsICdXZWJLaXRCb3hGbGV4R3JvdXAnLCAnV2Via2l0Qm94T3JkaW5hbEdyb3VwJywgJ1dlYmtpdENvbHVtbkNvdW50JywgJ1dlYmtpdENvbHVtbnMnLCAnV2Via2l0RmxleCcsICdXZWJraXRGbGV4R3JvdycsICdXZWJraXRGbGV4UG9zaXRpdmUnLCAnV2Via2l0RmxleFNocmluaycsICdXZWJraXRMaW5lQ2xhbXAnXSk7XG5mdW5jdGlvbiBpc1VuaXRsZXNzTnVtYmVyIChuYW1lKSB7XG4gIHJldHVybiB1bml0bGVzc051bWJlcnMuaGFzKG5hbWUpO1xufVxuXG52YXIgYWxpYXNlcyA9IG5ldyBNYXAoW1snYWNjZXB0Q2hhcnNldCcsICdhY2NlcHQtY2hhcnNldCddLCBbJ2h0bWxGb3InLCAnZm9yJ10sIFsnaHR0cEVxdWl2JywgJ2h0dHAtZXF1aXYnXSwgLy8gSFRNTCBhbmQgU1ZHIGF0dHJpYnV0ZXMsIGJ1dCB0aGUgU1ZHIGF0dHJpYnV0ZSBpcyBjYXNlIHNlbnNpdGl2ZS5dLFxuWydjcm9zc09yaWdpbicsICdjcm9zc29yaWdpbiddLCAvLyBUaGlzIGlzIGEgbGlzdCBvZiBhbGwgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBuZWVkIHNwZWNpYWwgY2FzaW5nLlxuLy8gUmVndWxhciBhdHRyaWJ1dGVzIHRoYXQganVzdCBhY2NlcHQgc3RyaW5ncy5dLFxuWydhY2NlbnRIZWlnaHQnLCAnYWNjZW50LWhlaWdodCddLCBbJ2FsaWdubWVudEJhc2VsaW5lJywgJ2FsaWdubWVudC1iYXNlbGluZSddLCBbJ2FyYWJpY0Zvcm0nLCAnYXJhYmljLWZvcm0nXSwgWydiYXNlbGluZVNoaWZ0JywgJ2Jhc2VsaW5lLXNoaWZ0J10sIFsnY2FwSGVpZ2h0JywgJ2NhcC1oZWlnaHQnXSwgWydjbGlwUGF0aCcsICdjbGlwLXBhdGgnXSwgWydjbGlwUnVsZScsICdjbGlwLXJ1bGUnXSwgWydjb2xvckludGVycG9sYXRpb24nLCAnY29sb3ItaW50ZXJwb2xhdGlvbiddLCBbJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLCAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJ10sIFsnY29sb3JQcm9maWxlJywgJ2NvbG9yLXByb2ZpbGUnXSwgWydjb2xvclJlbmRlcmluZycsICdjb2xvci1yZW5kZXJpbmcnXSwgWydkb21pbmFudEJhc2VsaW5lJywgJ2RvbWluYW50LWJhc2VsaW5lJ10sIFsnZW5hYmxlQmFja2dyb3VuZCcsICdlbmFibGUtYmFja2dyb3VuZCddLCBbJ2ZpbGxPcGFjaXR5JywgJ2ZpbGwtb3BhY2l0eSddLCBbJ2ZpbGxSdWxlJywgJ2ZpbGwtcnVsZSddLCBbJ2Zsb29kQ29sb3InLCAnZmxvb2QtY29sb3InXSwgWydmbG9vZE9wYWNpdHknLCAnZmxvb2Qtb3BhY2l0eSddLCBbJ2ZvbnRGYW1pbHknLCAnZm9udC1mYW1pbHknXSwgWydmb250U2l6ZScsICdmb250LXNpemUnXSwgWydmb250U2l6ZUFkanVzdCcsICdmb250LXNpemUtYWRqdXN0J10sIFsnZm9udFN0cmV0Y2gnLCAnZm9udC1zdHJldGNoJ10sIFsnZm9udFN0eWxlJywgJ2ZvbnQtc3R5bGUnXSwgWydmb250VmFyaWFudCcsICdmb250LXZhcmlhbnQnXSwgWydmb250V2VpZ2h0JywgJ2ZvbnQtd2VpZ2h0J10sIFsnZ2x5cGhOYW1lJywgJ2dseXBoLW5hbWUnXSwgWydnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJ10sIFsnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJywgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJ10sIFsnaG9yaXpBZHZYJywgJ2hvcml6LWFkdi14J10sIFsnaG9yaXpPcmlnaW5YJywgJ2hvcml6LW9yaWdpbi14J10sIFsnaW1hZ2VSZW5kZXJpbmcnLCAnaW1hZ2UtcmVuZGVyaW5nJ10sIFsnbGV0dGVyU3BhY2luZycsICdsZXR0ZXItc3BhY2luZyddLCBbJ2xpZ2h0aW5nQ29sb3InLCAnbGlnaHRpbmctY29sb3InXSwgWydtYXJrZXJFbmQnLCAnbWFya2VyLWVuZCddLCBbJ21hcmtlck1pZCcsICdtYXJrZXItbWlkJ10sIFsnbWFya2VyU3RhcnQnLCAnbWFya2VyLXN0YXJ0J10sIFsnb3ZlcmxpbmVQb3NpdGlvbicsICdvdmVybGluZS1wb3NpdGlvbiddLCBbJ292ZXJsaW5lVGhpY2tuZXNzJywgJ292ZXJsaW5lLXRoaWNrbmVzcyddLCBbJ3BhaW50T3JkZXInLCAncGFpbnQtb3JkZXInXSwgWydwYW5vc2UtMScsICdwYW5vc2UtMSddLCBbJ3BvaW50ZXJFdmVudHMnLCAncG9pbnRlci1ldmVudHMnXSwgWydyZW5kZXJpbmdJbnRlbnQnLCAncmVuZGVyaW5nLWludGVudCddLCBbJ3NoYXBlUmVuZGVyaW5nJywgJ3NoYXBlLXJlbmRlcmluZyddLCBbJ3N0b3BDb2xvcicsICdzdG9wLWNvbG9yJ10sIFsnc3RvcE9wYWNpdHknLCAnc3RvcC1vcGFjaXR5J10sIFsnc3RyaWtldGhyb3VnaFBvc2l0aW9uJywgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nXSwgWydzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJywgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJ10sIFsnc3Ryb2tlRGFzaGFycmF5JywgJ3N0cm9rZS1kYXNoYXJyYXknXSwgWydzdHJva2VEYXNob2Zmc2V0JywgJ3N0cm9rZS1kYXNob2Zmc2V0J10sIFsnc3Ryb2tlTGluZWNhcCcsICdzdHJva2UtbGluZWNhcCddLCBbJ3N0cm9rZUxpbmVqb2luJywgJ3N0cm9rZS1saW5lam9pbiddLCBbJ3N0cm9rZU1pdGVybGltaXQnLCAnc3Ryb2tlLW1pdGVybGltaXQnXSwgWydzdHJva2VPcGFjaXR5JywgJ3N0cm9rZS1vcGFjaXR5J10sIFsnc3Ryb2tlV2lkdGgnLCAnc3Ryb2tlLXdpZHRoJ10sIFsndGV4dEFuY2hvcicsICd0ZXh0LWFuY2hvciddLCBbJ3RleHREZWNvcmF0aW9uJywgJ3RleHQtZGVjb3JhdGlvbiddLCBbJ3RleHRSZW5kZXJpbmcnLCAndGV4dC1yZW5kZXJpbmcnXSwgWyd0cmFuc2Zvcm1PcmlnaW4nLCAndHJhbnNmb3JtLW9yaWdpbiddLCBbJ3VuZGVybGluZVBvc2l0aW9uJywgJ3VuZGVybGluZS1wb3NpdGlvbiddLCBbJ3VuZGVybGluZVRoaWNrbmVzcycsICd1bmRlcmxpbmUtdGhpY2tuZXNzJ10sIFsndW5pY29kZUJpZGknLCAndW5pY29kZS1iaWRpJ10sIFsndW5pY29kZVJhbmdlJywgJ3VuaWNvZGUtcmFuZ2UnXSwgWyd1bml0c1BlckVtJywgJ3VuaXRzLXBlci1lbSddLCBbJ3ZBbHBoYWJldGljJywgJ3YtYWxwaGFiZXRpYyddLCBbJ3ZIYW5naW5nJywgJ3YtaGFuZ2luZyddLCBbJ3ZJZGVvZ3JhcGhpYycsICd2LWlkZW9ncmFwaGljJ10sIFsndk1hdGhlbWF0aWNhbCcsICd2LW1hdGhlbWF0aWNhbCddLCBbJ3ZlY3RvckVmZmVjdCcsICd2ZWN0b3ItZWZmZWN0J10sIFsndmVydEFkdlknLCAndmVydC1hZHYteSddLCBbJ3ZlcnRPcmlnaW5YJywgJ3ZlcnQtb3JpZ2luLXgnXSwgWyd2ZXJ0T3JpZ2luWScsICd2ZXJ0LW9yaWdpbi15J10sIFsnd29yZFNwYWNpbmcnLCAnd29yZC1zcGFjaW5nJ10sIFsnd3JpdGluZ01vZGUnLCAnd3JpdGluZy1tb2RlJ10sIFsneG1sbnNYbGluaycsICd4bWxuczp4bGluayddLCBbJ3hIZWlnaHQnLCAneC1oZWlnaHQnXV0pO1xuZnVuY3Rpb24gZ2V0QXR0cmlidXRlQWxpYXMgKG5hbWUpIHtcbiAgcmV0dXJuIGFsaWFzZXMuZ2V0KG5hbWUpIHx8IG5hbWU7XG59XG5cbnZhciBoYXNSZWFkT25seVZhbHVlID0ge1xuICBidXR0b246IHRydWUsXG4gIGNoZWNrYm94OiB0cnVlLFxuICBpbWFnZTogdHJ1ZSxcbiAgaGlkZGVuOiB0cnVlLFxuICByYWRpbzogdHJ1ZSxcbiAgcmVzZXQ6IHRydWUsXG4gIHN1Ym1pdDogdHJ1ZVxufTtcbmZ1bmN0aW9uIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHModGFnTmFtZSwgcHJvcHMpIHtcbiAge1xuICAgIGlmICghKGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMub25JbnB1dCB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCB8fCBwcm9wcy52YWx1ZSA9PSBudWxsKSkge1xuICAgICAgZXJyb3IoJ1lvdSBwcm92aWRlZCBhIGB2YWx1ZWAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0VmFsdWVgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgfVxuXG4gICAgaWYgKCEocHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQgfHwgcHJvcHMuY2hlY2tlZCA9PSBudWxsKSkge1xuICAgICAgZXJyb3IoJ1lvdSBwcm92aWRlZCBhIGBjaGVja2VkYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRDaGVja2VkYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYXJpYVByb3BlcnRpZXMgPSB7XG4gICdhcmlhLWN1cnJlbnQnOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1kZXNjcmlwdGlvbic6IDAsXG4gICdhcmlhLWRldGFpbHMnOiAwLFxuICAnYXJpYS1kaXNhYmxlZCc6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWhpZGRlbic6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWludmFsaWQnOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1rZXlzaG9ydGN1dHMnOiAwLFxuICAnYXJpYS1sYWJlbCc6IDAsXG4gICdhcmlhLXJvbGVkZXNjcmlwdGlvbic6IDAsXG4gIC8vIFdpZGdldCBBdHRyaWJ1dGVzXG4gICdhcmlhLWF1dG9jb21wbGV0ZSc6IDAsXG4gICdhcmlhLWNoZWNrZWQnOiAwLFxuICAnYXJpYS1leHBhbmRlZCc6IDAsXG4gICdhcmlhLWhhc3BvcHVwJzogMCxcbiAgJ2FyaWEtbGV2ZWwnOiAwLFxuICAnYXJpYS1tb2RhbCc6IDAsXG4gICdhcmlhLW11bHRpbGluZSc6IDAsXG4gICdhcmlhLW11bHRpc2VsZWN0YWJsZSc6IDAsXG4gICdhcmlhLW9yaWVudGF0aW9uJzogMCxcbiAgJ2FyaWEtcGxhY2Vob2xkZXInOiAwLFxuICAnYXJpYS1wcmVzc2VkJzogMCxcbiAgJ2FyaWEtcmVhZG9ubHknOiAwLFxuICAnYXJpYS1yZXF1aXJlZCc6IDAsXG4gICdhcmlhLXNlbGVjdGVkJzogMCxcbiAgJ2FyaWEtc29ydCc6IDAsXG4gICdhcmlhLXZhbHVlbWF4JzogMCxcbiAgJ2FyaWEtdmFsdWVtaW4nOiAwLFxuICAnYXJpYS12YWx1ZW5vdyc6IDAsXG4gICdhcmlhLXZhbHVldGV4dCc6IDAsXG4gIC8vIExpdmUgUmVnaW9uIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXRvbWljJzogMCxcbiAgJ2FyaWEtYnVzeSc6IDAsXG4gICdhcmlhLWxpdmUnOiAwLFxuICAnYXJpYS1yZWxldmFudCc6IDAsXG4gIC8vIERyYWctYW5kLURyb3AgQXR0cmlidXRlc1xuICAnYXJpYS1kcm9wZWZmZWN0JzogMCxcbiAgJ2FyaWEtZ3JhYmJlZCc6IDAsXG4gIC8vIFJlbGF0aW9uc2hpcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiAwLFxuICAnYXJpYS1jb2xjb3VudCc6IDAsXG4gICdhcmlhLWNvbGluZGV4JzogMCxcbiAgJ2FyaWEtY29sc3Bhbic6IDAsXG4gICdhcmlhLWNvbnRyb2xzJzogMCxcbiAgJ2FyaWEtZGVzY3JpYmVkYnknOiAwLFxuICAnYXJpYS1lcnJvcm1lc3NhZ2UnOiAwLFxuICAnYXJpYS1mbG93dG8nOiAwLFxuICAnYXJpYS1sYWJlbGxlZGJ5JzogMCxcbiAgJ2FyaWEtb3ducyc6IDAsXG4gICdhcmlhLXBvc2luc2V0JzogMCxcbiAgJ2FyaWEtcm93Y291bnQnOiAwLFxuICAnYXJpYS1yb3dpbmRleCc6IDAsXG4gICdhcmlhLXJvd3NwYW4nOiAwLFxuICAnYXJpYS1zZXRzaXplJzogMFxufTtcblxudmFyIHdhcm5lZFByb3BlcnRpZXMkMSA9IHt9O1xudmFyIHJBUklBJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciByQVJJQUNhbWVsJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkkMSh0YWdOYW1lLCBuYW1lKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzJDEsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHJBUklBQ2FtZWwkMS50ZXN0KG5hbWUpKSB7XG4gICAgICB2YXIgYXJpYU5hbWUgPSAnYXJpYS0nICsgbmFtZS5zbGljZSg0KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIGNvcnJlY3ROYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoYXJpYU5hbWUpID8gYXJpYU5hbWUgOiBudWxsOyAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cblxuICAgICAgaWYgKGNvcnJlY3ROYW1lID09IG51bGwpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gQVJJQSBhdHRyaWJ1dGVzIGZvbGxvdyB0aGUgcGF0dGVybiBhcmlhLSogYW5kIG11c3QgYmUgbG93ZXJjYXNlLicsIG5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cblxuXG4gICAgICBpZiAobmFtZSAhPT0gY29ycmVjdE5hbWUpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgY29ycmVjdE5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyQVJJQSQxLnRlc3QobmFtZSkpIHtcbiAgICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBzdGFuZGFyZE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBsb3dlckNhc2VkTmFtZSA6IG51bGw7IC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgICAgLy8gRE9NIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYW4gaW52YWxpZCBhcmlhLSogYXR0cmlidXRlLlxuXG4gICAgICBpZiAoc3RhbmRhcmROYW1lID09IG51bGwpIHtcbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cblxuXG4gICAgICBpZiAobmFtZSAhPT0gc3RhbmRhcmROYW1lKSB7XG4gICAgICAgIGVycm9yKCdVbmtub3duIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIHN0YW5kYXJkTmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzKSB7XG4gIHtcbiAgICB2YXIgaW52YWxpZFByb3BzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSQxKHR5cGUsIGtleSk7XG5cbiAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICBpbnZhbGlkUHJvcHMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmtub3duUHJvcFN0cmluZyA9IGludmFsaWRQcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICAgIH0pLmpvaW4oJywgJyk7XG5cbiAgICBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgYXJpYSBwcm9wICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtYXJpYS1wcm9wcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9IGVsc2UgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgICBlcnJvcignSW52YWxpZCBhcmlhIHByb3BzICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtYXJpYS1wcm9wcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGRpZFdhcm5WYWx1ZU51bGwgPSBmYWxzZTtcbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUsIHByb3BzKSB7XG4gIHtcbiAgICBpZiAodHlwZSAhPT0gJ2lucHV0JyAmJiB0eXBlICE9PSAndGV4dGFyZWEnICYmIHR5cGUgIT09ICdzZWxlY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BzICE9IG51bGwgJiYgcHJvcHMudmFsdWUgPT09IG51bGwgJiYgIWRpZFdhcm5WYWx1ZU51bGwpIHtcbiAgICAgIGRpZFdhcm5WYWx1ZU51bGwgPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ3NlbGVjdCcgJiYgcHJvcHMubXVsdGlwbGUpIHtcbiAgICAgICAgZXJyb3IoJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyBhbiBlbXB0eSBhcnJheSB3aGVuIGBtdWx0aXBsZWAgaXMgc2V0IHRvIGB0cnVlYCAnICsgJ3RvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLicsIHR5cGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IoJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyBhbiBlbXB0eSBzdHJpbmcgdG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCAnICsgJ2ZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4nLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDdXN0b21FbGVtZW50KHRhZ05hbWUsIHByb3BzKSB7XG4gIGlmICh0YWdOYW1lLmluZGV4T2YoJy0nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICAvLyBUaGVzZSBhcmUgcmVzZXJ2ZWQgU1ZHIGFuZCBNYXRoTUwgZWxlbWVudHMuXG4gICAgLy8gV2UgZG9uJ3QgbWluZCB0aGlzIGxpc3QgdG9vIG11Y2ggYmVjYXVzZSB3ZSBleHBlY3QgaXQgdG8gbmV2ZXIgZ3Jvdy5cbiAgICAvLyBUaGUgYWx0ZXJuYXRpdmUgaXMgdG8gdHJhY2sgdGhlIG5hbWVzcGFjZSBpbiBhIGZldyBwbGFjZXMgd2hpY2ggaXMgY29udm9sdXRlZC5cbiAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL2N1c3RvbS8jY3VzdG9tLWVsZW1lbnRzLWNvcmUtY29uY2VwdHNcbiAgICBjYXNlICdhbm5vdGF0aW9uLXhtbCc6XG4gICAgY2FzZSAnY29sb3ItcHJvZmlsZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlJzpcbiAgICBjYXNlICdmb250LWZhY2Utc3JjJzpcbiAgICBjYXNlICdmb250LWZhY2UtdXJpJzpcbiAgICBjYXNlICdmb250LWZhY2UtZm9ybWF0JzpcbiAgICBjYXNlICdmb250LWZhY2UtbmFtZSc6XG4gICAgY2FzZSAnbWlzc2luZy1nbHlwaCc6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGUgSFRNTCBvciBTVkcgYWxsb3dlZCBhdHRyaWJ1dGUgbGlzdCwgYmUgc3VyZSB0b1xuLy8gYWxzbyBhZGQgdGhlbSB0byB0aGlzIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3QgbmFtZVxuLy8gd2FybmluZ3MuXG52YXIgcG9zc2libGVTdGFuZGFyZE5hbWVzID0ge1xuICAvLyBIVE1MXG4gIGFjY2VwdDogJ2FjY2VwdCcsXG4gIGFjY2VwdGNoYXJzZXQ6ICdhY2NlcHRDaGFyc2V0JyxcbiAgJ2FjY2VwdC1jaGFyc2V0JzogJ2FjY2VwdENoYXJzZXQnLFxuICBhY2Nlc3NrZXk6ICdhY2Nlc3NLZXknLFxuICBhY3Rpb246ICdhY3Rpb24nLFxuICBhbGxvd2Z1bGxzY3JlZW46ICdhbGxvd0Z1bGxTY3JlZW4nLFxuICBhbHQ6ICdhbHQnLFxuICBhczogJ2FzJyxcbiAgYXN5bmM6ICdhc3luYycsXG4gIGF1dG9jYXBpdGFsaXplOiAnYXV0b0NhcGl0YWxpemUnLFxuICBhdXRvY29tcGxldGU6ICdhdXRvQ29tcGxldGUnLFxuICBhdXRvY29ycmVjdDogJ2F1dG9Db3JyZWN0JyxcbiAgYXV0b2ZvY3VzOiAnYXV0b0ZvY3VzJyxcbiAgYXV0b3BsYXk6ICdhdXRvUGxheScsXG4gIGF1dG9zYXZlOiAnYXV0b1NhdmUnLFxuICBjYXB0dXJlOiAnY2FwdHVyZScsXG4gIGNlbGxwYWRkaW5nOiAnY2VsbFBhZGRpbmcnLFxuICBjZWxsc3BhY2luZzogJ2NlbGxTcGFjaW5nJyxcbiAgY2hhbGxlbmdlOiAnY2hhbGxlbmdlJyxcbiAgY2hhcnNldDogJ2NoYXJTZXQnLFxuICBjaGVja2VkOiAnY2hlY2tlZCcsXG4gIGNoaWxkcmVuOiAnY2hpbGRyZW4nLFxuICBjaXRlOiAnY2l0ZScsXG4gIGNsYXNzOiAnY2xhc3NOYW1lJyxcbiAgY2xhc3NpZDogJ2NsYXNzSUQnLFxuICBjbGFzc25hbWU6ICdjbGFzc05hbWUnLFxuICBjb2xzOiAnY29scycsXG4gIGNvbHNwYW46ICdjb2xTcGFuJyxcbiAgY29udGVudDogJ2NvbnRlbnQnLFxuICBjb250ZW50ZWRpdGFibGU6ICdjb250ZW50RWRpdGFibGUnLFxuICBjb250ZXh0bWVudTogJ2NvbnRleHRNZW51JyxcbiAgY29udHJvbHM6ICdjb250cm9scycsXG4gIGNvbnRyb2xzbGlzdDogJ2NvbnRyb2xzTGlzdCcsXG4gIGNvb3JkczogJ2Nvb3JkcycsXG4gIGNyb3Nzb3JpZ2luOiAnY3Jvc3NPcmlnaW4nLFxuICBkYW5nZXJvdXNseXNldGlubmVyaHRtbDogJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJyxcbiAgZGF0YTogJ2RhdGEnLFxuICBkYXRldGltZTogJ2RhdGVUaW1lJyxcbiAgZGVmYXVsdDogJ2RlZmF1bHQnLFxuICBkZWZhdWx0Y2hlY2tlZDogJ2RlZmF1bHRDaGVja2VkJyxcbiAgZGVmYXVsdHZhbHVlOiAnZGVmYXVsdFZhbHVlJyxcbiAgZGVmZXI6ICdkZWZlcicsXG4gIGRpcjogJ2RpcicsXG4gIGRpc2FibGVkOiAnZGlzYWJsZWQnLFxuICBkaXNhYmxlcGljdHVyZWlucGljdHVyZTogJ2Rpc2FibGVQaWN0dXJlSW5QaWN0dXJlJyxcbiAgZGlzYWJsZXJlbW90ZXBsYXliYWNrOiAnZGlzYWJsZVJlbW90ZVBsYXliYWNrJyxcbiAgZG93bmxvYWQ6ICdkb3dubG9hZCcsXG4gIGRyYWdnYWJsZTogJ2RyYWdnYWJsZScsXG4gIGVuY3R5cGU6ICdlbmNUeXBlJyxcbiAgZW50ZXJrZXloaW50OiAnZW50ZXJLZXlIaW50JyxcbiAgZmV0Y2hwcmlvcml0eTogJ2ZldGNoUHJpb3JpdHknLFxuICBmb3I6ICdodG1sRm9yJyxcbiAgZm9ybTogJ2Zvcm0nLFxuICBmb3JtbWV0aG9kOiAnZm9ybU1ldGhvZCcsXG4gIGZvcm1hY3Rpb246ICdmb3JtQWN0aW9uJyxcbiAgZm9ybWVuY3R5cGU6ICdmb3JtRW5jVHlwZScsXG4gIGZvcm1ub3ZhbGlkYXRlOiAnZm9ybU5vVmFsaWRhdGUnLFxuICBmb3JtdGFyZ2V0OiAnZm9ybVRhcmdldCcsXG4gIGZyYW1lYm9yZGVyOiAnZnJhbWVCb3JkZXInLFxuICBoZWFkZXJzOiAnaGVhZGVycycsXG4gIGhlaWdodDogJ2hlaWdodCcsXG4gIGhpZGRlbjogJ2hpZGRlbicsXG4gIGhpZ2g6ICdoaWdoJyxcbiAgaHJlZjogJ2hyZWYnLFxuICBocmVmbGFuZzogJ2hyZWZMYW5nJyxcbiAgaHRtbGZvcjogJ2h0bWxGb3InLFxuICBodHRwZXF1aXY6ICdodHRwRXF1aXYnLFxuICAnaHR0cC1lcXVpdic6ICdodHRwRXF1aXYnLFxuICBpY29uOiAnaWNvbicsXG4gIGlkOiAnaWQnLFxuICBpbWFnZXNpemVzOiAnaW1hZ2VTaXplcycsXG4gIGltYWdlc3Jjc2V0OiAnaW1hZ2VTcmNTZXQnLFxuICBpbm5lcmh0bWw6ICdpbm5lckhUTUwnLFxuICBpbnB1dG1vZGU6ICdpbnB1dE1vZGUnLFxuICBpbnRlZ3JpdHk6ICdpbnRlZ3JpdHknLFxuICBpczogJ2lzJyxcbiAgaXRlbWlkOiAnaXRlbUlEJyxcbiAgaXRlbXByb3A6ICdpdGVtUHJvcCcsXG4gIGl0ZW1yZWY6ICdpdGVtUmVmJyxcbiAgaXRlbXNjb3BlOiAnaXRlbVNjb3BlJyxcbiAgaXRlbXR5cGU6ICdpdGVtVHlwZScsXG4gIGtleXBhcmFtczogJ2tleVBhcmFtcycsXG4gIGtleXR5cGU6ICdrZXlUeXBlJyxcbiAga2luZDogJ2tpbmQnLFxuICBsYWJlbDogJ2xhYmVsJyxcbiAgbGFuZzogJ2xhbmcnLFxuICBsaXN0OiAnbGlzdCcsXG4gIGxvb3A6ICdsb29wJyxcbiAgbG93OiAnbG93JyxcbiAgbWFuaWZlc3Q6ICdtYW5pZmVzdCcsXG4gIG1hcmdpbndpZHRoOiAnbWFyZ2luV2lkdGgnLFxuICBtYXJnaW5oZWlnaHQ6ICdtYXJnaW5IZWlnaHQnLFxuICBtYXg6ICdtYXgnLFxuICBtYXhsZW5ndGg6ICdtYXhMZW5ndGgnLFxuICBtZWRpYTogJ21lZGlhJyxcbiAgbWVkaWFncm91cDogJ21lZGlhR3JvdXAnLFxuICBtZXRob2Q6ICdtZXRob2QnLFxuICBtaW46ICdtaW4nLFxuICBtaW5sZW5ndGg6ICdtaW5MZW5ndGgnLFxuICBtdWx0aXBsZTogJ211bHRpcGxlJyxcbiAgbXV0ZWQ6ICdtdXRlZCcsXG4gIG5hbWU6ICduYW1lJyxcbiAgbm9tb2R1bGU6ICdub01vZHVsZScsXG4gIG5vbmNlOiAnbm9uY2UnLFxuICBub3ZhbGlkYXRlOiAnbm9WYWxpZGF0ZScsXG4gIG9wZW46ICdvcGVuJyxcbiAgb3B0aW11bTogJ29wdGltdW0nLFxuICBwYXR0ZXJuOiAncGF0dGVybicsXG4gIHBsYWNlaG9sZGVyOiAncGxhY2Vob2xkZXInLFxuICBwbGF5c2lubGluZTogJ3BsYXlzSW5saW5lJyxcbiAgcG9zdGVyOiAncG9zdGVyJyxcbiAgcHJlbG9hZDogJ3ByZWxvYWQnLFxuICBwcm9maWxlOiAncHJvZmlsZScsXG4gIHJhZGlvZ3JvdXA6ICdyYWRpb0dyb3VwJyxcbiAgcmVhZG9ubHk6ICdyZWFkT25seScsXG4gIHJlZmVycmVycG9saWN5OiAncmVmZXJyZXJQb2xpY3knLFxuICByZWw6ICdyZWwnLFxuICByZXF1aXJlZDogJ3JlcXVpcmVkJyxcbiAgcmV2ZXJzZWQ6ICdyZXZlcnNlZCcsXG4gIHJvbGU6ICdyb2xlJyxcbiAgcm93czogJ3Jvd3MnLFxuICByb3dzcGFuOiAncm93U3BhbicsXG4gIHNhbmRib3g6ICdzYW5kYm94JyxcbiAgc2NvcGU6ICdzY29wZScsXG4gIHNjb3BlZDogJ3Njb3BlZCcsXG4gIHNjcm9sbGluZzogJ3Njcm9sbGluZycsXG4gIHNlYW1sZXNzOiAnc2VhbWxlc3MnLFxuICBzZWxlY3RlZDogJ3NlbGVjdGVkJyxcbiAgc2hhcGU6ICdzaGFwZScsXG4gIHNpemU6ICdzaXplJyxcbiAgc2l6ZXM6ICdzaXplcycsXG4gIHNwYW46ICdzcGFuJyxcbiAgc3BlbGxjaGVjazogJ3NwZWxsQ2hlY2snLFxuICBzcmM6ICdzcmMnLFxuICBzcmNkb2M6ICdzcmNEb2MnLFxuICBzcmNsYW5nOiAnc3JjTGFuZycsXG4gIHNyY3NldDogJ3NyY1NldCcsXG4gIHN0YXJ0OiAnc3RhcnQnLFxuICBzdGVwOiAnc3RlcCcsXG4gIHN0eWxlOiAnc3R5bGUnLFxuICBzdW1tYXJ5OiAnc3VtbWFyeScsXG4gIHRhYmluZGV4OiAndGFiSW5kZXgnLFxuICB0YXJnZXQ6ICd0YXJnZXQnLFxuICB0aXRsZTogJ3RpdGxlJyxcbiAgdHlwZTogJ3R5cGUnLFxuICB1c2VtYXA6ICd1c2VNYXAnLFxuICB2YWx1ZTogJ3ZhbHVlJyxcbiAgd2lkdGg6ICd3aWR0aCcsXG4gIHdtb2RlOiAnd21vZGUnLFxuICB3cmFwOiAnd3JhcCcsXG4gIC8vIFNWR1xuICBhYm91dDogJ2Fib3V0JyxcbiAgYWNjZW50aGVpZ2h0OiAnYWNjZW50SGVpZ2h0JyxcbiAgJ2FjY2VudC1oZWlnaHQnOiAnYWNjZW50SGVpZ2h0JyxcbiAgYWNjdW11bGF0ZTogJ2FjY3VtdWxhdGUnLFxuICBhZGRpdGl2ZTogJ2FkZGl0aXZlJyxcbiAgYWxpZ25tZW50YmFzZWxpbmU6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gICdhbGlnbm1lbnQtYmFzZWxpbmUnOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICBhbGxvd3Jlb3JkZXI6ICdhbGxvd1Jlb3JkZXInLFxuICBhbHBoYWJldGljOiAnYWxwaGFiZXRpYycsXG4gIGFtcGxpdHVkZTogJ2FtcGxpdHVkZScsXG4gIGFyYWJpY2Zvcm06ICdhcmFiaWNGb3JtJyxcbiAgJ2FyYWJpYy1mb3JtJzogJ2FyYWJpY0Zvcm0nLFxuICBhc2NlbnQ6ICdhc2NlbnQnLFxuICBhdHRyaWJ1dGVuYW1lOiAnYXR0cmlidXRlTmFtZScsXG4gIGF0dHJpYnV0ZXR5cGU6ICdhdHRyaWJ1dGVUeXBlJyxcbiAgYXV0b3JldmVyc2U6ICdhdXRvUmV2ZXJzZScsXG4gIGF6aW11dGg6ICdhemltdXRoJyxcbiAgYmFzZWZyZXF1ZW5jeTogJ2Jhc2VGcmVxdWVuY3knLFxuICBiYXNlbGluZXNoaWZ0OiAnYmFzZWxpbmVTaGlmdCcsXG4gICdiYXNlbGluZS1zaGlmdCc6ICdiYXNlbGluZVNoaWZ0JyxcbiAgYmFzZXByb2ZpbGU6ICdiYXNlUHJvZmlsZScsXG4gIGJib3g6ICdiYm94JyxcbiAgYmVnaW46ICdiZWdpbicsXG4gIGJpYXM6ICdiaWFzJyxcbiAgYnk6ICdieScsXG4gIGNhbGNtb2RlOiAnY2FsY01vZGUnLFxuICBjYXBoZWlnaHQ6ICdjYXBIZWlnaHQnLFxuICAnY2FwLWhlaWdodCc6ICdjYXBIZWlnaHQnLFxuICBjbGlwOiAnY2xpcCcsXG4gIGNsaXBwYXRoOiAnY2xpcFBhdGgnLFxuICAnY2xpcC1wYXRoJzogJ2NsaXBQYXRoJyxcbiAgY2xpcHBhdGh1bml0czogJ2NsaXBQYXRoVW5pdHMnLFxuICBjbGlwcnVsZTogJ2NsaXBSdWxlJyxcbiAgJ2NsaXAtcnVsZSc6ICdjbGlwUnVsZScsXG4gIGNvbG9yOiAnY29sb3InLFxuICBjb2xvcmludGVycG9sYXRpb246ICdjb2xvckludGVycG9sYXRpb24nLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbic6ICdjb2xvckludGVycG9sYXRpb24nLFxuICBjb2xvcmludGVycG9sYXRpb25maWx0ZXJzOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gIGNvbG9ycHJvZmlsZTogJ2NvbG9yUHJvZmlsZScsXG4gICdjb2xvci1wcm9maWxlJzogJ2NvbG9yUHJvZmlsZScsXG4gIGNvbG9ycmVuZGVyaW5nOiAnY29sb3JSZW5kZXJpbmcnLFxuICAnY29sb3ItcmVuZGVyaW5nJzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgY29udGVudHNjcmlwdHR5cGU6ICdjb250ZW50U2NyaXB0VHlwZScsXG4gIGNvbnRlbnRzdHlsZXR5cGU6ICdjb250ZW50U3R5bGVUeXBlJyxcbiAgY3Vyc29yOiAnY3Vyc29yJyxcbiAgY3g6ICdjeCcsXG4gIGN5OiAnY3knLFxuICBkOiAnZCcsXG4gIGRhdGF0eXBlOiAnZGF0YXR5cGUnLFxuICBkZWNlbGVyYXRlOiAnZGVjZWxlcmF0ZScsXG4gIGRlc2NlbnQ6ICdkZXNjZW50JyxcbiAgZGlmZnVzZWNvbnN0YW50OiAnZGlmZnVzZUNvbnN0YW50JyxcbiAgZGlyZWN0aW9uOiAnZGlyZWN0aW9uJyxcbiAgZGlzcGxheTogJ2Rpc3BsYXknLFxuICBkaXZpc29yOiAnZGl2aXNvcicsXG4gIGRvbWluYW50YmFzZWxpbmU6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgJ2RvbWluYW50LWJhc2VsaW5lJzogJ2RvbWluYW50QmFzZWxpbmUnLFxuICBkdXI6ICdkdXInLFxuICBkeDogJ2R4JyxcbiAgZHk6ICdkeScsXG4gIGVkZ2Vtb2RlOiAnZWRnZU1vZGUnLFxuICBlbGV2YXRpb246ICdlbGV2YXRpb24nLFxuICBlbmFibGViYWNrZ3JvdW5kOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gICdlbmFibGUtYmFja2dyb3VuZCc6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgZW5kOiAnZW5kJyxcbiAgZXhwb25lbnQ6ICdleHBvbmVudCcsXG4gIGV4dGVybmFscmVzb3VyY2VzcmVxdWlyZWQ6ICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxcbiAgZmlsbDogJ2ZpbGwnLFxuICBmaWxsb3BhY2l0eTogJ2ZpbGxPcGFjaXR5JyxcbiAgJ2ZpbGwtb3BhY2l0eSc6ICdmaWxsT3BhY2l0eScsXG4gIGZpbGxydWxlOiAnZmlsbFJ1bGUnLFxuICAnZmlsbC1ydWxlJzogJ2ZpbGxSdWxlJyxcbiAgZmlsdGVyOiAnZmlsdGVyJyxcbiAgZmlsdGVycmVzOiAnZmlsdGVyUmVzJyxcbiAgZmlsdGVydW5pdHM6ICdmaWx0ZXJVbml0cycsXG4gIGZsb29kb3BhY2l0eTogJ2Zsb29kT3BhY2l0eScsXG4gICdmbG9vZC1vcGFjaXR5JzogJ2Zsb29kT3BhY2l0eScsXG4gIGZsb29kY29sb3I6ICdmbG9vZENvbG9yJyxcbiAgJ2Zsb29kLWNvbG9yJzogJ2Zsb29kQ29sb3InLFxuICBmb2N1c2FibGU6ICdmb2N1c2FibGUnLFxuICBmb250ZmFtaWx5OiAnZm9udEZhbWlseScsXG4gICdmb250LWZhbWlseSc6ICdmb250RmFtaWx5JyxcbiAgZm9udHNpemU6ICdmb250U2l6ZScsXG4gICdmb250LXNpemUnOiAnZm9udFNpemUnLFxuICBmb250c2l6ZWFkanVzdDogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgJ2ZvbnQtc2l6ZS1hZGp1c3QnOiAnZm9udFNpemVBZGp1c3QnLFxuICBmb250c3RyZXRjaDogJ2ZvbnRTdHJldGNoJyxcbiAgJ2ZvbnQtc3RyZXRjaCc6ICdmb250U3RyZXRjaCcsXG4gIGZvbnRzdHlsZTogJ2ZvbnRTdHlsZScsXG4gICdmb250LXN0eWxlJzogJ2ZvbnRTdHlsZScsXG4gIGZvbnR2YXJpYW50OiAnZm9udFZhcmlhbnQnLFxuICAnZm9udC12YXJpYW50JzogJ2ZvbnRWYXJpYW50JyxcbiAgZm9udHdlaWdodDogJ2ZvbnRXZWlnaHQnLFxuICAnZm9udC13ZWlnaHQnOiAnZm9udFdlaWdodCcsXG4gIGZvcm1hdDogJ2Zvcm1hdCcsXG4gIGZyb206ICdmcm9tJyxcbiAgZng6ICdmeCcsXG4gIGZ5OiAnZnknLFxuICBnMTogJ2cxJyxcbiAgZzI6ICdnMicsXG4gIGdseXBobmFtZTogJ2dseXBoTmFtZScsXG4gICdnbHlwaC1uYW1lJzogJ2dseXBoTmFtZScsXG4gIGdseXBob3JpZW50YXRpb25ob3Jpem9udGFsOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCc6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gIGdseXBob3JpZW50YXRpb252ZXJ0aWNhbDogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCc6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICBnbHlwaHJlZjogJ2dseXBoUmVmJyxcbiAgZ3JhZGllbnR0cmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXG4gIGdyYWRpZW50dW5pdHM6ICdncmFkaWVudFVuaXRzJyxcbiAgaGFuZ2luZzogJ2hhbmdpbmcnLFxuICBob3JpemFkdng6ICdob3JpekFkdlgnLFxuICAnaG9yaXotYWR2LXgnOiAnaG9yaXpBZHZYJyxcbiAgaG9yaXpvcmlnaW54OiAnaG9yaXpPcmlnaW5YJyxcbiAgJ2hvcml6LW9yaWdpbi14JzogJ2hvcml6T3JpZ2luWCcsXG4gIGlkZW9ncmFwaGljOiAnaWRlb2dyYXBoaWMnLFxuICBpbWFnZXJlbmRlcmluZzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgJ2ltYWdlLXJlbmRlcmluZyc6ICdpbWFnZVJlbmRlcmluZycsXG4gIGluMjogJ2luMicsXG4gIGluOiAnaW4nLFxuICBpbmxpc3Q6ICdpbmxpc3QnLFxuICBpbnRlcmNlcHQ6ICdpbnRlcmNlcHQnLFxuICBrMTogJ2sxJyxcbiAgazI6ICdrMicsXG4gIGszOiAnazMnLFxuICBrNDogJ2s0JyxcbiAgazogJ2snLFxuICBrZXJuZWxtYXRyaXg6ICdrZXJuZWxNYXRyaXgnLFxuICBrZXJuZWx1bml0bGVuZ3RoOiAna2VybmVsVW5pdExlbmd0aCcsXG4gIGtlcm5pbmc6ICdrZXJuaW5nJyxcbiAga2V5cG9pbnRzOiAna2V5UG9pbnRzJyxcbiAga2V5c3BsaW5lczogJ2tleVNwbGluZXMnLFxuICBrZXl0aW1lczogJ2tleVRpbWVzJyxcbiAgbGVuZ3RoYWRqdXN0OiAnbGVuZ3RoQWRqdXN0JyxcbiAgbGV0dGVyc3BhY2luZzogJ2xldHRlclNwYWNpbmcnLFxuICAnbGV0dGVyLXNwYWNpbmcnOiAnbGV0dGVyU3BhY2luZycsXG4gIGxpZ2h0aW5nY29sb3I6ICdsaWdodGluZ0NvbG9yJyxcbiAgJ2xpZ2h0aW5nLWNvbG9yJzogJ2xpZ2h0aW5nQ29sb3InLFxuICBsaW1pdGluZ2NvbmVhbmdsZTogJ2xpbWl0aW5nQ29uZUFuZ2xlJyxcbiAgbG9jYWw6ICdsb2NhbCcsXG4gIG1hcmtlcmVuZDogJ21hcmtlckVuZCcsXG4gICdtYXJrZXItZW5kJzogJ21hcmtlckVuZCcsXG4gIG1hcmtlcmhlaWdodDogJ21hcmtlckhlaWdodCcsXG4gIG1hcmtlcm1pZDogJ21hcmtlck1pZCcsXG4gICdtYXJrZXItbWlkJzogJ21hcmtlck1pZCcsXG4gIG1hcmtlcnN0YXJ0OiAnbWFya2VyU3RhcnQnLFxuICAnbWFya2VyLXN0YXJ0JzogJ21hcmtlclN0YXJ0JyxcbiAgbWFya2VydW5pdHM6ICdtYXJrZXJVbml0cycsXG4gIG1hcmtlcndpZHRoOiAnbWFya2VyV2lkdGgnLFxuICBtYXNrOiAnbWFzaycsXG4gIG1hc2tjb250ZW50dW5pdHM6ICdtYXNrQ29udGVudFVuaXRzJyxcbiAgbWFza3VuaXRzOiAnbWFza1VuaXRzJyxcbiAgbWF0aGVtYXRpY2FsOiAnbWF0aGVtYXRpY2FsJyxcbiAgbW9kZTogJ21vZGUnLFxuICBudW1vY3RhdmVzOiAnbnVtT2N0YXZlcycsXG4gIG9mZnNldDogJ29mZnNldCcsXG4gIG9wYWNpdHk6ICdvcGFjaXR5JyxcbiAgb3BlcmF0b3I6ICdvcGVyYXRvcicsXG4gIG9yZGVyOiAnb3JkZXInLFxuICBvcmllbnQ6ICdvcmllbnQnLFxuICBvcmllbnRhdGlvbjogJ29yaWVudGF0aW9uJyxcbiAgb3JpZ2luOiAnb3JpZ2luJyxcbiAgb3ZlcmZsb3c6ICdvdmVyZmxvdycsXG4gIG92ZXJsaW5lcG9zaXRpb246ICdvdmVybGluZVBvc2l0aW9uJyxcbiAgJ292ZXJsaW5lLXBvc2l0aW9uJzogJ292ZXJsaW5lUG9zaXRpb24nLFxuICBvdmVybGluZXRoaWNrbmVzczogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgJ292ZXJsaW5lLXRoaWNrbmVzcyc6ICdvdmVybGluZVRoaWNrbmVzcycsXG4gIHBhaW50b3JkZXI6ICdwYWludE9yZGVyJyxcbiAgJ3BhaW50LW9yZGVyJzogJ3BhaW50T3JkZXInLFxuICBwYW5vc2UxOiAncGFub3NlMScsXG4gICdwYW5vc2UtMSc6ICdwYW5vc2UxJyxcbiAgcGF0aGxlbmd0aDogJ3BhdGhMZW5ndGgnLFxuICBwYXR0ZXJuY29udGVudHVuaXRzOiAncGF0dGVybkNvbnRlbnRVbml0cycsXG4gIHBhdHRlcm50cmFuc2Zvcm06ICdwYXR0ZXJuVHJhbnNmb3JtJyxcbiAgcGF0dGVybnVuaXRzOiAncGF0dGVyblVuaXRzJyxcbiAgcG9pbnRlcmV2ZW50czogJ3BvaW50ZXJFdmVudHMnLFxuICAncG9pbnRlci1ldmVudHMnOiAncG9pbnRlckV2ZW50cycsXG4gIHBvaW50czogJ3BvaW50cycsXG4gIHBvaW50c2F0eDogJ3BvaW50c0F0WCcsXG4gIHBvaW50c2F0eTogJ3BvaW50c0F0WScsXG4gIHBvaW50c2F0ejogJ3BvaW50c0F0WicsXG4gIHByZWZpeDogJ3ByZWZpeCcsXG4gIHByZXNlcnZlYWxwaGE6ICdwcmVzZXJ2ZUFscGhhJyxcbiAgcHJlc2VydmVhc3BlY3RyYXRpbzogJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLFxuICBwcmltaXRpdmV1bml0czogJ3ByaW1pdGl2ZVVuaXRzJyxcbiAgcHJvcGVydHk6ICdwcm9wZXJ0eScsXG4gIHI6ICdyJyxcbiAgcmFkaXVzOiAncmFkaXVzJyxcbiAgcmVmeDogJ3JlZlgnLFxuICByZWZ5OiAncmVmWScsXG4gIHJlbmRlcmluZ2ludGVudDogJ3JlbmRlcmluZ0ludGVudCcsXG4gICdyZW5kZXJpbmctaW50ZW50JzogJ3JlbmRlcmluZ0ludGVudCcsXG4gIHJlcGVhdGNvdW50OiAncmVwZWF0Q291bnQnLFxuICByZXBlYXRkdXI6ICdyZXBlYXREdXInLFxuICByZXF1aXJlZGV4dGVuc2lvbnM6ICdyZXF1aXJlZEV4dGVuc2lvbnMnLFxuICByZXF1aXJlZGZlYXR1cmVzOiAncmVxdWlyZWRGZWF0dXJlcycsXG4gIHJlc291cmNlOiAncmVzb3VyY2UnLFxuICByZXN0YXJ0OiAncmVzdGFydCcsXG4gIHJlc3VsdDogJ3Jlc3VsdCcsXG4gIHJlc3VsdHM6ICdyZXN1bHRzJyxcbiAgcm90YXRlOiAncm90YXRlJyxcbiAgcng6ICdyeCcsXG4gIHJ5OiAncnknLFxuICBzY2FsZTogJ3NjYWxlJyxcbiAgc2VjdXJpdHk6ICdzZWN1cml0eScsXG4gIHNlZWQ6ICdzZWVkJyxcbiAgc2hhcGVyZW5kZXJpbmc6ICdzaGFwZVJlbmRlcmluZycsXG4gICdzaGFwZS1yZW5kZXJpbmcnOiAnc2hhcGVSZW5kZXJpbmcnLFxuICBzbG9wZTogJ3Nsb3BlJyxcbiAgc3BhY2luZzogJ3NwYWNpbmcnLFxuICBzcGVjdWxhcmNvbnN0YW50OiAnc3BlY3VsYXJDb25zdGFudCcsXG4gIHNwZWN1bGFyZXhwb25lbnQ6ICdzcGVjdWxhckV4cG9uZW50JyxcbiAgc3BlZWQ6ICdzcGVlZCcsXG4gIHNwcmVhZG1ldGhvZDogJ3NwcmVhZE1ldGhvZCcsXG4gIHN0YXJ0b2Zmc2V0OiAnc3RhcnRPZmZzZXQnLFxuICBzdGRkZXZpYXRpb246ICdzdGREZXZpYXRpb24nLFxuICBzdGVtaDogJ3N0ZW1oJyxcbiAgc3RlbXY6ICdzdGVtdicsXG4gIHN0aXRjaHRpbGVzOiAnc3RpdGNoVGlsZXMnLFxuICBzdG9wY29sb3I6ICdzdG9wQ29sb3InLFxuICAnc3RvcC1jb2xvcic6ICdzdG9wQ29sb3InLFxuICBzdG9wb3BhY2l0eTogJ3N0b3BPcGFjaXR5JyxcbiAgJ3N0b3Atb3BhY2l0eSc6ICdzdG9wT3BhY2l0eScsXG4gIHN0cmlrZXRocm91Z2hwb3NpdGlvbjogJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsXG4gICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJzogJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsXG4gIHN0cmlrZXRocm91Z2h0aGlja25lc3M6ICdzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJyxcbiAgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJzogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICBzdHJpbmc6ICdzdHJpbmcnLFxuICBzdHJva2U6ICdzdHJva2UnLFxuICBzdHJva2VkYXNoYXJyYXk6ICdzdHJva2VEYXNoYXJyYXknLFxuICAnc3Ryb2tlLWRhc2hhcnJheSc6ICdzdHJva2VEYXNoYXJyYXknLFxuICBzdHJva2VkYXNob2Zmc2V0OiAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gICdzdHJva2UtZGFzaG9mZnNldCc6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgc3Ryb2tlbGluZWNhcDogJ3N0cm9rZUxpbmVjYXAnLFxuICAnc3Ryb2tlLWxpbmVjYXAnOiAnc3Ryb2tlTGluZWNhcCcsXG4gIHN0cm9rZWxpbmVqb2luOiAnc3Ryb2tlTGluZWpvaW4nLFxuICAnc3Ryb2tlLWxpbmVqb2luJzogJ3N0cm9rZUxpbmVqb2luJyxcbiAgc3Ryb2tlbWl0ZXJsaW1pdDogJ3N0cm9rZU1pdGVybGltaXQnLFxuICAnc3Ryb2tlLW1pdGVybGltaXQnOiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gIHN0cm9rZXdpZHRoOiAnc3Ryb2tlV2lkdGgnLFxuICAnc3Ryb2tlLXdpZHRoJzogJ3N0cm9rZVdpZHRoJyxcbiAgc3Ryb2tlb3BhY2l0eTogJ3N0cm9rZU9wYWNpdHknLFxuICAnc3Ryb2tlLW9wYWNpdHknOiAnc3Ryb2tlT3BhY2l0eScsXG4gIHN1cHByZXNzY29udGVudGVkaXRhYmxld2FybmluZzogJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZycsXG4gIHN1cHByZXNzaHlkcmF0aW9ud2FybmluZzogJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZycsXG4gIHN1cmZhY2VzY2FsZTogJ3N1cmZhY2VTY2FsZScsXG4gIHN5c3RlbWxhbmd1YWdlOiAnc3lzdGVtTGFuZ3VhZ2UnLFxuICB0YWJsZXZhbHVlczogJ3RhYmxlVmFsdWVzJyxcbiAgdGFyZ2V0eDogJ3RhcmdldFgnLFxuICB0YXJnZXR5OiAndGFyZ2V0WScsXG4gIHRleHRhbmNob3I6ICd0ZXh0QW5jaG9yJyxcbiAgJ3RleHQtYW5jaG9yJzogJ3RleHRBbmNob3InLFxuICB0ZXh0ZGVjb3JhdGlvbjogJ3RleHREZWNvcmF0aW9uJyxcbiAgJ3RleHQtZGVjb3JhdGlvbic6ICd0ZXh0RGVjb3JhdGlvbicsXG4gIHRleHRsZW5ndGg6ICd0ZXh0TGVuZ3RoJyxcbiAgdGV4dHJlbmRlcmluZzogJ3RleHRSZW5kZXJpbmcnLFxuICAndGV4dC1yZW5kZXJpbmcnOiAndGV4dFJlbmRlcmluZycsXG4gIHRvOiAndG8nLFxuICB0cmFuc2Zvcm06ICd0cmFuc2Zvcm0nLFxuICB0cmFuc2Zvcm1vcmlnaW46ICd0cmFuc2Zvcm1PcmlnaW4nLFxuICAndHJhbnNmb3JtLW9yaWdpbic6ICd0cmFuc2Zvcm1PcmlnaW4nLFxuICB0eXBlb2Y6ICd0eXBlb2YnLFxuICB1MTogJ3UxJyxcbiAgdTI6ICd1MicsXG4gIHVuZGVybGluZXBvc2l0aW9uOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICAndW5kZXJsaW5lLXBvc2l0aW9uJzogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgdW5kZXJsaW5ldGhpY2tuZXNzOiAndW5kZXJsaW5lVGhpY2tuZXNzJyxcbiAgJ3VuZGVybGluZS10aGlja25lc3MnOiAndW5kZXJsaW5lVGhpY2tuZXNzJyxcbiAgdW5pY29kZTogJ3VuaWNvZGUnLFxuICB1bmljb2RlYmlkaTogJ3VuaWNvZGVCaWRpJyxcbiAgJ3VuaWNvZGUtYmlkaSc6ICd1bmljb2RlQmlkaScsXG4gIHVuaWNvZGVyYW5nZTogJ3VuaWNvZGVSYW5nZScsXG4gICd1bmljb2RlLXJhbmdlJzogJ3VuaWNvZGVSYW5nZScsXG4gIHVuaXRzcGVyZW06ICd1bml0c1BlckVtJyxcbiAgJ3VuaXRzLXBlci1lbSc6ICd1bml0c1BlckVtJyxcbiAgdW5zZWxlY3RhYmxlOiAndW5zZWxlY3RhYmxlJyxcbiAgdmFscGhhYmV0aWM6ICd2QWxwaGFiZXRpYycsXG4gICd2LWFscGhhYmV0aWMnOiAndkFscGhhYmV0aWMnLFxuICB2YWx1ZXM6ICd2YWx1ZXMnLFxuICB2ZWN0b3JlZmZlY3Q6ICd2ZWN0b3JFZmZlY3QnLFxuICAndmVjdG9yLWVmZmVjdCc6ICd2ZWN0b3JFZmZlY3QnLFxuICB2ZXJzaW9uOiAndmVyc2lvbicsXG4gIHZlcnRhZHZ5OiAndmVydEFkdlknLFxuICAndmVydC1hZHYteSc6ICd2ZXJ0QWR2WScsXG4gIHZlcnRvcmlnaW54OiAndmVydE9yaWdpblgnLFxuICAndmVydC1vcmlnaW4teCc6ICd2ZXJ0T3JpZ2luWCcsXG4gIHZlcnRvcmlnaW55OiAndmVydE9yaWdpblknLFxuICAndmVydC1vcmlnaW4teSc6ICd2ZXJ0T3JpZ2luWScsXG4gIHZoYW5naW5nOiAndkhhbmdpbmcnLFxuICAndi1oYW5naW5nJzogJ3ZIYW5naW5nJyxcbiAgdmlkZW9ncmFwaGljOiAndklkZW9ncmFwaGljJyxcbiAgJ3YtaWRlb2dyYXBoaWMnOiAndklkZW9ncmFwaGljJyxcbiAgdmlld2JveDogJ3ZpZXdCb3gnLFxuICB2aWV3dGFyZ2V0OiAndmlld1RhcmdldCcsXG4gIHZpc2liaWxpdHk6ICd2aXNpYmlsaXR5JyxcbiAgdm1hdGhlbWF0aWNhbDogJ3ZNYXRoZW1hdGljYWwnLFxuICAndi1tYXRoZW1hdGljYWwnOiAndk1hdGhlbWF0aWNhbCcsXG4gIHZvY2FiOiAndm9jYWInLFxuICB3aWR0aHM6ICd3aWR0aHMnLFxuICB3b3Jkc3BhY2luZzogJ3dvcmRTcGFjaW5nJyxcbiAgJ3dvcmQtc3BhY2luZyc6ICd3b3JkU3BhY2luZycsXG4gIHdyaXRpbmdtb2RlOiAnd3JpdGluZ01vZGUnLFxuICAnd3JpdGluZy1tb2RlJzogJ3dyaXRpbmdNb2RlJyxcbiAgeDE6ICd4MScsXG4gIHgyOiAneDInLFxuICB4OiAneCcsXG4gIHhjaGFubmVsc2VsZWN0b3I6ICd4Q2hhbm5lbFNlbGVjdG9yJyxcbiAgeGhlaWdodDogJ3hIZWlnaHQnLFxuICAneC1oZWlnaHQnOiAneEhlaWdodCcsXG4gIHhsaW5rYWN0dWF0ZTogJ3hsaW5rQWN0dWF0ZScsXG4gICd4bGluazphY3R1YXRlJzogJ3hsaW5rQWN0dWF0ZScsXG4gIHhsaW5rYXJjcm9sZTogJ3hsaW5rQXJjcm9sZScsXG4gICd4bGluazphcmNyb2xlJzogJ3hsaW5rQXJjcm9sZScsXG4gIHhsaW5raHJlZjogJ3hsaW5rSHJlZicsXG4gICd4bGluazpocmVmJzogJ3hsaW5rSHJlZicsXG4gIHhsaW5rcm9sZTogJ3hsaW5rUm9sZScsXG4gICd4bGluazpyb2xlJzogJ3hsaW5rUm9sZScsXG4gIHhsaW5rc2hvdzogJ3hsaW5rU2hvdycsXG4gICd4bGluazpzaG93JzogJ3hsaW5rU2hvdycsXG4gIHhsaW5rdGl0bGU6ICd4bGlua1RpdGxlJyxcbiAgJ3hsaW5rOnRpdGxlJzogJ3hsaW5rVGl0bGUnLFxuICB4bGlua3R5cGU6ICd4bGlua1R5cGUnLFxuICAneGxpbms6dHlwZSc6ICd4bGlua1R5cGUnLFxuICB4bWxiYXNlOiAneG1sQmFzZScsXG4gICd4bWw6YmFzZSc6ICd4bWxCYXNlJyxcbiAgeG1sbGFuZzogJ3htbExhbmcnLFxuICAneG1sOmxhbmcnOiAneG1sTGFuZycsXG4gIHhtbG5zOiAneG1sbnMnLFxuICAneG1sOnNwYWNlJzogJ3htbFNwYWNlJyxcbiAgeG1sbnN4bGluazogJ3htbG5zWGxpbmsnLFxuICAneG1sbnM6eGxpbmsnOiAneG1sbnNYbGluaycsXG4gIHhtbHNwYWNlOiAneG1sU3BhY2UnLFxuICB5MTogJ3kxJyxcbiAgeTI6ICd5MicsXG4gIHk6ICd5JyxcbiAgeWNoYW5uZWxzZWxlY3RvcjogJ3lDaGFubmVsU2VsZWN0b3InLFxuICB6OiAneicsXG4gIHpvb21hbmRwYW46ICd6b29tQW5kUGFuJ1xufTtcblxudmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcbnZhciBFVkVOVF9OQU1FX1JFR0VYID0gL15vbi4vO1xudmFyIElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWCA9IC9eb25bXkEtWl0vO1xudmFyIHJBUklBID0gbmV3IFJlZ0V4cCgnXihhcmlhKS1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJykgO1xudmFyIHJBUklBQ2FtZWwgPSBuZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJykgO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5KHRhZ05hbWUsIG5hbWUsIHZhbHVlLCBldmVudFJlZ2lzdHJ5KSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3VzaW4nIHx8IGxvd2VyQ2FzZWROYW1lID09PSAnb25mb2N1c291dCcpIHtcbiAgICAgIGVycm9yKCdSZWFjdCB1c2VzIG9uRm9jdXMgYW5kIG9uQmx1ciBpbnN0ZWFkIG9mIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dC4gJyArICdBbGwgUmVhY3QgZXZlbnRzIGFyZSBub3JtYWxpemVkIHRvIGJ1YmJsZSwgc28gb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0ICcgKyAnYXJlIG5vdCBuZWVkZWQvc3VwcG9ydGVkIGJ5IFJlYWN0LicpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG4gICAgaWYgKGV2ZW50UmVnaXN0cnkgIT0gbnVsbCkge1xuICAgICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMgPSBldmVudFJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMsXG4gICAgICAgICAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyA9IGV2ZW50UmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lcztcblxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XG5cbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCByZWdpc3RyYXRpb25OYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgICAgZXJyb3IoJ1Vua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBJdCB3aWxsIGJlIGlnbm9yZWQuJywgbmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBJZiBubyBldmVudCBwbHVnaW5zIGhhdmUgYmVlbiBpbmplY3RlZCwgd2UgYXJlIGluIGEgc2VydmVyIGVudmlyb25tZW50LlxuICAgICAgLy8gU28gd2UgY2FuJ3QgdGVsbCBpZiB0aGUgZXZlbnQgbmFtZSBpcyBjb3JyZWN0IGZvciBzdXJlLCBidXQgd2UgY2FuIGZpbHRlclxuICAgICAgLy8gb3V0IGtub3duIGJhZCBvbmVzIGxpa2UgYG9uY2xpY2tgLiBXZSBjYW4ndCBzdWdnZXN0IGEgc3BlY2lmaWMgcmVwbGFjZW1lbnQgdGhvdWdoLlxuICAgICAgaWYgKElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gJyArICdSZWFjdCBldmVudHMgdXNlIHRoZSBjYW1lbENhc2UgbmFtaW5nIGNvbnZlbnRpb24sIGZvciBleGFtcGxlIGBvbkNsaWNrYC4nLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIExldCB0aGUgQVJJQSBhdHRyaWJ1dGUgaG9vayB2YWxpZGF0ZSBBUklBIGF0dHJpYnV0ZXNcblxuXG4gICAgaWYgKHJBUklBLnRlc3QobmFtZSkgfHwgckFSSUFDYW1lbC50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpbm5lcmh0bWwnKSB7XG4gICAgICBlcnJvcignRGlyZWN0bHkgc2V0dGluZyBwcm9wZXJ0eSBgaW5uZXJIVE1MYCBpcyBub3QgcGVybWl0dGVkLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBsb29rdXAgZG9jdW1lbnRhdGlvbiBvbiBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2FyaWEnKSB7XG4gICAgICBlcnJvcignVGhlIGBhcmlhYCBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2UgaW4gUmVhY3QuICcgKyAnUGFzcyBpbmRpdmlkdWFsIGBhcmlhLWAgYXR0cmlidXRlcyBpbnN0ZWFkLicpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lzJyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhIGAlc2AgZm9yIGEgc3RyaW5nIGF0dHJpYnV0ZSBgaXNgLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcgKyAndGhlIHZhbHVlIHRvIGEgc3RyaW5nLicsIHR5cGVvZiB2YWx1ZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgTmFOIGZvciB0aGUgYCVzYCBhdHRyaWJ1dGUuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgJyArICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJywgbmFtZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBLbm93biBhdHRyaWJ1dGVzIHNob3VsZCBtYXRjaCB0aGUgY2FzaW5nIHNwZWNpZmllZCBpbiB0aGUgcHJvcGVydHkgY29uZmlnLlxuXG5cbiAgICBpZiAocG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSkge1xuICAgICAgdmFyIHN0YW5kYXJkTmFtZSA9IHBvc3NpYmxlU3RhbmRhcmROYW1lc1tsb3dlckNhc2VkTmFtZV07XG5cbiAgICAgIGlmIChzdGFuZGFyZE5hbWUgIT09IG5hbWUpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgRE9NIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIHN0YW5kYXJkTmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmFtZSAhPT0gbG93ZXJDYXNlZE5hbWUpIHtcbiAgICAgIC8vIFVua25vd24gYXR0cmlidXRlcyBzaG91bGQgaGF2ZSBsb3dlcmNhc2UgY2FzaW5nIHNpbmNlIHRoYXQncyBob3cgdGhleVxuICAgICAgLy8gd2lsbCBiZSBjYXNlZCBhbnl3YXkgd2l0aCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgICAgZXJyb3IoJ1JlYWN0IGRvZXMgbm90IHJlY29nbml6ZSB0aGUgYCVzYCBwcm9wIG9uIGEgRE9NIGVsZW1lbnQuIElmIHlvdSAnICsgJ2ludGVudGlvbmFsbHkgd2FudCBpdCB0byBhcHBlYXIgaW4gdGhlIERPTSBhcyBhIGN1c3RvbSAnICsgJ2F0dHJpYnV0ZSwgc3BlbGwgaXQgYXMgbG93ZXJjYXNlIGAlc2AgaW5zdGVhZC4gJyArICdJZiB5b3UgYWNjaWRlbnRhbGx5IHBhc3NlZCBpdCBmcm9tIGEgcGFyZW50IGNvbXBvbmVudCwgcmVtb3ZlICcgKyAnaXQgZnJvbSB0aGUgRE9NIGVsZW1lbnQuJywgbmFtZSwgbG93ZXJDYXNlZE5hbWUpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gTm93IHRoYXQgd2UndmUgdmFsaWRhdGVkIGNhc2luZywgZG8gbm90IHZhbGlkYXRlXG4gICAgLy8gZGF0YSB0eXBlcyBmb3IgcmVzZXJ2ZWQgcHJvcHNcblxuXG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICBjYXNlICdzdHlsZSc6XG4gICAgICBjYXNlICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnOlxuICAgICAgY2FzZSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJzpcbiAgICAgIGNhc2UgJ2RlZmF1bHRWYWx1ZSc6IC8vIFJlc2VydmVkXG5cbiAgICAgIGNhc2UgJ2RlZmF1bHRDaGVja2VkJzpcbiAgICAgIGNhc2UgJ2lubmVySFRNTCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICB7XG4gICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdhdXRvRm9jdXMnOlxuICAgICAgICAgICAgY2FzZSAnY2hlY2tlZCc6XG4gICAgICAgICAgICBjYXNlICdtdWx0aXBsZSc6XG4gICAgICAgICAgICBjYXNlICdtdXRlZCc6XG4gICAgICAgICAgICBjYXNlICdzZWxlY3RlZCc6XG4gICAgICAgICAgICBjYXNlICdjb250ZW50RWRpdGFibGUnOlxuICAgICAgICAgICAgY2FzZSAnc3BlbGxDaGVjayc6XG4gICAgICAgICAgICBjYXNlICdkcmFnZ2FibGUnOlxuICAgICAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgICAgY2FzZSAnYXV0b1JldmVyc2UnOlxuICAgICAgICAgICAgY2FzZSAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCc6XG4gICAgICAgICAgICBjYXNlICdmb2N1c2FibGUnOlxuICAgICAgICAgICAgY2FzZSAncHJlc2VydmVBbHBoYSc6XG4gICAgICAgICAgICBjYXNlICdhbGxvd0Z1bGxTY3JlZW4nOlxuICAgICAgICAgICAgY2FzZSAnYXN5bmMnOlxuICAgICAgICAgICAgY2FzZSAnYXV0b1BsYXknOlxuICAgICAgICAgICAgY2FzZSAnY29udHJvbHMnOlxuICAgICAgICAgICAgY2FzZSAnZGVmYXVsdCc6XG4gICAgICAgICAgICBjYXNlICdkZWZlcic6XG4gICAgICAgICAgICBjYXNlICdkaXNhYmxlZCc6XG4gICAgICAgICAgICBjYXNlICdkaXNhYmxlUGljdHVyZUluUGljdHVyZSc6XG4gICAgICAgICAgICBjYXNlICdkaXNhYmxlUmVtb3RlUGxheWJhY2snOlxuICAgICAgICAgICAgY2FzZSAnZm9ybU5vVmFsaWRhdGUnOlxuICAgICAgICAgICAgY2FzZSAnaGlkZGVuJzpcbiAgICAgICAgICAgIGNhc2UgJ2xvb3AnOlxuICAgICAgICAgICAgY2FzZSAnbm9Nb2R1bGUnOlxuICAgICAgICAgICAgY2FzZSAnbm9WYWxpZGF0ZSc6XG4gICAgICAgICAgICBjYXNlICdvcGVuJzpcbiAgICAgICAgICAgIGNhc2UgJ3BsYXlzSW5saW5lJzpcbiAgICAgICAgICAgIGNhc2UgJ3JlYWRPbmx5JzpcbiAgICAgICAgICAgIGNhc2UgJ3JlcXVpcmVkJzpcbiAgICAgICAgICAgIGNhc2UgJ3JldmVyc2VkJzpcbiAgICAgICAgICAgIGNhc2UgJ3Njb3BlZCc6XG4gICAgICAgICAgICBjYXNlICdzZWFtbGVzcyc6XG4gICAgICAgICAgICBjYXNlICdpdGVtU2NvcGUnOlxuICAgICAgICAgICAgY2FzZSAnY2FwdHVyZSc6XG4gICAgICAgICAgICBjYXNlICdkb3dubG9hZCc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBCb29sZWFuIHByb3BlcnRpZXMgY2FuIGFjY2VwdCBib29sZWFuIHZhbHVlc1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJlZml4ID0gbmFtZS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsIDUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHByZWZpeCA9PT0gJ2RhdGEtJyB8fCBwcmVmaXggPT09ICdhcmlhLScpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuJyArICdJZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICcgKyAnJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS4nLCB2YWx1ZSwgbmFtZSwgbmFtZSwgdmFsdWUsIG5hbWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG4nICsgJ0lmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJyArICclcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LlxcblxcbicgKyAnSWYgeW91IHVzZWQgdG8gY29uZGl0aW9uYWxseSBvbWl0IGl0IHdpdGggJXM9e2NvbmRpdGlvbiAmJiB2YWx1ZX0sICcgKyAncGFzcyAlcz17Y29uZGl0aW9uID8gdmFsdWUgOiB1bmRlZmluZWR9IGluc3RlYWQuJywgdmFsdWUsIG5hbWUsIG5hbWUsIHZhbHVlLCBuYW1lLCBuYW1lLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIC8vIFdhcm4gd2hlbiBhIGtub3duIGF0dHJpYnV0ZSBpcyBhIGJhZCB0eXBlXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBXYXJuIHdoZW4gcGFzc2luZyB0aGUgc3RyaW5ncyAnZmFsc2UnIG9yICd0cnVlJyBpbnRvIGEgYm9vbGVhbiBwcm9wXG4gICAgICAgICAgaWYgKHZhbHVlID09PSAnZmFsc2UnIHx8IHZhbHVlID09PSAndHJ1ZScpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgICBjYXNlICdjaGVja2VkJzpcbiAgICAgICAgICAgICAgY2FzZSAnc2VsZWN0ZWQnOlxuICAgICAgICAgICAgICBjYXNlICdtdWx0aXBsZSc6XG4gICAgICAgICAgICAgIGNhc2UgJ211dGVkJzpcbiAgICAgICAgICAgICAgY2FzZSAnYWxsb3dGdWxsU2NyZWVuJzpcbiAgICAgICAgICAgICAgY2FzZSAnYXN5bmMnOlxuICAgICAgICAgICAgICBjYXNlICdhdXRvUGxheSc6XG4gICAgICAgICAgICAgIGNhc2UgJ2NvbnRyb2xzJzpcbiAgICAgICAgICAgICAgY2FzZSAnZGVmYXVsdCc6XG4gICAgICAgICAgICAgIGNhc2UgJ2RlZmVyJzpcbiAgICAgICAgICAgICAgY2FzZSAnZGlzYWJsZWQnOlxuICAgICAgICAgICAgICBjYXNlICdkaXNhYmxlUGljdHVyZUluUGljdHVyZSc6XG4gICAgICAgICAgICAgIGNhc2UgJ2Rpc2FibGVSZW1vdGVQbGF5YmFjayc6XG4gICAgICAgICAgICAgIGNhc2UgJ2Zvcm1Ob1ZhbGlkYXRlJzpcbiAgICAgICAgICAgICAgY2FzZSAnaGlkZGVuJzpcbiAgICAgICAgICAgICAgY2FzZSAnbG9vcCc6XG4gICAgICAgICAgICAgIGNhc2UgJ25vTW9kdWxlJzpcbiAgICAgICAgICAgICAgY2FzZSAnbm9WYWxpZGF0ZSc6XG4gICAgICAgICAgICAgIGNhc2UgJ29wZW4nOlxuICAgICAgICAgICAgICBjYXNlICdwbGF5c0lubGluZSc6XG4gICAgICAgICAgICAgIGNhc2UgJ3JlYWRPbmx5JzpcbiAgICAgICAgICAgICAgY2FzZSAncmVxdWlyZWQnOlxuICAgICAgICAgICAgICBjYXNlICdyZXZlcnNlZCc6XG4gICAgICAgICAgICAgIGNhc2UgJ3Njb3BlZCc6XG4gICAgICAgICAgICAgIGNhc2UgJ3NlYW1sZXNzJzpcbiAgICAgICAgICAgICAgY2FzZSAnaXRlbVNjb3BlJzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVycm9yKCdSZWNlaXZlZCB0aGUgc3RyaW5nIGAlc2AgZm9yIHRoZSBib29sZWFuIGF0dHJpYnV0ZSBgJXNgLiAnICsgJyVzICcgKyAnRGlkIHlvdSBtZWFuICVzPXslc30/JywgdmFsdWUsIG5hbWUsIHZhbHVlID09PSAnZmFsc2UnID8gJ1RoZSBicm93c2VyIHdpbGwgaW50ZXJwcmV0IGl0IGFzIGEgdHJ1dGh5IHZhbHVlLicgOiAnQWx0aG91Z2ggdGhpcyB3b3JrcywgaXQgd2lsbCBub3Qgd29yayBhcyBleHBlY3RlZCBpZiB5b3UgcGFzcyB0aGUgc3RyaW5nIFwiZmFsc2VcIi4nLCBuYW1lLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FyblVua25vd25Qcm9wZXJ0aWVzKHR5cGUsIHByb3BzLCBldmVudFJlZ2lzdHJ5KSB7XG4gIHtcbiAgICB2YXIgdW5rbm93blByb3BzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSh0eXBlLCBrZXksIHByb3BzW2tleV0sIGV2ZW50UmVnaXN0cnkpO1xuXG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgICB9KS5qb2luKCcsICcpO1xuXG4gICAgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBwcm9wICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIGl0IGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCBpdCBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2F0dHJpYnV0ZS1iZWhhdmlvciAnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfSBlbHNlIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID4gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgdmFsdWVzIGZvciBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSB0aGVtIGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCB0aGVtIGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvYXR0cmlidXRlLWJlaGF2aW9yICcsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzLCBldmVudFJlZ2lzdHJ5KSB7XG4gIGlmIChpc0N1c3RvbUVsZW1lbnQodHlwZSkgfHwgdHlwZW9mIHByb3BzLmlzID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHdhcm5Vbmtub3duUHJvcGVydGllcyh0eXBlLCBwcm9wcywgZXZlbnRSZWdpc3RyeSk7XG59XG5cbi8vICdtc1RyYW5zZm9ybScgaXMgY29ycmVjdCwgYnV0IHRoZSBvdGhlciBwcmVmaXhlcyBzaG91bGQgYmUgY2FwaXRhbGl6ZWRcbnZhciBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG52YXIgbXNQYXR0ZXJuJDEgPSAvXi1tcy0vO1xudmFyIGh5cGhlblBhdHRlcm4gPSAvLSguKS9nOyAvLyBzdHlsZSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb25cblxudmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiA9IC87XFxzKiQvO1xudmFyIHdhcm5lZFN0eWxlTmFtZXMgPSB7fTtcbnZhciB3YXJuZWRTdHlsZVZhbHVlcyA9IHt9O1xudmFyIHdhcm5lZEZvck5hTlZhbHVlID0gZmFsc2U7XG52YXIgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IGZhbHNlO1xuXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKGh5cGhlblBhdHRlcm4sIGZ1bmN0aW9uIChfLCBjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZShuYW1lKSB7XG4gIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG5cbiAgICBlcnJvcignVW5zdXBwb3J0ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCAvLyBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gICAgLy8gKGh0dHA6Ly93d3cuYW5kaXNtaXRoLmNvbS9ibG9nLzIwMTIvMDIvbW9kZXJuaXpyLXByZWZpeGVkLyksIGFuIGAtbXNgIHByZWZpeFxuICAgIC8vIGlzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYG1zYC5cbiAgICBjYW1lbGl6ZShuYW1lLnJlcGxhY2UobXNQYXR0ZXJuJDEsICdtcy0nKSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZShuYW1lKSB7XG4gIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG5cbiAgICBlcnJvcignVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLCB2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdhcm5lZFN0eWxlVmFsdWVzLmhhc093blByb3BlcnR5KHZhbHVlKSAmJiB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0gPSB0cnVlO1xuXG4gICAgZXJyb3IoXCJTdHlsZSBwcm9wZXJ0eSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb24uIFwiICsgJ1RyeSBcIiVzOiAlc1wiIGluc3RlYWQuJywgbmFtZSwgdmFsdWUucmVwbGFjZShiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4sICcnKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FyblN0eWxlVmFsdWVJc05hTihuYW1lLCB2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdhcm5lZEZvck5hTlZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9yTmFOVmFsdWUgPSB0cnVlO1xuXG4gICAgZXJyb3IoJ2BOYU5gIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4nLCBuYW1lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkobmFtZSwgdmFsdWUpIHtcbiAge1xuICAgIGlmICh3YXJuZWRGb3JJbmZpbml0eVZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IHRydWU7XG5cbiAgICBlcnJvcignYEluZmluaXR5YCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJywgbmFtZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FyblZhbGlkU3R5bGUobmFtZSwgdmFsdWUpIHtcbiAge1xuICAgIGlmIChuYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc05hTihuYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICB3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkobmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG52YXIgbWF0Y2hIdG1sUmVnRXhwID0gL1tcIicmPD5dLztcbi8qKlxuICogRXNjYXBlcyBzcGVjaWFsIGNoYXJhY3RlcnMgYW5kIEhUTUwgZW50aXRpZXMgaW4gYSBnaXZlbiBodG1sIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0cmluZyBIVE1MIHN0cmluZyB0byBlc2NhcGUgZm9yIGxhdGVyIGluc2VydGlvblxuICogQHJldHVybiB7c3RyaW5nfVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyaW5nKSB7XG4gIHtcbiAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihzdHJpbmcpO1xuICB9XG5cbiAgdmFyIHN0ciA9ICcnICsgc3RyaW5nO1xuICB2YXIgbWF0Y2ggPSBtYXRjaEh0bWxSZWdFeHAuZXhlYyhzdHIpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIGVzY2FwZTtcbiAgdmFyIGh0bWwgPSAnJztcbiAgdmFyIGluZGV4O1xuICB2YXIgbGFzdEluZGV4ID0gMDtcblxuICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XG4gICAgICBjYXNlIDM0OlxuICAgICAgICAvLyBcIlxuICAgICAgICBlc2NhcGUgPSAnJnF1b3Q7JztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMzg6XG4gICAgICAgIC8vICZcbiAgICAgICAgZXNjYXBlID0gJyZhbXA7JztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIC8vICdcbiAgICAgICAgZXNjYXBlID0gJyYjeDI3Oyc7IC8vIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWw7IHVzZWQgdG8gYmUgJyYjMzknXG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNjA6XG4gICAgICAgIC8vIDxcbiAgICAgICAgZXNjYXBlID0gJyZsdDsnO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA2MjpcbiAgICAgICAgLy8gPlxuICAgICAgICBlc2NhcGUgPSAnJmd0Oyc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobGFzdEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgaHRtbCArPSBzdHIuc2xpY2UobGFzdEluZGV4LCBpbmRleCk7XG4gICAgfVxuXG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyAxO1xuICAgIGh0bWwgKz0gZXNjYXBlO1xuICB9XG5cbiAgcmV0dXJuIGxhc3RJbmRleCAhPT0gaW5kZXggPyBodG1sICsgc3RyLnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbn0gLy8gZW5kIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG5cbi8qKlxuICogRXNjYXBlcyB0ZXh0IHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IFRleHQgdmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGVzY2FwZVRleHRGb3JCcm93c2VyKHRleHQpIHtcbiAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHRleHQgPT09ICdudW1iZXInKSB7XG4gICAgLy8gdGhpcyBzaG9ydGNpcmN1aXQgaGVscHMgcGVyZiBmb3IgdHlwZXMgdGhhdCB3ZSBrbm93IHdpbGwgbmV2ZXIgaGF2ZVxuICAgIC8vIHNwZWNpYWwgY2hhcmFjdGVycywgZXNwZWNpYWxseSBnaXZlbiB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgdXNlZCBvZnRlblxuICAgIC8vIGZvciBudW1lcmljIGRvbSBpZHMuXG4gICAgcmV0dXJuICcnICsgdGV4dDtcbiAgfVxuXG4gIHJldHVybiBlc2NhcGVIdG1sKHRleHQpO1xufVxuXG52YXIgdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2c7XG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKi9cblxuZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUucmVwbGFjZSh1cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxuLy8gYW5kIGFueSBuZXdsaW5lIG9yIHRhYiBhcmUgZmlsdGVyZWQgb3V0IGFzIGlmIHRoZXkncmUgbm90IHBhcnQgb2YgdGhlIFVSTC5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsLXBhcnNpbmdcbi8vIFRhYiBvciBuZXdsaW5lIGFyZSBkZWZpbmVkIGFzIFxcclxcblxcdDpcbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNhc2NpaS10YWItb3ItbmV3bGluZVxuLy8gQSBDMCBjb250cm9sIGlzIGEgY29kZSBwb2ludCBpbiB0aGUgcmFuZ2UgXFx1MDAwMCBOVUxMIHRvIFxcdTAwMUZcbi8vIElORk9STUFUSU9OIFNFUEFSQVRPUiBPTkUsIGluY2x1c2l2ZTpcbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNjMC1jb250cm9sLW9yLXNwYWNlXG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxudmFyIGlzSmF2YVNjcmlwdFByb3RvY29sID0gL15bXFx1MDAwMC1cXHUwMDFGIF0qaltcXHJcXG5cXHRdKmFbXFxyXFxuXFx0XSp2W1xcclxcblxcdF0qYVtcXHJcXG5cXHRdKnNbXFxyXFxuXFx0XSpjW1xcclxcblxcdF0qcltcXHJcXG5cXHRdKmlbXFxyXFxuXFx0XSpwW1xcclxcblxcdF0qdFtcXHJcXG5cXHRdKlxcOi9pO1xudmFyIGRpZFdhcm4gPSBmYWxzZTtcblxuZnVuY3Rpb24gc2FuaXRpemVVUkwodXJsKSB7XG4gIC8vIFdlIHNob3VsZCBuZXZlciBoYXZlIHN5bWJvbHMgaGVyZSBiZWNhdXNlIHRoZXkgZ2V0IGZpbHRlcmVkIG91dCBlbHNld2hlcmUuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICB2YXIgc3RyaW5naWZpZWRVUkwgPSAnJyArIHVybDtcblxuICB7XG4gICAgaWYgKCFkaWRXYXJuICYmIGlzSmF2YVNjcmlwdFByb3RvY29sLnRlc3Qoc3RyaW5naWZpZWRVUkwpKSB7XG4gICAgICBkaWRXYXJuID0gdHJ1ZTtcblxuICAgICAgZXJyb3IoJ0EgZnV0dXJlIHZlcnNpb24gb2YgUmVhY3Qgd2lsbCBibG9jayBqYXZhc2NyaXB0OiBVUkxzIGFzIGEgc2VjdXJpdHkgcHJlY2F1dGlvbi4gJyArICdVc2UgZXZlbnQgaGFuZGxlcnMgaW5zdGVhZCBpZiB5b3UgY2FuLiBJZiB5b3UgbmVlZCB0byBnZW5lcmF0ZSB1bnNhZmUgSFRNTCB0cnkgJyArICd1c2luZyBkYW5nZXJvdXNseVNldElubmVySFRNTCBpbnN0ZWFkLiBSZWFjdCB3YXMgcGFzc2VkICVzLicsIEpTT04uc3RyaW5naWZ5KHN0cmluZ2lmaWVkVVJMKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVybDtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBUaGUgYnVpbGQgc2NyaXB0IGlzIGF0IHNjcmlwdHMvcm9sbHVwL2dlbmVyYXRlLWlubGluZS1maXp6LXJ1bnRpbWUuanMuXG4vLyBSdW4gYHlhcm4gZ2VuZXJhdGUtaW5saW5lLWZpenotcnVudGltZWAgdG8gZ2VuZXJhdGUuXG52YXIgY2xpZW50UmVuZGVyQm91bmRhcnkgPSAnJFJYPWZ1bmN0aW9uKGIsYyxkLGUpe3ZhciBhPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGIpO2EmJihiPWEucHJldmlvdXNTaWJsaW5nLGIuZGF0YT1cIiQhXCIsYT1hLmRhdGFzZXQsYyYmKGEuZGdzdD1jKSxkJiYoYS5tc2c9ZCksZSYmKGEuc3Rjaz1lKSxiLl9yZWFjdFJldHJ5JiZiLl9yZWFjdFJldHJ5KCkpfTsnO1xudmFyIGNvbXBsZXRlQm91bmRhcnkgPSAnJFJDPWZ1bmN0aW9uKGIsYyxlKXtjPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGMpO2MucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjKTt2YXIgYT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChiKTtpZihhKXtiPWEucHJldmlvdXNTaWJsaW5nO2lmKGUpYi5kYXRhPVwiJCFcIixhLnNldEF0dHJpYnV0ZShcImRhdGEtZGdzdFwiLGUpO2Vsc2V7ZT1iLnBhcmVudE5vZGU7YT1iLm5leHRTaWJsaW5nO3ZhciBmPTA7ZG97aWYoYSYmOD09PWEubm9kZVR5cGUpe3ZhciBkPWEuZGF0YTtpZihcIi8kXCI9PT1kKWlmKDA9PT1mKWJyZWFrO2Vsc2UgZi0tO2Vsc2VcIiRcIiE9PWQmJlwiJD9cIiE9PWQmJlwiJCFcIiE9PWR8fGYrK31kPWEubmV4dFNpYmxpbmc7ZS5yZW1vdmVDaGlsZChhKTthPWR9d2hpbGUoYSk7Zm9yKDtjLmZpcnN0Q2hpbGQ7KWUuaW5zZXJ0QmVmb3JlKGMuZmlyc3RDaGlsZCxhKTtiLmRhdGE9XCIkXCJ9Yi5fcmVhY3RSZXRyeSYmYi5fcmVhY3RSZXRyeSgpfX07JztcbnZhciBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlcyA9ICckUk09bmV3IE1hcDtcXG4kUlI9ZnVuY3Rpb24ocix0LHcpe2Zvcih2YXIgdT0kUkMsbj0kUk0scD1uZXcgTWFwLHE9ZG9jdW1lbnQsZyxiLGg9cS5xdWVyeVNlbGVjdG9yQWxsKFwibGlua1tkYXRhLXByZWNlZGVuY2VdLHN0eWxlW2RhdGEtcHJlY2VkZW5jZV1cIiksdj1bXSxrPTA7Yj1oW2srK107KVwibm90IGFsbFwiPT09Yi5nZXRBdHRyaWJ1dGUoXCJtZWRpYVwiKT92LnB1c2goYik6KFwiTElOS1wiPT09Yi50YWdOYW1lJiZuLnNldChiLmdldEF0dHJpYnV0ZShcImhyZWZcIiksYikscC5zZXQoYi5kYXRhc2V0LnByZWNlZGVuY2UsZz1iKSk7Yj0wO2g9W107dmFyIGwsYTtmb3Ioaz0hMDs7KXtpZihrKXt2YXIgZj13W2IrK107aWYoIWYpe2s9ITE7Yj0wO2NvbnRpbnVlfXZhciBjPSExLG09MDt2YXIgZD1mW20rK107aWYoYT1uLmdldChkKSl7dmFyIGU9YS5fcDtjPSEwfWVsc2V7YT1xLmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO2EuaHJlZj1kO2EucmVsPVwic3R5bGVzaGVldFwiO2ZvcihhLmRhdGFzZXQucHJlY2VkZW5jZT1cXG5sPWZbbSsrXTtlPWZbbSsrXTspYS5zZXRBdHRyaWJ1dGUoZSxmW20rK10pO2U9YS5fcD1uZXcgUHJvbWlzZShmdW5jdGlvbih4LHkpe2Eub25sb2FkPXg7YS5vbmVycm9yPXl9KTtuLnNldChkLGEpfWQ9YS5nZXRBdHRyaWJ1dGUoXCJtZWRpYVwiKTshZXx8XCJsXCI9PT1lLnN8fGQmJiFtYXRjaE1lZGlhKGQpLm1hdGNoZXN8fGgucHVzaChlKTtpZihjKWNvbnRpbnVlfWVsc2V7YT12W2IrK107aWYoIWEpYnJlYWs7bD1hLmdldEF0dHJpYnV0ZShcImRhdGEtcHJlY2VkZW5jZVwiKTthLnJlbW92ZUF0dHJpYnV0ZShcIm1lZGlhXCIpfWM9cC5nZXQobCl8fGc7Yz09PWcmJihnPWEpO3Auc2V0KGwsYSk7Yz9jLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEsYy5uZXh0U2libGluZyk6KGM9cS5oZWFkLGMuaW5zZXJ0QmVmb3JlKGEsYy5maXJzdENoaWxkKSl9UHJvbWlzZS5hbGwoaCkudGhlbih1LmJpbmQobnVsbCxyLHQsXCJcIiksdS5iaW5kKG51bGwscix0LFwiUmVzb3VyY2UgZmFpbGVkIHRvIGxvYWRcIikpfTsnO1xudmFyIGNvbXBsZXRlU2VnbWVudCA9ICckUlM9ZnVuY3Rpb24oYSxiKXthPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGEpO2I9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYik7Zm9yKGEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKTthLmZpcnN0Q2hpbGQ7KWIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYS5maXJzdENoaWxkLGIpO2IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKX07JztcbnZhciBmb3JtUmVwbGF5aW5nID0gJ2FkZEV2ZW50TGlzdGVuZXIoXCJzdWJtaXRcIixmdW5jdGlvbihhKXtpZighYS5kZWZhdWx0UHJldmVudGVkKXt2YXIgYz1hLnRhcmdldCxkPWEuc3VibWl0dGVyLGU9Yy5hY3Rpb24sYj1kO2lmKGQpe3ZhciBmPWQuZ2V0QXR0cmlidXRlKFwiZm9ybUFjdGlvblwiKTtudWxsIT1mJiYoZT1mLGI9bnVsbCl9XCJqYXZhc2NyaXB0OnRocm93IG5ldyBFcnJvcihcXCdBIFJlYWN0IGZvcm0gd2FzIHVuZXhwZWN0ZWRseSBzdWJtaXR0ZWQuXFwnKVwiPT09ZSYmKGEucHJldmVudERlZmF1bHQoKSxiPyhhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSxhLm5hbWU9Yi5uYW1lLGEudmFsdWU9Yi52YWx1ZSxiLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEsYiksYj1uZXcgRm9ybURhdGEoYyksYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpKTpiPW5ldyBGb3JtRGF0YShjKSxhPWMuZ2V0Um9vdE5vZGUoKSwoYS4kJHJlYWN0Rm9ybVJlcGxheT1hLiQkcmVhY3RGb3JtUmVwbGF5fHxbXSkucHVzaChjLFxcbmQsYikpfX0pOyc7XG5cbmZ1bmN0aW9uIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcodGhpbmcpIHtcbiAgcmV0dXJuIHRoaW5nID09PSBudWxsID8gJ2BudWxsYCcgOiB0aGluZyA9PT0gdW5kZWZpbmVkID8gJ2B1bmRlZmluZWRgJyA6IHRoaW5nID09PSAnJyA/ICdhbiBlbXB0eSBzdHJpbmcnIDogXCJzb21ldGhpbmcgd2l0aCB0eXBlIFxcXCJcIiArIHR5cGVvZiB0aGluZyArIFwiXFxcIlwiO1xufVxuZnVuY3Rpb24gZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcodGhpbmcpIHtcbiAgcmV0dXJuIHRoaW5nID09PSBudWxsID8gJ2BudWxsYCcgOiB0aGluZyA9PT0gdW5kZWZpbmVkID8gJ2B1bmRlZmluZWRgJyA6IHRoaW5nID09PSAnJyA/ICdhbiBlbXB0eSBzdHJpbmcnIDogdHlwZW9mIHRoaW5nID09PSAnc3RyaW5nJyA/IEpTT04uc3RyaW5naWZ5KHRoaW5nKSA6IFwic29tZXRoaW5nIHdpdGggdHlwZSBcXFwiXCIgKyB0eXBlb2YgdGhpbmcgKyBcIlxcXCJcIjtcbn1cblxuZnVuY3Rpb24gY29tcGFyZVJlc291cmNlUHJvcHNGb3JXYXJuaW5nKG5ld1Byb3BzLCBjdXJyZW50UHJvcHMpIHtcbiAge1xuICAgIHZhciBwcm9wRGlmZnMgPSBudWxsO1xuICAgIHZhciBhbGxQcm9wcyA9IEFycmF5LmZyb20obmV3IFNldChPYmplY3Qua2V5cyhjdXJyZW50UHJvcHMpLmNvbmNhdChPYmplY3Qua2V5cyhuZXdQcm9wcykpKSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbFByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcE5hbWUgPSBhbGxQcm9wc1tpXTtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IG5ld1Byb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBjdXJyZW50UHJvcHNbcHJvcE5hbWVdO1xuXG4gICAgICBpZiAobmV3VmFsdWUgIT09IGN1cnJlbnRWYWx1ZSAmJiAhKG5ld1ZhbHVlID09IG51bGwgJiYgY3VycmVudFZhbHVlID09IG51bGwpKSB7XG4gICAgICAgIGlmIChuZXdWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHByb3BEaWZmcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvcERpZmZzID0ge1xuICAgICAgICAgICAgICBtaXNzaW5nOiB7fSxcbiAgICAgICAgICAgICAgZXh0cmE6IHt9LFxuICAgICAgICAgICAgICBkaWZmZXJlbnQ6IHt9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHByb3BEaWZmcy5taXNzaW5nW3Byb3BOYW1lXSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChwcm9wRGlmZnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHByb3BEaWZmcyA9IHtcbiAgICAgICAgICAgICAgbWlzc2luZzoge30sXG4gICAgICAgICAgICAgIGV4dHJhOiB7fSxcbiAgICAgICAgICAgICAgZGlmZmVyZW50OiB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwcm9wRGlmZnMuZXh0cmFbcHJvcE5hbWVdID0gbmV3VmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHByb3BEaWZmcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvcERpZmZzID0ge1xuICAgICAgICAgICAgICBtaXNzaW5nOiB7fSxcbiAgICAgICAgICAgICAgZXh0cmE6IHt9LFxuICAgICAgICAgICAgICBkaWZmZXJlbnQ6IHt9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHByb3BEaWZmcy5kaWZmZXJlbnRbcHJvcE5hbWVdID0ge1xuICAgICAgICAgICAgb3JpZ2luYWw6IGN1cnJlbnRWYWx1ZSxcbiAgICAgICAgICAgIGxhdGVzdDogbmV3VmFsdWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3BEaWZmcztcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXNjcmliZURpZmZlcmVuY2VzRm9yU3R5bGVzaGVldHMobmV3UHJvcHMsIGN1cnJlbnRQcm9wcykge1xuICB2YXIgZGlmZiA9IGNvbXBhcmVSZXNvdXJjZVByb3BzRm9yV2FybmluZyhuZXdQcm9wcywgY3VycmVudFByb3BzKTtcbiAgaWYgKCFkaWZmKSByZXR1cm4gJyc7XG4gIHZhciBkZXNjcmlwdGlvbiA9ICcnO1xuXG4gIGZvciAodmFyIHByb3BOYW1lIGluIGRpZmYubWlzc2luZykge1xuICAgIHZhciBwcm9wVmFsdWUgPSBkaWZmLm1pc3NpbmdbcHJvcE5hbWVdO1xuXG4gICAgaWYgKHByb3BOYW1lID09PSAnbWVkaWEnKSB7XG4gICAgICBkZXNjcmlwdGlvbiArPSBcIlxcbiAgXFxcIlwiICsgcHJvcE5hbWUgKyBcIlxcXCIgbWlzc2luZyBmb3IgcHJvcHMsIG9yaWdpbmFsIHZhbHVlOiBcIiArIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKHByb3BWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX3Byb3BOYW1lIGluIGRpZmYuZXh0cmEpIHtcbiAgICB2YXIgX3Byb3BWYWx1ZSA9IGRpZmYuZXh0cmFbX3Byb3BOYW1lXTtcbiAgICBkZXNjcmlwdGlvbiArPSBcIlxcbiAgXFxcIlwiICsgX3Byb3BOYW1lICsgXCJcXFwiIHByb3AgdmFsdWU6IFwiICsgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcoX3Byb3BWYWx1ZSkgKyBcIiwgbWlzc2luZyBmcm9tIG9yaWdpbmFsIHByb3BzXCI7XG4gIH1cblxuICBmb3IgKHZhciBfcHJvcE5hbWUyIGluIGRpZmYuZGlmZmVyZW50KSB7XG4gICAgdmFyIGxhdGVzdFZhbHVlID0gZGlmZi5kaWZmZXJlbnRbX3Byb3BOYW1lMl0ubGF0ZXN0O1xuICAgIHZhciBvcmlnaW5hbFZhbHVlID0gZGlmZi5kaWZmZXJlbnRbX3Byb3BOYW1lMl0ub3JpZ2luYWw7XG4gICAgZGVzY3JpcHRpb24gKz0gXCJcXG4gIFxcXCJcIiArIF9wcm9wTmFtZTIgKyBcIlxcXCIgcHJvcCB2YWx1ZTogXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhsYXRlc3RWYWx1ZSkgKyBcIiwgb3JpZ2luYWwgdmFsdWU6IFwiICsgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcob3JpZ2luYWxWYWx1ZSk7XG4gIH1cblxuICByZXR1cm4gZGVzY3JpcHRpb247XG59XG5mdW5jdGlvbiBkZXNjcmliZURpZmZlcmVuY2VzRm9yU3R5bGVzaGVldE92ZXJQcmVpbml0KG5ld1Byb3BzLCBjdXJyZW50UHJvcHMpIHtcbiAgdmFyIGRpZmYgPSBjb21wYXJlUmVzb3VyY2VQcm9wc0Zvcldhcm5pbmcobmV3UHJvcHMsIGN1cnJlbnRQcm9wcyk7XG4gIGlmICghZGlmZikgcmV0dXJuICcnO1xuICB2YXIgZGVzY3JpcHRpb24gPSAnJztcblxuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBkaWZmLmV4dHJhKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IGRpZmYuZXh0cmFbcHJvcE5hbWVdO1xuXG4gICAgaWYgKHByb3BOYW1lID09PSAncHJlY2VkZW5jZScgfHwgcHJvcE5hbWUgPT09ICdjcm9zc09yaWdpbicgfHwgcHJvcE5hbWUgPT09ICdpbnRlZ3JpdHknKSB7XG4gICAgICBkZXNjcmlwdGlvbiArPSBcIlxcbiAgXFxcIlwiICsgcHJvcE5hbWUgKyBcIlxcXCIgcHJvcCB2YWx1ZTogXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhwcm9wVmFsdWUpICsgXCIsIG9wdGlvbiBtaXNzaW5nXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlc2NyaXB0aW9uICs9IFwiXFxuICBcXFwiXCIgKyBwcm9wTmFtZSArIFwiXFxcIiBwcm9wIHZhbHVlOiBcIiArIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKHByb3BWYWx1ZSkgKyBcIiwgb3B0aW9uIG5vdCBhdmFpbGFibGUgd2l0aCBSZWFjdERPTS5wcmVpbml0KClcIjtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBfcHJvcE5hbWUzIGluIGRpZmYuZGlmZmVyZW50KSB7XG4gICAgdmFyIGxhdGVzdFZhbHVlID0gZGlmZi5kaWZmZXJlbnRbX3Byb3BOYW1lM10ubGF0ZXN0O1xuICAgIHZhciBvcmlnaW5hbFZhbHVlID0gZGlmZi5kaWZmZXJlbnRbX3Byb3BOYW1lM10ub3JpZ2luYWw7XG5cbiAgICBpZiAoX3Byb3BOYW1lMyA9PT0gJ3ByZWNlZGVuY2UnICYmIG9yaWdpbmFsVmFsdWUgPT09ICdkZWZhdWx0Jykge1xuICAgICAgZGVzY3JpcHRpb24gKz0gXCJcXG4gIFxcXCJcIiArIF9wcm9wTmFtZTMgKyBcIlxcXCIgcHJvcCB2YWx1ZTogXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhsYXRlc3RWYWx1ZSkgKyBcIiwgbWlzc2luZyBmcm9tIG9wdGlvbnNcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVzY3JpcHRpb24gKz0gXCJcXG4gIFxcXCJcIiArIF9wcm9wTmFtZTMgKyBcIlxcXCIgcHJvcCB2YWx1ZTogXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhsYXRlc3RWYWx1ZSkgKyBcIiwgb3B0aW9uIHZhbHVlOiBcIiArIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKG9yaWdpbmFsVmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZXNjcmlwdGlvbjtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRGlmZmVyZW5jZXNGb3JQcmVpbml0T3ZlclN0eWxlc2hlZXQobmV3UHJvcHMsIGN1cnJlbnRQcm9wcykge1xuICB2YXIgZGlmZiA9IGNvbXBhcmVSZXNvdXJjZVByb3BzRm9yV2FybmluZyhuZXdQcm9wcywgY3VycmVudFByb3BzKTtcbiAgaWYgKCFkaWZmKSByZXR1cm4gJyc7XG4gIHZhciBkZXNjcmlwdGlvbiA9ICcnO1xuXG4gIGZvciAodmFyIHByb3BOYW1lIGluIGRpZmYubWlzc2luZykge1xuICAgIHZhciBwcm9wVmFsdWUgPSBkaWZmLm1pc3NpbmdbcHJvcE5hbWVdO1xuXG4gICAgaWYgKHByb3BOYW1lID09PSAncHJlY2VkZW5jZScgJiYgcHJvcFZhbHVlICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgIGRlc2NyaXB0aW9uICs9IFwiXFxuICBcXFwiXCIgKyBwcm9wTmFtZSArIFwiXFxcIiBtaXNzaW5nIGZyb20gb3B0aW9ucywgcHJvcCB2YWx1ZTogXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhwcm9wVmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9wcm9wTmFtZTQgaW4gZGlmZi5leHRyYSkge1xuICAgIHZhciBfcHJvcFZhbHVlMiA9IGRpZmYuZXh0cmFbX3Byb3BOYW1lNF07XG5cbiAgICBpZiAoX3Byb3BOYW1lNCA9PT0gJ3ByZWNlZGVuY2UnIHx8IF9wcm9wTmFtZTQgPT09ICdjcm9zc09yaWdpbicgfHwgX3Byb3BOYW1lNCA9PT0gJ2ludGVncml0eScpIHtcbiAgICAgIGRlc2NyaXB0aW9uICs9IFwiXFxuICBcXFwiXCIgKyBfcHJvcE5hbWU0ICsgXCJcXFwiIG9wdGlvbiB2YWx1ZTogXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhfcHJvcFZhbHVlMikgKyBcIiwgbWlzc2luZyBmcm9tIHByb3BzXCI7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX3Byb3BOYW1lNSBpbiBkaWZmLmRpZmZlcmVudCkge1xuICAgIHZhciBsYXRlc3RWYWx1ZSA9IGRpZmYuZGlmZmVyZW50W19wcm9wTmFtZTVdLmxhdGVzdDtcbiAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IGRpZmYuZGlmZmVyZW50W19wcm9wTmFtZTVdLm9yaWdpbmFsO1xuICAgIGRlc2NyaXB0aW9uICs9IFwiXFxuICBcXFwiXCIgKyBfcHJvcE5hbWU1ICsgXCJcXFwiIG9wdGlvbiB2YWx1ZTogXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhsYXRlc3RWYWx1ZSkgKyBcIiwgcHJvcCB2YWx1ZTogXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhvcmlnaW5hbFZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiBkZXNjcmlwdGlvbjtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRGlmZmVyZW5jZXNGb3JQcmVpbml0cyhuZXdQcm9wcywgY3VycmVudFByb3BzKSB7XG4gIHZhciBkaWZmID0gY29tcGFyZVJlc291cmNlUHJvcHNGb3JXYXJuaW5nKG5ld1Byb3BzLCBjdXJyZW50UHJvcHMpO1xuICBpZiAoIWRpZmYpIHJldHVybiAnJztcbiAgdmFyIGRlc2NyaXB0aW9uID0gJyc7XG5cbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gZGlmZi5taXNzaW5nKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IGRpZmYubWlzc2luZ1twcm9wTmFtZV07XG5cbiAgICBpZiAocHJvcE5hbWUgPT09ICdwcmVjZWRlbmNlJyAmJiBwcm9wVmFsdWUgIT09ICdkZWZhdWx0Jykge1xuICAgICAgZGVzY3JpcHRpb24gKz0gXCJcXG4gIFxcXCJcIiArIHByb3BOYW1lICsgXCJcXFwiIG1pc3NpbmcgZnJvbSBvcHRpb25zLCBvcmlnaW5hbCBvcHRpb24gdmFsdWU6IFwiICsgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcocHJvcFZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBfcHJvcE5hbWU2IGluIGRpZmYuZXh0cmEpIHtcbiAgICB2YXIgX3Byb3BWYWx1ZTMgPSBkaWZmLmV4dHJhW19wcm9wTmFtZTZdO1xuXG4gICAgaWYgKF9wcm9wTmFtZTYgPT09ICdwcmVjZWRlbmNlJyAmJiBfcHJvcFZhbHVlMyAhPT0gJ2RlZmF1bHQnIHx8IF9wcm9wTmFtZTYgPT09ICdjcm9zc09yaWdpbicgfHwgX3Byb3BOYW1lNiA9PT0gJ2ludGVncml0eScpIHtcbiAgICAgIGRlc2NyaXB0aW9uICs9IFwiXFxuICBcXFwiXCIgKyBfcHJvcE5hbWU2ICsgXCJcXFwiIG9wdGlvbiB2YWx1ZTogXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhfcHJvcFZhbHVlMykgKyBcIiwgbWlzc2luZyBmcm9tIG9yaWdpbmFsIG9wdGlvbnNcIjtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBfcHJvcE5hbWU3IGluIGRpZmYuZGlmZmVyZW50KSB7XG4gICAgdmFyIGxhdGVzdFZhbHVlID0gZGlmZi5kaWZmZXJlbnRbX3Byb3BOYW1lN10ubGF0ZXN0O1xuICAgIHZhciBvcmlnaW5hbFZhbHVlID0gZGlmZi5kaWZmZXJlbnRbX3Byb3BOYW1lN10ub3JpZ2luYWw7XG4gICAgZGVzY3JpcHRpb24gKz0gXCJcXG4gIFxcXCJcIiArIF9wcm9wTmFtZTcgKyBcIlxcXCIgb3B0aW9uIHZhbHVlOiBcIiArIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKGxhdGVzdFZhbHVlKSArIFwiLCBvcmlnaW5hbCBvcHRpb24gdmFsdWU6IFwiICsgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcob3JpZ2luYWxWYWx1ZSk7XG4gIH1cblxuICByZXR1cm4gZGVzY3JpcHRpb247XG59XG52YXIgcHJlbG9hZE9wdGlvbnNGb3JDb21wYXJpc29uID0gWydhcycsICdjcm9zc09yaWdpbicsICdpbnRlZ3JpdHknLCAnbWVkaWEnXTtcbmZ1bmN0aW9uIGRlc2NyaWJlRGlmZmVyZW5jZXNGb3JQcmVsb2FkcyhuZXdQcm9wcywgY3VycmVudFByb3BzKSB7XG4gIHZhciBkaWZmID0gY29tcGFyZVJlc291cmNlUHJvcHNGb3JXYXJuaW5nKG5ld1Byb3BzLCBjdXJyZW50UHJvcHMpO1xuICBpZiAoIWRpZmYpIHJldHVybiAnJztcbiAgdmFyIGRlc2NyaXB0aW9uID0gJyc7XG5cbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gZGlmZi5taXNzaW5nKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IGRpZmYubWlzc2luZ1twcm9wTmFtZV07XG5cbiAgICBpZiAocHJlbG9hZE9wdGlvbnNGb3JDb21wYXJpc29uLmluY2x1ZGVzKHByb3BOYW1lKSkge1xuICAgICAgZGVzY3JpcHRpb24gKz0gXCJcXG4gIFxcXCJcIiArIHByb3BOYW1lICsgXCJcXFwiIG1pc3NpbmcgZnJvbSBvcHRpb25zLCBvcmlnaW5hbCBvcHRpb24gdmFsdWU6IFwiICsgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcocHJvcFZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBfcHJvcE5hbWU4IGluIGRpZmYuZXh0cmEpIHtcbiAgICB2YXIgX3Byb3BWYWx1ZTQgPSBkaWZmLmV4dHJhW19wcm9wTmFtZThdO1xuXG4gICAgaWYgKHByZWxvYWRPcHRpb25zRm9yQ29tcGFyaXNvbi5pbmNsdWRlcyhfcHJvcE5hbWU4KSkge1xuICAgICAgZGVzY3JpcHRpb24gKz0gXCJcXG4gIFxcXCJcIiArIF9wcm9wTmFtZTggKyBcIlxcXCIgb3B0aW9uIHZhbHVlOiBcIiArIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKF9wcm9wVmFsdWU0KSArIFwiLCBtaXNzaW5nIGZyb20gb3JpZ2luYWwgb3B0aW9uc1wiO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9wcm9wTmFtZTkgaW4gZGlmZi5kaWZmZXJlbnQpIHtcbiAgICB2YXIgbGF0ZXN0VmFsdWUgPSBkaWZmLmRpZmZlcmVudFtfcHJvcE5hbWU5XS5sYXRlc3Q7XG4gICAgdmFyIG9yaWdpbmFsVmFsdWUgPSBkaWZmLmRpZmZlcmVudFtfcHJvcE5hbWU5XS5vcmlnaW5hbDtcblxuICAgIGlmIChwcmVsb2FkT3B0aW9uc0ZvckNvbXBhcmlzb24uaW5jbHVkZXMoX3Byb3BOYW1lOSkpIHtcbiAgICAgIGRlc2NyaXB0aW9uICs9IFwiXFxuICBcXFwiXCIgKyBfcHJvcE5hbWU5ICsgXCJcXFwiIG9wdGlvbiB2YWx1ZTogXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhsYXRlc3RWYWx1ZSkgKyBcIiwgb3JpZ2luYWwgb3B0aW9uIHZhbHVlOiBcIiArIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKG9yaWdpbmFsVmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZXNjcmlwdGlvbjtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRGlmZmVyZW5jZXNGb3JQcmVsb2FkT3ZlckltcGxpY2l0UHJlbG9hZChuZXdQcm9wcywgY3VycmVudFByb3BzKSB7XG4gIHZhciBkaWZmID0gY29tcGFyZVJlc291cmNlUHJvcHNGb3JXYXJuaW5nKG5ld1Byb3BzLCBjdXJyZW50UHJvcHMpO1xuICBpZiAoIWRpZmYpIHJldHVybiAnJztcbiAgdmFyIGRlc2NyaXB0aW9uID0gJyc7XG5cbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gZGlmZi5taXNzaW5nKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IGRpZmYubWlzc2luZ1twcm9wTmFtZV07XG5cbiAgICBpZiAocHJlbG9hZE9wdGlvbnNGb3JDb21wYXJpc29uLmluY2x1ZGVzKHByb3BOYW1lKSkge1xuICAgICAgZGVzY3JpcHRpb24gKz0gXCJcXG4gIFxcXCJcIiArIHByb3BOYW1lICsgXCJcXFwiIG1pc3NpbmcgZnJvbSBvcHRpb25zLCB1bmRlcmx5aW5nIHByb3AgdmFsdWU6IFwiICsgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcocHJvcFZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBfcHJvcE5hbWUxMCBpbiBkaWZmLmV4dHJhKSB7XG4gICAgdmFyIF9wcm9wVmFsdWU1ID0gZGlmZi5leHRyYVtfcHJvcE5hbWUxMF07XG5cbiAgICBpZiAocHJlbG9hZE9wdGlvbnNGb3JDb21wYXJpc29uLmluY2x1ZGVzKF9wcm9wTmFtZTEwKSkge1xuICAgICAgZGVzY3JpcHRpb24gKz0gXCJcXG4gIFxcXCJcIiArIF9wcm9wTmFtZTEwICsgXCJcXFwiIG9wdGlvbiB2YWx1ZTogXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhfcHJvcFZhbHVlNSkgKyBcIiwgbWlzc2luZyBmcm9tIHVuZGVybHlpbmcgcHJvcHNcIjtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBfcHJvcE5hbWUxMSBpbiBkaWZmLmRpZmZlcmVudCkge1xuICAgIHZhciBsYXRlc3RWYWx1ZSA9IGRpZmYuZGlmZmVyZW50W19wcm9wTmFtZTExXS5sYXRlc3Q7XG4gICAgdmFyIG9yaWdpbmFsVmFsdWUgPSBkaWZmLmRpZmZlcmVudFtfcHJvcE5hbWUxMV0ub3JpZ2luYWw7XG5cbiAgICBpZiAocHJlbG9hZE9wdGlvbnNGb3JDb21wYXJpc29uLmluY2x1ZGVzKF9wcm9wTmFtZTExKSkge1xuICAgICAgZGVzY3JpcHRpb24gKz0gXCJcXG4gIFxcXCJcIiArIF9wcm9wTmFtZTExICsgXCJcXFwiIG9wdGlvbiB2YWx1ZTogXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhsYXRlc3RWYWx1ZSkgKyBcIiwgdW5kZXJseWluZyBwcm9wIHZhbHVlOiBcIiArIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKG9yaWdpbmFsVmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZXNjcmlwdGlvbjtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRGlmZmVyZW5jZXNGb3JTY3JpcHRzKG5ld1Byb3BzLCBjdXJyZW50UHJvcHMpIHtcbiAgdmFyIGRpZmYgPSBjb21wYXJlUmVzb3VyY2VQcm9wc0Zvcldhcm5pbmcobmV3UHJvcHMsIGN1cnJlbnRQcm9wcyk7XG4gIGlmICghZGlmZikgcmV0dXJuICcnO1xuICB2YXIgZGVzY3JpcHRpb24gPSAnJztcblxuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBkaWZmLm1pc3NpbmcpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gZGlmZi5taXNzaW5nW3Byb3BOYW1lXTtcbiAgICBkZXNjcmlwdGlvbiArPSBcIlxcbiAgXFxcIlwiICsgcHJvcE5hbWUgKyBcIlxcXCIgbWlzc2luZyBmb3IgcHJvcHMsIG9yaWdpbmFsIHZhbHVlOiBcIiArIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKHByb3BWYWx1ZSk7XG4gIH1cblxuICBmb3IgKHZhciBfcHJvcE5hbWUxMiBpbiBkaWZmLmV4dHJhKSB7XG4gICAgdmFyIF9wcm9wVmFsdWU2ID0gZGlmZi5leHRyYVtfcHJvcE5hbWUxMl07XG4gICAgZGVzY3JpcHRpb24gKz0gXCJcXG4gIFxcXCJcIiArIF9wcm9wTmFtZTEyICsgXCJcXFwiIHByb3AgdmFsdWU6IFwiICsgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcoX3Byb3BWYWx1ZTYpICsgXCIsIG1pc3NpbmcgZnJvbSBvcmlnaW5hbCBwcm9wc1wiO1xuICB9XG5cbiAgZm9yICh2YXIgX3Byb3BOYW1lMTMgaW4gZGlmZi5kaWZmZXJlbnQpIHtcbiAgICB2YXIgbGF0ZXN0VmFsdWUgPSBkaWZmLmRpZmZlcmVudFtfcHJvcE5hbWUxM10ubGF0ZXN0O1xuICAgIHZhciBvcmlnaW5hbFZhbHVlID0gZGlmZi5kaWZmZXJlbnRbX3Byb3BOYW1lMTNdLm9yaWdpbmFsO1xuICAgIGRlc2NyaXB0aW9uICs9IFwiXFxuICBcXFwiXCIgKyBfcHJvcE5hbWUxMyArIFwiXFxcIiBwcm9wIHZhbHVlOiBcIiArIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKGxhdGVzdFZhbHVlKSArIFwiLCBvcmlnaW5hbCB2YWx1ZTogXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhvcmlnaW5hbFZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiBkZXNjcmlwdGlvbjtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRGlmZmVyZW5jZXNGb3JTY3JpcHRPdmVyUHJlaW5pdChuZXdQcm9wcywgY3VycmVudFByb3BzKSB7XG4gIHZhciBkaWZmID0gY29tcGFyZVJlc291cmNlUHJvcHNGb3JXYXJuaW5nKG5ld1Byb3BzLCBjdXJyZW50UHJvcHMpO1xuICBpZiAoIWRpZmYpIHJldHVybiAnJztcbiAgdmFyIGRlc2NyaXB0aW9uID0gJyc7XG5cbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gZGlmZi5leHRyYSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBkaWZmLmV4dHJhW3Byb3BOYW1lXTtcblxuICAgIGlmIChwcm9wTmFtZSA9PT0gJ2Nyb3NzT3JpZ2luJyB8fCBwcm9wTmFtZSA9PT0gJ2ludGVncml0eScpIHtcbiAgICAgIGRlc2NyaXB0aW9uICs9IFwiXFxuICBcXFwiXCIgKyBwcm9wTmFtZSArIFwiXFxcIiBwcm9wIHZhbHVlOiBcIiArIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKHByb3BWYWx1ZSkgKyBcIiwgb3B0aW9uIG1pc3NpbmdcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVzY3JpcHRpb24gKz0gXCJcXG4gIFxcXCJcIiArIHByb3BOYW1lICsgXCJcXFwiIHByb3AgdmFsdWU6IFwiICsgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcocHJvcFZhbHVlKSArIFwiLCBvcHRpb24gbm90IGF2YWlsYWJsZSB3aXRoIFJlYWN0RE9NLnByZWluaXQoKVwiO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9wcm9wTmFtZTE0IGluIGRpZmYuZGlmZmVyZW50KSB7XG4gICAgdmFyIGxhdGVzdFZhbHVlID0gZGlmZi5kaWZmZXJlbnRbX3Byb3BOYW1lMTRdLmxhdGVzdDtcbiAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IGRpZmYuZGlmZmVyZW50W19wcm9wTmFtZTE0XS5vcmlnaW5hbDtcbiAgICBkZXNjcmlwdGlvbiArPSBcIlxcbiAgXFxcIlwiICsgX3Byb3BOYW1lMTQgKyBcIlxcXCIgcHJvcCB2YWx1ZTogXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhsYXRlc3RWYWx1ZSkgKyBcIiwgb3B0aW9uIHZhbHVlOiBcIiArIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKG9yaWdpbmFsVmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIGRlc2NyaXB0aW9uO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVEaWZmZXJlbmNlc0ZvclByZWluaXRPdmVyU2NyaXB0KG5ld1Byb3BzLCBjdXJyZW50UHJvcHMpIHtcbiAgdmFyIGRpZmYgPSBjb21wYXJlUmVzb3VyY2VQcm9wc0Zvcldhcm5pbmcobmV3UHJvcHMsIGN1cnJlbnRQcm9wcyk7XG4gIGlmICghZGlmZikgcmV0dXJuICcnO1xuICB2YXIgZGVzY3JpcHRpb24gPSAnJztcblxuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBkaWZmLmV4dHJhKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IGRpZmYuZXh0cmFbcHJvcE5hbWVdO1xuXG4gICAgaWYgKHByb3BOYW1lID09PSAnY3Jvc3NPcmlnaW4nIHx8IHByb3BOYW1lID09PSAnaW50ZWdyaXR5Jykge1xuICAgICAgZGVzY3JpcHRpb24gKz0gXCJcXG4gIFxcXCJcIiArIHByb3BOYW1lICsgXCJcXFwiIG9wdGlvbiB2YWx1ZTogXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhwcm9wVmFsdWUpICsgXCIsIG1pc3NpbmcgZnJvbSBwcm9wc1wiO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9wcm9wTmFtZTE1IGluIGRpZmYuZGlmZmVyZW50KSB7XG4gICAgdmFyIGxhdGVzdFZhbHVlID0gZGlmZi5kaWZmZXJlbnRbX3Byb3BOYW1lMTVdLmxhdGVzdDtcbiAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IGRpZmYuZGlmZmVyZW50W19wcm9wTmFtZTE1XS5vcmlnaW5hbDtcbiAgICBkZXNjcmlwdGlvbiArPSBcIlxcbiAgXFxcIlwiICsgX3Byb3BOYW1lMTUgKyBcIlxcXCIgb3B0aW9uIHZhbHVlOiBcIiArIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKGxhdGVzdFZhbHVlKSArIFwiLCBwcm9wIHZhbHVlOiBcIiArIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKG9yaWdpbmFsVmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIGRlc2NyaXB0aW9uO1xufVxuXG52YXIgUmVhY3RET01TaGFyZWRJbnRlcm5hbHMgPSBSZWFjdERPTS5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxudmFyIFJlYWN0RE9NQ3VycmVudERpc3BhdGNoZXIgPSBSZWFjdERPTVNoYXJlZEludGVybmFscy5EaXNwYXRjaGVyO1xudmFyIFJlYWN0RE9NU2VydmVyRGlzcGF0Y2hlciA9IHtcbiAgcHJlZmV0Y2hETlM6IHByZWZldGNoRE5TLFxuICBwcmVjb25uZWN0OiBwcmVjb25uZWN0LFxuICBwcmVsb2FkOiBwcmVsb2FkLFxuICBwcmVpbml0OiBwcmVpbml0XG59O1xuZnVuY3Rpb24gcHJlcGFyZUhvc3REaXNwYXRjaGVyKCkge1xuICBSZWFjdERPTUN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBSZWFjdERPTVNlcnZlckRpc3BhdGNoZXI7XG59IC8vIFVzZWQgdG8gZGlzdGluZ3Vpc2ggdGhlc2UgY29udGV4dHMgZnJvbSBvbmVzIHVzZWQgaW4gb3RoZXIgcmVuZGVyZXJzLlxudmFyIFNjcmlwdFN0cmVhbWluZ0Zvcm1hdCA9IDA7XG52YXIgRGF0YVN0cmVhbWluZ0Zvcm1hdCA9IDE7XG52YXIgTm90aGluZ1NlbnRcbi8qICAgICAgICAgICAgICAgICAgICAgICovXG49IDA7XG52YXIgU2VudENvbXBsZXRlU2VnbWVudEZ1bmN0aW9uXG4vKiAgICAgICovXG49IDE7XG52YXIgU2VudENvbXBsZXRlQm91bmRhcnlGdW5jdGlvblxuLyogICAgICovXG49IDI7XG52YXIgU2VudENsaWVudFJlbmRlckZ1bmN0aW9uXG4vKiAgICAgICAgICovXG49IDQ7XG52YXIgU2VudFN0eWxlSW5zZXJ0aW9uRnVuY3Rpb25cbi8qICAgICAgICovXG49IDg7XG5cbnZhciBkYXRhRWxlbWVudFF1b3RlZEVuZCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+PC90ZW1wbGF0ZT4nKTtcbnZhciBzdGFydElubGluZVNjcmlwdCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHNjcmlwdD4nKTtcbnZhciBlbmRJbmxpbmVTY3JpcHQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvc2NyaXB0PicpO1xudmFyIHN0YXJ0U2NyaXB0U3JjID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8c2NyaXB0IHNyYz1cIicpO1xudmFyIHN0YXJ0TW9kdWxlU3JjID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8c2NyaXB0IHR5cGU9XCJtb2R1bGVcIiBzcmM9XCInKTtcbnZhciBzY3JpcHROb25jZSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgbm9uY2U9XCInKTtcbnZhciBzY3JpcHRJbnRlZ2lydHkgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGludGVncml0eT1cIicpO1xudmFyIHNjcmlwdENyb3NzT3JpZ2luID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBjcm9zc29yaWdpbj1cIicpO1xudmFyIGVuZEFzeW5jU2NyaXB0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBhc3luYz1cIlwiPjwvc2NyaXB0PicpO1xuLyoqXG4gKiBUaGlzIGVzY2FwaW5nIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIHdvcmsgd2l0aCBib290c3RyYXBTY3JpcHRDb250ZW50IG9ubHkuXG4gKiBiZWNhdXNlIHdlIGtub3cgd2UgYXJlIGVzY2FwaW5nIHRoZSBlbnRpcmUgc2NyaXB0LiBXZSBjYW4gYXZvaWQgZm9yIGluc3RhbmNlXG4gKiBlc2NhcGluZyBodG1sIGNvbW1lbnQgc3RyaW5nIHNlcXVlbmNlcyB0aGF0IGFyZSB2YWxpZCBqYXZhc2NyaXB0IGFzIHdlbGwgYmVjYXVzZVxuICogaWYgdGhlcmUgYXJlIG5vIHNlYnNlcXVlbnQgPHNjcmlwdCBzZXF1ZW5jZXMgdGhlIGh0bWwgcGFyc2VyIHdpbGwgbmV2ZXIgZW50ZXJcbiAqIHNjcmlwdCBkYXRhIGRvdWJsZSBlc2NhcGVkIHN0YXRlIChzZWU6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTMvc3ludGF4Lmh0bWwjc2NyaXB0LWRhdGEtZG91YmxlLWVzY2FwZWQtc3RhdGUpXG4gKlxuICogV2hpbGUgdW50cnVzdGVkIHNjcmlwdCBjb250ZW50IHNob3VsZCBiZSBtYWRlIHNhZmUgYmVmb3JlIHVzaW5nIHRoaXMgYXBpIGl0IHdpbGxcbiAqIGVuc3VyZSB0aGF0IHRoZSBzY3JpcHQgY2Fubm90IGJlIGVhcmx5IHRlcm1pbmF0ZWQgb3IgbmV2ZXIgdGVybWluYXRlZCBzdGF0ZVxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZUJvb3RzdHJhcFNjcmlwdENvbnRlbnQoc2NyaXB0VGV4dCkge1xuICB7XG4gICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oc2NyaXB0VGV4dCk7XG4gIH1cblxuICByZXR1cm4gKCcnICsgc2NyaXB0VGV4dCkucmVwbGFjZShzY3JpcHRSZWdleCwgc2NyaXB0UmVwbGFjZXIpO1xufVxuXG52YXIgc2NyaXB0UmVnZXggPSAvKDxcXC98PCkocykoY3JpcHQpL2dpO1xuXG52YXIgc2NyaXB0UmVwbGFjZXIgPSBmdW5jdGlvbiAobWF0Y2gsIHByZWZpeCwgcywgc3VmZml4KSB7XG4gIHJldHVybiBcIlwiICsgcHJlZml4ICsgKHMgPT09ICdzJyA/IFwiXFxcXHUwMDczXCIgOiBcIlxcXFx1MDA1M1wiKSArIHN1ZmZpeDtcbn07IC8vIEFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIHdoYXQgd2UndmUgYWxyZWFkeSB3cml0dGVuIHNvIHdlIGNhbiByZWZlciBiYWNrIHRvIGl0LlxuLy8gaWYgcGFzc2VkIGV4dGVybmFsUnVudGltZUNvbmZpZyBhbmQgdGhlIGVuYWJsZUZpenpFeHRlcm5hbFJ1bnRpbWUgZmVhdHVyZSBmbGFnXG4vLyBpcyBzZXQsIHRoZSBzZXJ2ZXIgd2lsbCBzZW5kIGluc3RydWN0aW9ucyB2aWEgZGF0YSBhdHRyaWJ1dGVzIChpbnN0ZWFkIG9mIGlubGluZSBzY3JpcHRzKVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlU3RhdGUocmVzb3VyY2VzLCBpZGVudGlmaWVyUHJlZml4LCBub25jZSwgYm9vdHN0cmFwU2NyaXB0Q29udGVudCwgYm9vdHN0cmFwU2NyaXB0cywgYm9vdHN0cmFwTW9kdWxlcywgZXh0ZXJuYWxSdW50aW1lQ29uZmlnKSB7XG4gIHZhciBpZFByZWZpeCA9IGlkZW50aWZpZXJQcmVmaXggPT09IHVuZGVmaW5lZCA/ICcnIDogaWRlbnRpZmllclByZWZpeDtcbiAgdmFyIGlubGluZVNjcmlwdFdpdGhOb25jZSA9IG5vbmNlID09PSB1bmRlZmluZWQgPyBzdGFydElubGluZVNjcmlwdCA6IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHNjcmlwdCBub25jZT1cIicgKyBlc2NhcGVUZXh0Rm9yQnJvd3Nlcihub25jZSkgKyAnXCI+Jyk7XG4gIHZhciBib290c3RyYXBDaHVua3MgPSBbXTtcbiAgdmFyIGV4dGVybmFsUnVudGltZVNjcmlwdCA9IG51bGw7XG4gIHZhciBzdHJlYW1pbmdGb3JtYXQgPSBTY3JpcHRTdHJlYW1pbmdGb3JtYXQ7XG5cbiAgaWYgKGJvb3RzdHJhcFNjcmlwdENvbnRlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKGlubGluZVNjcmlwdFdpdGhOb25jZSwgc3RyaW5nVG9DaHVuayhlc2NhcGVCb290c3RyYXBTY3JpcHRDb250ZW50KGJvb3RzdHJhcFNjcmlwdENvbnRlbnQpKSwgZW5kSW5saW5lU2NyaXB0KTtcbiAgfVxuXG4gIHtcblxuICAgIGlmIChleHRlcm5hbFJ1bnRpbWVDb25maWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RyZWFtaW5nRm9ybWF0ID0gRGF0YVN0cmVhbWluZ0Zvcm1hdDtcblxuICAgICAgaWYgKHR5cGVvZiBleHRlcm5hbFJ1bnRpbWVDb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGV4dGVybmFsUnVudGltZVNjcmlwdCA9IHtcbiAgICAgICAgICBzcmM6IGV4dGVybmFsUnVudGltZUNvbmZpZyxcbiAgICAgICAgICBjaHVua3M6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHB1c2hTY3JpcHRJbXBsKGV4dGVybmFsUnVudGltZVNjcmlwdC5jaHVua3MsIHtcbiAgICAgICAgICBzcmM6IGV4dGVybmFsUnVudGltZUNvbmZpZyxcbiAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICBpbnRlZ3JpdHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICBub25jZTogbm9uY2VcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleHRlcm5hbFJ1bnRpbWVTY3JpcHQgPSB7XG4gICAgICAgICAgc3JjOiBleHRlcm5hbFJ1bnRpbWVDb25maWcuc3JjLFxuICAgICAgICAgIGNodW5rczogW11cbiAgICAgICAgfTtcbiAgICAgICAgcHVzaFNjcmlwdEltcGwoZXh0ZXJuYWxSdW50aW1lU2NyaXB0LmNodW5rcywge1xuICAgICAgICAgIHNyYzogZXh0ZXJuYWxSdW50aW1lQ29uZmlnLnNyYyxcbiAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICBpbnRlZ3JpdHk6IGV4dGVybmFsUnVudGltZUNvbmZpZy5pbnRlZ3JpdHksXG4gICAgICAgICAgbm9uY2U6IG5vbmNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChib290c3RyYXBTY3JpcHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb3RzdHJhcFNjcmlwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzY3JpcHRDb25maWcgPSBib290c3RyYXBTY3JpcHRzW2ldO1xuICAgICAgdmFyIHNyYyA9IHR5cGVvZiBzY3JpcHRDb25maWcgPT09ICdzdHJpbmcnID8gc2NyaXB0Q29uZmlnIDogc2NyaXB0Q29uZmlnLnNyYztcbiAgICAgIHZhciBpbnRlZ3JpdHkgPSB0eXBlb2Ygc2NyaXB0Q29uZmlnID09PSAnc3RyaW5nJyA/IHVuZGVmaW5lZCA6IHNjcmlwdENvbmZpZy5pbnRlZ3JpdHk7XG4gICAgICB2YXIgY3Jvc3NPcmlnaW4gPSB0eXBlb2Ygc2NyaXB0Q29uZmlnID09PSAnc3RyaW5nJyB8fCBzY3JpcHRDb25maWcuY3Jvc3NPcmlnaW4gPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHNjcmlwdENvbmZpZy5jcm9zc09yaWdpbiA9PT0gJ3VzZS1jcmVkZW50aWFscycgPyAndXNlLWNyZWRlbnRpYWxzJyA6ICcnO1xuICAgICAgcHJlbG9hZEJvb3RzdHJhcFNjcmlwdChyZXNvdXJjZXMsIHNyYywgbm9uY2UsIGludGVncml0eSwgY3Jvc3NPcmlnaW4pO1xuICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goc3RhcnRTY3JpcHRTcmMsIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoc3JjKSkpO1xuXG4gICAgICBpZiAobm9uY2UpIHtcbiAgICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goc2NyaXB0Tm9uY2UsIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIobm9uY2UpKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnRlZ3JpdHkpIHtcbiAgICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goc2NyaXB0SW50ZWdpcnR5LCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGludGVncml0eSkpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjcm9zc09yaWdpbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goc2NyaXB0Q3Jvc3NPcmlnaW4sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoY3Jvc3NPcmlnaW4pKSk7XG4gICAgICB9XG5cbiAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKGVuZEFzeW5jU2NyaXB0KTtcbiAgICB9XG4gIH1cblxuICBpZiAoYm9vdHN0cmFwTW9kdWxlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGJvb3RzdHJhcE1vZHVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX3NjcmlwdENvbmZpZyA9IGJvb3RzdHJhcE1vZHVsZXNbX2ldO1xuXG4gICAgICB2YXIgX3NyYyA9IHR5cGVvZiBfc2NyaXB0Q29uZmlnID09PSAnc3RyaW5nJyA/IF9zY3JpcHRDb25maWcgOiBfc2NyaXB0Q29uZmlnLnNyYztcblxuICAgICAgdmFyIF9pbnRlZ3JpdHkgPSB0eXBlb2YgX3NjcmlwdENvbmZpZyA9PT0gJ3N0cmluZycgPyB1bmRlZmluZWQgOiBfc2NyaXB0Q29uZmlnLmludGVncml0eTtcblxuICAgICAgdmFyIF9jcm9zc09yaWdpbiA9IHR5cGVvZiBfc2NyaXB0Q29uZmlnID09PSAnc3RyaW5nJyB8fCBfc2NyaXB0Q29uZmlnLmNyb3NzT3JpZ2luID09IG51bGwgPyB1bmRlZmluZWQgOiBfc2NyaXB0Q29uZmlnLmNyb3NzT3JpZ2luID09PSAndXNlLWNyZWRlbnRpYWxzJyA/ICd1c2UtY3JlZGVudGlhbHMnIDogJyc7XG5cbiAgICAgIHByZWxvYWRCb290c3RyYXBNb2R1bGUocmVzb3VyY2VzLCBfc3JjLCBub25jZSwgX2ludGVncml0eSwgX2Nyb3NzT3JpZ2luKTtcbiAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKHN0YXJ0TW9kdWxlU3JjLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKF9zcmMpKSk7XG5cbiAgICAgIGlmIChub25jZSkge1xuICAgICAgICBib290c3RyYXBDaHVua3MucHVzaChzY3JpcHROb25jZSwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcihub25jZSkpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9pbnRlZ3JpdHkpIHtcbiAgICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goc2NyaXB0SW50ZWdpcnR5LCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKF9pbnRlZ3JpdHkpKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgX2Nyb3NzT3JpZ2luID09PSAnc3RyaW5nJykge1xuICAgICAgICBib290c3RyYXBDaHVua3MucHVzaChzY3JpcHRDcm9zc09yaWdpbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihfY3Jvc3NPcmlnaW4pKSk7XG4gICAgICB9XG5cbiAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKGVuZEFzeW5jU2NyaXB0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJvb3RzdHJhcENodW5rczogYm9vdHN0cmFwQ2h1bmtzLFxuICAgIHBsYWNlaG9sZGVyUHJlZml4OiBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoaWRQcmVmaXggKyAnUDonKSxcbiAgICBzZWdtZW50UHJlZml4OiBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoaWRQcmVmaXggKyAnUzonKSxcbiAgICBib3VuZGFyeVByZWZpeDogaWRQcmVmaXggKyAnQjonLFxuICAgIGlkUHJlZml4OiBpZFByZWZpeCxcbiAgICBuZXh0U3VzcGVuc2VJRDogMCxcbiAgICBzdHJlYW1pbmdGb3JtYXQ6IHN0cmVhbWluZ0Zvcm1hdCxcbiAgICBzdGFydElubGluZVNjcmlwdDogaW5saW5lU2NyaXB0V2l0aE5vbmNlLFxuICAgIGluc3RydWN0aW9uczogTm90aGluZ1NlbnQsXG4gICAgZXh0ZXJuYWxSdW50aW1lU2NyaXB0OiBleHRlcm5hbFJ1bnRpbWVTY3JpcHQsXG4gICAgaHRtbENodW5rczogbnVsbCxcbiAgICBoZWFkQ2h1bmtzOiBudWxsLFxuICAgIGhhc0JvZHk6IGZhbHNlLFxuICAgIGNoYXJzZXRDaHVua3M6IFtdLFxuICAgIHByZWNvbm5lY3RDaHVua3M6IFtdLFxuICAgIHByZWxvYWRDaHVua3M6IFtdLFxuICAgIGhvaXN0YWJsZUNodW5rczogW10sXG4gICAgc3R5bGVzVG9Ib2lzdDogZmFsc2UsXG4gICAgbm9uY2U6IG5vbmNlXG4gIH07XG59IC8vIENvbnN0YW50cyBmb3IgdGhlIGluc2VydGlvbiBtb2RlIHdlJ3JlIGN1cnJlbnRseSB3cml0aW5nIGluLiBXZSBkb24ndCBlbmNvZGUgYWxsIEhUTUw1IGluc2VydGlvblxuLy8gbW9kZXMuIFdlIG9ubHkgaW5jbHVkZSB0aGUgdmFyaWFudHMgYXMgdGhleSBtYXR0ZXIgZm9yIHRoZSBzYWtlIG9mIG91ciBwdXJwb3Nlcy5cbi8vIFdlIGRvbid0IGFjdHVhbGx5IHByb3ZpZGUgdGhlIG5hbWVzcGFjZSB0aGVyZWZvcmUgd2UgdXNlIGNvbnN0YW50cyBpbnN0ZWFkIG9mIHRoZSBzdHJpbmcuXG5cbnZhciBST09UX0hUTUxfTU9ERSA9IDA7IC8vIFVzZWQgZm9yIHRoZSByb290IG1vc3QgZWxlbWVudCB0YWcuXG4vLyBXZSBoYXZlIGEgbGVzcyB0aGFuIEhUTUxfSFRNTF9NT0RFIGNoZWNrIGVsc2V3aGVyZS4gSWYgeW91IGFkZCBtb3JlIGNhc2VzIGhlcmUsIG1ha2Ugc3VyZSBpdFxuLy8gc3RpbGwgbWFrZXMgc2Vuc2VcblxudmFyIEhUTUxfSFRNTF9NT0RFID0gMTsgLy8gVXNlZCBmb3IgdGhlIDxodG1sPiBpZiBpdCBpcyBhdCB0aGUgdG9wIGxldmVsLlxuXG52YXIgSFRNTF9NT0RFID0gMjtcbnZhciBTVkdfTU9ERSA9IDM7XG52YXIgTUFUSE1MX01PREUgPSA0O1xudmFyIEhUTUxfVEFCTEVfTU9ERSA9IDU7XG52YXIgSFRNTF9UQUJMRV9CT0RZX01PREUgPSA2O1xudmFyIEhUTUxfVEFCTEVfUk9XX01PREUgPSA3O1xudmFyIEhUTUxfQ09MR1JPVVBfTU9ERSA9IDg7IC8vIFdlIGhhdmUgYSBncmVhdGVyIHRoYW4gSFRNTF9UQUJMRV9NT0RFIGNoZWNrIGVsc2V3aGVyZS4gSWYgeW91IGFkZCBtb3JlIGNhc2VzIGhlcmUsIG1ha2Ugc3VyZSBpdFxuLy8gc3RpbGwgbWFrZXMgc2Vuc2Vcbi8vIExldHMgdXMga2VlcCB0cmFjayBvZiBjb250ZXh0dWFsIHN0YXRlIGFuZCBwaWNrIGl0IGJhY2sgdXAgYWZ0ZXIgc3VzcGVuZGluZy5cblxuZnVuY3Rpb24gY3JlYXRlRm9ybWF0Q29udGV4dChpbnNlcnRpb25Nb2RlLCBzZWxlY3RlZFZhbHVlLCBub3NjcmlwdFRhZ0luU2NvcGUpIHtcbiAgcmV0dXJuIHtcbiAgICBpbnNlcnRpb25Nb2RlOiBpbnNlcnRpb25Nb2RlLFxuICAgIHNlbGVjdGVkVmFsdWU6IHNlbGVjdGVkVmFsdWUsXG4gICAgbm9zY3JpcHRUYWdJblNjb3BlOiBub3NjcmlwdFRhZ0luU2NvcGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUm9vdEZvcm1hdENvbnRleHQobmFtZXNwYWNlVVJJKSB7XG4gIHZhciBpbnNlcnRpb25Nb2RlID0gbmFtZXNwYWNlVVJJID09PSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnID8gU1ZHX01PREUgOiBuYW1lc3BhY2VVUkkgPT09ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJyA/IE1BVEhNTF9NT0RFIDogUk9PVF9IVE1MX01PREU7XG4gIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KGluc2VydGlvbk1vZGUsIG51bGwsIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIGdldENoaWxkRm9ybWF0Q29udGV4dChwYXJlbnRDb250ZXh0LCB0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdub3NjcmlwdCc6XG4gICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX01PREUsIG51bGwsIHRydWUpO1xuXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfTU9ERSwgcHJvcHMudmFsdWUgIT0gbnVsbCA/IHByb3BzLnZhbHVlIDogcHJvcHMuZGVmYXVsdFZhbHVlLCBwYXJlbnRDb250ZXh0Lm5vc2NyaXB0VGFnSW5TY29wZSk7XG5cbiAgICBjYXNlICdzdmcnOlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoU1ZHX01PREUsIG51bGwsIHBhcmVudENvbnRleHQubm9zY3JpcHRUYWdJblNjb3BlKTtcblxuICAgIGNhc2UgJ21hdGgnOlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoTUFUSE1MX01PREUsIG51bGwsIHBhcmVudENvbnRleHQubm9zY3JpcHRUYWdJblNjb3BlKTtcblxuICAgIGNhc2UgJ2ZvcmVpZ25PYmplY3QnOlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0Lm5vc2NyaXB0VGFnSW5TY29wZSk7XG4gICAgLy8gVGFibGUgcGFyZW50cyBhcmUgc3BlY2lhbCBpbiB0aGF0IHRoZWlyIGNoaWxkcmVuIGNhbiBvbmx5IGJlIGNyZWF0ZWQgYXQgYWxsIGlmIHRoZXkncmVcbiAgICAvLyB3cmFwcGVkIGluIGEgdGFibGUgcGFyZW50LiBTbyB3ZSBuZWVkIHRvIGVuY29kZSB0aGF0IHdlJ3JlIGVudGVyaW5nIHRoaXMgbW9kZS5cblxuICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfVEFCTEVfTU9ERSwgbnVsbCwgcGFyZW50Q29udGV4dC5ub3NjcmlwdFRhZ0luU2NvcGUpO1xuXG4gICAgY2FzZSAndGhlYWQnOlxuICAgIGNhc2UgJ3Rib2R5JzpcbiAgICBjYXNlICd0Zm9vdCc6XG4gICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX1RBQkxFX0JPRFlfTU9ERSwgbnVsbCwgcGFyZW50Q29udGV4dC5ub3NjcmlwdFRhZ0luU2NvcGUpO1xuXG4gICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9DT0xHUk9VUF9NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0Lm5vc2NyaXB0VGFnSW5TY29wZSk7XG5cbiAgICBjYXNlICd0cic6XG4gICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX1RBQkxFX1JPV19NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0Lm5vc2NyaXB0VGFnSW5TY29wZSk7XG4gIH1cblxuICBpZiAocGFyZW50Q29udGV4dC5pbnNlcnRpb25Nb2RlID49IEhUTUxfVEFCTEVfTU9ERSkge1xuICAgIC8vIFdoYXRldmVyIHRhZyB0aGlzIHdhcywgaXQgd2Fzbid0IGEgdGFibGUgcGFyZW50IG9yIG90aGVyIHNwZWNpYWwgcGFyZW50LCBzbyB3ZSBtdXN0IGhhdmVcbiAgICAvLyBlbnRlcmVkIHBsYWluIEhUTUwgYWdhaW4uXG4gICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0Lm5vc2NyaXB0VGFnSW5TY29wZSk7XG4gIH1cblxuICBpZiAocGFyZW50Q29udGV4dC5pbnNlcnRpb25Nb2RlID09PSBST09UX0hUTUxfTU9ERSkge1xuICAgIGlmICh0eXBlID09PSAnaHRtbCcpIHtcbiAgICAgIC8vIFdlJ3ZlIGVtaXR0ZWQgdGhlIHJvb3QgYW5kIGlzIG5vdyBpbiA8aHRtbD4gbW9kZS5cbiAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfSFRNTF9NT0RFLCBudWxsLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlJ3ZlIGVtaXR0ZWQgdGhlIHJvb3QgYW5kIGlzIG5vdyBpbiBwbGFpbiBIVE1MIG1vZGUuXG4gICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX01PREUsIG51bGwsIGZhbHNlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocGFyZW50Q29udGV4dC5pbnNlcnRpb25Nb2RlID09PSBIVE1MX0hUTUxfTU9ERSkge1xuICAgIC8vIFdlJ3ZlIGVtaXR0ZWQgdGhlIGRvY3VtZW50IGVsZW1lbnQgYW5kIGlzIG5vdyBpbiBwbGFpbiBIVE1MIG1vZGUuXG4gICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9NT0RFLCBudWxsLCBmYWxzZSk7XG4gIH1cblxuICByZXR1cm4gcGFyZW50Q29udGV4dDtcbn1cbnZhciBVTklOSVRJQUxJWkVEX1NVU1BFTlNFX0JPVU5EQVJZX0lEID0gbnVsbDtcbmZ1bmN0aW9uIGFzc2lnblN1c3BlbnNlQm91bmRhcnlJRChyZXNwb25zZVN0YXRlKSB7XG4gIHZhciBnZW5lcmF0ZWRJRCA9IHJlc3BvbnNlU3RhdGUubmV4dFN1c3BlbnNlSUQrKztcbiAgcmV0dXJuIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhyZXNwb25zZVN0YXRlLmJvdW5kYXJ5UHJlZml4ICsgZ2VuZXJhdGVkSUQudG9TdHJpbmcoMTYpKTtcbn1cbmZ1bmN0aW9uIG1ha2VJZChyZXNwb25zZVN0YXRlLCB0cmVlSWQsIGxvY2FsSWQpIHtcbiAgdmFyIGlkUHJlZml4ID0gcmVzcG9uc2VTdGF0ZS5pZFByZWZpeDtcbiAgdmFyIGlkID0gJzonICsgaWRQcmVmaXggKyAnUicgKyB0cmVlSWQ7IC8vIFVubGVzcyB0aGlzIGlzIHRoZSBmaXJzdCBpZCBhdCB0aGlzIGxldmVsLCBhcHBlbmQgYSBudW1iZXIgYXQgdGhlIGVuZFxuICAvLyB0aGF0IHJlcHJlc2VudHMgdGhlIHBvc2l0aW9uIG9mIHRoaXMgdXNlSWQgaG9vayBhbW9uZyBhbGwgdGhlIHVzZUlkXG4gIC8vIGhvb2tzIGZvciB0aGlzIGZpYmVyLlxuXG4gIGlmIChsb2NhbElkID4gMCkge1xuICAgIGlkICs9ICdIJyArIGxvY2FsSWQudG9TdHJpbmcoMzIpO1xuICB9XG5cbiAgcmV0dXJuIGlkICsgJzonO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVIVE1MVGV4dE5vZGUodGV4dCkge1xuICByZXR1cm4gZXNjYXBlVGV4dEZvckJyb3dzZXIodGV4dCk7XG59XG5cbnZhciB0ZXh0U2VwYXJhdG9yID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8IS0tIC0tPicpO1xuZnVuY3Rpb24gcHVzaFRleHRJbnN0YW5jZSh0YXJnZXQsIHRleHQsIHJlc3BvbnNlU3RhdGUsIHRleHRFbWJlZGRlZCkge1xuICBpZiAodGV4dCA9PT0gJycpIHtcbiAgICAvLyBFbXB0eSB0ZXh0IGRvZXNuJ3QgaGF2ZSBhIERPTSBub2RlIHJlcHJlc2VudGF0aW9uIGFuZCB0aGUgaHlkcmF0aW9uIGlzIGF3YXJlIG9mIHRoaXMuXG4gICAgcmV0dXJuIHRleHRFbWJlZGRlZDtcbiAgfVxuXG4gIGlmICh0ZXh0RW1iZWRkZWQpIHtcbiAgICB0YXJnZXQucHVzaCh0ZXh0U2VwYXJhdG9yKTtcbiAgfVxuXG4gIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoZW5jb2RlSFRNTFRleHROb2RlKHRleHQpKSk7XG4gIHJldHVybiB0cnVlO1xufSAvLyBDYWxsZWQgd2hlbiBGaXp6IGlzIGRvbmUgd2l0aCBhIFNlZ21lbnQuIEN1cnJlbnRseSB0aGUgb25seSBwdXJwb3NlIGlzIHRvIGNvbmRpdGlvbmFsbHlcbi8vIGVtaXQgYSB0ZXh0IHNlcGFyYXRvciB3aGVuIHdlIGRvbid0IGtub3cgZm9yIHN1cmUgaXQgaXMgc2FmZSB0byBvbWl0XG5cbmZ1bmN0aW9uIHB1c2hTZWdtZW50RmluYWxlKHRhcmdldCwgcmVzcG9uc2VTdGF0ZSwgbGFzdFB1c2hlZFRleHQsIHRleHRFbWJlZGRlZCkge1xuICBpZiAobGFzdFB1c2hlZFRleHQgJiYgdGV4dEVtYmVkZGVkKSB7XG4gICAgdGFyZ2V0LnB1c2godGV4dFNlcGFyYXRvcik7XG4gIH1cbn1cbnZhciBzdHlsZU5hbWVDYWNoZSA9IG5ldyBNYXAoKTtcblxuZnVuY3Rpb24gcHJvY2Vzc1N0eWxlTmFtZShzdHlsZU5hbWUpIHtcbiAgdmFyIGNodW5rID0gc3R5bGVOYW1lQ2FjaGUuZ2V0KHN0eWxlTmFtZSk7XG5cbiAgaWYgKGNodW5rICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY2h1bms7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGh5cGhlbmF0ZVN0eWxlTmFtZShzdHlsZU5hbWUpKSk7XG4gIHN0eWxlTmFtZUNhY2hlLnNldChzdHlsZU5hbWUsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBzdHlsZUF0dHJpYnV0ZVN0YXJ0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgc3R5bGU9XCInKTtcbnZhciBzdHlsZUFzc2lnbiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnOicpO1xudmFyIHN0eWxlU2VwYXJhdG9yID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc7Jyk7XG5cbmZ1bmN0aW9uIHB1c2hTdHlsZUF0dHJpYnV0ZSh0YXJnZXQsIHN0eWxlKSB7XG4gIGlmICh0eXBlb2Ygc3R5bGUgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsICcgKyBcIm5vdCBhIHN0cmluZy4gRm9yIGV4YW1wbGUsIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IHNwYWNpbmcgKyAnZW0nfX0gd2hlbiBcIiArICd1c2luZyBKU1guJyk7XG4gIH1cblxuICB2YXIgaXNGaXJzdCA9IHRydWU7XG5cbiAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHN0eWxlLCBzdHlsZU5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIElmIHlvdSBwcm92aWRlIHVuc2FmZSB1c2VyIGRhdGEgaGVyZSB0aGV5IGNhbiBpbmplY3QgYXJiaXRyYXJ5IENTU1xuICAgIC8vIHdoaWNoIG1heSBiZSBwcm9ibGVtYXRpYyAoSSBjb3VsZG4ndCByZXBybyB0aGlzKTpcbiAgICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldFxuICAgIC8vIGh0dHA6Ly93d3cudGhlc3Bhbm5lci5jby51ay8yMDA3LzExLzI2L3VsdGltYXRlLXhzcy1jc3MtaW5qZWN0aW9uL1xuICAgIC8vIFRoaXMgaXMgbm90IGFuIFhTUyBob2xlIGJ1dCBpbnN0ZWFkIGEgcG90ZW50aWFsIENTUyBpbmplY3Rpb24gaXNzdWVcbiAgICAvLyB3aGljaCBoYXMgbGVhZCB0byBhIGdyZWF0ZXIgZGlzY3Vzc2lvbiBhYm91dCBob3cgd2UncmUgZ29pbmcgdG9cbiAgICAvLyB0cnVzdCBVUkxzIG1vdmluZyBmb3J3YXJkLiBTZWUgIzIxMTU5MDFcblxuXG4gICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZVtzdHlsZU5hbWVdO1xuXG4gICAgaWYgKHN0eWxlVmFsdWUgPT0gbnVsbCB8fCB0eXBlb2Ygc3R5bGVWYWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHN0eWxlVmFsdWUgPT09ICcnKSB7XG4gICAgICAvLyBUT0RPOiBXZSB1c2VkIHRvIHNldCBlbXB0eSBzdHJpbmcgYXMgYSBzdHlsZSB3aXRoIGFuIGVtcHR5IHZhbHVlLiBEb2VzIHRoYXQgZXZlciBtYWtlIHNlbnNlP1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIG5hbWVDaHVuayA9IHZvaWQgMDtcbiAgICB2YXIgdmFsdWVDaHVuayA9IHZvaWQgMDtcbiAgICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuXG4gICAgaWYgKGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgIG5hbWVDaHVuayA9IHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoc3R5bGVOYW1lKSk7XG5cbiAgICAgIHtcbiAgICAgICAgY2hlY2tDU1NQcm9wZXJ0eVN0cmluZ0NvZXJjaW9uKHN0eWxlVmFsdWUsIHN0eWxlTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlQ2h1bmsgPSBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKCgnJyArIHN0eWxlVmFsdWUpLnRyaW0oKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5WYWxpZFN0eWxlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIG5hbWVDaHVuayA9IHByb2Nlc3NTdHlsZU5hbWUoc3R5bGVOYW1lKTtcblxuICAgICAgaWYgKHR5cGVvZiBzdHlsZVZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoc3R5bGVWYWx1ZSAhPT0gMCAmJiAhaXNVbml0bGVzc051bWJlcihzdHlsZU5hbWUpKSB7XG4gICAgICAgICAgdmFsdWVDaHVuayA9IHN0cmluZ1RvQ2h1bmsoc3R5bGVWYWx1ZSArICdweCcpOyAvLyBQcmVzdW1lcyBpbXBsaWNpdCAncHgnIHN1ZmZpeCBmb3IgdW5pdGxlc3MgbnVtYmVyc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlQ2h1bmsgPSBzdHJpbmdUb0NodW5rKCcnICsgc3R5bGVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24oc3R5bGVWYWx1ZSwgc3R5bGVOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlQ2h1bmsgPSBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKCgnJyArIHN0eWxlVmFsdWUpLnRyaW0oKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICBpc0ZpcnN0ID0gZmFsc2U7IC8vIElmIGl0J3MgZmlyc3QsIHdlIGRvbid0IG5lZWQgYW55IHNlcGFyYXRvcnMgcHJlZml4ZWQuXG5cbiAgICAgIHRhcmdldC5wdXNoKHN0eWxlQXR0cmlidXRlU3RhcnQsIG5hbWVDaHVuaywgc3R5bGVBc3NpZ24sIHZhbHVlQ2h1bmspO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQucHVzaChzdHlsZVNlcGFyYXRvciwgbmFtZUNodW5rLCBzdHlsZUFzc2lnbiwgdmFsdWVDaHVuayk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFpc0ZpcnN0KSB7XG4gICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlRW5kKTtcbiAgfVxufVxuXG52YXIgYXR0cmlidXRlU2VwYXJhdG9yID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgJyk7XG52YXIgYXR0cmlidXRlQXNzaWduID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc9XCInKTtcbnZhciBhdHRyaWJ1dGVFbmQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiJyk7XG52YXIgYXR0cmlidXRlRW1wdHlTdHJpbmcgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJz1cIlwiJyk7XG5cbmZ1bmN0aW9uIHB1c2hCb29sZWFuQXR0cmlidXRlKHRhcmdldCwgbmFtZSwgdmFsdWUpIC8vIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxue1xuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N5bWJvbCcpIHtcbiAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIHN0cmluZ1RvQ2h1bmsobmFtZSksIGF0dHJpYnV0ZUVtcHR5U3RyaW5nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgbmFtZSwgdmFsdWUpIC8vIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxue1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N5bWJvbCcgJiYgdHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHtcbiAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIHN0cmluZ1RvQ2h1bmsobmFtZSksIGF0dHJpYnV0ZUFzc2lnbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSkpLCBhdHRyaWJ1dGVFbmQpO1xuICB9XG59XG4vLyB0aGFuIG9uIHRoZSBjbGllbnQgYW5kIGhvcGVmdWxseSBpdCdzIGdvb2dsZWFibGUuXG5cblxuc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2NyaXB0LXVybFxuXCJqYXZhc2NyaXB0OnRocm93IG5ldyBFcnJvcignQSBSZWFjdCBmb3JtIHdhcyB1bmV4cGVjdGVkbHkgc3VibWl0dGVkLicpXCIpKTtcbnZhciBzdGFydEhpZGRlbklucHV0Q2h1bmsgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxpbnB1dCB0eXBlPVwiaGlkZGVuXCInKTtcblxuZnVuY3Rpb24gcHVzaEFkZGl0aW9uYWxGb3JtRmllbGQodmFsdWUsIGtleSkge1xuICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgdGFyZ2V0LnB1c2goc3RhcnRIaWRkZW5JbnB1dENodW5rKTtcblxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRmlsZS9CbG9iIGZpZWxkcyBhcmUgbm90IHlldCBzdXBwb3J0ZWQgaW4gcHJvZ3Jlc3NpdmUgZm9ybXMuICcgKyAnSXQgcHJvYmFibHkgbWVhbnMgeW91IGFyZSBjbG9zaW5nIG92ZXIgYmluYXJ5IGRhdGEgb3IgRm9ybURhdGEgaW4gYSBTZXJ2ZXIgQWN0aW9uLicpO1xuICB9XG5cbiAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsICduYW1lJywga2V5KTtcbiAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsICd2YWx1ZScsIHZhbHVlKTtcbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nKTtcbn1cblxuZnVuY3Rpb24gcHVzaEFkZGl0aW9uYWxGb3JtRmllbGRzKHRhcmdldCwgZm9ybURhdGEpIHtcbiAgaWYgKGZvcm1EYXRhICE9PSBudWxsKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddOiBGb3JtRGF0YSBoYXMgZm9yRWFjaC5cbiAgICBmb3JtRGF0YS5mb3JFYWNoKHB1c2hBZGRpdGlvbmFsRm9ybUZpZWxkLCB0YXJnZXQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hGb3JtQWN0aW9uQXR0cmlidXRlKHRhcmdldCwgcmVzcG9uc2VTdGF0ZSwgZm9ybUFjdGlvbiwgZm9ybUVuY1R5cGUsIGZvcm1NZXRob2QsIGZvcm1UYXJnZXQsIG5hbWUpIHtcbiAgdmFyIGZvcm1EYXRhID0gbnVsbDtcblxuICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsICduYW1lJywgbmFtZSk7XG4gIH1cblxuICBpZiAoZm9ybUFjdGlvbiAhPSBudWxsKSB7XG4gICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsICdmb3JtQWN0aW9uJywgZm9ybUFjdGlvbik7XG4gIH1cblxuICBpZiAoZm9ybUVuY1R5cGUgIT0gbnVsbCkge1xuICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCAnZm9ybUVuY1R5cGUnLCBmb3JtRW5jVHlwZSk7XG4gIH1cblxuICBpZiAoZm9ybU1ldGhvZCAhPSBudWxsKSB7XG4gICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsICdmb3JtTWV0aG9kJywgZm9ybU1ldGhvZCk7XG4gIH1cblxuICBpZiAoZm9ybVRhcmdldCAhPSBudWxsKSB7XG4gICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsICdmb3JtVGFyZ2V0JywgZm9ybVRhcmdldCk7XG4gIH1cblxuICByZXR1cm4gZm9ybURhdGE7XG59XG5cbmZ1bmN0aW9uIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBuYW1lLCB2YWx1ZSkgLy8gbm90IG51bGwgb3IgdW5kZWZpbmVkXG57XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIC8vIFRoZXNlIGFyZSB2ZXJ5IGNvbW1vbiBwcm9wcyBhbmQgdGhlcmVmb3JlIGFyZSBpbiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzd2l0Y2guXG4gICAgLy8gVE9ETzogYXJpYS1sYWJlbCBpcyBhIHZlcnkgY29tbW9uIHByb3AgYnV0IGFsbG93cyBib29sZWFucyBzbyBpcyBub3QgbGlrZSB0aGUgb3RoZXJzXG4gICAgLy8gYnV0IHNob3VsZCBpZGVhbGx5IGdvIGluIHRoaXMgbGlzdCB0b28uXG4gICAgY2FzZSAnY2xhc3NOYW1lJzpcbiAgICAgIHtcbiAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsICdjbGFzcycsIHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICd0YWJJbmRleCc6XG4gICAgICB7XG4gICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAndGFiaW5kZXgnLCB2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZGlyJzpcbiAgICBjYXNlICdyb2xlJzpcbiAgICBjYXNlICd2aWV3Qm94JzpcbiAgICBjYXNlICd3aWR0aCc6XG4gICAgY2FzZSAnaGVpZ2h0JzpcbiAgICAgIHtcbiAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdzdHlsZSc6XG4gICAgICB7XG4gICAgICAgIHB1c2hTdHlsZUF0dHJpYnV0ZSh0YXJnZXQsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSAnc3JjJzpcbiAgICBjYXNlICdocmVmJzpcbiAgICAvLyBGYWxsIHRocm91Z2ggdG8gdGhlIGxhc3QgY2FzZSB3aGljaCBzaG91bGRuJ3QgcmVtb3ZlIGVtcHR5IHN0cmluZ3MuXG5cbiAgICBjYXNlICdhY3Rpb24nOlxuICAgIGNhc2UgJ2Zvcm1BY3Rpb24nOlxuICAgICAge1xuICAgICAgICAvLyBUT0RPOiBDb25zaWRlciBvbmx5IHNwZWNpYWwgY2FzaW5nIHRoZXNlIGZvciBlYWNoIHRhZy5cbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgbmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2FuaXRpemVkVmFsdWUgPSBzYW5pdGl6ZVVSTCgnJyArIHZhbHVlKTtcbiAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBzdHJpbmdUb0NodW5rKG5hbWUpLCBhdHRyaWJ1dGVBc3NpZ24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoc2FuaXRpemVkVmFsdWUpKSwgYXR0cmlidXRlRW5kKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZGVmYXVsdFZhbHVlJzpcbiAgICBjYXNlICdkZWZhdWx0Q2hlY2tlZCc6IC8vIFRoZXNlIHNob3VsZG4ndCBiZSBzZXQgYXMgYXR0cmlidXRlcyBvbiBnZW5lcmljIEhUTUwgZWxlbWVudHMuXG5cbiAgICBjYXNlICdpbm5lckhUTUwnOiAvLyBNdXN0IHVzZSBkYW5nZXJvdXNseVNldElubmVySFRNTCBpbnN0ZWFkLlxuXG4gICAgY2FzZSAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJzpcbiAgICBjYXNlICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnOlxuICAgICAgLy8gSWdub3JlZC4gVGhlc2UgYXJlIGJ1aWx0LWluIHRvIFJlYWN0IG9uIHRoZSBjbGllbnQuXG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICdhdXRvRm9jdXMnOlxuICAgIGNhc2UgJ211bHRpcGxlJzpcbiAgICBjYXNlICdtdXRlZCc6XG4gICAgICB7XG4gICAgICAgIHB1c2hCb29sZWFuQXR0cmlidXRlKHRhcmdldCwgbmFtZS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3hsaW5rSHJlZic6XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfc2FuaXRpemVkVmFsdWUgPSBzYW5pdGl6ZVVSTCgnJyArIHZhbHVlKTtcblxuICAgICAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIHN0cmluZ1RvQ2h1bmsoJ3hsaW5rOmhyZWYnKSwgYXR0cmlidXRlQXNzaWduLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKF9zYW5pdGl6ZWRWYWx1ZSkpLCBhdHRyaWJ1dGVFbmQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlICdjb250ZW50RWRpdGFibGUnOlxuICAgIGNhc2UgJ3NwZWxsQ2hlY2snOlxuICAgIGNhc2UgJ2RyYWdnYWJsZSc6XG4gICAgY2FzZSAndmFsdWUnOlxuICAgIGNhc2UgJ2F1dG9SZXZlcnNlJzpcbiAgICBjYXNlICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJzpcbiAgICBjYXNlICdmb2N1c2FibGUnOlxuICAgIGNhc2UgJ3ByZXNlcnZlQWxwaGEnOlxuICAgICAge1xuICAgICAgICAvLyBCb29sZWFuaXNoIFN0cmluZ1xuICAgICAgICAvLyBUaGVzZSBhcmUgXCJlbnVtZXJhdGVkXCIgYXR0cmlidXRlcyB0aGF0IGFjY2VwdCBcInRydWVcIiBhbmQgXCJmYWxzZVwiLlxuICAgICAgICAvLyBJbiBSZWFjdCwgd2UgbGV0IHVzZXJzIHBhc3MgYHRydWVgIGFuZCBgZmFsc2VgIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5XG4gICAgICAgIC8vIHRoZXNlIGFyZW4ndCBib29sZWFuIGF0dHJpYnV0ZXMgKHRoZXkgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncykuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3ltYm9sJykge1xuICAgICAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuayhuYW1lKSwgYXR0cmlidXRlQXNzaWduLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSksIGF0dHJpYnV0ZUVuZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlICdhbGxvd0Z1bGxTY3JlZW4nOlxuICAgIGNhc2UgJ2FzeW5jJzpcbiAgICBjYXNlICdhdXRvUGxheSc6XG4gICAgY2FzZSAnY29udHJvbHMnOlxuICAgIGNhc2UgJ2RlZmF1bHQnOlxuICAgIGNhc2UgJ2RlZmVyJzpcbiAgICBjYXNlICdkaXNhYmxlZCc6XG4gICAgY2FzZSAnZGlzYWJsZVBpY3R1cmVJblBpY3R1cmUnOlxuICAgIGNhc2UgJ2Rpc2FibGVSZW1vdGVQbGF5YmFjayc6XG4gICAgY2FzZSAnZm9ybU5vVmFsaWRhdGUnOlxuICAgIGNhc2UgJ2hpZGRlbic6XG4gICAgY2FzZSAnbG9vcCc6XG4gICAgY2FzZSAnbm9Nb2R1bGUnOlxuICAgIGNhc2UgJ25vVmFsaWRhdGUnOlxuICAgIGNhc2UgJ29wZW4nOlxuICAgIGNhc2UgJ3BsYXlzSW5saW5lJzpcbiAgICBjYXNlICdyZWFkT25seSc6XG4gICAgY2FzZSAncmVxdWlyZWQnOlxuICAgIGNhc2UgJ3JldmVyc2VkJzpcbiAgICBjYXNlICdzY29wZWQnOlxuICAgIGNhc2UgJ3NlYW1sZXNzJzpcbiAgICBjYXNlICdpdGVtU2NvcGUnOlxuICAgICAge1xuICAgICAgICAvLyBCb29sZWFuXG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3ltYm9sJykge1xuICAgICAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuayhuYW1lKSwgYXR0cmlidXRlRW1wdHlTdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSAnY2FwdHVyZSc6XG4gICAgY2FzZSAnZG93bmxvYWQnOlxuICAgICAge1xuICAgICAgICAvLyBPdmVybG9hZGVkIEJvb2xlYW5cbiAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBzdHJpbmdUb0NodW5rKG5hbWUpLCBhdHRyaWJ1dGVFbXB0eVN0cmluZyk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IGZhbHNlKSA7IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBzdHJpbmdUb0NodW5rKG5hbWUpLCBhdHRyaWJ1dGVBc3NpZ24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpKSwgYXR0cmlidXRlRW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgJ2NvbHMnOlxuICAgIGNhc2UgJ3Jvd3MnOlxuICAgIGNhc2UgJ3NpemUnOlxuICAgIGNhc2UgJ3NwYW4nOlxuICAgICAge1xuICAgICAgICAvLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgbXVzdCBiZSBwb3NpdGl2ZSBudW1iZXJzLlxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N5bWJvbCcgJiYgIWlzTmFOKHZhbHVlKSAmJiB2YWx1ZSA+PSAxKSB7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBzdHJpbmdUb0NodW5rKG5hbWUpLCBhdHRyaWJ1dGVBc3NpZ24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpKSwgYXR0cmlidXRlRW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3Jvd1NwYW4nOlxuICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgIHtcbiAgICAgICAgLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IG11c3QgYmUgbnVtYmVycy5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdzeW1ib2wnICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIHN0cmluZ1RvQ2h1bmsobmFtZSksIGF0dHJpYnV0ZUFzc2lnbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSkpLCBhdHRyaWJ1dGVFbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSAneGxpbmtBY3R1YXRlJzpcbiAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAneGxpbms6YWN0dWF0ZScsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcblxuICAgIGNhc2UgJ3hsaW5rQXJjcm9sZSc6XG4gICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgJ3hsaW5rOmFyY3JvbGUnLCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICd4bGlua1JvbGUnOlxuICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsICd4bGluazpyb2xlJywgdmFsdWUpO1xuICAgICAgcmV0dXJuO1xuXG4gICAgY2FzZSAneGxpbmtTaG93JzpcbiAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAneGxpbms6c2hvdycsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcblxuICAgIGNhc2UgJ3hsaW5rVGl0bGUnOlxuICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsICd4bGluazp0aXRsZScsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcblxuICAgIGNhc2UgJ3hsaW5rVHlwZSc6XG4gICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgJ3hsaW5rOnR5cGUnLCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICd4bWxCYXNlJzpcbiAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAneG1sOmJhc2UnLCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICd4bWxMYW5nJzpcbiAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAneG1sOmxhbmcnLCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICd4bWxTcGFjZSc6XG4gICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgJ3htbDpzcGFjZScsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoIC8vIHNob3VsZElnbm9yZUF0dHJpYnV0ZVxuICAgICAgLy8gV2UgaGF2ZSBhbHJlYWR5IGZpbHRlcmVkIG91dCBudWxsL3VuZGVmaW5lZCBhbmQgcmVzZXJ2ZWQgd29yZHMuXG4gICAgICBuYW1lLmxlbmd0aCA+IDIgJiYgKG5hbWVbMF0gPT09ICdvJyB8fCBuYW1lWzBdID09PSAnTycpICYmIChuYW1lWzFdID09PSAnbicgfHwgbmFtZVsxXSA9PT0gJ04nKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gZ2V0QXR0cmlidXRlQWxpYXMobmFtZSk7XG5cbiAgICAgIGlmIChpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgIC8vIHNob3VsZFJlbW92ZUF0dHJpYnV0ZVxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBwcmVmaXggPSBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG5cbiAgICAgICAgICAgICAgaWYgKHByZWZpeCAhPT0gJ2RhdGEtJyAmJiBwcmVmaXggIT09ICdhcmlhLScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuayhhdHRyaWJ1dGVOYW1lKSwgYXR0cmlidXRlQXNzaWduLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSksIGF0dHJpYnV0ZUVuZCk7XG4gICAgICB9XG5cbiAgfVxufVxuXG52YXIgZW5kT2ZTdGFydFRhZyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPicpO1xudmFyIGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnLz4nKTtcblxuZnVuY3Rpb24gcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pIHtcbiAgaWYgKGlubmVySFRNTCAhPSBudWxsKSB7XG4gICAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbm5lckhUTUwgIT09ICdvYmplY3QnIHx8ICEoJ19faHRtbCcgaW4gaW5uZXJIVE1MKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiAnICsgJ1BsZWFzZSB2aXNpdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgJyArICdmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICB9XG5cbiAgICB2YXIgaHRtbCA9IGlubmVySFRNTC5fX2h0bWw7XG5cbiAgICBpZiAoaHRtbCAhPT0gbnVsbCAmJiBodG1sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oaHRtbCk7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoJycgKyBodG1sKSk7XG4gICAgfVxuICB9XG59IC8vIFRPRE86IE1vdmUgdGhlc2UgdG8gUmVzcG9uc2VTdGF0ZSBzbyB0aGF0IHdlIHdhcm4gZm9yIGV2ZXJ5IHJlcXVlc3QuXG4vLyBJdCB3b3VsZCBoZWxwIGRlYnVnZ2luZyBpbiBzdGF0ZWZ1bCBzZXJ2ZXJzIChlLmcuIHNlcnZpY2Ugd29ya2VyKS5cblxuXG52YXIgZGlkV2FybkRlZmF1bHRJbnB1dFZhbHVlID0gZmFsc2U7XG52YXIgZGlkV2FybkRlZmF1bHRDaGVja2VkID0gZmFsc2U7XG52YXIgZGlkV2FybkRlZmF1bHRTZWxlY3RWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gPSBmYWxzZTtcbnZhciBkaWRXYXJuSW52YWxpZE9wdGlvbklubmVySFRNTCA9IGZhbHNlO1xudmFyIGRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uID0gZmFsc2U7XG52YXIgZGlkV2FybkZvcm1BY3Rpb25UeXBlID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGNoZWNrU2VsZWN0UHJvcChwcm9wcywgcHJvcE5hbWUpIHtcbiAge1xuICAgIHZhciB2YWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcblxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICB2YXIgYXJyYXkgPSBpc0FycmF5KHZhbHVlKTtcblxuICAgICAgaWYgKHByb3BzLm11bHRpcGxlICYmICFhcnJheSkge1xuICAgICAgICBlcnJvcignVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGFuIGFycmF5IGlmICcgKyAnYG11bHRpcGxlYCBpcyB0cnVlLicsIHByb3BOYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoIXByb3BzLm11bHRpcGxlICYmIGFycmF5KSB7XG4gICAgICAgIGVycm9yKCdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYSBzY2FsYXIgJyArICd2YWx1ZSBpZiBgbXVsdGlwbGVgIGlzIGZhbHNlLicsIHByb3BOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaFN0YXJ0U2VsZWN0KHRhcmdldCwgcHJvcHMpIHtcbiAge1xuICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoJ3NlbGVjdCcsIHByb3BzKTtcbiAgICBjaGVja1NlbGVjdFByb3AocHJvcHMsICd2YWx1ZScpO1xuICAgIGNoZWNrU2VsZWN0UHJvcChwcm9wcywgJ2RlZmF1bHRWYWx1ZScpO1xuXG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUpIHtcbiAgICAgIGVycm9yKCdTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHNlbGVjdCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG5cbiAgICAgIGRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoJ3NlbGVjdCcpKTtcbiAgdmFyIGNoaWxkcmVuID0gbnVsbDtcbiAgdmFyIGlubmVySFRNTCA9IG51bGw7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIC8vIFRPRE86IFRoaXMgZG9lc24ndCByZWFsbHkgbWFrZSBzZW5zZSBmb3Igc2VsZWN0IHNpbmNlIGl0IGNhbid0IHVzZSB0aGUgY29udHJvbGxlZFxuICAgICAgICAgIC8vIHZhbHVlIGluIHRoZSBpbm5lckhUTUwuXG4gICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2RlZmF1bHRWYWx1ZSc6XG4gICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICAvLyBUaGVzZSBhcmUgc2V0IG9uIHRoZSBDb250ZXh0IGluc3RlYWQgYW5kIGFwcGxpZWQgdG8gdGhlIG5lc3RlZCBvcHRpb25zLlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuT3B0aW9uQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIGNvbnRlbnQgPSAnJzsgLy8gRmxhdHRlbiBjaGlsZHJlbiBhbmQgd2FybiBpZiB0aGV5IGFyZW4ndCBzdHJpbmdzIG9yIG51bWJlcnM7XG4gIC8vIGludmFsaWQgdHlwZXMgYXJlIGlnbm9yZWQuXG5cbiAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb250ZW50ICs9IGNoaWxkO1xuXG4gICAge1xuICAgICAgaWYgKCFkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuICYmIHR5cGVvZiBjaGlsZCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGNoaWxkICE9PSAnbnVtYmVyJykge1xuICAgICAgICBkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignQ2Fubm90IGluZmVyIHRoZSBvcHRpb24gdmFsdWUgb2YgY29tcGxleCBjaGlsZHJlbi4gJyArICdQYXNzIGEgYHZhbHVlYCBwcm9wIG9yIHVzZSBhIHBsYWluIHN0cmluZyBhcyBjaGlsZHJlbiB0byA8b3B0aW9uPi4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY29udGVudDtcbn1cblxudmFyIHNlbGVjdGVkTWFya2VyQXR0cmlidXRlID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgc2VsZWN0ZWQ9XCJcIicpO1xuXG5mdW5jdGlvbiBwdXNoU3RhcnRPcHRpb24odGFyZ2V0LCBwcm9wcywgZm9ybWF0Q29udGV4dCkge1xuICB2YXIgc2VsZWN0ZWRWYWx1ZSA9IGZvcm1hdENvbnRleHQuc2VsZWN0ZWRWYWx1ZTtcbiAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZygnb3B0aW9uJykpO1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICB2YXIgdmFsdWUgPSBudWxsO1xuICB2YXIgc2VsZWN0ZWQgPSBudWxsO1xuICB2YXIgaW5uZXJIVE1MID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzZWxlY3RlZCc6XG4gICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgICAgc2VsZWN0ZWQgPSBwcm9wVmFsdWU7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgc3VwcG9ydCBmb3IgYHNlbGVjdGVkYCBpbiA8b3B0aW9uPi5cbiAgICAgICAgICAgIGlmICghZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24pIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mICcgKyAnc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LicpO1xuXG4gICAgICAgICAgICAgIGRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICB2YWx1ZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgLy8gV2UgaW50ZW50aW9uYWxseSBmYWxsdGhyb3VnaCB0byBhbHNvIHNldCB0aGUgYXR0cmlidXRlIG9uIHRoZSBub2RlLlxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHNlbGVjdGVkVmFsdWUgIT0gbnVsbCkge1xuICAgIHZhciBzdHJpbmdWYWx1ZTtcblxuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCAndmFsdWUnKTtcbiAgICAgIH1cblxuICAgICAgc3RyaW5nVmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIGlmIChpbm5lckhUTUwgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoIWRpZFdhcm5JbnZhbGlkT3B0aW9uSW5uZXJIVE1MKSB7XG4gICAgICAgICAgICBkaWRXYXJuSW52YWxpZE9wdGlvbklubmVySFRNTCA9IHRydWU7XG5cbiAgICAgICAgICAgIGVycm9yKCdQYXNzIGEgYHZhbHVlYCBwcm9wIGlmIHlvdSBzZXQgZGFuZ2Vyb3VzbHlJbm5lckhUTUwgc28gUmVhY3Qga25vd3MgJyArICd3aGljaCB2YWx1ZSBzaG91bGQgYmUgc2VsZWN0ZWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0cmluZ1ZhbHVlID0gZmxhdHRlbk9wdGlvbkNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShzZWxlY3RlZFZhbHVlKSkge1xuICAgICAgLy8gbXVsdGlwbGVcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWRWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihzZWxlY3RlZFZhbHVlW2ldLCAndmFsdWUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2ID0gJycgKyBzZWxlY3RlZFZhbHVlW2ldO1xuXG4gICAgICAgIGlmICh2ID09PSBzdHJpbmdWYWx1ZSkge1xuICAgICAgICAgIHRhcmdldC5wdXNoKHNlbGVjdGVkTWFya2VyQXR0cmlidXRlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24oc2VsZWN0ZWRWYWx1ZSwgJ3NlbGVjdC52YWx1ZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoJycgKyBzZWxlY3RlZFZhbHVlID09PSBzdHJpbmdWYWx1ZSkge1xuICAgICAgICB0YXJnZXQucHVzaChzZWxlY3RlZE1hcmtlckF0dHJpYnV0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHNlbGVjdGVkKSB7XG4gICAgdGFyZ2V0LnB1c2goc2VsZWN0ZWRNYXJrZXJBdHRyaWJ1dGUpO1xuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5zdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoZm9ybVJlcGxheWluZyk7XG5cbmZ1bmN0aW9uIHB1c2hTdGFydEZvcm0odGFyZ2V0LCBwcm9wcywgcmVzcG9uc2VTdGF0ZSkge1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKCdmb3JtJykpO1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICB2YXIgaW5uZXJIVE1MID0gbnVsbDtcbiAgdmFyIGZvcm1BY3Rpb24gPSBudWxsO1xuICB2YXIgZm9ybUVuY1R5cGUgPSBudWxsO1xuICB2YXIgZm9ybU1ldGhvZCA9IG51bGw7XG4gIHZhciBmb3JtVGFyZ2V0ID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2FjdGlvbic6XG4gICAgICAgICAgZm9ybUFjdGlvbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdlbmNUeXBlJzpcbiAgICAgICAgICBmb3JtRW5jVHlwZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdtZXRob2QnOlxuICAgICAgICAgIGZvcm1NZXRob2QgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndGFyZ2V0JzpcbiAgICAgICAgICBmb3JtVGFyZ2V0ID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGZvcm1BY3Rpb24gIT0gbnVsbCkge1xuICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCAnYWN0aW9uJywgZm9ybUFjdGlvbik7XG4gIH1cblxuICBpZiAoZm9ybUVuY1R5cGUgIT0gbnVsbCkge1xuICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCAnZW5jVHlwZScsIGZvcm1FbmNUeXBlKTtcbiAgfVxuXG4gIGlmIChmb3JtTWV0aG9kICE9IG51bGwpIHtcbiAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgJ21ldGhvZCcsIGZvcm1NZXRob2QpO1xuICB9XG5cbiAgaWYgKGZvcm1UYXJnZXQgIT0gbnVsbCkge1xuICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCAndGFyZ2V0JywgZm9ybVRhcmdldCk7XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcblxuICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MLCBjaGlsZHJlbik7XG5cbiAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2UgY2hpbGRyZW4gYXMgYSBzdHJpbmcgdG8gYXZvaWQgdGhlIHVubmVjZXNzYXJ5IGNvbW1lbnQuXG4gICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgc3BlY2lhbCBjYXNlIGFmdGVyIHRoZSBnZW5lcmFsIG9wdGltaXphdGlvbiBpcyBpbiBwbGFjZS5cbiAgICB0YXJnZXQucHVzaChzdHJpbmdUb0NodW5rKGVuY29kZUhUTUxUZXh0Tm9kZShjaGlsZHJlbikpKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gcHVzaElucHV0KHRhcmdldCwgcHJvcHMsIHJlc3BvbnNlU3RhdGUpIHtcbiAge1xuICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoJ2lucHV0JywgcHJvcHMpO1xuICB9XG5cbiAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZygnaW5wdXQnKSk7XG4gIHZhciBuYW1lID0gbnVsbDtcbiAgdmFyIGZvcm1BY3Rpb24gPSBudWxsO1xuICB2YXIgZm9ybUVuY1R5cGUgPSBudWxsO1xuICB2YXIgZm9ybU1ldGhvZCA9IG51bGw7XG4gIHZhciBmb3JtVGFyZ2V0ID0gbnVsbDtcbiAgdmFyIHZhbHVlID0gbnVsbDtcbiAgdmFyIGRlZmF1bHRWYWx1ZSA9IG51bGw7XG4gIHZhciBjaGVja2VkID0gbnVsbDtcbiAgdmFyIGRlZmF1bHRDaGVja2VkID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQnICsgXCIgaXMgYSBzZWxmLWNsb3NpbmcgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciBcIiArICd1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcblxuICAgICAgICBjYXNlICduYW1lJzpcbiAgICAgICAgICBuYW1lID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Zvcm1BY3Rpb24nOlxuICAgICAgICAgIGZvcm1BY3Rpb24gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZm9ybUVuY1R5cGUnOlxuICAgICAgICAgIGZvcm1FbmNUeXBlID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Zvcm1NZXRob2QnOlxuICAgICAgICAgIGZvcm1NZXRob2QgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZm9ybVRhcmdldCc6XG4gICAgICAgICAgZm9ybVRhcmdldCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkZWZhdWx0Q2hlY2tlZCc6XG4gICAgICAgICAgZGVmYXVsdENoZWNrZWQgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGVmYXVsdFZhbHVlJzpcbiAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnY2hlY2tlZCc6XG4gICAgICAgICAgY2hlY2tlZCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgICAgdmFsdWUgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKGZvcm1BY3Rpb24gIT09IG51bGwgJiYgcHJvcHMudHlwZSAhPT0gJ2ltYWdlJyAmJiBwcm9wcy50eXBlICE9PSAnc3VibWl0JyAmJiAhZGlkV2FybkZvcm1BY3Rpb25UeXBlKSB7XG4gICAgICBkaWRXYXJuRm9ybUFjdGlvblR5cGUgPSB0cnVlO1xuXG4gICAgICBlcnJvcignQW4gaW5wdXQgY2FuIG9ubHkgc3BlY2lmeSBhIGZvcm1BY3Rpb24gYWxvbmcgd2l0aCB0eXBlPVwic3VibWl0XCIgb3IgdHlwZT1cImltYWdlXCIuJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZvcm1EYXRhID0gcHVzaEZvcm1BY3Rpb25BdHRyaWJ1dGUodGFyZ2V0LCByZXNwb25zZVN0YXRlLCBmb3JtQWN0aW9uLCBmb3JtRW5jVHlwZSwgZm9ybU1ldGhvZCwgZm9ybVRhcmdldCwgbmFtZSk7XG5cbiAge1xuICAgIGlmIChjaGVja2VkICE9PSBudWxsICYmIGRlZmF1bHRDaGVja2VkICE9PSBudWxsICYmICFkaWRXYXJuRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgIGVycm9yKCclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgY2hlY2tlZCBwcm9wLCBvciB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnLCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcblxuICAgICAgZGlkV2FybkRlZmF1bHRDaGVja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgZGVmYXVsdFZhbHVlICE9PSBudWxsICYmICFkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUpIHtcbiAgICAgIGVycm9yKCclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJywgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG5cbiAgICAgIGRpZFdhcm5EZWZhdWx0SW5wdXRWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNoZWNrZWQgIT09IG51bGwpIHtcbiAgICBwdXNoQm9vbGVhbkF0dHJpYnV0ZSh0YXJnZXQsICdjaGVja2VkJywgY2hlY2tlZCk7XG4gIH0gZWxzZSBpZiAoZGVmYXVsdENoZWNrZWQgIT09IG51bGwpIHtcbiAgICBwdXNoQm9vbGVhbkF0dHJpYnV0ZSh0YXJnZXQsICdjaGVja2VkJywgZGVmYXVsdENoZWNrZWQpO1xuICB9XG5cbiAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsICd2YWx1ZScsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChkZWZhdWx0VmFsdWUgIT09IG51bGwpIHtcbiAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgJ3ZhbHVlJywgZGVmYXVsdFZhbHVlKTtcbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyk7IC8vIFdlIHBsYWNlIGFueSBhZGRpdGlvbmFsIGhpZGRlbiBmb3JtIGZpZWxkcyBhZnRlciB0aGUgaW5wdXQuXG5cbiAgcHVzaEFkZGl0aW9uYWxGb3JtRmllbGRzKHRhcmdldCwgZm9ybURhdGEpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHVzaFN0YXJ0QnV0dG9uKHRhcmdldCwgcHJvcHMsIHJlc3BvbnNlU3RhdGUpIHtcbiAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZygnYnV0dG9uJykpO1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICB2YXIgaW5uZXJIVE1MID0gbnVsbDtcbiAgdmFyIG5hbWUgPSBudWxsO1xuICB2YXIgZm9ybUFjdGlvbiA9IG51bGw7XG4gIHZhciBmb3JtRW5jVHlwZSA9IG51bGw7XG4gIHZhciBmb3JtTWV0aG9kID0gbnVsbDtcbiAgdmFyIGZvcm1UYXJnZXQgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbmFtZSc6XG4gICAgICAgICAgbmFtZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmb3JtQWN0aW9uJzpcbiAgICAgICAgICBmb3JtQWN0aW9uID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Zvcm1FbmNUeXBlJzpcbiAgICAgICAgICBmb3JtRW5jVHlwZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmb3JtTWV0aG9kJzpcbiAgICAgICAgICBmb3JtTWV0aG9kID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Zvcm1UYXJnZXQnOlxuICAgICAgICAgIGZvcm1UYXJnZXQgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKGZvcm1BY3Rpb24gIT09IG51bGwgJiYgcHJvcHMudHlwZSAhPSBudWxsICYmIHByb3BzLnR5cGUgIT09ICdzdWJtaXQnICYmICFkaWRXYXJuRm9ybUFjdGlvblR5cGUpIHtcbiAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uVHlwZSA9IHRydWU7XG5cbiAgICAgIGVycm9yKCdBIGJ1dHRvbiBjYW4gb25seSBzcGVjaWZ5IGEgZm9ybUFjdGlvbiBhbG9uZyB3aXRoIHR5cGU9XCJzdWJtaXRcIiBvciBubyB0eXBlLicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmb3JtRGF0YSA9IHB1c2hGb3JtQWN0aW9uQXR0cmlidXRlKHRhcmdldCwgcmVzcG9uc2VTdGF0ZSwgZm9ybUFjdGlvbiwgZm9ybUVuY1R5cGUsIGZvcm1NZXRob2QsIGZvcm1UYXJnZXQsIG5hbWUpO1xuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTsgLy8gV2UgcGxhY2UgYW55IGFkZGl0aW9uYWwgaGlkZGVuIGZvcm0gZmllbGRzIHdlIG5lZWQgdG8gaW5jbHVkZSBpbnNpZGUgdGhlIGJ1dHRvbiBpdHNlbGYuXG5cbiAgcHVzaEFkZGl0aW9uYWxGb3JtRmllbGRzKHRhcmdldCwgZm9ybURhdGEpO1xuICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MLCBjaGlsZHJlbik7XG5cbiAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2UgY2hpbGRyZW4gYXMgYSBzdHJpbmcgdG8gYXZvaWQgdGhlIHVubmVjZXNzYXJ5IGNvbW1lbnQuXG4gICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgc3BlY2lhbCBjYXNlIGFmdGVyIHRoZSBnZW5lcmFsIG9wdGltaXphdGlvbiBpcyBpbiBwbGFjZS5cbiAgICB0YXJnZXQucHVzaChzdHJpbmdUb0NodW5rKGVuY29kZUhUTUxUZXh0Tm9kZShjaGlsZHJlbikpKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gcHVzaFN0YXJ0VGV4dEFyZWEodGFyZ2V0LCBwcm9wcykge1xuICB7XG4gICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcygndGV4dGFyZWEnLCBwcm9wcyk7XG5cbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkRlZmF1bHRUZXh0YXJlYVZhbHVlKSB7XG4gICAgICBlcnJvcignVGV4dGFyZWEgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHRleHRhcmVhICcgKyAnYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG5cbiAgICAgIGRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZygndGV4dGFyZWEnKSk7XG4gIHZhciB2YWx1ZSA9IG51bGw7XG4gIHZhciBkZWZhdWx0VmFsdWUgPSBudWxsO1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICB2YWx1ZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkZWZhdWx0VmFsdWUnOlxuICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi4nKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCAmJiBkZWZhdWx0VmFsdWUgIT09IG51bGwpIHtcbiAgICB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpOyAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgY2hpbGRyZW4gY29udGVudCBpbiA8dGV4dGFyZWE+LlxuXG4gIGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG4gICAge1xuICAgICAgZXJyb3IoJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBpbnN0ZWFkIG9mIHNldHRpbmcgJyArICdjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LicpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi4nKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignPHRleHRhcmVhPiBjYW4gb25seSBoYXZlIGF0IG1vc3Qgb25lIGNoaWxkLicpO1xuICAgICAgfSAvLyBUT0RPOiByZW1vdmUgdGhlIGNvZXJjaW9uIGFuZCB0aGUgREVWIGNoZWNrIGJlbG93IGJlY2F1c2UgaXQgd2lsbFxuICAgICAgLy8gYWx3YXlzIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBjb2VyY2lvbiBzZXZlcmFsIGxpbmVzIGJlbG93IGl0LiAjMjIzMDlcblxuXG4gICAgICB7XG4gICAgICAgIGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKGNoaWxkcmVuWzBdKTtcbiAgICAgIH1cblxuICAgICAgdmFsdWUgPSAnJyArIGNoaWxkcmVuWzBdO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKGNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICB2YWx1ZSA9ICcnICsgY2hpbGRyZW47XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZVswXSA9PT0gJ1xcbicpIHtcbiAgICAvLyB0ZXh0L2h0bWwgaWdub3JlcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZXNlIHRhZ3MgaWYgaXQncyBhIG5ld2xpbmVcbiAgICAvLyBQcmVmZXIgdG8gYnJlYWsgYXBwbGljYXRpb24veG1sIG92ZXIgdGV4dC9odG1sIChmb3Igbm93KSBieSBhZGRpbmdcbiAgICAvLyBhIG5ld2xpbmUgc3BlY2lmaWNhbGx5IHRvIGdldCBlYXRlbiBieSB0aGUgcGFyc2VyLiAoQWx0ZXJuYXRlbHkgZm9yXG4gICAgLy8gdGV4dGFyZWFzLCByZXBsYWNpbmcgXCJeXFxuXCIgd2l0aCBcIlxcclxcblwiIGRvZXNuJ3QgZ2V0IGVhdGVuLCBhbmQgdGhlIGZpcnN0XG4gICAgLy8gXFxyIGlzIG5vcm1hbGl6ZWQgb3V0IGJ5IEhUTUxUZXh0QXJlYUVsZW1lbnQjdmFsdWUuKVxuICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWwtcG9seWdsb3QvI25ld2xpbmVzLWluLXRleHRhcmVhLWFuZC1wcmU+XG4gICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjZWxlbWVudC1yZXN0cmljdGlvbnM+XG4gICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjbmV3bGluZXM+XG4gICAgLy8gU2VlOiBQYXJzaW5nIG9mIFwidGV4dGFyZWFcIiBcImxpc3RpbmdcIiBhbmQgXCJwcmVcIiBlbGVtZW50c1xuICAgIC8vICBmcm9tIDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5PlxuICAgIHRhcmdldC5wdXNoKGxlYWRpbmdOZXdsaW5lKTtcbiAgfSAvLyBUb1N0cmluZyBhbmQgcHVzaCBkaXJlY3RseSBpbnN0ZWFkIG9mIHJlY3Vyc2Ugb3ZlciBjaGlsZHJlbi5cbiAgLy8gV2UgZG9uJ3QgcmVhbGx5IHN1cHBvcnQgY29tcGxleCBjaGlsZHJlbiBpbiB0aGUgdmFsdWUgYW55d2F5LlxuICAvLyBUaGlzIGFsc28gY3VycmVudGx5IGF2b2lkcyBhIHRyYWlsaW5nIGNvbW1lbnQgbm9kZSB3aGljaCBicmVha3MgdGV4dGFyZWEuXG5cblxuICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICB7XG4gICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCAndmFsdWUnKTtcbiAgICB9XG5cbiAgICB0YXJnZXQucHVzaChzdHJpbmdUb0NodW5rKGVuY29kZUhUTUxUZXh0Tm9kZSgnJyArIHZhbHVlKSkpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHB1c2hNZXRhKHRhcmdldCwgcHJvcHMsIHJlc3BvbnNlU3RhdGUsIHRleHRFbWJlZGRlZCwgaW5zZXJ0aW9uTW9kZSwgbm9zY3JpcHRUYWdJblNjb3BlKSB7XG4gIHtcbiAgICBpZiAoaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHwgbm9zY3JpcHRUYWdJblNjb3BlIHx8IHByb3BzLml0ZW1Qcm9wICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBwdXNoU2VsZkNsb3NpbmcodGFyZ2V0LCBwcm9wcywgJ21ldGEnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRleHRFbWJlZGRlZCkge1xuICAgICAgICAvLyBUaGlzIGxpbmsgZm9sbG93cyB0ZXh0IGJ1dCB3ZSBhcmVuJ3Qgd3JpdGluZyBhIHRhZy4gd2hpbGUgbm90IGFzIGVmZmljaWVudCBhcyBwb3NzaWJsZSB3ZSBuZWVkXG4gICAgICAgIC8vIHRvIGJlIHNhZmUgYW5kIGFzc3VtZSB0ZXh0IHdpbGwgZm9sbG93IGJ5IGluc2VydGluZyBhIHRleHRTZXBhcmF0b3JcbiAgICAgICAgdGFyZ2V0LnB1c2godGV4dFNlcGFyYXRvcik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgcHJvcHMuY2hhclNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHB1c2hTZWxmQ2xvc2luZyhyZXNwb25zZVN0YXRlLmNoYXJzZXRDaHVua3MsIHByb3BzLCAnbWV0YScpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wcy5uYW1lID09PSAndmlld3BvcnQnKSB7XG4gICAgICAgIC8vIFwidmlld3BvcnRcIiBpc24ndCByZWxhdGVkIHRvIHByZWNvbm5lY3QgYnV0IGl0IGhhcyB0aGUgcmlnaHQgcHJpb3JpdHlcbiAgICAgICAgcmV0dXJuIHB1c2hTZWxmQ2xvc2luZyhyZXNwb25zZVN0YXRlLnByZWNvbm5lY3RDaHVua3MsIHByb3BzLCAnbWV0YScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHB1c2hTZWxmQ2xvc2luZyhyZXNwb25zZVN0YXRlLmhvaXN0YWJsZUNodW5rcywgcHJvcHMsICdtZXRhJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hMaW5rKHRhcmdldCwgcHJvcHMsIHJlc3BvbnNlU3RhdGUsIHJlc291cmNlcywgdGV4dEVtYmVkZGVkLCBpbnNlcnRpb25Nb2RlLCBub3NjcmlwdFRhZ0luU2NvcGUpIHtcbiAge1xuICAgIHZhciByZWwgPSBwcm9wcy5yZWw7XG4gICAgdmFyIGhyZWYgPSBwcm9wcy5ocmVmO1xuICAgIHZhciBwcmVjZWRlbmNlID0gcHJvcHMucHJlY2VkZW5jZTtcblxuICAgIGlmIChpbnNlcnRpb25Nb2RlID09PSBTVkdfTU9ERSB8fCBub3NjcmlwdFRhZ0luU2NvcGUgfHwgcHJvcHMuaXRlbVByb3AgIT0gbnVsbCB8fCB0eXBlb2YgcmVsICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgaHJlZiAhPT0gJ3N0cmluZycgfHwgaHJlZiA9PT0gJycpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKHJlbCA9PT0gJ3N0eWxlc2hlZXQnICYmIHR5cGVvZiBwcm9wcy5wcmVjZWRlbmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmICh0eXBlb2YgaHJlZiAhPT0gJ3N0cmluZycgfHwgIWhyZWYpIHtcbiAgICAgICAgICAgIGVycm9yKCdSZWFjdCBlbmNvdW50ZXJlZCBhIGA8bGluayByZWw9XCJzdHlsZXNoZWV0XCIgLi4uLz5gIHdpdGggYSBgcHJlY2VkZW5jZWAgcHJvcCBhbmQgZXhwZWN0ZWQgdGhlIGBocmVmYCBwcm9wIHRvIGJlIGEgbm9uLWVtcHR5IHN0cmluZyBidXQgZWNvdW50ZXJlZCAlcyBpbnN0ZWFkLiBJZiB5b3VyIGludGVudCB3YXMgdG8gaGF2ZSBSZWFjdCBob2lzdCBhbmQgZGVkdXBsY2lhdGUgdGhpcyBzdHlsZXNoZWV0IHVzaW5nIHRoZSBgcHJlY2VkZW5jZWAgcHJvcCBlbnN1cmUgdGhlcmUgaXMgYSBub24tZW1wdHkgc3RyaW5nIGBocmVmYCBwcm9wIGFzIHdlbGwsIG90aGVyd2lzZSByZW1vdmUgdGhlIGBwcmVjZWRlbmNlYCBwcm9wLicsIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcoaHJlZikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwdXNoTGlua0ltcGwodGFyZ2V0LCBwcm9wcyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMucmVsID09PSAnc3R5bGVzaGVldCcpIHtcbiAgICAgIC8vIFRoaXMgPGxpbms+IG1heSBob2lzdGFibGUgYXMgYSBTdHlsZXNoZWV0IFJlc291cmNlLCBvdGhlcndpc2UgaXQgd2lsbCBlbWl0IGluIHBsYWNlXG4gICAgICB2YXIga2V5ID0gZ2V0UmVzb3VyY2VLZXkoJ3N0eWxlJywgaHJlZik7XG5cbiAgICAgIGlmICh0eXBlb2YgcHJlY2VkZW5jZSAhPT0gJ3N0cmluZycgfHwgcHJvcHMuZGlzYWJsZWQgIT0gbnVsbCB8fCBwcm9wcy5vbkxvYWQgfHwgcHJvcHMub25FcnJvcikge1xuICAgICAgICAvLyBUaGlzIHN0eWxlc2hlZXQgaXMgZWl0aGVyIG5vdCBvcHRlZCBpbnRvIFJlc291cmNlIHNlbWFudGljcyBvciBoYXMgY29uZmxpY3RpbmcgcHJvcGVydGllcyB3aGljaFxuICAgICAgICAvLyBkaXNxdWFsaWZ5IGl0IGZvciBzdWNoLiBXZSBjYW4gc3RpbGwgY3JlYXRlIGEgcHJlbG9hZCByZXNvdXJjZSB0byBoZWxwIGl0IGxvYWQgZmFzdGVyIG9uIHRoZVxuICAgICAgICAvLyBjbGllbnRcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0eXBlb2YgcHJlY2VkZW5jZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChwcm9wcy5kaXNhYmxlZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGVycm9yKCdSZWFjdCBlbmNvdW50ZXJlZCBhIGA8bGluayByZWw9XCJzdHlsZXNoZWV0XCIgLi4uLz5gIHdpdGggYSBgcHJlY2VkZW5jZWAgcHJvcCBhbmQgYSBgZGlzYWJsZWRgIHByb3AuIFRoZSBwcmVzZW5jZSBvZiB0aGUgYGRpc2FibGVkYCBwcm9wIGluZGljYXRlcyBhbiBpbnRlbnQgdG8gbWFuYWdlIHRoZSBzdHlsZXNoZWV0IGFjdGl2ZSBzdGF0ZSBmcm9tIHlvdXIgZnJvbSB5b3VyIENvbXBvbmVudCBjb2RlIGFuZCBSZWFjdCB3aWxsIG5vdCBob2lzdCBvciBkZWR1cGxpY2F0ZSB0aGlzIHN0eWxlc2hlZXQuIElmIHlvdXIgaW50ZW50IHdhcyB0byBoYXZlIFJlYWN0IGhvaXN0IGFuZCBkZWR1cGxjaWF0ZSB0aGlzIHN0eWxlc2hlZXQgdXNpbmcgdGhlIGBwcmVjZWRlbmNlYCBwcm9wIHJlbW92ZSB0aGUgYGRpc2FibGVkYCBwcm9wLCBvdGhlcndpc2UgcmVtb3ZlIHRoZSBgcHJlY2VkZW5jZWAgcHJvcC4nKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcHMub25Mb2FkIHx8IHByb3BzLm9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BEZXNjcmlwdGlvbiA9IHByb3BzLm9uTG9hZCAmJiBwcm9wcy5vbkVycm9yID8gJ2BvbkxvYWRgIGFuZCBgb25FcnJvcmAgcHJvcHMnIDogcHJvcHMub25Mb2FkID8gJ2BvbkxvYWRgIHByb3AnIDogJ2BvbkVycm9yYCBwcm9wJztcblxuICAgICAgICAgICAgICBlcnJvcignUmVhY3QgZW5jb3VudGVyZWQgYSBgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIC4uLi8+YCB3aXRoIGEgYHByZWNlZGVuY2VgIHByb3AgYW5kICVzLiBUaGUgcHJlc2VuY2Ugb2YgbG9hZGluZyBhbmQgZXJyb3IgaGFuZGxlcnMgaW5kaWNhdGVzIGFuIGludGVudCB0byBtYW5hZ2UgdGhlIHN0eWxlc2hlZXQgbG9hZGluZyBzdGF0ZSBmcm9tIHlvdXIgZnJvbSB5b3VyIENvbXBvbmVudCBjb2RlIGFuZCBSZWFjdCB3aWxsIG5vdCBob2lzdCBvciBkZWR1cGxpY2F0ZSB0aGlzIHN0eWxlc2hlZXQuIElmIHlvdXIgaW50ZW50IHdhcyB0byBoYXZlIFJlYWN0IGhvaXN0IGFuZCBkZWR1cGxjaWF0ZSB0aGlzIHN0eWxlc2hlZXQgdXNpbmcgdGhlIGBwcmVjZWRlbmNlYCBwcm9wIHJlbW92ZSB0aGUgJXMsIG90aGVyd2lzZSByZW1vdmUgdGhlIGBwcmVjZWRlbmNlYCBwcm9wLicsIHByb3BEZXNjcmlwdGlvbiwgcHJvcERlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHVzaExpbmtJbXBsKHRhcmdldCwgcHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBzdHlsZXNoZWV0IHJlZmVycyB0byBhIFJlc291cmNlIGFuZCB3ZSBjcmVhdGUgYSBuZXcgb25lIGlmIG5lY2Vzc2FyeVxuICAgICAgICB2YXIgcmVzb3VyY2UgPSByZXNvdXJjZXMuc3R5bGVzTWFwLmdldChrZXkpO1xuXG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZGV2UmVzb3VyY2UgPSBnZXRBc1Jlc291cmNlREVWKHJlc291cmNlKTtcblxuICAgICAgICAgIGlmIChkZXZSZXNvdXJjZSkge1xuICAgICAgICAgICAgc3dpdGNoIChkZXZSZXNvdXJjZS5fX3Byb3ZlbmFuY2UpIHtcbiAgICAgICAgICAgICAgY2FzZSAncmVuZGVyZWQnOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHZhciBkaWZmZXJlbmNlRGVzY3JpcHRpb24gPSBkZXNjcmliZURpZmZlcmVuY2VzRm9yU3R5bGVzaGVldHMoIC8vIERpZmYgdGhlIHByb3BzIGZyb20gdGhlIEpTWCBlbGVtZW50LCBub3QgdGhlIGRlcml2ZWQgcmVzb3VyY2UgcHJvcHNcbiAgICAgICAgICAgICAgICAgIHByb3BzLCBkZXZSZXNvdXJjZS5fX29yaWdpbmFsUHJvcHMpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoZGlmZmVyZW5jZURlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKCdSZWFjdCBlbmNvdW50ZXJlZCBhIDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiBocmVmPVwiJXNcIiAuLi4vPiB3aXRoIGEgYHByZWNlZGVuY2VgIHByb3AgdGhhdCBoYXMgcHJvcHMgdGhhdCBjb25mbGljdCcgKyAnIHdpdGggYW5vdGhlciBob2lzdGFibGUgc3R5bGVzaGVldCB3aXRoIHRoZSBzYW1lIGBocmVmYC4gV2hlbiB1c2luZyBgcHJlY2VkZW5jZWAgd2l0aCA8bGluayByZWw9XCJzdHlsc2hlZXRcIiAuLi4vPicgKyAnIHRoZSBwcm9wcyBmcm9tIHRoZSBmaXJzdCBlbmNvdW50ZXJlZCBpbnN0YW5jZSB3aWxsIGJlIHVzZWQgYW5kIHByb3BzIGZyb20gbGF0ZXIgaW5zdGFuY2VzIHdpbGwgYmUgaWdub3JlZC4nICsgJyBVcGRhdGUgdGhlIHByb3BzIG9uIGVpdGhlciA8bGluayByZWw9XCJzdHlsZXNoZWV0XCIgLi4uLz4gaW5zdGFuY2Ugc28gdGhleSBhZ3JlZS4lcycsIGhyZWYsIGRpZmZlcmVuY2VEZXNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjYXNlICdwcmVpbml0JzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2RpZmZlcmVuY2VEZXNjcmlwdGlvbiA9IGRlc2NyaWJlRGlmZmVyZW5jZXNGb3JTdHlsZXNoZWV0T3ZlclByZWluaXQoIC8vIERpZmYgdGhlIHByb3BzIGZyb20gdGhlIEpTWCBlbGVtZW50LCBub3QgdGhlIGRlcml2ZWQgcmVzb3VyY2UgcHJvcHNcbiAgICAgICAgICAgICAgICAgIHByb3BzLCBkZXZSZXNvdXJjZS5fX3Byb3BzRXF1aXZhbGVudCk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChfZGlmZmVyZW5jZURlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKCdSZWFjdCBlbmNvdW50ZXJlZCBhIDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiBwcmVjZWRlbmNlPVwiJXNcIiBocmVmPVwiJXNcIiAuLi4vPiB3aXRoIHByb3BzIHRoYXQgY29uZmxpY3QnICsgJyB3aXRoIHRoZSBvcHRpb25zIHByb3ZpZGVkIHRvIGBSZWFjdERPTS5wcmVpbml0KFwiJXNcIiwgeyBhczogXCJzdHlsZVwiLCAuLi4gfSlgLiBSZWFjdCB3aWxsIHVzZSB0aGUgZmlyc3QgcHJvcHMgb3IgcHJlaW5pdGlhbGl6YXRpb24nICsgJyBvcHRpb25zIGVuY291bnRlcmVkIHdoZW4gcmVuZGVyaW5nIGEgaG9pc3RhYmxlIHN0eWxlc2hlZXQgd2l0aCBhIHBhcnRpY3VsYXIgYGhyZWZgIGFuZCB3aWxsIGlnbm9yZSBhbnkgbmV3ZXIgcHJvcHMgb3InICsgJyBvcHRpb25zLiBUaGUgZmlyc3QgaW5zdGFuY2Ugb2YgdGhpcyBzdHlsZXNoZWV0IHJlc291cmNlIHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBgUmVhY3RET00ucHJlaW5pdCgpYCBmdW5jdGlvbi4nICsgJyBQbGVhc2Ugbm90ZSwgYFJlYWN0RE9NLnByZWluaXQoKWAgaXMgbW9kZWxlZCBvZmYgb2YgbW9kdWxlIGltcG9ydCBhc3NlcnRpb25zIGNhcGFiaWxpdGllcyBhbmQgZG9lcyBub3Qgc3VwcG9ydCcgKyAnIGFyYml0cmFyeSBwcm9wcy4gSWYgeW91IG5lZWQgdG8gaGF2ZSBwcm9wcyBub3QgaW5jbHVkZWQgd2l0aCB0aGUgcHJlaW5pdCBvcHRpb25zIHlvdSB3aWxsIG5lZWQgdG8gcmVseSBvbiByZW5kZXJpbmcnICsgJyA8bGluaz4gdGFncyBvbmx5LiVzJywgcHJlY2VkZW5jZSwgaHJlZiwgaHJlZiwgX2RpZmZlcmVuY2VEZXNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlc291cmNlKSB7XG4gICAgICAgICAgdmFyIHJlc291cmNlUHJvcHMgPSBzdHlsZXNoZWV0UHJvcHNGcm9tUmF3UHJvcHMocHJvcHMpO1xuICAgICAgICAgIHZhciBwcmVsb2FkUmVzb3VyY2UgPSByZXNvdXJjZXMucHJlbG9hZHNNYXAuZ2V0KGtleSk7XG4gICAgICAgICAgdmFyIHN0YXRlID0gTm9TdGF0ZTtcblxuICAgICAgICAgIGlmIChwcmVsb2FkUmVzb3VyY2UpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGFscmVhZHkgaGFkIGEgcHJlbG9hZCB3ZSBkb24ndCB3YW50IHRoYXQgcmVzb3VyY2UgdG8gZmx1c2ggZGlyZWN0bHkuXG4gICAgICAgICAgICAvLyBXZSBsZXQgdGhlIG5ld2x5IGNyZWF0ZWQgcmVzb3VyY2UgZ292ZXJuIGZsdXNoaW5nLlxuICAgICAgICAgICAgcHJlbG9hZFJlc291cmNlLnN0YXRlIHw9IEJsb2NrZWQ7XG4gICAgICAgICAgICBhZG9wdFByZWxvYWRQcm9wc0ZvclN0eWxlc2hlZXRQcm9wcyhyZXNvdXJjZVByb3BzLCBwcmVsb2FkUmVzb3VyY2UucHJvcHMpO1xuXG4gICAgICAgICAgICBpZiAocHJlbG9hZFJlc291cmNlLnN0YXRlICYgRmx1c2hlZCkge1xuICAgICAgICAgICAgICBzdGF0ZSA9IFByZWxvYWRGbHVzaGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc291cmNlID0ge1xuICAgICAgICAgICAgdHlwZTogJ3N0eWxlc2hlZXQnLFxuICAgICAgICAgICAgY2h1bmtzOiBbXSxcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgIHByb3BzOiByZXNvdXJjZVByb3BzXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXNvdXJjZXMuc3R5bGVzTWFwLnNldChrZXksIHJlc291cmNlKTtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1hcmtBc1JlbmRlcmVkUmVzb3VyY2VERVYocmVzb3VyY2UsIHByb3BzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcHJlY2VkZW5jZVNldCA9IHJlc291cmNlcy5wcmVjZWRlbmNlcy5nZXQocHJlY2VkZW5jZSk7XG5cbiAgICAgICAgICBpZiAoIXByZWNlZGVuY2VTZXQpIHtcbiAgICAgICAgICAgIHByZWNlZGVuY2VTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICByZXNvdXJjZXMucHJlY2VkZW5jZXMuc2V0KHByZWNlZGVuY2UsIHByZWNlZGVuY2VTZXQpO1xuICAgICAgICAgICAgdmFyIGVtcHR5U3R5bGVSZXNvdXJjZSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogJ3N0eWxlJyxcbiAgICAgICAgICAgICAgY2h1bmtzOiBbXSxcbiAgICAgICAgICAgICAgc3RhdGU6IE5vU3RhdGUsXG4gICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogcHJlY2VkZW5jZSxcbiAgICAgICAgICAgICAgICBocmVmczogW11cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByZWNlZGVuY2VTZXQuYWRkKGVtcHR5U3R5bGVSZXNvdXJjZSk7XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKHJlc291cmNlcy5zdHlsZVByZWNlZGVuY2VzLmhhcyhwcmVjZWRlbmNlKSkge1xuICAgICAgICAgICAgICAgIGVycm9yKCdSZWFjdCBjb25zdHJ1Y3RlZCBhbiBlbXB0eSBzdHlsZSByZXNvdXJjZSB3aGVuIGEgc3R5bGUgcmVzb3VyY2UgYWxyZWFkeSBleGlzdHMgZm9yIHRoaXMgcHJlY2VkZW5jZTogXCIlc1wiLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicsIHByZWNlZGVuY2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc291cmNlcy5zdHlsZVByZWNlZGVuY2VzLnNldChwcmVjZWRlbmNlLCBlbXB0eVN0eWxlUmVzb3VyY2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHByZWNlZGVuY2VTZXQuYWRkKHJlc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXNvdXJjZXMuYm91bmRhcnlSZXNvdXJjZXMpIHtcbiAgICAgICAgICByZXNvdXJjZXMuYm91bmRhcnlSZXNvdXJjZXMuYWRkKHJlc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0RW1iZWRkZWQpIHtcbiAgICAgICAgICAvLyBUaGlzIGxpbmsgZm9sbG93cyB0ZXh0IGJ1dCB3ZSBhcmVuJ3Qgd3JpdGluZyBhIHRhZy4gd2hpbGUgbm90IGFzIGVmZmljaWVudCBhcyBwb3NzaWJsZSB3ZSBuZWVkXG4gICAgICAgICAgLy8gdG8gYmUgc2FmZSBhbmQgYXNzdW1lIHRleHQgd2lsbCBmb2xsb3cgYnkgaW5zZXJ0aW5nIGEgdGV4dFNlcGFyYXRvclxuICAgICAgICAgIHRhcmdldC5wdXNoKHRleHRTZXBhcmF0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wcy5vbkxvYWQgfHwgcHJvcHMub25FcnJvcikge1xuICAgICAgLy8gV2hlbiB1c2luZyBsb2FkIGhhbmRsZXJzIHdlIGNhbm5vdCBob2lzdCBhbmQgbmVlZCB0byBlbWl0IGxpbmtzIGluIHBsYWNlXG4gICAgICByZXR1cm4gcHVzaExpbmtJbXBsKHRhcmdldCwgcHJvcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBjYW4gaG9pc3QgdGhpcyBsaW5rIHNvIHdlIG1heSBuZWVkIHRvIGVtaXQgYSB0ZXh0IHNlcGFyYXRvci5cbiAgICAgIC8vIEBUT0RPIHJlZmFjdG9yIHRleHQgc2VwYXJhdG9ycyBzbyB3ZSBkb24ndCBoYXZlIHRvIGRlZmVuc2l2ZWx5IGFkZFxuICAgICAgLy8gdGhlbSB3aGVuIHdlIGRvbid0IGVuZCB1cCBlbWl0dGluZyBhIHRhZyBhcyBhIHJlc3VsdCBvZiBwdXNoU3RhcnRJbnN0YW5jZVxuICAgICAgaWYgKHRleHRFbWJlZGRlZCkge1xuICAgICAgICAvLyBUaGlzIGxpbmsgZm9sbG93cyB0ZXh0IGJ1dCB3ZSBhcmVuJ3Qgd3JpdGluZyBhIHRhZy4gd2hpbGUgbm90IGFzIGVmZmljaWVudCBhcyBwb3NzaWJsZSB3ZSBuZWVkXG4gICAgICAgIC8vIHRvIGJlIHNhZmUgYW5kIGFzc3VtZSB0ZXh0IHdpbGwgZm9sbG93IGJ5IGluc2VydGluZyBhIHRleHRTZXBhcmF0b3JcbiAgICAgICAgdGFyZ2V0LnB1c2godGV4dFNlcGFyYXRvcik7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcHMucmVsKSB7XG4gICAgICAgIGNhc2UgJ3ByZWNvbm5lY3QnOlxuICAgICAgICBjYXNlICdkbnMtcHJlZmV0Y2gnOlxuICAgICAgICAgIHJldHVybiBwdXNoTGlua0ltcGwocmVzcG9uc2VTdGF0ZS5wcmVjb25uZWN0Q2h1bmtzLCBwcm9wcyk7XG5cbiAgICAgICAgY2FzZSAncHJlbG9hZCc6XG4gICAgICAgICAgcmV0dXJuIHB1c2hMaW5rSW1wbChyZXNwb25zZVN0YXRlLnByZWxvYWRDaHVua3MsIHByb3BzKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBwdXNoTGlua0ltcGwocmVzcG9uc2VTdGF0ZS5ob2lzdGFibGVDaHVua3MsIHByb3BzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaExpbmtJbXBsKHRhcmdldCwgcHJvcHMpIHtcbiAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZygnbGluaycpKTtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbGluaycgKyBcIiBpcyBhIHNlbGYtY2xvc2luZyB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIFwiICsgJ3VzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHB1c2hTdHlsZSh0YXJnZXQsIHByb3BzLCByZXNvdXJjZXMsIHRleHRFbWJlZGRlZCwgaW5zZXJ0aW9uTW9kZSwgbm9zY3JpcHRUYWdJblNjb3BlKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgJ2NoaWxkcmVuJykpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICAgICAgdmFyIGNoaWxkID0gQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbi5sZW5ndGggPCAyID8gY2hpbGRyZW5bMF0gOiBudWxsIDogY2hpbGRyZW47XG5cbiAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGNoaWxkID09PSAnc3ltYm9sJyB8fCBBcnJheS5pc0FycmF5KGNoaWxkKSkge1xuICAgICAgICB2YXIgY2hpbGRUeXBlID0gdHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nID8gJ2EgRnVuY3Rpb24nIDogdHlwZW9mIGNoaWxkID09PSAnc3ltYm9sJyA/ICdhIFN5Ym1vbCcgOiAnYW4gQXJyYXknO1xuXG4gICAgICAgIGVycm9yKCdSZWFjdCBleHBlY3QgY2hpbGRyZW4gb2YgPHN0eWxlPiB0YWdzIHRvIGJlIGEgc3RyaW5nLCBudW1iZXIsIG9yIG9iamVjdCB3aXRoIGEgYHRvU3RyaW5nYCBtZXRob2QgYnV0IGZvdW5kICVzIGluc3RlYWQuICcgKyAnSW4gYnJvd3NlcnMgc3R5bGUgRWxlbWVudHMgY2FuIG9ubHkgaGF2ZSBgVGV4dGAgTm9kZXMgYXMgY2hpbGRyZW4uJywgY2hpbGRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgdmFyIHByZWNlZGVuY2UgPSBwcm9wcy5wcmVjZWRlbmNlO1xuICAgIHZhciBocmVmID0gcHJvcHMuaHJlZjtcblxuICAgIGlmIChpbnNlcnRpb25Nb2RlID09PSBTVkdfTU9ERSB8fCBub3NjcmlwdFRhZ0luU2NvcGUgfHwgcHJvcHMuaXRlbVByb3AgIT0gbnVsbCB8fCB0eXBlb2YgcHJlY2VkZW5jZSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGhyZWYgIT09ICdzdHJpbmcnIHx8IGhyZWYgPT09ICcnKSB7XG4gICAgICAvLyBUaGlzIHN0eWxlIHRhZyBpcyBub3QgYWJsZSB0byBiZSB0dXJuZWQgaW50byBhIFN0eWxlIFJlc291cmNlXG4gICAgICByZXR1cm4gcHVzaFN0eWxlSW1wbCh0YXJnZXQsIHByb3BzKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAoaHJlZi5pbmNsdWRlcygnICcpKSB7XG4gICAgICAgIGVycm9yKCdSZWFjdCBleHBlY3RlZCB0aGUgYGhyZWZgIHByb3AgZm9yIGEgPHN0eWxlPiB0YWcgb3B0aW5nIGludG8gaG9pc3Rpbmcgc2VtYW50aWNzIHVzaW5nIHRoZSBgcHJlY2VkZW5jZWAgcHJvcCB0byBub3QgaGF2ZSBhbnkgc3BhY2VzIGJ1dCBlY291bnRlcmVkIHNwYWNlcyBpbnN0ZWFkLiB1c2luZyBzcGFjZXMgaW4gdGhpcyBwcm9wIHdpbGwgY2F1c2UgaHlkcmF0aW9uIG9mIHRoaXMgc3R5bGUgdG8gZmFpbCBvbiB0aGUgY2xpZW50LiBUaGUgaHJlZiBmb3IgdGhlIDxzdHlsZT4gd2hlcmUgdGhpcyBvY3VycmVkIGlzIFwiJXNcIi4nLCBocmVmKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5ID0gZ2V0UmVzb3VyY2VLZXkoJ3N0eWxlJywgaHJlZik7XG4gICAgdmFyIHJlc291cmNlID0gcmVzb3VyY2VzLnN0eWxlc01hcC5nZXQoa2V5KTtcblxuICAgIGlmICghcmVzb3VyY2UpIHtcbiAgICAgIHJlc291cmNlID0gcmVzb3VyY2VzLnN0eWxlUHJlY2VkZW5jZXMuZ2V0KHByZWNlZGVuY2UpO1xuXG4gICAgICBpZiAoIXJlc291cmNlKSB7XG4gICAgICAgIHJlc291cmNlID0ge1xuICAgICAgICAgIHR5cGU6ICdzdHlsZScsXG4gICAgICAgICAgY2h1bmtzOiBbXSxcbiAgICAgICAgICBzdGF0ZTogTm9TdGF0ZSxcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgcHJlY2VkZW5jZTogcHJlY2VkZW5jZSxcbiAgICAgICAgICAgIGhyZWZzOiBbaHJlZl1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJlc291cmNlcy5zdHlsZVByZWNlZGVuY2VzLnNldChwcmVjZWRlbmNlLCByZXNvdXJjZSk7XG4gICAgICAgIHZhciBwcmVjZWRlbmNlU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICBwcmVjZWRlbmNlU2V0LmFkZChyZXNvdXJjZSk7XG5cbiAgICAgICAge1xuICAgICAgICAgIGlmIChyZXNvdXJjZXMucHJlY2VkZW5jZXMuaGFzKHByZWNlZGVuY2UpKSB7XG4gICAgICAgICAgICBlcnJvcignUmVhY3QgY29uc3RydWN0ZWQgYSBuZXcgc3R5bGUgcHJlY2VkZW5jZSBzZXQgd2hlbiBvbmUgYWxyZWFkeSBleGlzdHMgZm9yIHRoaXMgcHJlY2VkZW5jZTogXCIlc1wiLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicsIHByZWNlZGVuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc291cmNlcy5wcmVjZWRlbmNlcy5zZXQocHJlY2VkZW5jZSwgcHJlY2VkZW5jZVNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvdXJjZS5wcm9wcy5ocmVmcy5wdXNoKGhyZWYpO1xuICAgICAgfVxuXG4gICAgICByZXNvdXJjZXMuc3R5bGVzTWFwLnNldChrZXksIHJlc291cmNlKTtcblxuICAgICAgaWYgKHJlc291cmNlcy5ib3VuZGFyeVJlc291cmNlcykge1xuICAgICAgICByZXNvdXJjZXMuYm91bmRhcnlSZXNvdXJjZXMuYWRkKHJlc291cmNlKTtcbiAgICAgIH1cblxuICAgICAgcHVzaFN0eWxlQ29udGVudHMocmVzb3VyY2UuY2h1bmtzLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgaWYgKHRleHRFbWJlZGRlZCkge1xuICAgICAgLy8gVGhpcyBsaW5rIGZvbGxvd3MgdGV4dCBidXQgd2UgYXJlbid0IHdyaXRpbmcgYSB0YWcuIHdoaWxlIG5vdCBhcyBlZmZpY2llbnQgYXMgcG9zc2libGUgd2UgbmVlZFxuICAgICAgLy8gdG8gYmUgc2FmZSBhbmQgYXNzdW1lIHRleHQgd2lsbCBmb2xsb3cgYnkgaW5zZXJ0aW5nIGEgdGV4dFNlcGFyYXRvclxuICAgICAgdGFyZ2V0LnB1c2godGV4dFNlcGFyYXRvcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hTdHlsZUltcGwodGFyZ2V0LCBwcm9wcykge1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKCdzdHlsZScpKTtcbiAgdmFyIGNoaWxkcmVuID0gbnVsbDtcbiAgdmFyIGlubmVySFRNTCA9IG51bGw7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICB2YXIgY2hpbGQgPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuLmxlbmd0aCA8IDIgPyBjaGlsZHJlblswXSA6IG51bGwgOiBjaGlsZHJlbjtcblxuICBpZiAodHlwZW9mIGNoaWxkICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjaGlsZCAhPT0gJ3N5bWJvbCcgJiYgY2hpbGQgIT09IG51bGwgJiYgY2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoJycgKyBjaGlsZCkpKTtcbiAgfVxuXG4gIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcbiAgdGFyZ2V0LnB1c2goZW5kVGFnMSwgc3RyaW5nVG9DaHVuaygnc3R5bGUnKSwgZW5kVGFnMik7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwdXNoU3R5bGVDb250ZW50cyh0YXJnZXQsIHByb3BzKSB7XG4gIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gIHZhciBpbm5lckhUTUwgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoaWxkID0gQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbi5sZW5ndGggPCAyID8gY2hpbGRyZW5bMF0gOiBudWxsIDogY2hpbGRyZW47XG5cbiAgaWYgKHR5cGVvZiBjaGlsZCAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY2hpbGQgIT09ICdzeW1ib2wnICYmIGNoaWxkICE9PSBudWxsICYmIGNoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgICB0YXJnZXQucHVzaChzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKCcnICsgY2hpbGQpKSk7XG4gIH1cblxuICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MLCBjaGlsZHJlbik7XG4gIHJldHVybjtcbn1cblxuZnVuY3Rpb24gZ2V0SW1hZ2VQcmVsb2FkS2V5KGhyZWYsIGltYWdlU3JjU2V0LCBpbWFnZVNpemVzKSB7XG4gIHZhciB1bmlxdWVQYXJ0ID0gJyc7XG5cbiAgaWYgKHR5cGVvZiBpbWFnZVNyY1NldCA9PT0gJ3N0cmluZycgJiYgaW1hZ2VTcmNTZXQgIT09ICcnKSB7XG4gICAgdW5pcXVlUGFydCArPSAnWycgKyBpbWFnZVNyY1NldCArICddJztcblxuICAgIGlmICh0eXBlb2YgaW1hZ2VTaXplcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHVuaXF1ZVBhcnQgKz0gJ1snICsgaW1hZ2VTaXplcyArICddJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdW5pcXVlUGFydCArPSAnW11bXScgKyBocmVmO1xuICB9XG5cbiAgcmV0dXJuIGdldFJlc291cmNlS2V5KCdpbWFnZScsIHVuaXF1ZVBhcnQpO1xufVxuXG5mdW5jdGlvbiBwdXNoSW1nKHRhcmdldCwgcHJvcHMsIHJlc291cmNlcykge1xuICB2YXIgc3JjID0gcHJvcHMuc3JjLFxuICAgICAgc3JjU2V0ID0gcHJvcHMuc3JjU2V0O1xuXG4gIGlmIChwcm9wcy5sb2FkaW5nICE9PSAnbGF6eScgJiYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBzcmNTZXQgPT09ICdzdHJpbmcnKSAmJiBwcm9wcy5mZXRjaFByaW9yaXR5ICE9PSAnbG93JyAmJiAvLyBXZSBleGNsdWRlIGRhdGEgVVJJcyBpbiBzcmMgYW5kIHNyY1NldCBzaW5jZSB0aGVzZSBzaG91bGQgbm90IGJlIHByZWxvYWRlZFxuICAhKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnICYmIHNyY1s0XSA9PT0gJzonICYmIChzcmNbMF0gPT09ICdkJyB8fCBzcmNbMF0gPT09ICdEJykgJiYgKHNyY1sxXSA9PT0gJ2EnIHx8IHNyY1sxXSA9PT0gJ0EnKSAmJiAoc3JjWzJdID09PSAndCcgfHwgc3JjWzJdID09PSAnVCcpICYmIChzcmNbM10gPT09ICdhJyB8fCBzcmNbM10gPT09ICdBJykpICYmICEodHlwZW9mIHNyY1NldCA9PT0gJ3N0cmluZycgJiYgc3JjU2V0WzRdID09PSAnOicgJiYgKHNyY1NldFswXSA9PT0gJ2QnIHx8IHNyY1NldFswXSA9PT0gJ0QnKSAmJiAoc3JjU2V0WzFdID09PSAnYScgfHwgc3JjU2V0WzFdID09PSAnQScpICYmIChzcmNTZXRbMl0gPT09ICd0JyB8fCBzcmNTZXRbMl0gPT09ICdUJykgJiYgKHNyY1NldFszXSA9PT0gJ2EnIHx8IHNyY1NldFszXSA9PT0gJ0EnKSkpIHtcbiAgICAvLyBXZSBoYXZlIGEgc3VzcGVuc2V5IGltYWdlIGFuZCBvdWdodCB0byBwcmVsb2FkIGl0IHRvIG9wdGltaXplIHRoZSBsb2FkaW5nIG9mIGRpc3BsYXkgYmxvY2tpbmdcbiAgICAvLyByZXNvdXJjZXMuXG4gICAgdmFyIHNpemVzID0gcHJvcHMuc2l6ZXM7XG4gICAgdmFyIGtleSA9IGdldEltYWdlUHJlbG9hZEtleShzcmMsIHNyY1NldCwgc2l6ZXMpO1xuICAgIHZhciByZXNvdXJjZSA9IHJlc291cmNlcy5wcmVsb2Fkc01hcC5nZXQoa2V5KTtcblxuICAgIGlmICghcmVzb3VyY2UpIHtcbiAgICAgIHJlc291cmNlID0ge1xuICAgICAgICB0eXBlOiAncHJlbG9hZCcsXG4gICAgICAgIGNodW5rczogW10sXG4gICAgICAgIHN0YXRlOiBOb1N0YXRlLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIHJlbDogJ3ByZWxvYWQnLFxuICAgICAgICAgIGFzOiAnaW1hZ2UnLFxuICAgICAgICAgIC8vIFRoZXJlIGlzIGEgYnVnIGluIFNhZmFyaSB3aGVyZSBpbWFnZVNyY1NldCBpcyBub3QgcmVzcGVjdGVkIG9uIHByZWxvYWQgbGlua3NcbiAgICAgICAgICAvLyBzbyB3ZSBvbWl0IHRoZSBocmVmIGhlcmUgaWYgd2UgaGF2ZSBpbWFnZVNyY1NldCBiL2Mgc2FmYXJpIHdpbGwgbG9hZCB0aGUgd3JvbmcgaW1hZ2UuXG4gICAgICAgICAgLy8gVGhpcyBoYXJtcyBvbGRlciBicm93ZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgaW1hZ2VTcmNTZXQgYnkgbWFraW5nIHRoZWlyIHByZWxvYWRzIG5vdCB3b3JrXG4gICAgICAgICAgLy8gYnV0IHRoaXMgcG9wdWxhdGlvbiBpcyBzaHJpbmtpbmcgZmFzdCBhbmQgaXMgYWxyZWFkeSBzbWFsbCBzbyB3ZSBhY2NlcHQgdGhpcyB0cmFkZW9mZi5cbiAgICAgICAgICBocmVmOiBzcmNTZXQgPyB1bmRlZmluZWQgOiBzcmMsXG4gICAgICAgICAgaW1hZ2VTcmNTZXQ6IHNyY1NldCxcbiAgICAgICAgICBpbWFnZVNpemVzOiBzaXplcyxcbiAgICAgICAgICBjcm9zc09yaWdpbjogcHJvcHMuY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgaW50ZWdyaXR5OiBwcm9wcy5pbnRlZ3JpdHksXG4gICAgICAgICAgdHlwZTogcHJvcHMudHlwZSxcbiAgICAgICAgICBmZXRjaFByaW9yaXR5OiBwcm9wcy5mZXRjaFByaW9yaXR5LFxuICAgICAgICAgIHJlZmVycmVyUG9saWN5OiBwcm9wcy5yZWZlcnJlclBvbGljeVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmVzb3VyY2VzLnByZWxvYWRzTWFwLnNldChrZXksIHJlc291cmNlKTtcblxuICAgICAge1xuICAgICAgICBtYXJrQXNSZW5kZXJlZFJlc291cmNlREVWKHJlc291cmNlLCBwcm9wcyk7XG4gICAgICB9XG5cbiAgICAgIHB1c2hMaW5rSW1wbChyZXNvdXJjZS5jaHVua3MsIHJlc291cmNlLnByb3BzKTtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMuZmV0Y2hQcmlvcml0eSA9PT0gJ2hpZ2gnIHx8IHJlc291cmNlcy5oaWdoSW1hZ2VQcmVsb2Fkcy5zaXplIDwgMTApIHtcbiAgICAgIHJlc291cmNlcy5oaWdoSW1hZ2VQcmVsb2Fkcy5hZGQocmVzb3VyY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvdXJjZXMuYnVsa1ByZWxvYWRzLmFkZChyZXNvdXJjZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHB1c2hTZWxmQ2xvc2luZyh0YXJnZXQsIHByb3BzLCAnaW1nJyk7XG59XG5cbmZ1bmN0aW9uIHB1c2hTZWxmQ2xvc2luZyh0YXJnZXQsIHByb3BzLCB0YWcpIHtcbiAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZyh0YWcpKTtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0YWcgKyBcIiBpcyBhIHNlbGYtY2xvc2luZyB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIFwiICsgJ3VzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHB1c2hTdGFydE1lbnVJdGVtKHRhcmdldCwgcHJvcHMpIHtcbiAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZygnbWVudWl0ZW0nKSk7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21lbnVpdGVtcyBjYW5ub3QgaGF2ZSBgY2hpbGRyZW5gIG5vciBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwdXNoVGl0bGUodGFyZ2V0LCBwcm9wcywgcmVzcG9uc2VTdGF0ZSwgaW5zZXJ0aW9uTW9kZSwgbm9zY3JpcHRUYWdJblNjb3BlKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgJ2NoaWxkcmVuJykpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICAgICAgdmFyIGNoaWxkID0gQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbi5sZW5ndGggPCAyID8gY2hpbGRyZW5bMF0gOiBudWxsIDogY2hpbGRyZW47XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICAgIGVycm9yKCdSZWFjdCBleHBlY3RzIHRoZSBgY2hpbGRyZW5gIHByb3Agb2YgPHRpdGxlPiB0YWdzIHRvIGJlIGEgc3RyaW5nLCBudW1iZXIsIG9yIG9iamVjdCB3aXRoIGEgbm92ZWwgYHRvU3RyaW5nYCBtZXRob2QgYnV0IGZvdW5kIGFuIEFycmF5IHdpdGggbGVuZ3RoICVzIGluc3RlYWQuJyArICcgQnJvd3NlcnMgdHJlYXQgYWxsIGNoaWxkIE5vZGVzIG9mIDx0aXRsZT4gdGFncyBhcyBUZXh0IGNvbnRlbnQgYW5kIFJlYWN0IGV4cGVjdHMgdG8gYmUgYWJsZSB0byBjb252ZXJ0IGBjaGlsZHJlbmAgb2YgPHRpdGxlPiB0YWdzIHRvIGEgc2luZ2xlIHN0cmluZyB2YWx1ZScgKyAnIHdoaWNoIGlzIHdoeSBBcnJheXMgb2YgbGVuZ3RoIGdyZWF0ZXIgdGhhbiAxIGFyZSBub3Qgc3VwcG9ydGVkLiBXaGVuIHVzaW5nIEpTWCBpdCBjYW4gYmUgY29tbW9uZyB0byBjb21iaW5lIHRleHQgbm9kZXMgYW5kIHZhbHVlIG5vZGVzLicgKyAnIEZvciBleGFtcGxlOiA8dGl0bGU+aGVsbG8ge25hbWVPZlVzZXJ9PC90aXRsZT4uIFdoaWxlIG5vdCBpbW1lZGlhdGVseSBhcHBhcmVudCwgYGNoaWxkcmVuYCBpbiB0aGlzIGNhc2UgaXMgYW4gQXJyYXkgd2l0aCBsZW5ndGggMi4gSWYgeW91ciBgY2hpbGRyZW5gIHByb3AnICsgJyBpcyB1c2luZyB0aGlzIGZvcm0gdHJ5IHJld3JpdGluZyBpdCB1c2luZyBhIHRlbXBsYXRlIHN0cmluZzogPHRpdGxlPntgaGVsbG8gJHtuYW1lT2ZVc2VyfWB9PC90aXRsZT4uJywgY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgdmFyIGNoaWxkVHlwZSA9IHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJyA/ICdhIEZ1bmN0aW9uJyA6ICdhIFN5Ym1vbCc7XG5cbiAgICAgICAgZXJyb3IoJ1JlYWN0IGV4cGVjdCBjaGlsZHJlbiBvZiA8dGl0bGU+IHRhZ3MgdG8gYmUgYSBzdHJpbmcsIG51bWJlciwgb3Igb2JqZWN0IHdpdGggYSBub3ZlbCBgdG9TdHJpbmdgIG1ldGhvZCBidXQgZm91bmQgJXMgaW5zdGVhZC4nICsgJyBCcm93c2VycyB0cmVhdCBhbGwgY2hpbGQgTm9kZXMgb2YgPHRpdGxlPiB0YWdzIGFzIFRleHQgY29udGVudCBhbmQgUmVhY3QgZXhwZWN0cyB0byBiZSBhYmxlIHRvIGNvbnZlcnQgY2hpbGRyZW4gb2YgPHRpdGxlPicgKyAnIHRhZ3MgdG8gYSBzaW5nbGUgc3RyaW5nIHZhbHVlLicsIGNoaWxkVHlwZSk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkICYmIGNoaWxkLnRvU3RyaW5nID09PSB7fS50b1N0cmluZykge1xuICAgICAgICBpZiAoY2hpbGQuJCR0eXBlb2YgIT0gbnVsbCkge1xuICAgICAgICAgIGVycm9yKCdSZWFjdCBleHBlY3RzIHRoZSBgY2hpbGRyZW5gIHByb3Agb2YgPHRpdGxlPiB0YWdzIHRvIGJlIGEgc3RyaW5nLCBudW1iZXIsIG9yIG9iamVjdCB3aXRoIGEgbm92ZWwgYHRvU3RyaW5nYCBtZXRob2QgYnV0IGZvdW5kIGFuIG9iamVjdCB0aGF0IGFwcGVhcnMgdG8gYmUnICsgJyBhIFJlYWN0IGVsZW1lbnQgd2hpY2ggbmV2ZXIgaW1wbGVtZW50cyBhIHN1aXRhYmxlIGB0b1N0cmluZ2AgbWV0aG9kLiBCcm93c2VycyB0cmVhdCBhbGwgY2hpbGQgTm9kZXMgb2YgPHRpdGxlPiB0YWdzIGFzIFRleHQgY29udGVudCBhbmQgUmVhY3QgZXhwZWN0cyB0bycgKyAnIGJlIGFibGUgdG8gY29udmVydCBjaGlsZHJlbiBvZiA8dGl0bGU+IHRhZ3MgdG8gYSBzaW5nbGUgc3RyaW5nIHZhbHVlIHdoaWNoIGlzIHdoeSByZW5kZXJpbmcgUmVhY3QgZWxlbWVudHMgaXMgbm90IHN1cHBvcnRlZC4gSWYgdGhlIGBjaGlsZHJlbmAgb2YgPHRpdGxlPiBpcycgKyAnIGEgUmVhY3QgQ29tcG9uZW50IHRyeSBtb3ZpbmcgdGhlIDx0aXRsZT4gdGFnIGludG8gdGhhdCBjb21wb25lbnQuIElmIHRoZSBgY2hpbGRyZW5gIG9mIDx0aXRsZT4gaXMgc29tZSBIVE1MIG1hcmt1cCBjaGFuZ2UgaXQgdG8gYmUgVGV4dCBvbmx5IHRvIGJlIHZhbGlkIEhUTUwuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0IGV4cGVjdHMgdGhlIGBjaGlsZHJlbmAgcHJvcCBvZiA8dGl0bGU+IHRhZ3MgdG8gYmUgYSBzdHJpbmcsIG51bWJlciwgb3Igb2JqZWN0IHdpdGggYSBub3ZlbCBgdG9TdHJpbmdgIG1ldGhvZCBidXQgZm91bmQgYW4gb2JqZWN0IHRoYXQgZG9lcyBub3QgaW1wbGVtZW50JyArICcgYSBzdWl0YWJsZSBgdG9TdHJpbmdgIG1ldGhvZC4gQnJvd3NlcnMgdHJlYXQgYWxsIGNoaWxkIE5vZGVzIG9mIDx0aXRsZT4gdGFncyBhcyBUZXh0IGNvbnRlbnQgYW5kIFJlYWN0IGV4cGVjdHMgdG8gYmUgYWJsZSB0byBjb252ZXJ0IGNoaWxkcmVuIG9mIDx0aXRsZT4gdGFncycgKyAnIHRvIGEgc2luZ2xlIHN0cmluZyB2YWx1ZS4gVXNpbmcgdGhlIGRlZmF1bHQgYHRvU3RyaW5nYCBtZXRob2QgYXZhaWxhYmxlIG9uIGV2ZXJ5IG9iamVjdCBpcyBhbG1vc3QgY2VydGFpbmx5IGFuIGVycm9yLiBDb25zaWRlciB3aGV0aGVyIHRoZSBgY2hpbGRyZW5gIG9mIHRoaXMgPHRpdGxlPicgKyAnIGlzIGFuIG9iamVjdCBpbiBlcnJvciBhbmQgY2hhbmdlIGl0IHRvIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSBpZiBzby4gT3RoZXJ3aXNlIGltcGxlbWVudCBhIGB0b1N0cmluZ2AgbWV0aG9kIHRoYXQgUmVhY3QgY2FuIHVzZSB0byBwcm9kdWNlIGEgdmFsaWQgPHRpdGxlPi4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoaW5zZXJ0aW9uTW9kZSAhPT0gU1ZHX01PREUgJiYgIW5vc2NyaXB0VGFnSW5TY29wZSAmJiBwcm9wcy5pdGVtUHJvcCA9PSBudWxsKSB7XG4gICAgICBwdXNoVGl0bGVJbXBsKHJlc3BvbnNlU3RhdGUuaG9pc3RhYmxlQ2h1bmtzLCBwcm9wcyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHB1c2hUaXRsZUltcGwodGFyZ2V0LCBwcm9wcyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hUaXRsZUltcGwodGFyZ2V0LCBwcm9wcykge1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKCd0aXRsZScpKTtcbiAgdmFyIGNoaWxkcmVuID0gbnVsbDtcbiAgdmFyIGlubmVySFRNTCA9IG51bGw7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICB2YXIgY2hpbGQgPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuLmxlbmd0aCA8IDIgPyBjaGlsZHJlblswXSA6IG51bGwgOiBjaGlsZHJlbjtcblxuICBpZiAodHlwZW9mIGNoaWxkICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjaGlsZCAhPT0gJ3N5bWJvbCcgJiYgY2hpbGQgIT09IG51bGwgJiYgY2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoJycgKyBjaGlsZCkpKTtcbiAgfVxuXG4gIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcbiAgdGFyZ2V0LnB1c2goZW5kVGFnMSwgc3RyaW5nVG9DaHVuaygndGl0bGUnKSwgZW5kVGFnMik7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwdXNoU3RhcnRIZWFkKHRhcmdldCwgcHJvcHMsIHJlc3BvbnNlU3RhdGUsIGluc2VydGlvbk1vZGUpIHtcbiAge1xuICAgIGlmIChpbnNlcnRpb25Nb2RlIDwgSFRNTF9NT0RFICYmIHJlc3BvbnNlU3RhdGUuaGVhZENodW5rcyA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyA8aGVhZD4gaXMgdGhlIERvY3VtZW50LmhlYWQgYW5kIHNob3VsZCBiZSBwYXJ0IG9mIHRoZSBwcmVhbWJsZVxuICAgICAgcmVzcG9uc2VTdGF0ZS5oZWFkQ2h1bmtzID0gW107XG4gICAgICByZXR1cm4gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQocmVzcG9uc2VTdGF0ZS5oZWFkQ2h1bmtzLCBwcm9wcywgJ2hlYWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyA8aGVhZD4gaXMgZGVlcCBhbmQgaXMgbGlrZWx5IGp1c3QgYW4gZXJyb3IuIHdlIGVtaXQgaXQgaW5saW5lIHRob3VnaC5cbiAgICAgIC8vIFZhbGlkYXRpb24gc2hvdWxkIHdhcm4gdGhhdCB0aGlzIHRhZyBpcyB0aGUgdGhlIHdyb25nIHNwb3QuXG4gICAgICByZXR1cm4gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQodGFyZ2V0LCBwcm9wcywgJ2hlYWQnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaFN0YXJ0SHRtbCh0YXJnZXQsIHByb3BzLCByZXNwb25zZVN0YXRlLCBpbnNlcnRpb25Nb2RlKSB7XG4gIHtcbiAgICBpZiAoaW5zZXJ0aW9uTW9kZSA9PT0gUk9PVF9IVE1MX01PREUgJiYgcmVzcG9uc2VTdGF0ZS5odG1sQ2h1bmtzID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIDxodG1sPiBpcyB0aGUgRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IGFuZCBzaG91bGQgYmUgcGFydCBvZiB0aGUgcHJlYW1ibGVcbiAgICAgIHJlc3BvbnNlU3RhdGUuaHRtbENodW5rcyA9IFtET0NUWVBFXTtcbiAgICAgIHJldHVybiBwdXNoU3RhcnRHZW5lcmljRWxlbWVudChyZXNwb25zZVN0YXRlLmh0bWxDaHVua3MsIHByb3BzLCAnaHRtbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIDxodG1sPiBpcyBkZWVwIGFuZCBpcyBsaWtlbHkganVzdCBhbiBlcnJvci4gd2UgZW1pdCBpdCBpbmxpbmUgdGhvdWdoLlxuICAgICAgLy8gVmFsaWRhdGlvbiBzaG91bGQgd2FybiB0aGF0IHRoaXMgdGFnIGlzIHRoZSB0aGUgd3Jvbmcgc3BvdC5cbiAgICAgIHJldHVybiBwdXNoU3RhcnRHZW5lcmljRWxlbWVudCh0YXJnZXQsIHByb3BzLCAnaHRtbCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoU2NyaXB0KHRhcmdldCwgcHJvcHMsIHJlc291cmNlcywgdGV4dEVtYmVkZGVkLCBpbnNlcnRpb25Nb2RlLCBub3NjcmlwdFRhZ0luU2NvcGUpIHtcbiAge1xuICAgIHZhciBhc3luY1Byb3AgPSBwcm9wcy5hc3luYztcblxuICAgIGlmICh0eXBlb2YgcHJvcHMuc3JjICE9PSAnc3RyaW5nJyB8fCAhcHJvcHMuc3JjIHx8ICEoYXN5bmNQcm9wICYmIHR5cGVvZiBhc3luY1Byb3AgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGFzeW5jUHJvcCAhPT0gJ3N5bWJvbCcpIHx8IHByb3BzLm9uTG9hZCB8fCBwcm9wcy5vbkVycm9yIHx8IGluc2VydGlvbk1vZGUgPT09IFNWR19NT0RFIHx8IG5vc2NyaXB0VGFnSW5TY29wZSB8fCBwcm9wcy5pdGVtUHJvcCAhPSBudWxsKSB7XG4gICAgICAvLyBUaGlzIHNjcmlwdCB3aWxsIG5vdCBiZSBhIHJlc291cmNlLCB3ZSBiYWlsb3V0IGVhcmx5IGFuZCBlbWl0IGl0IGluIHBsYWNlLlxuICAgICAgcmV0dXJuIHB1c2hTY3JpcHRJbXBsKHRhcmdldCwgcHJvcHMpO1xuICAgIH1cblxuICAgIHZhciBzcmMgPSBwcm9wcy5zcmM7XG4gICAgdmFyIGtleSA9IGdldFJlc291cmNlS2V5KCdzY3JpcHQnLCBzcmMpOyAvLyBXZSBjYW4gbWFrZSB0aGlzIDxzY3JpcHQ+IGludG8gYSBTY3JpcHRSZXNvdXJjZVxuXG4gICAgdmFyIHJlc291cmNlID0gcmVzb3VyY2VzLnNjcmlwdHNNYXAuZ2V0KGtleSk7XG5cbiAgICB7XG4gICAgICB2YXIgZGV2UmVzb3VyY2UgPSBnZXRBc1Jlc291cmNlREVWKHJlc291cmNlKTtcblxuICAgICAgaWYgKGRldlJlc291cmNlKSB7XG4gICAgICAgIHN3aXRjaCAoZGV2UmVzb3VyY2UuX19wcm92ZW5hbmNlKSB7XG4gICAgICAgICAgY2FzZSAncmVuZGVyZWQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgZGlmZmVyZW5jZURlc2NyaXB0aW9uID0gZGVzY3JpYmVEaWZmZXJlbmNlc0ZvclNjcmlwdHMoIC8vIERpZmYgdGhlIHByb3BzIGZyb20gdGhlIEpTWCBlbGVtZW50LCBub3QgdGhlIGRlcml2ZWQgcmVzb3VyY2UgcHJvcHNcbiAgICAgICAgICAgICAgcHJvcHMsIGRldlJlc291cmNlLl9fb3JpZ2luYWxQcm9wcyk7XG5cbiAgICAgICAgICAgICAgaWYgKGRpZmZlcmVuY2VEZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIGVycm9yKCdSZWFjdCBlbmNvdW50ZXJlZCBhIDxzY3JpcHQgYXN5bmM9e3RydWV9IHNyYz1cIiVzXCIgLi4uLz4gdGhhdCBoYXMgcHJvcHMgdGhhdCBjb25mbGljdCcgKyAnIHdpdGggYW5vdGhlciBob2lzdGFibGUgc2NyaXB0IHdpdGggdGhlIHNhbWUgYHNyY2AuIFdoZW4gcmVuZGVyaW5nIGhvaXN0YWJsZSBzY3JpcHRzIChhc3luYyBzY3JpcHRzIHdpdGhvdXQgYW55IGxvYWRpbmcgaGFuZGxlcnMpJyArICcgdGhlIHByb3BzIGZyb20gdGhlIGZpcnN0IGVuY291bnRlcmVkIGluc3RhbmNlIHdpbGwgYmUgdXNlZCBhbmQgcHJvcHMgZnJvbSBsYXRlciBpbnN0YW5jZXMgd2lsbCBiZSBpZ25vcmVkLicgKyAnIFVwZGF0ZSB0aGUgcHJvcHMgb24gYm90aCA8c2NyaXB0IGFzeW5jPXt0cnVlfSAuLi4vPiBpbnN0YW5jZSBzbyB0aGV5IGFncmVlLiVzJywgc3JjLCBkaWZmZXJlbmNlRGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdwcmVpbml0JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIF9kaWZmZXJlbmNlRGVzY3JpcHRpb24yID0gZGVzY3JpYmVEaWZmZXJlbmNlc0ZvclNjcmlwdE92ZXJQcmVpbml0KCAvLyBEaWZmIHRoZSBwcm9wcyBmcm9tIHRoZSBKU1ggZWxlbWVudCwgbm90IHRoZSBkZXJpdmVkIHJlc291cmNlIHByb3BzXG4gICAgICAgICAgICAgIHByb3BzLCBkZXZSZXNvdXJjZS5fX3Byb3BzRXF1aXZhbGVudCk7XG5cbiAgICAgICAgICAgICAgaWYgKF9kaWZmZXJlbmNlRGVzY3JpcHRpb24yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoJ1JlYWN0IGVuY291bnRlcmVkIGEgPHNjcmlwdCBhc3luYz17dHJ1ZX0gc3JjPVwiJXNcIiAuLi4vPiB3aXRoIHByb3BzIHRoYXQgY29uZmxpY3QnICsgJyB3aXRoIHRoZSBvcHRpb25zIHByb3ZpZGVkIHRvIGBSZWFjdERPTS5wcmVpbml0KFwiJXNcIiwgeyBhczogXCJzY3JpcHRcIiwgLi4uIH0pYC4gUmVhY3Qgd2lsbCB1c2UgdGhlIGZpcnN0IHByb3BzIG9yIHByZWluaXRpYWxpemF0aW9uJyArICcgb3B0aW9ucyBlbmNvdW50ZXJlZCB3aGVuIHJlbmRlcmluZyBhIGhvaXN0YWJsZSBzY3JpcHQgd2l0aCBhIHBhcnRpY3VsYXIgYHNyY2AgYW5kIHdpbGwgaWdub3JlIGFueSBuZXdlciBwcm9wcyBvcicgKyAnIG9wdGlvbnMuIFRoZSBmaXJzdCBpbnN0YW5jZSBvZiB0aGlzIHNjcmlwdCByZXNvdXJjZSB3YXMgY3JlYXRlZCB1c2luZyB0aGUgYFJlYWN0RE9NLnByZWluaXQoKWAgZnVuY3Rpb24uJyArICcgUGxlYXNlIG5vdGUsIGBSZWFjdERPTS5wcmVpbml0KClgIGlzIG1vZGVsZWQgb2ZmIG9mIG1vZHVsZSBpbXBvcnQgYXNzZXJ0aW9ucyBjYXBhYmlsaXRpZXMgYW5kIGRvZXMgbm90IHN1cHBvcnQnICsgJyBhcmJpdHJhcnkgcHJvcHMuIElmIHlvdSBuZWVkIHRvIGhhdmUgcHJvcHMgbm90IGluY2x1ZGVkIHdpdGggdGhlIHByZWluaXQgb3B0aW9ucyB5b3Ugd2lsbCBuZWVkIHRvIHJlbHkgb24gcmVuZGVyaW5nJyArICcgPHNjcmlwdD4gdGFncyBvbmx5LiVzJywgc3JjLCBzcmMsIF9kaWZmZXJlbmNlRGVzY3JpcHRpb24yKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFyZXNvdXJjZSkge1xuICAgICAgcmVzb3VyY2UgPSB7XG4gICAgICAgIHR5cGU6ICdzY3JpcHQnLFxuICAgICAgICBjaHVua3M6IFtdLFxuICAgICAgICBzdGF0ZTogTm9TdGF0ZSxcbiAgICAgICAgcHJvcHM6IG51bGxcbiAgICAgIH07XG4gICAgICByZXNvdXJjZXMuc2NyaXB0c01hcC5zZXQoa2V5LCByZXNvdXJjZSk7XG5cbiAgICAgIHtcbiAgICAgICAgbWFya0FzUmVuZGVyZWRSZXNvdXJjZURFVihyZXNvdXJjZSwgcHJvcHMpO1xuICAgICAgfSAvLyBBZGQgdG8gdGhlIHNjcmlwdCBmbHVzaGluZyBxdWV1ZVxuXG5cbiAgICAgIHJlc291cmNlcy5zY3JpcHRzLmFkZChyZXNvdXJjZSk7XG4gICAgICB2YXIgc2NyaXB0UHJvcHMgPSBwcm9wcztcbiAgICAgIHZhciBwcmVsb2FkUmVzb3VyY2UgPSByZXNvdXJjZXMucHJlbG9hZHNNYXAuZ2V0KGtleSk7XG5cbiAgICAgIGlmIChwcmVsb2FkUmVzb3VyY2UpIHtcbiAgICAgICAgLy8gSWYgd2UgYWxyZWFkeSBoYWQgYSBwcmVsb2FkIHdlIGRvbid0IHdhbnQgdGhhdCByZXNvdXJjZSB0byBmbHVzaCBkaXJlY3RseS5cbiAgICAgICAgLy8gV2UgbGV0IHRoZSBuZXdseSBjcmVhdGVkIHJlc291cmNlIGdvdmVybiBmbHVzaGluZy5cbiAgICAgICAgcHJlbG9hZFJlc291cmNlLnN0YXRlIHw9IEJsb2NrZWQ7XG4gICAgICAgIHNjcmlwdFByb3BzID0gYXNzaWduKHt9LCBwcm9wcyk7XG4gICAgICAgIGFkb3B0UHJlbG9hZFByb3BzRm9yU2NyaXB0UHJvcHMoc2NyaXB0UHJvcHMsIHByZWxvYWRSZXNvdXJjZS5wcm9wcyk7XG4gICAgICB9IC8vIGVuY29kZSB0aGUgdGFnIGFzIENodW5rc1xuXG5cbiAgICAgIHB1c2hTY3JpcHRJbXBsKHJlc291cmNlLmNodW5rcywgc2NyaXB0UHJvcHMpO1xuICAgIH1cblxuICAgIGlmICh0ZXh0RW1iZWRkZWQpIHtcbiAgICAgIC8vIFRoaXMgc2NyaXB0IGZvbGxvd3MgdGV4dCBidXQgd2UgYXJlbid0IHdyaXRpbmcgYSB0YWcuIHdoaWxlIG5vdCBhcyBlZmZpY2llbnQgYXMgcG9zc2libGUgd2UgbmVlZFxuICAgICAgLy8gdG8gYmUgc2FmZSBhbmQgYXNzdW1lIHRleHQgd2lsbCBmb2xsb3cgYnkgaW5zZXJ0aW5nIGEgdGV4dFNlcGFyYXRvclxuICAgICAgdGFyZ2V0LnB1c2godGV4dFNlcGFyYXRvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaFNjcmlwdEltcGwodGFyZ2V0LCBwcm9wcykge1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKCdzY3JpcHQnKSk7XG4gIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gIHZhciBpbm5lckhUTUwgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcblxuICB7XG4gICAgaWYgKGNoaWxkcmVuICE9IG51bGwgJiYgdHlwZW9mIGNoaWxkcmVuICE9PSAnc3RyaW5nJykge1xuICAgICAgdmFyIGRlc2NyaXB0aXZlU3RhdGVtZW50ID0gdHlwZW9mIGNoaWxkcmVuID09PSAnbnVtYmVyJyA/ICdhIG51bWJlciBmb3IgY2hpbGRyZW4nIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyAnYW4gYXJyYXkgZm9yIGNoaWxkcmVuJyA6ICdzb21ldGhpbmcgdW5leHBlY3RlZCBmb3IgY2hpbGRyZW4nO1xuXG4gICAgICBlcnJvcignQSBzY3JpcHQgZWxlbWVudCB3YXMgcmVuZGVyZWQgd2l0aCAlcy4gSWYgc2NyaXB0IGVsZW1lbnQgaGFzIGNoaWxkcmVuIGl0IG11c3QgYmUgYSBzaW5nbGUgc3RyaW5nLicgKyAnIENvbnNpZGVyIHVzaW5nIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIG9yIHBhc3NpbmcgYSBwbGFpbiBzdHJpbmcgYXMgY2hpbGRyZW4uJywgZGVzY3JpcHRpdmVTdGF0ZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcblxuICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJykge1xuICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoZW5jb2RlSFRNTFRleHROb2RlKGNoaWxkcmVuKSkpO1xuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kVGFnMSwgc3RyaW5nVG9DaHVuaygnc2NyaXB0JyksIGVuZFRhZzIpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQodGFyZ2V0LCBwcm9wcywgdGFnKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcodGFnKSk7XG4gIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gIHZhciBpbm5lckhUTUwgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuXG4gIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlIGNoaWxkcmVuIGFzIGEgc3RyaW5nIHRvIGF2b2lkIHRoZSB1bm5lY2Vzc2FyeSBjb21tZW50LlxuICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIHNwZWNpYWwgY2FzZSBhZnRlciB0aGUgZ2VuZXJhbCBvcHRpbWl6YXRpb24gaXMgaW4gcGxhY2UuXG4gICAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlbmNvZGVIVE1MVGV4dE5vZGUoY2hpbGRyZW4pKSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIHB1c2hTdGFydEN1c3RvbUVsZW1lbnQodGFyZ2V0LCBwcm9wcywgdGFnKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcodGFnKSk7XG4gIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gIHZhciBpbm5lckhUTUwgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc3R5bGUnOlxuICAgICAgICAgIHB1c2hTdHlsZUF0dHJpYnV0ZSh0YXJnZXQsIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJzpcbiAgICAgICAgY2FzZSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJzpcbiAgICAgICAgICAvLyBJZ25vcmVkLiBUaGVzZSBhcmUgYnVpbHQtaW4gdG8gUmVhY3Qgb24gdGhlIGNsaWVudC5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChpc0F0dHJpYnV0ZU5hbWVTYWZlKHByb3BLZXkpICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuayhwcm9wS2V5KSwgYXR0cmlidXRlQXNzaWduLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHByb3BWYWx1ZSkpLCBhdHRyaWJ1dGVFbmQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MLCBjaGlsZHJlbik7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxudmFyIGxlYWRpbmdOZXdsaW5lID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcXG4nKTtcblxuZnVuY3Rpb24gcHVzaFN0YXJ0UHJlZm9ybWF0dGVkRWxlbWVudCh0YXJnZXQsIHByb3BzLCB0YWcpIHtcbiAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZyh0YWcpKTtcbiAgdmFyIGNoaWxkcmVuID0gbnVsbDtcbiAgdmFyIGlubmVySFRNTCA9IG51bGw7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpOyAvLyB0ZXh0L2h0bWwgaWdub3JlcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZXNlIHRhZ3MgaWYgaXQncyBhIG5ld2xpbmVcbiAgLy8gUHJlZmVyIHRvIGJyZWFrIGFwcGxpY2F0aW9uL3htbCBvdmVyIHRleHQvaHRtbCAoZm9yIG5vdykgYnkgYWRkaW5nXG4gIC8vIGEgbmV3bGluZSBzcGVjaWZpY2FsbHkgdG8gZ2V0IGVhdGVuIGJ5IHRoZSBwYXJzZXIuIChBbHRlcm5hdGVseSBmb3JcbiAgLy8gdGV4dGFyZWFzLCByZXBsYWNpbmcgXCJeXFxuXCIgd2l0aCBcIlxcclxcblwiIGRvZXNuJ3QgZ2V0IGVhdGVuLCBhbmQgdGhlIGZpcnN0XG4gIC8vIFxcciBpcyBub3JtYWxpemVkIG91dCBieSBIVE1MVGV4dEFyZWFFbGVtZW50I3ZhbHVlLilcbiAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbC1wb2x5Z2xvdC8jbmV3bGluZXMtaW4tdGV4dGFyZWEtYW5kLXByZT5cbiAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjZWxlbWVudC1yZXN0cmljdGlvbnM+XG4gIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI25ld2xpbmVzPlxuICAvLyBTZWU6IFBhcnNpbmcgb2YgXCJ0ZXh0YXJlYVwiIFwibGlzdGluZ1wiIGFuZCBcInByZVwiIGVsZW1lbnRzXG4gIC8vICBmcm9tIDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5PlxuICAvLyBUT0RPOiBUaGlzIGRvZXNuJ3QgZGVhbCB3aXRoIHRoZSBjYXNlIHdoZXJlIHRoZSBjaGlsZCBpcyBhbiBhcnJheVxuICAvLyBvciBjb21wb25lbnQgdGhhdCByZXR1cm5zIGEgc3RyaW5nLlxuXG4gIGlmIChpbm5lckhUTUwgIT0gbnVsbCkge1xuICAgIGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5uZXJIVE1MICE9PSAnb2JqZWN0JyB8fCAhKCdfX2h0bWwnIGluIGlubmVySFRNTCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gJyArICdQbGVhc2UgdmlzaXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Rhbmdlcm91c2x5LXNldC1pbm5lci1odG1sICcgKyAnZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgfVxuXG4gICAgdmFyIGh0bWwgPSBpbm5lckhUTUwuX19odG1sO1xuXG4gICAgaWYgKGh0bWwgIT09IG51bGwgJiYgaHRtbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIGh0bWwgPT09ICdzdHJpbmcnICYmIGh0bWwubGVuZ3RoID4gMCAmJiBodG1sWzBdID09PSAnXFxuJykge1xuICAgICAgICB0YXJnZXQucHVzaChsZWFkaW5nTmV3bGluZSwgc3RyaW5nVG9DaHVuayhodG1sKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oaHRtbCk7XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXQucHVzaChzdHJpbmdUb0NodW5rKCcnICsgaHRtbCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnICYmIGNoaWxkcmVuWzBdID09PSAnXFxuJykge1xuICAgIHRhcmdldC5wdXNoKGxlYWRpbmdOZXdsaW5lKTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlbjtcbn0gLy8gV2UgYWNjZXB0IGFueSB0YWcgdG8gYmUgcmVuZGVyZWQgYnV0IHNpbmNlIHRoaXMgZ2V0cyBpbmplY3RlZCBpbnRvIGFyYml0cmFyeVxuLy8gSFRNTCwgd2Ugd2FudCB0byBtYWtlIHN1cmUgdGhhdCBpdCdzIGEgc2FmZSB0YWcuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMteG1sLyNOVC1OYW1lXG5cblxudmFyIFZBTElEX1RBR19SRUdFWCA9IC9eW2EtekEtWl1bYS16QS1aOl9cXC5cXC1cXGRdKiQvOyAvLyBTaW1wbGlmaWVkIHN1YnNldFxuXG52YXIgdmFsaWRhdGVkVGFnQ2FjaGUgPSBuZXcgTWFwKCk7XG5cbmZ1bmN0aW9uIHN0YXJ0Q2h1bmtGb3JUYWcodGFnKSB7XG4gIHZhciB0YWdTdGFydENodW5rID0gdmFsaWRhdGVkVGFnQ2FjaGUuZ2V0KHRhZyk7XG5cbiAgaWYgKHRhZ1N0YXJ0Q2h1bmsgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmICghVkFMSURfVEFHX1JFR0VYLnRlc3QodGFnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0YWc6IFwiICsgdGFnKTtcbiAgICB9XG5cbiAgICB0YWdTdGFydENodW5rID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8JyArIHRhZyk7XG4gICAgdmFsaWRhdGVkVGFnQ2FjaGUuc2V0KHRhZywgdGFnU3RhcnRDaHVuayk7XG4gIH1cblxuICByZXR1cm4gdGFnU3RhcnRDaHVuaztcbn1cblxudmFyIERPQ1RZUEUgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwhRE9DVFlQRSBodG1sPicpO1xuZnVuY3Rpb24gcHVzaFN0YXJ0SW5zdGFuY2UodGFyZ2V0LCB0eXBlLCBwcm9wcywgcmVzb3VyY2VzLCByZXNwb25zZVN0YXRlLCBmb3JtYXRDb250ZXh0LCB0ZXh0RW1iZWRkZWQpIHtcbiAge1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzLCBudWxsKTtcblxuICAgIGlmICghcHJvcHMuc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nICYmIHByb3BzLmNvbnRlbnRFZGl0YWJsZSAmJiBwcm9wcy5jaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICBlcnJvcignQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnICsgJ1JlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mICcgKyAndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcgKyAncHJvYmFibHkgbm90IGludGVudGlvbmFsLicpO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgIT09IFNWR19NT0RFICYmIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSAhPT0gTUFUSE1MX01PREUpIHtcbiAgICAgIGlmICh0eXBlLmluZGV4T2YoJy0nKSA9PT0gLTEgJiYgdHlwZS50b0xvd2VyQ2FzZSgpICE9PSB0eXBlKSB7XG4gICAgICAgIGVycm9yKCc8JXMgLz4gaXMgdXNpbmcgaW5jb3JyZWN0IGNhc2luZy4gJyArICdVc2UgUGFzY2FsQ2FzZSBmb3IgUmVhY3QgY29tcG9uZW50cywgJyArICdvciBsb3dlcmNhc2UgZm9yIEhUTUwgZWxlbWVudHMuJywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnZGl2JzpcbiAgICBjYXNlICdzcGFuJzpcbiAgICBjYXNlICdzdmcnOlxuICAgIGNhc2UgJ3BhdGgnOlxuICAgIGNhc2UgJ2EnOlxuICAgIGNhc2UgJ2cnOlxuICAgIGNhc2UgJ3AnOlxuICAgIGNhc2UgJ2xpJzpcbiAgICAgIC8vIEZhc3QgdHJhY2sgdmVyeSBjb21tb24gdGFnc1xuICAgICAgYnJlYWs7XG4gICAgLy8gU3BlY2lhbCB0YWdzXG5cbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgcmV0dXJuIHB1c2hTdGFydFNlbGVjdCh0YXJnZXQsIHByb3BzKTtcblxuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICByZXR1cm4gcHVzaFN0YXJ0T3B0aW9uKHRhcmdldCwgcHJvcHMsIGZvcm1hdENvbnRleHQpO1xuXG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgcmV0dXJuIHB1c2hTdGFydFRleHRBcmVhKHRhcmdldCwgcHJvcHMpO1xuXG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgcmV0dXJuIHB1c2hJbnB1dCh0YXJnZXQsIHByb3BzLCByZXNwb25zZVN0YXRlKTtcblxuICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICByZXR1cm4gcHVzaFN0YXJ0QnV0dG9uKHRhcmdldCwgcHJvcHMsIHJlc3BvbnNlU3RhdGUpO1xuXG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICByZXR1cm4gcHVzaFN0YXJ0Rm9ybSh0YXJnZXQsIHByb3BzKTtcblxuICAgIGNhc2UgJ21lbnVpdGVtJzpcbiAgICAgIHJldHVybiBwdXNoU3RhcnRNZW51SXRlbSh0YXJnZXQsIHByb3BzKTtcblxuICAgIGNhc2UgJ3RpdGxlJzpcbiAgICAgIHJldHVybiBwdXNoVGl0bGUodGFyZ2V0LCBwcm9wcywgcmVzcG9uc2VTdGF0ZSwgZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlLCBmb3JtYXRDb250ZXh0Lm5vc2NyaXB0VGFnSW5TY29wZSkgO1xuXG4gICAgY2FzZSAnbGluayc6XG4gICAgICByZXR1cm4gcHVzaExpbmsodGFyZ2V0LCBwcm9wcywgcmVzcG9uc2VTdGF0ZSwgcmVzb3VyY2VzLCB0ZXh0RW1iZWRkZWQsIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSwgZm9ybWF0Q29udGV4dC5ub3NjcmlwdFRhZ0luU2NvcGUpO1xuXG4gICAgY2FzZSAnc2NyaXB0JzpcbiAgICAgIHJldHVybiBwdXNoU2NyaXB0KHRhcmdldCwgcHJvcHMsIHJlc291cmNlcywgdGV4dEVtYmVkZGVkLCBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUsIGZvcm1hdENvbnRleHQubm9zY3JpcHRUYWdJblNjb3BlKSA7XG5cbiAgICBjYXNlICdzdHlsZSc6XG4gICAgICByZXR1cm4gcHVzaFN0eWxlKHRhcmdldCwgcHJvcHMsIHJlc291cmNlcywgdGV4dEVtYmVkZGVkLCBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUsIGZvcm1hdENvbnRleHQubm9zY3JpcHRUYWdJblNjb3BlKTtcblxuICAgIGNhc2UgJ21ldGEnOlxuICAgICAgcmV0dXJuIHB1c2hNZXRhKHRhcmdldCwgcHJvcHMsIHJlc3BvbnNlU3RhdGUsIHRleHRFbWJlZGRlZCwgZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlLCBmb3JtYXRDb250ZXh0Lm5vc2NyaXB0VGFnSW5TY29wZSk7XG4gICAgLy8gTmV3bGluZSBlYXRpbmcgdGFnc1xuXG4gICAgY2FzZSAnbGlzdGluZyc6XG4gICAgY2FzZSAncHJlJzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHB1c2hTdGFydFByZWZvcm1hdHRlZEVsZW1lbnQodGFyZ2V0LCBwcm9wcywgdHlwZSk7XG4gICAgICB9XG5cbiAgICBjYXNlICdpbWcnOlxuICAgICAge1xuICAgICAgICByZXR1cm4gcHVzaEltZyh0YXJnZXQsIHByb3BzLCByZXNvdXJjZXMpIDtcbiAgICAgIH1cbiAgICAvLyBPbWl0dGVkIGNsb3NlIHRhZ3NcblxuICAgIGNhc2UgJ2Jhc2UnOlxuICAgIGNhc2UgJ2FyZWEnOlxuICAgIGNhc2UgJ2JyJzpcbiAgICBjYXNlICdjb2wnOlxuICAgIGNhc2UgJ2VtYmVkJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAna2V5Z2VuJzpcbiAgICBjYXNlICdwYXJhbSc6XG4gICAgY2FzZSAnc291cmNlJzpcbiAgICBjYXNlICd0cmFjayc6XG4gICAgY2FzZSAnd2JyJzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHB1c2hTZWxmQ2xvc2luZyh0YXJnZXQsIHByb3BzLCB0eXBlKTtcbiAgICAgIH1cbiAgICAvLyBUaGVzZSBhcmUgcmVzZXJ2ZWQgU1ZHIGFuZCBNYXRoTUwgZWxlbWVudHMsIHRoYXQgYXJlIG5ldmVyIGN1c3RvbSBlbGVtZW50cy5cbiAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL2N1c3RvbS8jY3VzdG9tLWVsZW1lbnRzLWNvcmUtY29uY2VwdHNcblxuICAgIGNhc2UgJ2Fubm90YXRpb24teG1sJzpcbiAgICBjYXNlICdjb2xvci1wcm9maWxlJzpcbiAgICBjYXNlICdmb250LWZhY2UnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1zcmMnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS11cmknOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1mb3JtYXQnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1uYW1lJzpcbiAgICBjYXNlICdtaXNzaW5nLWdseXBoJzpcbiAgICAgIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgLy8gUHJlYW1ibGUgc3RhcnQgdGFnc1xuXG4gICAgY2FzZSAnaGVhZCc6XG4gICAgICByZXR1cm4gcHVzaFN0YXJ0SGVhZCh0YXJnZXQsIHByb3BzLCByZXNwb25zZVN0YXRlLCBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUpO1xuXG4gICAgY2FzZSAnaHRtbCc6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBwdXNoU3RhcnRIdG1sKHRhcmdldCwgcHJvcHMsIHJlc3BvbnNlU3RhdGUsIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSk7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBpZiAodHlwZS5pbmRleE9mKCctJykgIT09IC0xKSB7XG4gICAgICAgICAgLy8gQ3VzdG9tIGVsZW1lbnRcbiAgICAgICAgICByZXR1cm4gcHVzaFN0YXJ0Q3VzdG9tRWxlbWVudCh0YXJnZXQsIHByb3BzLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICB9IC8vIEdlbmVyaWMgZWxlbWVudFxuXG5cbiAgcmV0dXJuIHB1c2hTdGFydEdlbmVyaWNFbGVtZW50KHRhcmdldCwgcHJvcHMsIHR5cGUpO1xufVxudmFyIGVuZFRhZzEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvJyk7XG52YXIgZW5kVGFnMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPicpO1xuZnVuY3Rpb24gcHVzaEVuZEluc3RhbmNlKHRhcmdldCwgdHlwZSwgcHJvcHMsIHJlc3BvbnNlU3RhdGUsIGZvcm1hdENvbnRleHQpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgLy8gV2hlbiBmbG9hdCBpcyBvbiB3ZSBleHBlY3QgdGl0bGUgYW5kIHNjcmlwdCB0YWdzIHRvIGFsd2F5cyBiZSBwdXNoZWQgaW5cbiAgICAvLyBhIHVuaXQgYW5kIG5ldmVyIHJldHVybiBjaGlsZHJlbi4gd2hlbiB3ZSBlbmQgdXAgcHVzaGluZyB0aGUgZW5kIHRhZyB3ZVxuICAgIC8vIHdhbnQgdG8gZW5zdXJlIHRoZXJlIGlzIG5vIGV4dHJhIGNsb3NpbmcgdGFnIHB1c2hlZFxuICAgIGNhc2UgJ3RpdGxlJzpcbiAgICBjYXNlICdzdHlsZSc6XG4gICAgY2FzZSAnc2NyaXB0JzpcbiAgICAvLyBPbWl0dGVkIGNsb3NlIHRhZ3NcbiAgICAvLyBUT0RPOiBJbnN0ZWFkIG9mIHJlcGVhdGluZyB0aGlzIHN3aXRjaCB3ZSBjb3VsZCB0cnkgdG8gcGFzcyBhIGZsYWcgZnJvbSBhYm92ZS5cbiAgICAvLyBUaGF0IHdvdWxkIHJlcXVpcmUgcmV0dXJuaW5nIGEgdHVwbGUuIFdoaWNoIG1pZ2h0IGJlIG9rIGlmIGl0IGdldHMgaW5saW5lZC5cblxuICAgIGNhc2UgJ2FyZWEnOlxuICAgIGNhc2UgJ2Jhc2UnOlxuICAgIGNhc2UgJ2JyJzpcbiAgICBjYXNlICdjb2wnOlxuICAgIGNhc2UgJ2VtYmVkJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaW1nJzpcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgY2FzZSAna2V5Z2VuJzpcbiAgICBjYXNlICdsaW5rJzpcbiAgICBjYXNlICdtZXRhJzpcbiAgICBjYXNlICdwYXJhbSc6XG4gICAgY2FzZSAnc291cmNlJzpcbiAgICBjYXNlICd0cmFjayc6XG4gICAgY2FzZSAnd2JyJzpcbiAgICAgIHtcbiAgICAgICAgLy8gTm8gY2xvc2UgdGFnIG5lZWRlZC5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIC8vIFBvc3RhbWJsZSBlbmQgdGFnc1xuICAgIC8vIFdoZW4gZmxvYXQgaXMgZW5hYmxlZCB3ZSBvbWl0IHRoZSBlbmQgdGFncyBmb3IgYm9keSBhbmQgaHRtbCB3aGVuXG4gICAgLy8gdGhleSByZXByZXNlbnQgdGhlIERvY3VtZW50LmJvZHkgYW5kIERvY3VtZW50LmRvY3VtZW50RWxlbWVudCBOb2Rlcy5cbiAgICAvLyBUaGlzIGlzIHNvIHdlIGNhbiB3aXRoaG9sZCB0aGVtIHVudGlsIHRoZSBwb3N0YW1ibGUgd2hlbiB3ZSBrbm93XG4gICAgLy8gd2Ugd29uJ3QgZW1pdCBhbnkgbW9yZSB0YWdzXG5cbiAgICBjYXNlICdib2R5JzpcbiAgICAgIHtcbiAgICAgICAgaWYgKGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA8PSBIVE1MX0hUTUxfTU9ERSkge1xuICAgICAgICAgIHJlc3BvbnNlU3RhdGUuaGFzQm9keSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdodG1sJzpcbiAgICAgIGlmIChmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgPT09IFJPT1RfSFRNTF9NT0RFKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRUYWcxLCBzdHJpbmdUb0NodW5rKHR5cGUpLCBlbmRUYWcyKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVCb290c3RyYXAoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUpIHtcbiAgdmFyIGJvb3RzdHJhcENodW5rcyA9IHJlc3BvbnNlU3RhdGUuYm9vdHN0cmFwQ2h1bmtzO1xuICB2YXIgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBib290c3RyYXBDaHVua3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYm9vdHN0cmFwQ2h1bmtzW2ldKTtcbiAgfVxuXG4gIGlmIChpIDwgYm9vdHN0cmFwQ2h1bmtzLmxlbmd0aCkge1xuICAgIHZhciBsYXN0Q2h1bmsgPSBib290c3RyYXBDaHVua3NbaV07XG4gICAgYm9vdHN0cmFwQ2h1bmtzLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGxhc3RDaHVuayk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gd3JpdGVDb21wbGV0ZWRSb290KGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlKSB7XG4gIHJldHVybiB3cml0ZUJvb3RzdHJhcChkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZSk7XG59IC8vIFN0cnVjdHVyYWwgTm9kZXNcbi8vIEEgcGxhY2Vob2xkZXIgaXMgYSBub2RlIGluc2lkZSBhIGhpZGRlbiBwYXJ0aWFsIHRyZWUgdGhhdCBjYW4gYmUgZmlsbGVkIGluIGxhdGVyLCBidXQgYmVmb3JlXG4vLyBkaXNwbGF5LiBJdCdzIG5ldmVyIHZpc2libGUgdG8gdXNlcnMuIFdlIHVzZSB0aGUgdGVtcGxhdGUgdGFnIGJlY2F1c2UgaXQgY2FuIGJlIHVzZWQgaW4gZXZlcnlcbi8vIHR5cGUgb2YgcGFyZW50LiA8c2NyaXB0PiB0YWdzIGFsc28gd29yayBpbiBldmVyeSBvdGhlciB0YWcgZXhjZXB0IDxjb2xncm91cD4uXG5cbnZhciBwbGFjZWhvbGRlcjEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0ZW1wbGF0ZSBpZD1cIicpO1xudmFyIHBsYWNlaG9sZGVyMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+PC90ZW1wbGF0ZT4nKTtcbmZ1bmN0aW9uIHdyaXRlUGxhY2Vob2xkZXIoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUsIGlkKSB7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHBsYWNlaG9sZGVyMSk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUucGxhY2Vob2xkZXJQcmVmaXgpO1xuICB2YXIgZm9ybWF0dGVkSUQgPSBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGZvcm1hdHRlZElEKTtcbiAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHBsYWNlaG9sZGVyMik7XG59IC8vIFN1c3BlbnNlIGJvdW5kYXJpZXMgYXJlIGVuY29kZWQgYXMgY29tbWVudHMuXG5cbnZhciBzdGFydENvbXBsZXRlZFN1c3BlbnNlQm91bmRhcnkgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwhLS0kLS0+Jyk7XG52YXIgc3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwhLS0kPy0tPjx0ZW1wbGF0ZSBpZD1cIicpO1xudmFyIHN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj48L3RlbXBsYXRlPicpO1xudmFyIHN0YXJ0Q2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8IS0tJCEtLT4nKTtcbnZhciBlbmRTdXNwZW5zZUJvdW5kYXJ5ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8IS0tLyQtLT4nKTtcbnZhciBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0ZW1wbGF0ZScpO1xudmFyIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yQXR0ckludGVyc3RpdGlhbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCInKTtcbnZhciBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFBID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgZGF0YS1kZ3N0PVwiJyk7XG52YXIgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnIGRhdGEtbXNnPVwiJyk7XG52YXIgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnIGRhdGEtc3Rjaz1cIicpO1xudmFyIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPjwvdGVtcGxhdGU+Jyk7XG5mdW5jdGlvbiB3cml0ZVN0YXJ0Q29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZSkge1xuICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5KTtcbn1cbmZ1bmN0aW9uIHdyaXRlU3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZSwgaWQpIHtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTEpO1xuXG4gIGlmIChpZCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQW4gSUQgbXVzdCBoYXZlIGJlZW4gYXNzaWduZWQgYmVmb3JlIHdlIGNhbiBjb21wbGV0ZSB0aGUgYm91bmRhcnkuJyk7XG4gIH1cblxuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBpZCk7XG4gIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5Mik7XG59XG5mdW5jdGlvbiB3cml0ZVN0YXJ0Q2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlLCBlcnJvckRpZ2VzdCwgZXJyb3JNZXNzc2FnZSwgZXJyb3JDb21wb25lbnRTdGFjaykge1xuICB2YXIgcmVzdWx0O1xuICByZXN1bHQgPSB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMSk7XG5cbiAgaWYgKGVycm9yRGlnZXN0KSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQSk7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihlcnJvckRpZ2VzdCkpKTtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWwpO1xuICB9XG5cbiAge1xuICAgIGlmIChlcnJvck1lc3NzYWdlKSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFCKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoZXJyb3JNZXNzc2FnZSkpKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yQXR0ckludGVyc3RpdGlhbCk7XG4gICAgfVxuXG4gICAgaWYgKGVycm9yQ29tcG9uZW50U3RhY2spIHtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUMpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihlcnJvckNvbXBvbmVudFN0YWNrKSkpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3JBdHRySW50ZXJzdGl0aWFsKTtcbiAgICB9XG4gIH1cblxuICByZXN1bHQgPSB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gd3JpdGVFbmRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlKSB7XG4gIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTdXNwZW5zZUJvdW5kYXJ5KTtcbn1cbmZ1bmN0aW9uIHdyaXRlRW5kUGVuZGluZ1N1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUpIHtcbiAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFN1c3BlbnNlQm91bmRhcnkpO1xufVxuZnVuY3Rpb24gd3JpdGVFbmRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUpIHtcbiAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFN1c3BlbnNlQm91bmRhcnkpO1xufVxudmFyIHN0YXJ0U2VnbWVudEhUTUwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxkaXYgaGlkZGVuIGlkPVwiJyk7XG52YXIgc3RhcnRTZWdtZW50SFRNTDIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpO1xudmFyIGVuZFNlZ21lbnRIVE1MID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L2Rpdj4nKTtcbnZhciBzdGFydFNlZ21lbnRTVkcgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmVcIiBpZD1cIicpO1xudmFyIHN0YXJ0U2VnbWVudFNWRzIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpO1xudmFyIGVuZFNlZ21lbnRTVkcgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvc3ZnPicpO1xudmFyIHN0YXJ0U2VnbWVudE1hdGhNTCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPG1hdGggYXJpYS1oaWRkZW49XCJ0cnVlXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmVcIiBpZD1cIicpO1xudmFyIHN0YXJ0U2VnbWVudE1hdGhNTDIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpO1xudmFyIGVuZFNlZ21lbnRNYXRoTUwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvbWF0aD4nKTtcbnZhciBzdGFydFNlZ21lbnRUYWJsZSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRhYmxlIGhpZGRlbiBpZD1cIicpO1xudmFyIHN0YXJ0U2VnbWVudFRhYmxlMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+Jyk7XG52YXIgZW5kU2VnbWVudFRhYmxlID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L3RhYmxlPicpO1xudmFyIHN0YXJ0U2VnbWVudFRhYmxlQm9keSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRhYmxlIGhpZGRlbj48dGJvZHkgaWQ9XCInKTtcbnZhciBzdGFydFNlZ21lbnRUYWJsZUJvZHkyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj4nKTtcbnZhciBlbmRTZWdtZW50VGFibGVCb2R5ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L3Rib2R5PjwvdGFibGU+Jyk7XG52YXIgc3RhcnRTZWdtZW50VGFibGVSb3cgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0YWJsZSBoaWRkZW4+PHRyIGlkPVwiJyk7XG52YXIgc3RhcnRTZWdtZW50VGFibGVSb3cyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj4nKTtcbnZhciBlbmRTZWdtZW50VGFibGVSb3cgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvdHI+PC90YWJsZT4nKTtcbnZhciBzdGFydFNlZ21lbnRDb2xHcm91cCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRhYmxlIGhpZGRlbj48Y29sZ3JvdXAgaWQ9XCInKTtcbnZhciBzdGFydFNlZ21lbnRDb2xHcm91cDIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpO1xudmFyIGVuZFNlZ21lbnRDb2xHcm91cCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPC9jb2xncm91cD48L3RhYmxlPicpO1xuZnVuY3Rpb24gd3JpdGVTdGFydFNlZ21lbnQoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUsIGZvcm1hdENvbnRleHQsIGlkKSB7XG4gIHN3aXRjaCAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlKSB7XG4gICAgY2FzZSBST09UX0hUTUxfTU9ERTpcbiAgICBjYXNlIEhUTUxfSFRNTF9NT0RFOlxuICAgIGNhc2UgSFRNTF9NT0RFOlxuICAgICAge1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRIVE1MKTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZS5zZWdtZW50UHJlZml4KTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudEhUTUwyKTtcbiAgICAgIH1cblxuICAgIGNhc2UgU1ZHX01PREU6XG4gICAgICB7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudFNWRyk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUuc2VnbWVudFByZWZpeCk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSk7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRTVkcyKTtcbiAgICAgIH1cblxuICAgIGNhc2UgTUFUSE1MX01PREU6XG4gICAgICB7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudE1hdGhNTCk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUuc2VnbWVudFByZWZpeCk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSk7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRNYXRoTUwyKTtcbiAgICAgIH1cblxuICAgIGNhc2UgSFRNTF9UQUJMRV9NT0RFOlxuICAgICAge1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRUYWJsZSk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUuc2VnbWVudFByZWZpeCk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSk7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRUYWJsZTIpO1xuICAgICAgfVxuICAgIC8vIFRPRE86IEZvciB0aGUgcmVzdCBvZiB0aGVzZSwgdGhlcmUgd2lsbCBiZSBleHRyYSB3cmFwcGVyIG5vZGVzIHRoYXQgbmV2ZXJcbiAgICAvLyBnZXQgZGVsZXRlZCBmcm9tIHRoZSBkb2N1bWVudC4gV2UgbmVlZCB0byBkZWxldGUgdGhlIHRhYmxlIHRvbyBhcyBwYXJ0XG4gICAgLy8gb2YgdGhlIGluamVjdGVkIHNjcmlwdHMuIFRoZXkgYXJlIGludmlzaWJsZSB0aG91Z2ggc28gaXQncyBub3QgdG9vIHRlcnJpYmxlXG4gICAgLy8gYW5kIGl0J3Mga2luZCBvZiBhbiBlZGdlIGNhc2UgdG8gc3VzcGVuZCBpbiBhIHRhYmxlLiBUb3RhbGx5IHN1cHBvcnRlZCB0aG91Z2guXG5cbiAgICBjYXNlIEhUTUxfVEFCTEVfQk9EWV9NT0RFOlxuICAgICAge1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRUYWJsZUJvZHkpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlLnNlZ21lbnRQcmVmaXgpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSkpO1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50VGFibGVCb2R5Mik7XG4gICAgICB9XG5cbiAgICBjYXNlIEhUTUxfVEFCTEVfUk9XX01PREU6XG4gICAgICB7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudFRhYmxlUm93KTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZS5zZWdtZW50UHJlZml4KTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudFRhYmxlUm93Mik7XG4gICAgICB9XG5cbiAgICBjYXNlIEhUTUxfQ09MR1JPVVBfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50Q29sR3JvdXApO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlLnNlZ21lbnRQcmVmaXgpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSkpO1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50Q29sR3JvdXAyKTtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBpbnNlcnRpb24gbW9kZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gd3JpdGVFbmRTZWdtZW50KGRlc3RpbmF0aW9uLCBmb3JtYXRDb250ZXh0KSB7XG4gIHN3aXRjaCAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlKSB7XG4gICAgY2FzZSBST09UX0hUTUxfTU9ERTpcbiAgICBjYXNlIEhUTUxfSFRNTF9NT0RFOlxuICAgIGNhc2UgSFRNTF9NT0RFOlxuICAgICAge1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU2VnbWVudEhUTUwpO1xuICAgICAgfVxuXG4gICAgY2FzZSBTVkdfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRTVkcpO1xuICAgICAgfVxuXG4gICAgY2FzZSBNQVRITUxfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRNYXRoTUwpO1xuICAgICAgfVxuXG4gICAgY2FzZSBIVE1MX1RBQkxFX01PREU6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTZWdtZW50VGFibGUpO1xuICAgICAgfVxuXG4gICAgY2FzZSBIVE1MX1RBQkxFX0JPRFlfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRUYWJsZUJvZHkpO1xuICAgICAgfVxuXG4gICAgY2FzZSBIVE1MX1RBQkxFX1JPV19NT0RFOlxuICAgICAge1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU2VnbWVudFRhYmxlUm93KTtcbiAgICAgIH1cblxuICAgIGNhc2UgSFRNTF9DT0xHUk9VUF9NT0RFOlxuICAgICAge1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU2VnbWVudENvbEdyb3VwKTtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBpbnNlcnRpb24gbW9kZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cbiAgfVxufVxudmFyIGNvbXBsZXRlU2VnbWVudFNjcmlwdDFGdWxsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGNvbXBsZXRlU2VnbWVudCArICc7JFJTKFwiJyk7XG52YXIgY29tcGxldGVTZWdtZW50U2NyaXB0MVBhcnRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyRSUyhcIicpO1xudmFyIGNvbXBsZXRlU2VnbWVudFNjcmlwdDIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiLFwiJyk7XG52YXIgY29tcGxldGVTZWdtZW50U2NyaXB0RW5kID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIik8L3NjcmlwdD4nKTtcbnZhciBjb21wbGV0ZVNlZ21lbnREYXRhMSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRlbXBsYXRlIGRhdGEtcnNpPVwiXCIgZGF0YS1zaWQ9XCInKTtcbnZhciBjb21wbGV0ZVNlZ21lbnREYXRhMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1waWQ9XCInKTtcbnZhciBjb21wbGV0ZVNlZ21lbnREYXRhRW5kID0gZGF0YUVsZW1lbnRRdW90ZWRFbmQ7XG5mdW5jdGlvbiB3cml0ZUNvbXBsZXRlZFNlZ21lbnRJbnN0cnVjdGlvbihkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZSwgY29udGVudFNlZ21lbnRJRCkge1xuICB2YXIgc2NyaXB0Rm9ybWF0ID0gcmVzcG9uc2VTdGF0ZS5zdHJlYW1pbmdGb3JtYXQgPT09IFNjcmlwdFN0cmVhbWluZ0Zvcm1hdDtcblxuICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZS5zdGFydElubGluZVNjcmlwdCk7XG5cbiAgICBpZiAoKHJlc3BvbnNlU3RhdGUuaW5zdHJ1Y3Rpb25zICYgU2VudENvbXBsZXRlU2VnbWVudEZ1bmN0aW9uKSA9PT0gTm90aGluZ1NlbnQpIHtcbiAgICAgIC8vIFRoZSBmaXJzdCB0aW1lIHdlIHdyaXRlIHRoaXMsIHdlJ2xsIG5lZWQgdG8gaW5jbHVkZSB0aGUgZnVsbCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHJlc3BvbnNlU3RhdGUuaW5zdHJ1Y3Rpb25zIHw9IFNlbnRDb21wbGV0ZVNlZ21lbnRGdW5jdGlvbjtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlU2VnbWVudFNjcmlwdDFGdWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRnV0dXJlIGNhbGxzIGNhbiBqdXN0IHJldXNlIHRoZSBzYW1lIGZ1bmN0aW9uLlxuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVTZWdtZW50U2NyaXB0MVBhcnRpYWwpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZVNlZ21lbnREYXRhMSk7XG4gIH0gLy8gV3JpdGUgZnVuY3Rpb24gYXJndW1lbnRzLCB3aGljaCBhcmUgc3RyaW5nIGxpdGVyYWxzXG5cblxuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlLnNlZ21lbnRQcmVmaXgpO1xuICB2YXIgZm9ybWF0dGVkSUQgPSBzdHJpbmdUb0NodW5rKGNvbnRlbnRTZWdtZW50SUQudG9TdHJpbmcoMTYpKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgZm9ybWF0dGVkSUQpO1xuXG4gIGlmIChzY3JpcHRGb3JtYXQpIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZVNlZ21lbnRTY3JpcHQyKTtcbiAgfSBlbHNlIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZVNlZ21lbnREYXRhMik7XG4gIH1cblxuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlLnBsYWNlaG9sZGVyUHJlZml4KTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgZm9ybWF0dGVkSUQpO1xuXG4gIGlmIChzY3JpcHRGb3JtYXQpIHtcbiAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY29tcGxldGVTZWdtZW50U2NyaXB0RW5kKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY29tcGxldGVTZWdtZW50RGF0YUVuZCk7XG4gIH1cbn1cbnZhciBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MUZ1bGwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoY29tcGxldGVCb3VuZGFyeSArICckUkMoXCInKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MVBhcnRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyRSQyhcIicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MUZ1bGxCb3RoID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGNvbXBsZXRlQm91bmRhcnkgKyBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlcyArICckUlIoXCInKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFGdWxsUGFydGlhbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlcyArICckUlIoXCInKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFQYXJ0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCckUlIoXCInKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIsXCInKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0M2EgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiLCcpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQzYiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCInKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0RW5kID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcpPC9zY3JpcHQ+Jyk7XG52YXIgY29tcGxldGVCb3VuZGFyeURhdGExID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGVtcGxhdGUgZGF0YS1yY2k9XCJcIiBkYXRhLWJpZD1cIicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzRGF0YTEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0ZW1wbGF0ZSBkYXRhLXJyaT1cIlwiIGRhdGEtYmlkPVwiJyk7XG52YXIgY29tcGxldGVCb3VuZGFyeURhdGEyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBkYXRhLXNpZD1cIicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlEYXRhM2EgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGRhdGEtc3R5PVwiJyk7XG52YXIgY29tcGxldGVCb3VuZGFyeURhdGFFbmQgPSBkYXRhRWxlbWVudFF1b3RlZEVuZDtcbmZ1bmN0aW9uIHdyaXRlQ29tcGxldGVkQm91bmRhcnlJbnN0cnVjdGlvbihkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZSwgYm91bmRhcnlJRCwgY29udGVudFNlZ21lbnRJRCwgYm91bmRhcnlSZXNvdXJjZXMpIHtcbiAgdmFyIHJlcXVpcmVzU3R5bGVJbnNlcnRpb247XG5cbiAge1xuICAgIHJlcXVpcmVzU3R5bGVJbnNlcnRpb24gPSByZXNwb25zZVN0YXRlLnN0eWxlc1RvSG9pc3Q7IC8vIElmIG5lY2Vzc2FyeSBzdHlsZXNoZWV0cyB3aWxsIGJlIGZsdXNoZWQgd2l0aCB0aGlzIGluc3RydWN0aW9uLlxuICAgIC8vIEFueSBzdHlsZSB0YWdzIG5vdCB5ZXQgaG9pc3RlZCBpbiB0aGUgRG9jdW1lbnQgd2lsbCBhbHNvIGJlIGhvaXN0ZWQuXG4gICAgLy8gV2UgcmVzZXQgdGhpcyBzdGF0ZSBzaW5jZSBhZnRlciB0aGlzIGluc3RydWN0aW9uIGV4ZWN1dGVzIGFsbCBzdHlsZXNcbiAgICAvLyB1cCB0byB0aGlzIHBvaW50IHdpbGwgaGF2ZSBiZWVuIGhvaXN0ZWRcblxuICAgIHJlc3BvbnNlU3RhdGUuc3R5bGVzVG9Ib2lzdCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIHNjcmlwdEZvcm1hdCA9IHJlc3BvbnNlU3RhdGUuc3RyZWFtaW5nRm9ybWF0ID09PSBTY3JpcHRTdHJlYW1pbmdGb3JtYXQ7XG5cbiAgaWYgKHNjcmlwdEZvcm1hdCkge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUuc3RhcnRJbmxpbmVTY3JpcHQpO1xuXG4gICAgaWYgKHJlcXVpcmVzU3R5bGVJbnNlcnRpb24pIHtcbiAgICAgIGlmICgocmVzcG9uc2VTdGF0ZS5pbnN0cnVjdGlvbnMgJiBTZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uKSA9PT0gTm90aGluZ1NlbnQpIHtcbiAgICAgICAgcmVzcG9uc2VTdGF0ZS5pbnN0cnVjdGlvbnMgfD0gU2VudFN0eWxlSW5zZXJ0aW9uRnVuY3Rpb24gfCBTZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbG9uZVByZWNvbXB1dGVkQ2h1bmsoY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNTY3JpcHQxRnVsbEJvdGgpKTtcbiAgICAgIH0gZWxzZSBpZiAoKHJlc3BvbnNlU3RhdGUuaW5zdHJ1Y3Rpb25zICYgU2VudFN0eWxlSW5zZXJ0aW9uRnVuY3Rpb24pID09PSBOb3RoaW5nU2VudCkge1xuICAgICAgICByZXNwb25zZVN0YXRlLmluc3RydWN0aW9ucyB8PSBTZW50U3R5bGVJbnNlcnRpb25GdW5jdGlvbjtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNTY3JpcHQxRnVsbFBhcnRpYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNTY3JpcHQxUGFydGlhbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgocmVzcG9uc2VTdGF0ZS5pbnN0cnVjdGlvbnMgJiBTZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uKSA9PT0gTm90aGluZ1NlbnQpIHtcbiAgICAgICAgcmVzcG9uc2VTdGF0ZS5pbnN0cnVjdGlvbnMgfD0gU2VudENvbXBsZXRlQm91bmRhcnlGdW5jdGlvbjtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVNjcmlwdDFGdWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQxUGFydGlhbCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChyZXF1aXJlc1N0eWxlSW5zZXJ0aW9uKSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc0RhdGExKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeURhdGExKTtcbiAgICB9XG4gIH1cblxuICBpZiAoYm91bmRhcnlJRCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQW4gSUQgbXVzdCBoYXZlIGJlZW4gYXNzaWduZWQgYmVmb3JlIHdlIGNhbiBjb21wbGV0ZSB0aGUgYm91bmRhcnkuJyk7XG4gIH0gLy8gV3JpdGUgZnVuY3Rpb24gYXJndW1lbnRzLCB3aGljaCBhcmUgc3RyaW5nIGFuZCBhcnJheSBsaXRlcmFsc1xuXG5cbiAgdmFyIGZvcm1hdHRlZENvbnRlbnRJRCA9IHN0cmluZ1RvQ2h1bmsoY29udGVudFNlZ21lbnRJRC50b1N0cmluZygxNikpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBib3VuZGFyeUlEKTtcblxuICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVNjcmlwdDIpO1xuICB9IGVsc2Uge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlEYXRhMik7XG4gIH1cblxuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlLnNlZ21lbnRQcmVmaXgpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBmb3JtYXR0ZWRDb250ZW50SUQpO1xuXG4gIGlmIChyZXF1aXJlc1N0eWxlSW5zZXJ0aW9uKSB7XG4gICAgLy8gU2NyaXB0IGFuZCBkYXRhIHdyaXRlcnMgbXVzdCBmb3JtYXQgdGhpcyBkaWZmZXJlbnRseTpcbiAgICAvLyAgLSBzY3JpcHQgd3JpdGVyIGVtaXRzIGFuIGFycmF5IGxpdGVyYWwsIHdob3NlIHN0cmluZyBlbGVtZW50cyBhcmVcbiAgICAvLyAgICBlc2NhcGVkIGZvciBqYXZhc2NyaXB0ICBlLmcuIFtcIkFcIiwgXCJCXCJdXG4gICAgLy8gIC0gZGF0YSB3cml0ZXIgZW1pdHMgYSBzdHJpbmcgbGl0ZXJhbCwgd2hpY2ggaXMgZXNjYXBlZCBhcyBodG1sXG4gICAgLy8gICAgZS5nLiBbJiMzNDtBJiMzNDssICYjMzQ7QiYjMzQ7XVxuICAgIGlmIChzY3JpcHRGb3JtYXQpIHtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQzYSk7IC8vIGJvdW5kYXJ5UmVzb3VyY2VzIGVuY29kZXMgYW4gYXJyYXkgbGl0ZXJhbFxuXG4gICAgICB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmNpZXNJbkpTKGRlc3RpbmF0aW9uLCBib3VuZGFyeVJlc291cmNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlEYXRhM2EpO1xuICAgICAgd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jaWVzSW5BdHRyKGRlc3RpbmF0aW9uLCBib3VuZGFyeVJlc291cmNlcyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChzY3JpcHRGb3JtYXQpIHtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQzYik7XG4gICAgfVxuICB9XG5cbiAgdmFyIHdyaXRlTW9yZTtcblxuICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgd3JpdGVNb3JlID0gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVNjcmlwdEVuZCk7XG4gIH0gZWxzZSB7XG4gICAgd3JpdGVNb3JlID0gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeURhdGFFbmQpO1xuICB9XG5cbiAgcmV0dXJuIHdyaXRlQm9vdHN0cmFwKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlKSAmJiB3cml0ZU1vcmU7XG59XG52YXIgY2xpZW50UmVuZGVyU2NyaXB0MUZ1bGwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoY2xpZW50UmVuZGVyQm91bmRhcnkgKyAnOyRSWChcIicpO1xudmFyIGNsaWVudFJlbmRlclNjcmlwdDFQYXJ0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCckUlgoXCInKTtcbnZhciBjbGllbnRSZW5kZXJTY3JpcHQxQSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCInKTtcbnZhciBjbGllbnRSZW5kZXJFcnJvclNjcmlwdEFyZ0ludGVyc3RpdGlhbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnLCcpO1xudmFyIGNsaWVudFJlbmRlclNjcmlwdEVuZCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnKTwvc2NyaXB0PicpO1xudmFyIGNsaWVudFJlbmRlckRhdGExID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGVtcGxhdGUgZGF0YS1yeGk9XCJcIiBkYXRhLWJpZD1cIicpO1xudmFyIGNsaWVudFJlbmRlckRhdGEyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBkYXRhLWRnc3Q9XCInKTtcbnZhciBjbGllbnRSZW5kZXJEYXRhMyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1tc2c9XCInKTtcbnZhciBjbGllbnRSZW5kZXJEYXRhNCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1zdGNrPVwiJyk7XG52YXIgY2xpZW50UmVuZGVyRGF0YUVuZCA9IGRhdGFFbGVtZW50UXVvdGVkRW5kO1xuZnVuY3Rpb24gd3JpdGVDbGllbnRSZW5kZXJCb3VuZGFyeUluc3RydWN0aW9uKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlLCBib3VuZGFyeUlELCBlcnJvckRpZ2VzdCwgZXJyb3JNZXNzYWdlLCBlcnJvckNvbXBvbmVudFN0YWNrKSB7XG4gIHZhciBzY3JpcHRGb3JtYXQgPSByZXNwb25zZVN0YXRlLnN0cmVhbWluZ0Zvcm1hdCA9PT0gU2NyaXB0U3RyZWFtaW5nRm9ybWF0O1xuXG4gIGlmIChzY3JpcHRGb3JtYXQpIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlLnN0YXJ0SW5saW5lU2NyaXB0KTtcblxuICAgIGlmICgocmVzcG9uc2VTdGF0ZS5pbnN0cnVjdGlvbnMgJiBTZW50Q2xpZW50UmVuZGVyRnVuY3Rpb24pID09PSBOb3RoaW5nU2VudCkge1xuICAgICAgLy8gVGhlIGZpcnN0IHRpbWUgd2Ugd3JpdGUgdGhpcywgd2UnbGwgbmVlZCB0byBpbmNsdWRlIHRoZSBmdWxsIGltcGxlbWVudGF0aW9uLlxuICAgICAgcmVzcG9uc2VTdGF0ZS5pbnN0cnVjdGlvbnMgfD0gU2VudENsaWVudFJlbmRlckZ1bmN0aW9uO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyU2NyaXB0MUZ1bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGdXR1cmUgY2FsbHMgY2FuIGp1c3QgcmV1c2UgdGhlIHNhbWUgZnVuY3Rpb24uXG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJTY3JpcHQxUGFydGlhbCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIDx0ZW1wbGF0ZSBkYXRhLXJ4aT1cIlwiIGRhdGEtYmlkPVwiXG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyRGF0YTEpO1xuICB9XG5cbiAgaWYgKGJvdW5kYXJ5SUQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIElEIG11c3QgaGF2ZSBiZWVuIGFzc2lnbmVkIGJlZm9yZSB3ZSBjYW4gY29tcGxldGUgdGhlIGJvdW5kYXJ5LicpO1xuICB9XG5cbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYm91bmRhcnlJRCk7XG5cbiAgaWYgKHNjcmlwdEZvcm1hdCkge1xuICAgIC8vIFwiIG5lZWRzIHRvIGJlIGluc2VydGVkIGZvciBzY3JpcHRzLCBzaW5jZSBBcmdJbnRlcnN0aXR1YWwgZG9lcyBub3QgY29udGFpblxuICAgIC8vIGxlYWRpbmcgb3IgdHJhaWxpbmcgcXVvdGVzXG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyU2NyaXB0MUEpO1xuICB9XG5cbiAgaWYgKGVycm9yRGlnZXN0IHx8IGVycm9yTWVzc2FnZSB8fCBlcnJvckNvbXBvbmVudFN0YWNrKSB7XG4gICAgaWYgKHNjcmlwdEZvcm1hdCkge1xuICAgICAgLy8gLFwiSlNPTlN0cmluZ1wiXG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJFcnJvclNjcmlwdEFyZ0ludGVyc3RpdGlhbCk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyhlcnJvckRpZ2VzdCB8fCAnJykpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gXCIgZGF0YS1kZ3N0PVwiSFRNTFN0cmluZ1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyRGF0YTIpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihlcnJvckRpZ2VzdCB8fCAnJykpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZXJyb3JNZXNzYWdlIHx8IGVycm9yQ29tcG9uZW50U3RhY2spIHtcbiAgICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgICAvLyAsXCJKU09OU3RyaW5nXCJcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGVycm9yTWVzc2FnZSB8fCAnJykpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gXCIgZGF0YS1tc2c9XCJIVE1MU3RyaW5nXG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJEYXRhMyk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGVycm9yTWVzc2FnZSB8fCAnJykpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZXJyb3JDb21wb25lbnRTdGFjaykge1xuICAgIC8vICxcIkpTT05TdHJpbmdcIlxuICAgIGlmIChzY3JpcHRGb3JtYXQpIHtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGVycm9yQ29tcG9uZW50U3RhY2spKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFwiIGRhdGEtc3Rjaz1cIkhUTUxTdHJpbmdcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlckRhdGE0KTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoZXJyb3JDb21wb25lbnRTdGFjaykpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgLy8gPjwvc2NyaXB0PlxuICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJTY3JpcHRFbmQpO1xuICB9IGVsc2Uge1xuICAgIC8vIFwiPjwvdGVtcGxhdGU+XG4gICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGNsaWVudFJlbmRlckRhdGFFbmQpO1xuICB9XG59XG52YXIgcmVnZXhGb3JKU1N0cmluZ3NJbkluc3RydWN0aW9uU2NyaXB0cyA9IC9bPFxcdTIwMjhcXHUyMDI5XS9nO1xuXG5mdW5jdGlvbiBlc2NhcGVKU1N0cmluZ3NGb3JJbnN0cnVjdGlvblNjcmlwdHMoaW5wdXQpIHtcbiAgdmFyIGVzY2FwZWQgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gIHJldHVybiBlc2NhcGVkLnJlcGxhY2UocmVnZXhGb3JKU1N0cmluZ3NJbkluc3RydWN0aW9uU2NyaXB0cywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgc3dpdGNoIChtYXRjaCkge1xuICAgICAgLy8gc2FudGl6aW5nIGJyZWFraW5nIG91dCBvZiBzdHJpbmdzIGFuZCBzY3JpcHQgdGFnc1xuICAgICAgY2FzZSAnPCc6XG4gICAgICAgIHJldHVybiBcIlxcXFx1MDAzY1wiO1xuXG4gICAgICBjYXNlIFwiXFx1MjAyOFwiOlxuICAgICAgICByZXR1cm4gXCJcXFxcdTIwMjhcIjtcblxuICAgICAgY2FzZSBcIlxcdTIwMjlcIjpcbiAgICAgICAgcmV0dXJuIFwiXFxcXHUyMDI5XCI7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzIGVuY291bnRlcmVkIGEgbWF0Y2ggaXQgZG9lcyBub3Qga25vdyBob3cgdG8gcmVwbGFjZS4gdGhpcyBtZWFucyB0aGUgbWF0Y2ggcmVnZXggYW5kIHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGFyZSBubyBsb25nZXIgaW4gc3luYy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdCcpO1xuICAgICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxudmFyIHJlZ2V4Rm9ySlNTdHJpbmdzSW5TY3JpcHRzID0gL1smPjxcXHUyMDI4XFx1MjAyOV0vZztcblxuZnVuY3Rpb24gZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMoaW5wdXQpIHtcbiAgdmFyIGVzY2FwZWQgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gIHJldHVybiBlc2NhcGVkLnJlcGxhY2UocmVnZXhGb3JKU1N0cmluZ3NJblNjcmlwdHMsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHN3aXRjaCAobWF0Y2gpIHtcbiAgICAgIC8vIHNhbnRpemluZyBicmVha2luZyBvdXQgb2Ygc3RyaW5ncyBhbmQgc2NyaXB0IHRhZ3NcbiAgICAgIGNhc2UgJyYnOlxuICAgICAgICByZXR1cm4gXCJcXFxcdTAwMjZcIjtcblxuICAgICAgY2FzZSAnPic6XG4gICAgICAgIHJldHVybiBcIlxcXFx1MDAzZVwiO1xuXG4gICAgICBjYXNlICc8JzpcbiAgICAgICAgcmV0dXJuIFwiXFxcXHUwMDNjXCI7XG5cbiAgICAgIGNhc2UgXCJcXHUyMDI4XCI6XG4gICAgICAgIHJldHVybiBcIlxcXFx1MjAyOFwiO1xuXG4gICAgICBjYXNlIFwiXFx1MjAyOVwiOlxuICAgICAgICByZXR1cm4gXCJcXFxcdTIwMjlcIjtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyBlbmNvdW50ZXJlZCBhIG1hdGNoIGl0IGRvZXMgbm90IGtub3cgaG93IHRvIHJlcGxhY2UuIHRoaXMgbWVhbnMgdGhlIG1hdGNoIHJlZ2V4IGFuZCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBhcmUgbm8gbG9uZ2VyIGluIHN5bmMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbnZhciBsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4xID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8c3R5bGUgbWVkaWE9XCJub3QgYWxsXCIgZGF0YS1wcmVjZWRlbmNlPVwiJyk7XG52YXIgbGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1ocmVmPVwiJyk7XG52YXIgbGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+Jyk7XG52YXIgbGF0ZVN0eWxlVGFnVGVtcGxhdGVDbG9zZSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPC9zdHlsZT4nKTsgLy8gVHJhY2tzIHdoZXRoZXIgdGhlIGJvdW5kYXJ5IGN1cnJlbnRseSBmbHVzaGluZyBpcyBmbHVzaGlnbiBzdHlsZSB0YWdzIG9yIGhhcyBhbnlcbi8vIHN0eWxlc2hlZXQgZGVwZW5kZW5jaWVzIG5vdCBmbHVzaGVkIGluIHRoZSBQcmVhbWJsZS5cblxudmFyIGN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5SGFzU3R5bGVzVG9Ib2lzdCA9IGZhbHNlOyAvLyBBY3RzIGFzIGEgcmV0dXJuIHZhbHVlIGZvciB0aGUgZm9yRWFjaCBleGVjdXRpb24gb2Ygc3R5bGUgdGFnIGZsdXNoaW5nLlxuXG52YXIgZGVzdGluYXRpb25IYXNDYXBhY2l0eSA9IHRydWU7XG5cbmZ1bmN0aW9uIGZsdXNoU3R5bGVUYWdzTGF0ZUZvckJvdW5kYXJ5KHJlc291cmNlKSB7XG4gIGlmIChyZXNvdXJjZS50eXBlID09PSAnc3R5bGVzaGVldCcgJiYgKHJlc291cmNlLnN0YXRlICYgRmx1c2hlZEluUHJlYW1ibGUpID09PSBOb1N0YXRlKSB7XG4gICAgY3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlIYXNTdHlsZXNUb0hvaXN0ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChyZXNvdXJjZS50eXBlID09PSAnc3R5bGUnKSB7XG4gICAgdmFyIGNodW5rcyA9IHJlc291cmNlLmNodW5rcztcbiAgICB2YXIgaHJlZnMgPSByZXNvdXJjZS5wcm9wcy5ocmVmcztcbiAgICB2YXIgaSA9IDA7XG5cbiAgICBpZiAoY2h1bmtzLmxlbmd0aCkge1xuICAgICAgd3JpdGVDaHVuayh0aGlzLCBsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4xKTtcbiAgICAgIHdyaXRlQ2h1bmsodGhpcywgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihyZXNvdXJjZS5wcm9wcy5wcmVjZWRlbmNlKSkpO1xuXG4gICAgICBpZiAoaHJlZnMubGVuZ3RoKSB7XG4gICAgICAgIHdyaXRlQ2h1bmsodGhpcywgbGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMik7XG5cbiAgICAgICAgZm9yICg7IGkgPCBocmVmcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICB3cml0ZUNodW5rKHRoaXMsIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoaHJlZnNbaV0pKSk7XG4gICAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBzcGFjZVNlcGFyYXRvcik7XG4gICAgICAgIH1cblxuICAgICAgICB3cml0ZUNodW5rKHRoaXMsIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoaHJlZnNbaV0pKSk7XG4gICAgICB9XG5cbiAgICAgIHdyaXRlQ2h1bmsodGhpcywgbGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMyk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBjaHVua3NbaV0pO1xuICAgICAgfVxuXG4gICAgICBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5ID0gd3JpdGVDaHVua0FuZFJldHVybih0aGlzLCBsYXRlU3R5bGVUYWdUZW1wbGF0ZUNsb3NlKTsgLy8gV2Ugd3JvdGUgc3R5bGUgdGFncyBmb3IgdGhpcyBib3VuZGFyeSBhbmQgd2UgbWF5IG5lZWQgdG8gZW1pdCBhIHNjcmlwdFxuICAgICAgLy8gdG8gaG9pc3QgdGhlbS5cblxuICAgICAgY3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlIYXNTdHlsZXNUb0hvaXN0ID0gdHJ1ZTsgLy8gc3R5bGUgcmVzb3VyY2VzIGNhbiBmbHVzaCBjb250aW51b3VzbHkgc2luY2UgbW9yZSBydWxlcyBtYXkgYmUgd3JpdHRlbiBpbnRvXG4gICAgICAvLyB0aGVtIHdpdGggbmV3IGhyZWZzLiBJbnN0ZWFkIG9mIG1hcmtpbmcgaXQgZmx1c2hlZCwgd2Ugc2ltcGx5IHJlc2V0IHRoZSBjaHVua3NcbiAgICAgIC8vIGFuZCBocmVmc1xuXG4gICAgICBjaHVua3MubGVuZ3RoID0gMDtcbiAgICAgIGhyZWZzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdyaXRlUmVzb3VyY2VzRm9yQm91bmRhcnkoZGVzdGluYXRpb24sIGJvdW5kYXJ5UmVzb3VyY2VzLCByZXNwb25zZVN0YXRlKSB7XG4gIC8vIFJlc2V0IHRoZXNlIG9uIGVhY2ggaW52b2NhdGlvbiwgdGhleSBhcmUgb25seSBzYWZlIHRvIHJlYWQgaW4gdGhpcyBmdW5jdGlvblxuICBjdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeUhhc1N0eWxlc1RvSG9pc3QgPSBmYWxzZTtcbiAgZGVzdGluYXRpb25IYXNDYXBhY2l0eSA9IHRydWU7IC8vIEZsdXNoIGVhY2ggQm91bmRhcnkgcmVzb3VyY2VcblxuICBib3VuZGFyeVJlc291cmNlcy5mb3JFYWNoKGZsdXNoU3R5bGVUYWdzTGF0ZUZvckJvdW5kYXJ5LCBkZXN0aW5hdGlvbik7XG5cbiAgaWYgKGN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5SGFzU3R5bGVzVG9Ib2lzdCkge1xuICAgIHJlc3BvbnNlU3RhdGUuc3R5bGVzVG9Ib2lzdCA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gZGVzdGluYXRpb25IYXNDYXBhY2l0eTtcbn1cblxuZnVuY3Rpb24gZmx1c2hSZXNvdXJjZUluUHJlYW1ibGUocmVzb3VyY2UpIHtcbiAgaWYgKChyZXNvdXJjZS5zdGF0ZSAmIChGbHVzaGVkIHwgQmxvY2tlZCkpID09PSBOb1N0YXRlKSB7XG4gICAgdmFyIGNodW5rcyA9IHJlc291cmNlLmNodW5rcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3cml0ZUNodW5rKHRoaXMsIGNodW5rc1tpXSk7XG4gICAgfVxuXG4gICAgcmVzb3VyY2Uuc3RhdGUgfD0gRmx1c2hlZEluUHJlYW1ibGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hSZXNvdXJjZUxhdGUocmVzb3VyY2UpIHtcbiAgaWYgKChyZXNvdXJjZS5zdGF0ZSAmIChGbHVzaGVkIHwgQmxvY2tlZCkpID09PSBOb1N0YXRlKSB7XG4gICAgdmFyIGNodW5rcyA9IHJlc291cmNlLmNodW5rcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3cml0ZUNodW5rKHRoaXMsIGNodW5rc1tpXSk7XG4gICAgfVxuXG4gICAgcmVzb3VyY2Uuc3RhdGUgfD0gRmx1c2hlZExhdGU7XG4gIH1cbn0gLy8gVGhpcyBtdXN0IGFsd2F5cyBiZSByZWFkIGFmdGVyIGZsdXNoaW5nIHN0eWxlc2hlZXQgc3R5bGVzLiB3ZSBrbm93IHdlIHdpbGwgZW5jb3VudGVyIGEgc3R5bGUgcmVzb3VyY2Vcbi8vIHBlciBwcmVjZWRlbmNlIGFuZCBpdCB3aWxsIGJlIHNldCBiZWZvcmUgcmVhZHkgc28gd2UgY2FzdCB0aGlzIHRvIGF2b2lkIGFuIGV4dHJhIGNoZWNrIGF0IHJ1bnRpbWVcblxuXG52YXIgcHJlY2VkZW5jZVN0eWxlVGFnUmVzb3VyY2UgPSBudWxsOyAvLyBUaGlzIGZsYWdzIGxldCdzIHVzIG9wdCBvdXQgb2YgZmx1c2hpbmcgYSBwbGFjZWhvbGRlciBzdHlsZSB0YWcgdG8gZW1pdCB0aGUgcHJlY2VkZW5jZSBpbiB0aGUgcmlnaHQgb3JkZXIuXG4vLyBJZiBhIHN0eWxlc2hlZXQgd2FzIGZsdXNoZWQgdGhlbiB3ZSBoYXZlIHRoZSBwcmVjZWRlbmNlIG9yZGVyIHByZXNlcnZlZCBhbmQgb25seSBuZWVkIHRvIGVtaXQgPHN0eWxlPiB0YWdzXG4vLyBpZiB0aGVyZSBhcmUgYWN0dWFsIGNodW5rcyB0byBmbHVzaFxuXG52YXIgZGlkRmx1c2hQcmVjZWRlbmNlID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZsdXNoU3R5bGVJblByZWFtYmxlKHJlc291cmNlLCBrZXksIHNldCkge1xuICB2YXIgY2h1bmtzID0gcmVzb3VyY2UuY2h1bmtzO1xuXG4gIGlmIChyZXNvdXJjZS5zdGF0ZSAmIEZsdXNoZWQpIHtcbiAgICAvLyBJbiB0aGVvcnkgdGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuIGJlY2F1c2Ugd2UgY2xlYXIgZnJvbSB0aGVcbiAgICAvLyBTZXQgb24gZmx1c2ggYnV0IHRvIGVuc3VyZSBjb3JyZWN0IHNlbWFudGljcyB3ZSBkb24ndCBlbWl0XG4gICAgLy8gYW55dGhpbmcgaWYgd2UgYXJlIGluIHRoaXMgc3RhdGUuXG4gICAgc2V0LmRlbGV0ZShyZXNvdXJjZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgY2FuIGVtaXQgdGhpcyBzdHlsZSBvciBzdHlsZXNoZWV0IGFzIGlzLlxuICAgIGlmIChyZXNvdXJjZS50eXBlID09PSAnc3R5bGUnKSB7XG4gICAgICBwcmVjZWRlbmNlU3R5bGVUYWdSZXNvdXJjZSA9IHJlc291cmNlO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gV2Ugc3RpbGwgbmVlZCB0byBlbmNvZGUgc3R5bGVzaGVldCBjaHVua3NcbiAgICAvLyBiZWNhdXNlIHVubGlrZSBtb3N0IEhvaXN0YWJsZXMgYW5kIFJlc291cmNlcyB3ZSBkbyBub3QgZWFnZXJseSBlbmNvZGVcbiAgICAvLyB0aGVtIGR1cmluZyByZW5kZXIuIFRoaXMgaXMgYmVjYXVzZSBpZiB3ZSBmbHVzaCBsYXRlIHdlIGhhdmUgdG8gc2VuZCBhXG4gICAgLy8gZGlmZmVyZW50IGVuY29kaW5nIGFuZCB3ZSBkb24ndCB3YW50IHRvIGVuY29kZSBtdWx0aXBsZSB0aW1lc1xuXG5cbiAgICBwdXNoTGlua0ltcGwoY2h1bmtzLCByZXNvdXJjZS5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgd3JpdGVDaHVuayh0aGlzLCBjaHVua3NbaV0pO1xuICAgIH1cblxuICAgIHJlc291cmNlLnN0YXRlIHw9IEZsdXNoZWRJblByZWFtYmxlO1xuICAgIGRpZEZsdXNoUHJlY2VkZW5jZSA9IHRydWU7XG4gIH1cbn1cblxudmFyIHN0eWxlVGFnUmVzb3VyY2VPcGVuMSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHN0eWxlIGRhdGEtcHJlY2VkZW5jZT1cIicpO1xudmFyIHN0eWxlVGFnUmVzb3VyY2VPcGVuMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1ocmVmPVwiJyk7XG52YXIgc3BhY2VTZXBhcmF0b3IgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyAnKTtcbnZhciBzdHlsZVRhZ1Jlc291cmNlT3BlbjMgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpO1xudmFyIHN0eWxlVGFnUmVzb3VyY2VDbG9zZSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPC9zdHlsZT4nKTtcblxuZnVuY3Rpb24gZmx1c2hBbGxTdHlsZXNJblByZWFtYmxlKHNldCwgcHJlY2VkZW5jZSkge1xuICBkaWRGbHVzaFByZWNlZGVuY2UgPSBmYWxzZTtcbiAgc2V0LmZvckVhY2goZmx1c2hTdHlsZUluUHJlYW1ibGUsIHRoaXMpO1xuICBzZXQuY2xlYXIoKTtcbiAgdmFyIGNodW5rcyA9IHByZWNlZGVuY2VTdHlsZVRhZ1Jlc291cmNlLmNodW5rcztcbiAgdmFyIGhyZWZzID0gcHJlY2VkZW5jZVN0eWxlVGFnUmVzb3VyY2UucHJvcHMuaHJlZnM7XG5cbiAgaWYgKGRpZEZsdXNoUHJlY2VkZW5jZSA9PT0gZmFsc2UgfHwgY2h1bmtzLmxlbmd0aCkge1xuICAgIHdyaXRlQ2h1bmsodGhpcywgc3R5bGVUYWdSZXNvdXJjZU9wZW4xKTtcbiAgICB3cml0ZUNodW5rKHRoaXMsIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIocHJlY2VkZW5jZSkpKTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICBpZiAoaHJlZnMubGVuZ3RoKSB7XG4gICAgICB3cml0ZUNodW5rKHRoaXMsIHN0eWxlVGFnUmVzb3VyY2VPcGVuMik7XG5cbiAgICAgIGZvciAoOyBpIDwgaHJlZnMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHdyaXRlQ2h1bmsodGhpcywgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihocmVmc1tpXSkpKTtcbiAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBzcGFjZVNlcGFyYXRvcik7XG4gICAgICB9XG5cbiAgICAgIHdyaXRlQ2h1bmsodGhpcywgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihocmVmc1tpXSkpKTtcbiAgICB9XG5cbiAgICB3cml0ZUNodW5rKHRoaXMsIHN0eWxlVGFnUmVzb3VyY2VPcGVuMyk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3cml0ZUNodW5rKHRoaXMsIGNodW5rc1tpXSk7XG4gICAgfVxuXG4gICAgd3JpdGVDaHVuayh0aGlzLCBzdHlsZVRhZ1Jlc291cmNlQ2xvc2UpOyAvLyBzdHlsZSByZXNvdXJjZXMgY2FuIGZsdXNoIGNvbnRpbnVvdXNseSBzaW5jZSBtb3JlIHJ1bGVzIG1heSBiZSB3cml0dGVuIGludG9cbiAgICAvLyB0aGVtIHdpdGggbmV3IGhyZWZzLiBJbnN0ZWFkIG9mIG1hcmtpbmcgaXQgZmx1c2hlZCwgd2Ugc2ltcGx5IHJlc2V0IHRoZSBjaHVua3NcbiAgICAvLyBhbmQgaHJlZnNcblxuICAgIGNodW5rcy5sZW5ndGggPSAwO1xuICAgIGhyZWZzLmxlbmd0aCA9IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlbG9hZExhdGVTdHlsZShyZXNvdXJjZSkge1xuICBpZiAocmVzb3VyY2Uuc3RhdGUgJiBQcmVsb2FkRmx1c2hlZCkge1xuICAgIC8vIFRoaXMgcmVzb3VyY2UgaGFzIGFscmVhZHkgaGFkIGEgcHJlbG9hZCBmbHVzaGVkXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHJlc291cmNlLnR5cGUgPT09ICdzdHlsZScpIHtcbiAgICAvLyA8c3R5bGU+IHRhZ3MgZG8gbm90IG5lZWQgdG8gYmUgcHJlbG9hZGVkXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNodW5rcyA9IHJlc291cmNlLmNodW5rcztcbiAgdmFyIHByZWxvYWRQcm9wcyA9IHByZWxvYWRBc1N0eWxlUHJvcHNGcm9tUHJvcHMocmVzb3VyY2UucHJvcHMuaHJlZiwgcmVzb3VyY2UucHJvcHMpO1xuICBwdXNoTGlua0ltcGwoY2h1bmtzLCBwcmVsb2FkUHJvcHMpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgd3JpdGVDaHVuayh0aGlzLCBjaHVua3NbaV0pO1xuICB9XG5cbiAgcmVzb3VyY2Uuc3RhdGUgfD0gUHJlbG9hZEZsdXNoZWQ7XG4gIGNodW5rcy5sZW5ndGggPSAwO1xufVxuXG5mdW5jdGlvbiBwcmVsb2FkTGF0ZVN0eWxlcyhzZXQsIHByZWNlZGVuY2UpIHtcbiAgc2V0LmZvckVhY2gocHJlbG9hZExhdGVTdHlsZSwgdGhpcyk7XG4gIHNldC5jbGVhcigpO1xufSAvLyBXZSBkb24ndCBib3RoZXIgcmVwb3J0aW5nIGJhY2twcmVzc3VyZSBhdCB0aGUgbW9tZW50IGJlY2F1c2Ugd2UgZXhwZWN0IHRvXG4vLyBmbHVzaCB0aGUgZW50aXJlIHByZWFtYmxlIGluIGEgc2luZ2xlIHBhc3MuIFRoaXMgcHJvYmFibHkgc2hvdWxkIGJlIG1vZGlmaWVkXG4vLyBpbiB0aGUgZnV0dXJlIHRvIGJlIGJhY2twcmVzc3VyZSBzZW5zaXRpdmUgYnV0IHRoYXQgcmVxdWlyZXMgYSBsYXJnZXIgcmVmYWN0b3Jcbi8vIG9mIHRoZSBmbHVzaGluZyBjb2RlIGluIEZpenouXG5cblxuZnVuY3Rpb24gd3JpdGVQcmVhbWJsZShkZXN0aW5hdGlvbiwgcmVzb3VyY2VzLCByZXNwb25zZVN0YXRlLCB3aWxsRmx1c2hBbGxTZWdtZW50cykge1xuICAvLyBUaGlzIGZ1bmN0aW9uIG11c3QgYmUgY2FsbGVkIGV4YWN0bHkgb25jZSBvbiBldmVyeSByZXF1ZXN0XG4gIGlmICghd2lsbEZsdXNoQWxsU2VnbWVudHMgJiYgcmVzcG9uc2VTdGF0ZS5leHRlcm5hbFJ1bnRpbWVTY3JpcHQpIHtcbiAgICAvLyBJZiB0aGUgcm9vdCBzZWdtZW50IGlzIGluY29tcGxldGUgZHVlIHRvIHN1c3BlbmRlZCB0YXNrc1xuICAgIC8vIChlLmcuIHdpbGxGbHVzaEFsbFNlZ21lbnRzID0gZmFsc2UpIGFuZCB3ZSBhcmUgdXNpbmcgZGF0YVxuICAgIC8vIHN0cmVhbWluZyBmb3JtYXQsIGVuc3VyZSB0aGUgZXh0ZXJuYWwgcnVudGltZSBpcyBzZW50LlxuICAgIC8vIChVc2VyIGNvZGUgY291bGQgY2hvb3NlIHRvIHNlbmQgdGhpcyBldmVuIGVhcmxpZXIgYnkgY2FsbGluZ1xuICAgIC8vICBwcmVpbml0KC4uLiksIGlmIHRoZXkga25vdyB0aGV5IHdpbGwgc3VzcGVuZCkuXG4gICAgdmFyIF9yZXNwb25zZVN0YXRlJGV4dGVybiA9IHJlc3BvbnNlU3RhdGUuZXh0ZXJuYWxSdW50aW1lU2NyaXB0LFxuICAgICAgICBzcmMgPSBfcmVzcG9uc2VTdGF0ZSRleHRlcm4uc3JjLFxuICAgICAgICBjaHVua3MgPSBfcmVzcG9uc2VTdGF0ZSRleHRlcm4uY2h1bmtzO1xuICAgIGludGVybmFsUHJlaW5pdFNjcmlwdChyZXNvdXJjZXMsIHNyYywgY2h1bmtzKTtcbiAgfVxuXG4gIHZhciBodG1sQ2h1bmtzID0gcmVzcG9uc2VTdGF0ZS5odG1sQ2h1bmtzO1xuICB2YXIgaGVhZENodW5rcyA9IHJlc3BvbnNlU3RhdGUuaGVhZENodW5rcztcbiAgdmFyIGkgPSAwOyAvLyBFbWl0IG9wZW4gdGFncyBiZWZvcmUgSG9pc3RhYmxlcyBhbmQgUmVzb3VyY2VzXG5cbiAgaWYgKGh0bWxDaHVua3MpIHtcbiAgICAvLyBXZSBoYXZlIGFuIDxodG1sPiB0byBlbWl0IGFzIHBhcnQgb2YgdGhlIHByZWFtYmxlXG4gICAgZm9yIChpID0gMDsgaSA8IGh0bWxDaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGh0bWxDaHVua3NbaV0pO1xuICAgIH1cblxuICAgIGlmIChoZWFkQ2h1bmtzKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaGVhZENodW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBoZWFkQ2h1bmtzW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2UgZGlkIG5vdCByZW5kZXIgYSBoZWFkIGJ1dCB3ZSBlbWl0dGVkIGFuIDxodG1sPiBzbyB3ZSBlbWl0IG9uZSBub3dcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0Q2h1bmtGb3JUYWcoJ2hlYWQnKSk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBlbmRPZlN0YXJ0VGFnKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaGVhZENodW5rcykge1xuICAgIC8vIFdlIGRvIG5vdCBoYXZlIGFuIDxodG1sPiBidXQgd2UgZG8gaGF2ZSBhIDxoZWFkPlxuICAgIGZvciAoaSA9IDA7IGkgPCBoZWFkQ2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBoZWFkQ2h1bmtzW2ldKTtcbiAgICB9XG4gIH0gLy8gRW1pdCBoaWdoIHByaW9yaXR5IEhvaXN0YWJsZXNcblxuXG4gIHZhciBjaGFyc2V0Q2h1bmtzID0gcmVzcG9uc2VTdGF0ZS5jaGFyc2V0Q2h1bmtzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBjaGFyc2V0Q2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2hhcnNldENodW5rc1tpXSk7XG4gIH1cblxuICBjaGFyc2V0Q2h1bmtzLmxlbmd0aCA9IDA7IC8vIGVtaXQgcHJlY29ubmVjdCByZXNvdXJjZXNcblxuICByZXNvdXJjZXMucHJlY29ubmVjdHMuZm9yRWFjaChmbHVzaFJlc291cmNlSW5QcmVhbWJsZSwgZGVzdGluYXRpb24pO1xuICByZXNvdXJjZXMucHJlY29ubmVjdHMuY2xlYXIoKTtcbiAgdmFyIHByZWNvbm5lY3RDaHVua3MgPSByZXNwb25zZVN0YXRlLnByZWNvbm5lY3RDaHVua3M7XG5cbiAgZm9yIChpID0gMDsgaSA8IHByZWNvbm5lY3RDaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBwcmVjb25uZWN0Q2h1bmtzW2ldKTtcbiAgfVxuXG4gIHByZWNvbm5lY3RDaHVua3MubGVuZ3RoID0gMDtcbiAgcmVzb3VyY2VzLmZvbnRQcmVsb2Fkcy5mb3JFYWNoKGZsdXNoUmVzb3VyY2VJblByZWFtYmxlLCBkZXN0aW5hdGlvbik7XG4gIHJlc291cmNlcy5mb250UHJlbG9hZHMuY2xlYXIoKTtcbiAgcmVzb3VyY2VzLmhpZ2hJbWFnZVByZWxvYWRzLmZvckVhY2goZmx1c2hSZXNvdXJjZUluUHJlYW1ibGUsIGRlc3RpbmF0aW9uKTtcbiAgcmVzb3VyY2VzLmhpZ2hJbWFnZVByZWxvYWRzLmNsZWFyKCk7IC8vIEZsdXNoIHVuYmxvY2tlZCBzdHlsZXNoZWV0cyBieSBwcmVjZWRlbmNlXG5cbiAgcmVzb3VyY2VzLnByZWNlZGVuY2VzLmZvckVhY2goZmx1c2hBbGxTdHlsZXNJblByZWFtYmxlLCBkZXN0aW5hdGlvbik7XG4gIHJlc291cmNlcy5ib290c3RyYXBTY3JpcHRzLmZvckVhY2goZmx1c2hSZXNvdXJjZUluUHJlYW1ibGUsIGRlc3RpbmF0aW9uKTtcbiAgcmVzb3VyY2VzLnNjcmlwdHMuZm9yRWFjaChmbHVzaFJlc291cmNlSW5QcmVhbWJsZSwgZGVzdGluYXRpb24pO1xuICByZXNvdXJjZXMuc2NyaXB0cy5jbGVhcigpO1xuICByZXNvdXJjZXMuYnVsa1ByZWxvYWRzLmZvckVhY2goZmx1c2hSZXNvdXJjZUluUHJlYW1ibGUsIGRlc3RpbmF0aW9uKTtcbiAgcmVzb3VyY2VzLmJ1bGtQcmVsb2Fkcy5jbGVhcigpOyAvLyBXcml0ZSBlbWJlZGRpbmcgcHJlbG9hZENodW5rc1xuXG4gIHZhciBwcmVsb2FkQ2h1bmtzID0gcmVzcG9uc2VTdGF0ZS5wcmVsb2FkQ2h1bmtzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBwcmVsb2FkQ2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcHJlbG9hZENodW5rc1tpXSk7XG4gIH1cblxuICBwcmVsb2FkQ2h1bmtzLmxlbmd0aCA9IDA7IC8vIFdyaXRlIGVtYmVkZGluZyBob2lzdGFibGVDaHVua3NcblxuICB2YXIgaG9pc3RhYmxlQ2h1bmtzID0gcmVzcG9uc2VTdGF0ZS5ob2lzdGFibGVDaHVua3M7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvaXN0YWJsZUNodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGhvaXN0YWJsZUNodW5rc1tpXSk7XG4gIH1cblxuICBob2lzdGFibGVDaHVua3MubGVuZ3RoID0gMDsgLy8gRmx1c2ggY2xvc2luZyBoZWFkIGlmIG5lY2Vzc2FyeVxuXG4gIGlmIChodG1sQ2h1bmtzICYmIGhlYWRDaHVua3MgPT09IG51bGwpIHtcbiAgICAvLyBXZSBoYXZlIGFuIDxodG1sPiByZW5kZXJlZCBidXQgbm8gPGhlYWQ+IHJlbmRlcmVkLiBXZSBob3dldmVyIGluc2VydGVkXG4gICAgLy8gYSA8aGVhZD4gdXAgYWJvdmUgc28gd2UgbmVlZCB0byBlbWl0IHRoZSA8L2hlYWQ+IG5vdy4gVGhpcyBpcyBzYWZlIGJlY2F1c2VcbiAgICAvLyBpZiB0aGUgbWFpbiBjb250ZW50IGNvbnRhaW5lZCB0aGUgPC9oZWFkPiBpdCB3b3VsZCBhbHNvIGhhdmUgcHJvdmlkZWQgYVxuICAgIC8vIDxoZWFkPi4gVGhpcyBtZWFucyB0aGF0IGFsbCB0aGUgY29udGVudCBpbnNpZGUgPGh0bWw+IGlzIGVpdGhlciA8Ym9keT4gb3JcbiAgICAvLyBpbnZhbGlkIEhUTUxcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBlbmRUYWcxKTtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKCdoZWFkJykpO1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGVuZFRhZzIpO1xuICB9XG59IC8vIFdlIGRvbid0IGJvdGhlciByZXBvcnRpbmcgYmFja3ByZXNzdXJlIGF0IHRoZSBtb21lbnQgYmVjYXVzZSB3ZSBleHBlY3QgdG9cbi8vIGZsdXNoIHRoZSBlbnRpcmUgcHJlYW1ibGUgaW4gYSBzaW5nbGUgcGFzcy4gVGhpcyBwcm9iYWJseSBzaG91bGQgYmUgbW9kaWZpZWRcbi8vIGluIHRoZSBmdXR1cmUgdG8gYmUgYmFja3ByZXNzdXJlIHNlbnNpdGl2ZSBidXQgdGhhdCByZXF1aXJlcyBhIGxhcmdlciByZWZhY3RvclxuLy8gb2YgdGhlIGZsdXNoaW5nIGNvZGUgaW4gRml6ei5cblxuZnVuY3Rpb24gd3JpdGVIb2lzdGFibGVzKGRlc3RpbmF0aW9uLCByZXNvdXJjZXMsIHJlc3BvbnNlU3RhdGUpIHtcbiAgdmFyIGkgPSAwOyAvLyBFbWl0IGhpZ2ggcHJpb3JpdHkgSG9pc3RhYmxlc1xuICAvLyBXZSBvbWl0IGNoYXJzZXRDaHVua3MgYmVjYXVzZSB3ZSBoYXZlIGFscmVhZHkgc2VudCB0aGUgc2hlbGwgYW5kIGlmIGl0IHdhc24ndFxuICAvLyBhbHJlYWR5IHNlbnQgaXQgaXMgdG9vIGxhdGUgbm93LlxuXG4gIHJlc291cmNlcy5wcmVjb25uZWN0cy5mb3JFYWNoKGZsdXNoUmVzb3VyY2VMYXRlLCBkZXN0aW5hdGlvbik7XG4gIHJlc291cmNlcy5wcmVjb25uZWN0cy5jbGVhcigpO1xuICB2YXIgcHJlY29ubmVjdENodW5rcyA9IHJlc3BvbnNlU3RhdGUucHJlY29ubmVjdENodW5rcztcblxuICBmb3IgKGkgPSAwOyBpIDwgcHJlY29ubmVjdENodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHByZWNvbm5lY3RDaHVua3NbaV0pO1xuICB9XG5cbiAgcHJlY29ubmVjdENodW5rcy5sZW5ndGggPSAwO1xuICByZXNvdXJjZXMuZm9udFByZWxvYWRzLmZvckVhY2goZmx1c2hSZXNvdXJjZUxhdGUsIGRlc3RpbmF0aW9uKTtcbiAgcmVzb3VyY2VzLmZvbnRQcmVsb2Fkcy5jbGVhcigpO1xuICByZXNvdXJjZXMuaGlnaEltYWdlUHJlbG9hZHMuZm9yRWFjaChmbHVzaFJlc291cmNlSW5QcmVhbWJsZSwgZGVzdGluYXRpb24pO1xuICByZXNvdXJjZXMuaGlnaEltYWdlUHJlbG9hZHMuY2xlYXIoKTsgLy8gUHJlbG9hZCBhbnkgc3R5bGVzaGVldHMuIHRoZXNlIHdpbGwgZW1pdCBpbiBhIHJlbmRlciBpbnN0cnVjdGlvbiB0aGF0IGZvbGxvd3MgdGhpc1xuICAvLyBidXQgd2Ugd2FudCB0byBraWNrIG9mZiBwcmVsb2FkaW5nIGFzIHNvb24gYXMgcG9zc2libGVcblxuICByZXNvdXJjZXMucHJlY2VkZW5jZXMuZm9yRWFjaChwcmVsb2FkTGF0ZVN0eWxlcywgZGVzdGluYXRpb24pOyAvLyBib290c3RyYXAgc2NyaXB0cyBzaG91bGQgZmx1c2ggYWJvdmUgc2NyaXB0IHByaW9yaXR5IGJ1dCB0aGVzZSBjYW4gb25seSBmbHVzaCBpbiB0aGUgcHJlYW1ibGVcbiAgLy8gc28gd2UgZWxpZGUgdGhlIGNvZGUgaGVyZSBmb3IgcGVyZm9ybWFuY2VcblxuICByZXNvdXJjZXMuc2NyaXB0cy5mb3JFYWNoKGZsdXNoUmVzb3VyY2VMYXRlLCBkZXN0aW5hdGlvbik7XG4gIHJlc291cmNlcy5zY3JpcHRzLmNsZWFyKCk7XG4gIHJlc291cmNlcy5idWxrUHJlbG9hZHMuZm9yRWFjaChmbHVzaFJlc291cmNlTGF0ZSwgZGVzdGluYXRpb24pO1xuICByZXNvdXJjZXMuYnVsa1ByZWxvYWRzLmNsZWFyKCk7IC8vIFdyaXRlIGVtYmVkZGluZyBwcmVsb2FkQ2h1bmtzXG5cbiAgdmFyIHByZWxvYWRDaHVua3MgPSByZXNwb25zZVN0YXRlLnByZWxvYWRDaHVua3M7XG5cbiAgZm9yIChpID0gMDsgaSA8IHByZWxvYWRDaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBwcmVsb2FkQ2h1bmtzW2ldKTtcbiAgfVxuXG4gIHByZWxvYWRDaHVua3MubGVuZ3RoID0gMDsgLy8gV3JpdGUgZW1iZWRkaW5nIGhvaXN0YWJsZUNodW5rc1xuXG4gIHZhciBob2lzdGFibGVDaHVua3MgPSByZXNwb25zZVN0YXRlLmhvaXN0YWJsZUNodW5rcztcblxuICBmb3IgKGkgPSAwOyBpIDwgaG9pc3RhYmxlQ2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgaG9pc3RhYmxlQ2h1bmtzW2ldKTtcbiAgfVxuXG4gIGhvaXN0YWJsZUNodW5rcy5sZW5ndGggPSAwO1xufVxuZnVuY3Rpb24gd3JpdGVQb3N0YW1ibGUoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUpIHtcbiAgaWYgKHJlc3BvbnNlU3RhdGUuaGFzQm9keSkge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGVuZFRhZzEpO1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoJ2JvZHknKSk7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgZW5kVGFnMik7XG4gIH1cblxuICBpZiAocmVzcG9uc2VTdGF0ZS5odG1sQ2h1bmtzKSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgZW5kVGFnMSk7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuaygnaHRtbCcpKTtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBlbmRUYWcyKTtcbiAgfVxufVxudmFyIGFycmF5Rmlyc3RPcGVuQnJhY2tldCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnWycpO1xudmFyIGFycmF5U3Vic2VxdWVudE9wZW5CcmFja2V0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcsWycpO1xudmFyIGFycmF5SW50ZXJzdGl0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcsJyk7XG52YXIgYXJyYXlDbG9zZUJyYWNrZXQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ10nKTsgLy8gVGhpcyBmdW5jdGlvbiB3cml0ZXMgYSAyRCBhcnJheSBvZiBzdHJpbmdzIHRvIGJlIGVtYmVkZGVkIGluIGphdmFzY3JpcHQuXG4vLyBFLmcuXG4vLyAgW1tcIkpTX2VzY2FwZWRfc3RyaW5nMVwiLCBcIkpTX2VzY2FwZWRfc3RyaW5nMlwiXV1cblxuZnVuY3Rpb24gd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jaWVzSW5KUyhkZXN0aW5hdGlvbiwgYm91bmRhcnlSZXNvdXJjZXMpIHtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlGaXJzdE9wZW5CcmFja2V0KTtcbiAgdmFyIG5leHRBcnJheU9wZW5CcmFja0NodW5rID0gYXJyYXlGaXJzdE9wZW5CcmFja2V0O1xuICBib3VuZGFyeVJlc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChyZXNvdXJjZSkge1xuICAgIGlmIChyZXNvdXJjZS50eXBlID09PSAnc3R5bGUnKSA7IGVsc2UgaWYgKHJlc291cmNlLnN0YXRlICYgRmx1c2hlZEluUHJlYW1ibGUpIDsgZWxzZSBpZiAocmVzb3VyY2Uuc3RhdGUgJiBGbHVzaGVkKSB7XG4gICAgICAvLyBXZSBvbmx5IG5lZWQgdG8gZW1pdCB0aGUgaHJlZiBiZWNhdXNlIHRoaXMgcmVzb3VyY2UgZmx1c2hlZCBpbiBhbiBlYXJsaWVyXG4gICAgICAvLyBib3VuZGFyeSBhbHJlYWR5IHdoaWNoIGVuY29kZWQgdGhlIGF0dHJpYnV0ZXMgbmVjZXNzYXJ5IHRvIGNvbnN0cnVjdFxuICAgICAgLy8gdGhlIHJlc291cmNlIGluc3RhbmNlIG9uIHRoZSBjbGllbnQuXG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayk7XG4gICAgICB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmN5SHJlZk9ubHlJbkpTKGRlc3RpbmF0aW9uLCByZXNvdXJjZS5wcm9wcy5ocmVmKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGFycmF5Q2xvc2VCcmFja2V0KTtcbiAgICAgIG5leHRBcnJheU9wZW5CcmFja0NodW5rID0gYXJyYXlTdWJzZXF1ZW50T3BlbkJyYWNrZXQ7XG4gICAgfSBlbHNlIGlmIChyZXNvdXJjZS50eXBlID09PSAnc3R5bGVzaGVldCcpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gZW1pdCB0aGUgd2hvbGUgcmVzb3VyY2UgZm9yIGluc2VydGlvbiBvbiB0aGUgY2xpZW50XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayk7XG4gICAgICB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmN5SW5KUyhkZXN0aW5hdGlvbiwgcmVzb3VyY2UucHJvcHMuaHJlZiwgcmVzb3VyY2UucHJvcHNbJ2RhdGEtcHJlY2VkZW5jZSddLCByZXNvdXJjZS5wcm9wcyk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUNsb3NlQnJhY2tldCk7XG4gICAgICBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayA9IGFycmF5U3Vic2VxdWVudE9wZW5CcmFja2V0O1xuICAgICAgcmVzb3VyY2Uuc3RhdGUgfD0gRmx1c2hlZExhdGU7XG4gICAgfVxuICB9KTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlDbG9zZUJyYWNrZXQpO1xufVxuLyogSGVscGVyIGZ1bmN0aW9ucyAqL1xuXG5cbmZ1bmN0aW9uIHdyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY3lIcmVmT25seUluSlMoZGVzdGluYXRpb24sIGhyZWYpIHtcbiAgLy8gV2Ugc2hvdWxkIGFjdHVhbGx5IGVuZm9yY2UgdGhpcyBlYXJsaWVyIHdoZW4gdGhlIHJlc291cmNlIGlzIGNyZWF0ZWQgYnV0IGZvclxuICAvLyBub3cgd2UgbWFrZSBzdXJlIHdlIGFyZSBhY3R1YWxseSBkZWFsaW5nIHdpdGggYSBzdHJpbmcgaGVyZS5cbiAge1xuICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24oaHJlZiwgJ2hyZWYnKTtcbiAgfVxuXG4gIHZhciBjb2VyY2VkSHJlZiA9ICcnICsgaHJlZjtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyhjb2VyY2VkSHJlZikpKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jeUluSlMoZGVzdGluYXRpb24sIGhyZWYsIHByZWNlZGVuY2UsIHByb3BzKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICB2YXIgY29lcmNlZEhyZWYgPSBzYW5pdGl6ZVVSTCgnJyArIGhyZWYpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGNvZXJjZWRIcmVmKSkpO1xuXG4gIHtcbiAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHByZWNlZGVuY2UsICdwcmVjZWRlbmNlJyk7XG4gIH1cblxuICB2YXIgY29lcmNlZFByZWNlZGVuY2UgPSAnJyArIHByZWNlZGVuY2U7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGFycmF5SW50ZXJzdGl0aWFsKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyhjb2VyY2VkUHJlY2VkZW5jZSkpKTtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2hyZWYnOlxuICAgICAgICBjYXNlICdyZWwnOlxuICAgICAgICBjYXNlICdwcmVjZWRlbmNlJzpcbiAgICAgICAgY2FzZSAnZGF0YS1wcmVjZWRlbmNlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsaW5rJyArIFwiIGlzIGEgc2VsZi1jbG9zaW5nIHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgXCIgKyAndXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB3cml0ZVN0eWxlUmVzb3VyY2VBdHRyaWJ1dGVJbkpTKGRlc3RpbmF0aW9uLCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiB3cml0ZVN0eWxlUmVzb3VyY2VBdHRyaWJ1dGVJbkpTKGRlc3RpbmF0aW9uLCBuYW1lLCB2YWx1ZSkgLy8gbm90IG51bGwgb3IgdW5kZWZpbmVkXG57XG4gIHZhciBhdHRyaWJ1dGVOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICB2YXIgYXR0cmlidXRlVmFsdWU7XG5cbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAobmFtZSkge1xuICAgIC8vIFJlc2VydmVkIG5hbWVzXG4gICAgY2FzZSAnaW5uZXJIVE1MJzpcbiAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgY2FzZSAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJzpcbiAgICBjYXNlICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnOlxuICAgIGNhc2UgJ3N0eWxlJzpcbiAgICAgIC8vIElnbm9yZWRcbiAgICAgIHJldHVybjtcbiAgICAvLyBBdHRyaWJ1dGUgcmVuYW1lc1xuXG4gICAgY2FzZSAnY2xhc3NOYW1lJzpcbiAgICAgIHtcbiAgICAgICAgYXR0cmlidXRlTmFtZSA9ICdjbGFzcyc7XG5cbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAvLyBCb29sZWFuc1xuXG4gICAgY2FzZSAnaGlkZGVuJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJpYnV0ZVZhbHVlID0gJyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIC8vIFNhbnRpemVkIFVSTHNcblxuICAgIGNhc2UgJ3NyYyc6XG4gICAgY2FzZSAnaHJlZic6XG4gICAgICB7XG4gICAgICAgIHZhbHVlID0gc2FuaXRpemVVUkwodmFsdWUpO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJpYnV0ZVZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBpZiAoIC8vIHVucmVjb2duaXplZCBldmVudCBoYW5kbGVycyBhcmUgbm90IFNTUidkIGFuZCB3ZSAoYXBwYXJlbnRseSlcbiAgICAgICAgLy8gdXNlIG9uKiBhcyBodWVyaXN0aWMgZm9yIHRoZXNlIGhhbmRsZXIgcHJvcHNcbiAgICAgICAgbmFtZS5sZW5ndGggPiAyICYmIChuYW1lWzBdID09PSAnbycgfHwgbmFtZVswXSA9PT0gJ08nKSAmJiAobmFtZVsxXSA9PT0gJ24nIHx8IG5hbWVbMV0gPT09ICdOJykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWJ1dGVWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICB9XG4gIH1cblxuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUludGVyc3RpdGlhbCk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMoYXR0cmlidXRlTmFtZSkpKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlJbnRlcnN0aXRpYWwpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGF0dHJpYnV0ZVZhbHVlKSkpO1xufSAvLyBUaGlzIGZ1bmN0aW9uIHdyaXRlcyBhIDJEIGFycmF5IG9mIHN0cmluZ3MgdG8gYmUgZW1iZWRkZWQgaW4gYW4gYXR0cmlidXRlXG4vLyB2YWx1ZSBhbmQgcmVhZCB3aXRoIEpTT04ucGFyc2UgaW4gUmVhY3RET01TZXJ2ZXJFeHRlcm5hbFJ1bnRpbWUuanNcbi8vIEUuZy5cbi8vICBbWyZxdW90O0pTT05fZXNjYXBlZF9zdHJpbmcxJnF1b3Q7LCAmcXVvdDtKU09OX2VzY2FwZWRfc3RyaW5nMiZxdW90O11dXG5cblxuZnVuY3Rpb24gd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jaWVzSW5BdHRyKGRlc3RpbmF0aW9uLCBib3VuZGFyeVJlc291cmNlcykge1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUZpcnN0T3BlbkJyYWNrZXQpO1xuICB2YXIgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmsgPSBhcnJheUZpcnN0T3BlbkJyYWNrZXQ7XG4gIGJvdW5kYXJ5UmVzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHJlc291cmNlKSB7XG4gICAgaWYgKHJlc291cmNlLnR5cGUgPT09ICdzdHlsZScpIDsgZWxzZSBpZiAocmVzb3VyY2Uuc3RhdGUgJiBGbHVzaGVkSW5QcmVhbWJsZSkgOyBlbHNlIGlmIChyZXNvdXJjZS5zdGF0ZSAmIEZsdXNoZWQpIHtcbiAgICAgIC8vIFdlIG9ubHkgbmVlZCB0byBlbWl0IHRoZSBocmVmIGJlY2F1c2UgdGhpcyByZXNvdXJjZSBmbHVzaGVkIGluIGFuIGVhcmxpZXJcbiAgICAgIC8vIGJvdW5kYXJ5IGFscmVhZHkgd2hpY2ggZW5jb2RlZCB0aGUgYXR0cmlidXRlcyBuZWNlc3NhcnkgdG8gY29uc3RydWN0XG4gICAgICAvLyB0aGUgcmVzb3VyY2UgaW5zdGFuY2Ugb24gdGhlIGNsaWVudC5cbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIG5leHRBcnJheU9wZW5CcmFja0NodW5rKTtcbiAgICAgIHdyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY3lIcmVmT25seUluQXR0cihkZXN0aW5hdGlvbiwgcmVzb3VyY2UucHJvcHMuaHJlZik7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUNsb3NlQnJhY2tldCk7XG4gICAgICBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayA9IGFycmF5U3Vic2VxdWVudE9wZW5CcmFja2V0O1xuICAgIH0gZWxzZSBpZiAocmVzb3VyY2UudHlwZSA9PT0gJ3N0eWxlc2hlZXQnKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGVtaXQgdGhlIHdob2xlIHJlc291cmNlIGZvciBpbnNlcnRpb24gb24gdGhlIGNsaWVudFxuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmspO1xuICAgICAgd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jeUluQXR0cihkZXN0aW5hdGlvbiwgcmVzb3VyY2UucHJvcHMuaHJlZiwgcmVzb3VyY2UucHJvcHNbJ2RhdGEtcHJlY2VkZW5jZSddLCByZXNvdXJjZS5wcm9wcyk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUNsb3NlQnJhY2tldCk7XG4gICAgICBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayA9IGFycmF5U3Vic2VxdWVudE9wZW5CcmFja2V0O1xuICAgICAgcmVzb3VyY2Uuc3RhdGUgfD0gRmx1c2hlZExhdGU7XG4gICAgfVxuICB9KTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlDbG9zZUJyYWNrZXQpO1xufVxuLyogSGVscGVyIGZ1bmN0aW9ucyAqL1xuXG5cbmZ1bmN0aW9uIHdyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY3lIcmVmT25seUluQXR0cihkZXN0aW5hdGlvbiwgaHJlZikge1xuICAvLyBXZSBzaG91bGQgYWN0dWFsbHkgZW5mb3JjZSB0aGlzIGVhcmxpZXIgd2hlbiB0aGUgcmVzb3VyY2UgaXMgY3JlYXRlZCBidXQgZm9yXG4gIC8vIG5vdyB3ZSBtYWtlIHN1cmUgd2UgYXJlIGFjdHVhbGx5IGRlYWxpbmcgd2l0aCBhIHN0cmluZyBoZXJlLlxuICB7XG4gICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihocmVmLCAnaHJlZicpO1xuICB9XG5cbiAgdmFyIGNvZXJjZWRIcmVmID0gJycgKyBocmVmO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKEpTT04uc3RyaW5naWZ5KGNvZXJjZWRIcmVmKSkpKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jeUluQXR0cihkZXN0aW5hdGlvbiwgaHJlZiwgcHJlY2VkZW5jZSwgcHJvcHMpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHZhciBjb2VyY2VkSHJlZiA9IHNhbml0aXplVVJMKCcnICsgaHJlZik7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoSlNPTi5zdHJpbmdpZnkoY29lcmNlZEhyZWYpKSkpO1xuXG4gIHtcbiAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHByZWNlZGVuY2UsICdwcmVjZWRlbmNlJyk7XG4gIH1cblxuICB2YXIgY29lcmNlZFByZWNlZGVuY2UgPSAnJyArIHByZWNlZGVuY2U7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGFycmF5SW50ZXJzdGl0aWFsKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihKU09OLnN0cmluZ2lmeShjb2VyY2VkUHJlY2VkZW5jZSkpKSk7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdocmVmJzpcbiAgICAgICAgY2FzZSAncmVsJzpcbiAgICAgICAgY2FzZSAncHJlY2VkZW5jZSc6XG4gICAgICAgIGNhc2UgJ2RhdGEtcHJlY2VkZW5jZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbGluaycgKyBcIiBpcyBhIHNlbGYtY2xvc2luZyB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIFwiICsgJ3VzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgd3JpdGVTdHlsZVJlc291cmNlQXR0cmlidXRlSW5BdHRyKGRlc3RpbmF0aW9uLCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiB3cml0ZVN0eWxlUmVzb3VyY2VBdHRyaWJ1dGVJbkF0dHIoZGVzdGluYXRpb24sIG5hbWUsIHZhbHVlKSAvLyBub3QgbnVsbCBvciB1bmRlZmluZWRcbntcbiAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBhdHRyaWJ1dGVWYWx1ZTtcblxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgLy8gUmVzZXJ2ZWQgbmFtZXNcbiAgICBjYXNlICdpbm5lckhUTUwnOlxuICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICBjYXNlICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnOlxuICAgIGNhc2UgJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZyc6XG4gICAgY2FzZSAnc3R5bGUnOlxuICAgICAgLy8gSWdub3JlZFxuICAgICAgcmV0dXJuO1xuICAgIC8vIEF0dHJpYnV0ZSByZW5hbWVzXG5cbiAgICBjYXNlICdjbGFzc05hbWUnOlxuICAgICAge1xuICAgICAgICBhdHRyaWJ1dGVOYW1lID0gJ2NsYXNzJztcblxuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWJ1dGVWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIC8vIEJvb2xlYW5zXG5cbiAgICBjYXNlICdoaWRkZW4nOlxuICAgICAge1xuICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgLy8gU2FudGl6ZWQgVVJMc1xuXG4gICAgY2FzZSAnc3JjJzpcbiAgICBjYXNlICdocmVmJzpcbiAgICAgIHtcbiAgICAgICAgdmFsdWUgPSBzYW5pdGl6ZVVSTCh2YWx1ZSk7XG5cbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIGlmICggLy8gdW5yZWNvZ25pemVkIGV2ZW50IGhhbmRsZXJzIGFyZSBub3QgU1NSJ2QgYW5kIHdlIChhcHBhcmVudGx5KVxuICAgICAgICAvLyB1c2Ugb24qIGFzIGh1ZXJpc3RpYyBmb3IgdGhlc2UgaGFuZGxlciBwcm9wc1xuICAgICAgICBuYW1lLmxlbmd0aCA+IDIgJiYgKG5hbWVbMF0gPT09ICdvJyB8fCBuYW1lWzBdID09PSAnTycpICYmIChuYW1lWzFdID09PSAnbicgfHwgbmFtZVsxXSA9PT0gJ04nKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJpYnV0ZVZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgIH1cbiAgfVxuXG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGFycmF5SW50ZXJzdGl0aWFsKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihKU09OLnN0cmluZ2lmeShhdHRyaWJ1dGVOYW1lKSkpKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlJbnRlcnN0aXRpYWwpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKEpTT04uc3RyaW5naWZ5KGF0dHJpYnV0ZVZhbHVlKSkpKTtcbn1cbi8qKlxuICogUmVzb3VyY2VzXG4gKi9cblxuXG52YXIgTm9TdGF0ZVxuLyogICAgICAgICAgICAqL1xuPSAwOyAvLyBUaGVzZSB0YWdzIGluZGljYXRlIHdoZXRoZXIgdGhlIFJlc291cmNlIHdhcyBmbHVzaGVkIGFuZCBpbiB3aGljaCBwaGFzZVxuXG52YXIgRmx1c2hlZEluUHJlYW1ibGVcbi8qICAqL1xuPSAxO1xudmFyIEZsdXNoZWRMYXRlXG4vKiAgICAgICAgKi9cbj0gMjtcbnZhciBGbHVzaGVkXG4vKiAgICAgICAgICAgICovXG49IDM7IC8vIFRoaXMgdGFnIGluZGljYXRlcyB3aGV0aGVyIHRoaXMgUmVzb3VyY2UgaXMgYmxvY2tlZCBmcm9tIGZsdXNoaW5nLlxuLy8gVGhpcyBjdXJyZW50bHkgaXMgb25seSB1c2VkIHdpdGggc3R5bGVzaGVldHMgdGhhdCBhcmUgYmxvY2tlZCBieSBhIEJvdW5kYXJ5XG5cbnZhciBCbG9ja2VkXG4vKiAgICAgICAgICAgICovXG49IDQ7IC8vIFRoaXMgdGFnIGluZGljYXRlcyB3aGV0aGVyIHRoaXMgUmVzb3VyY2UgaGFzIGJlZW4gcHJlbG9hZGVkLlxuLy8gVGhpcyBnZW5lcmFsbHkgb25seSBtYWtlcyBzZW5zZSBmb3IgUmVzb3VyY2VzIG90aGVyIHRoYW4gUHJlbG9hZFJlc291cmNlXG5cbnZhciBQcmVsb2FkRmx1c2hlZFxuLyogICAgICovXG49IDg7IC8vIERldiBleHRlbnNpb25zLlxuLy8gU3R5bGVzaGVldHMgYW5kIFNjcmlwdHMgcmVuZGVyZWQgd2l0aCBqc3hcbi8vIFByZWxvYWRzLCBTdHlsZXNoZWV0cywgYW5kIFNjcmlwdHMgZnJvbSBSZWFjdERPTS5wcmVsb2FkIG9yIFJlYWN0RE9NLnByZWluaXRcbi8vIFByZWxvYWRzIGNyZWF0ZWQgZm9yIG5vcm1hbCBjb21wb25lbnRzIHdlIHJlbmRlcmVkIGJ1dCBrbm93IHdlIGNhbiBwcmVsb2FkIGVhcmx5IHN1Y2ggYXNcbi8vIHN5bmMgU2NyaXB0cyBhbmQgc3R5bGVzaGVldHMgd2l0aG91dCBwcmVjZWRlbmNlIG9yIHdpdGggb25Mb2FkL29uRXJyb3IgaGFuZGxlcnNcbi8vIEBUT0RPIGFkZCBib290c3RyYXAgc2NyaXB0IHRvIGltcGxpY2l0IHByZWxvYWRzXG5cbmZ1bmN0aW9uIGNyZWF0ZVJlc291cmNlcygpIHtcbiAgcmV0dXJuIHtcbiAgICAvLyBwZXJzaXN0ZW50XG4gICAgcHJlbG9hZHNNYXA6IG5ldyBNYXAoKSxcbiAgICBwcmVjb25uZWN0c01hcDogbmV3IE1hcCgpLFxuICAgIHN0eWxlc01hcDogbmV3IE1hcCgpLFxuICAgIHNjcmlwdHNNYXA6IG5ldyBNYXAoKSxcbiAgICAvLyBjbGVhcmVkIG9uIGZsdXNoXG4gICAgcHJlY29ubmVjdHM6IG5ldyBTZXQoKSxcbiAgICBmb250UHJlbG9hZHM6IG5ldyBTZXQoKSxcbiAgICBoaWdoSW1hZ2VQcmVsb2FkczogbmV3IFNldCgpLFxuICAgIC8vIHVzZWRJbWFnZVByZWxvYWRzOiBuZXcgU2V0KCksXG4gICAgcHJlY2VkZW5jZXM6IG5ldyBNYXAoKSxcbiAgICBzdHlsZVByZWNlZGVuY2VzOiBuZXcgTWFwKCksXG4gICAgYm9vdHN0cmFwU2NyaXB0czogbmV3IFNldCgpLFxuICAgIHNjcmlwdHM6IG5ldyBTZXQoKSxcbiAgICBidWxrUHJlbG9hZHM6IG5ldyBTZXQoKSxcbiAgICAvLyBsaWtlIGEgbW9kdWxlIGdsb2JhbCBmb3IgY3VycmVudGx5IHJlbmRlcmluZyBib3VuZGFyeVxuICAgIGJvdW5kYXJ5UmVzb3VyY2VzOiBudWxsXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVCb3VuZGFyeVJlc291cmNlcygpIHtcbiAgcmV0dXJuIG5ldyBTZXQoKTtcbn1cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5UmVzb3VyY2VzVGFyZ2V0KHJlc291cmNlcywgYm91bmRhcnlSZXNvdXJjZXMpIHtcbiAgcmVzb3VyY2VzLmJvdW5kYXJ5UmVzb3VyY2VzID0gYm91bmRhcnlSZXNvdXJjZXM7XG59XG5cbmZ1bmN0aW9uIGdldFJlc291cmNlS2V5KGFzLCBocmVmKSB7XG4gIHJldHVybiBcIltcIiArIGFzICsgXCJdXCIgKyBocmVmO1xufVxuXG5mdW5jdGlvbiBwcmVmZXRjaEROUyhocmVmLCBvcHRpb25zKSB7XG5cbiAgdmFyIHJlcXVlc3QgPSByZXNvbHZlUmVxdWVzdCgpO1xuXG4gIGlmICghcmVxdWVzdCkge1xuICAgIC8vIEluIGFzeW5jIGNvbnRleHRzIHdlIGNhbiBzb21ldGltZXMgcmVzb2x2ZSByZXNvdXJjZXMgZnJvbSBBc3luY0xvY2FsU3RvcmFnZS4gSWYgd2UgY2FuJ3Qgd2UgY2FuIGFsc29cbiAgICAvLyBwb3NzaWJseSBnZXQgdGhlbSBmcm9tIHRoZSBzdGFjayBpZiB3ZSBhcmUgbm90IGluIGFuIGFzeW5jIGNvbnRleHQuIFNpbmNlIHdlIHdlcmUgbm90IGFibGUgdG8gcmVzb2x2ZVxuICAgIC8vIHRoZSByZXNvdXJjZXMgZm9yIHRoaXMgY2FsbCBpbiBlaXRoZXIgY2FzZSB3ZSBvcHQgdG8gZG8gbm90aGluZy4gV2UgY2FuIGNvbnNpZGVyIG1ha2luZyB0aGlzIGEgd2FybmluZ1xuICAgIC8vIGJ1dCB0aGVyZSBtYXkgYmUgdGltZXMgd2hlcmUgY2FsbGluZyBhIGZ1bmN0aW9uIG91dHNpZGUgb2YgcmVuZGVyIGlzIGludGVudGlvbmFsIChpLmUuIHRvIHdhcm0gdXAgZGF0YVxuICAgIC8vIGZldGNoaW5nKSBhbmQgd2UgZG9uJ3Qgd2FudCB0byB3YXJuIGluIHRob3NlIGNhc2VzLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByZXNvdXJjZXMgPSBnZXRSZXNvdXJjZXMocmVxdWVzdCk7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgaHJlZiAhPT0gJ3N0cmluZycgfHwgIWhyZWYpIHtcbiAgICAgIGVycm9yKCdSZWFjdERPTS5wcmVmZXRjaEROUygpOiBFeHBlY3RlZCB0aGUgYGhyZWZgIGFyZ3VtZW50IChmaXJzdCkgdG8gYmUgYSBub24tZW1wdHkgc3RyaW5nIGJ1dCBlbmNvdW50ZXJlZCAlcyBpbnN0ZWFkLicsIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcoaHJlZikpO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2Nyb3NzT3JpZ2luJykpIHtcbiAgICAgICAgZXJyb3IoJ1JlYWN0RE9NLnByZWZldGNoRE5TKCk6IEV4cGVjdGVkIG9ubHkgb25lIGFyZ3VtZW50LCBgaHJlZmAsIGJ1dCBlbmNvdW50ZXJlZCAlcyBhcyBhIHNlY29uZCBhcmd1bWVudCBpbnN0ZWFkLiBUaGlzIGFyZ3VtZW50IGlzIHJlc2VydmVkIGZvciBmdXR1cmUgb3B0aW9ucyBhbmQgaXMgY3VycmVudGx5IGRpc2FsbG93ZWQuIEl0IGxvb2tzIGxpa2UgdGhlIHlvdSBhcmUgYXR0ZW1wdGluZyB0byBzZXQgYSBjcm9zc09yaWdpbiBwcm9wZXJ0eSBmb3IgdGhpcyBETlMgbG9va3VwIGhpbnQuIEJyb3dzZXJzIGRvIG5vdCBwZXJmb3JtIEROUyBxdWVyaWVzIHVzaW5nIENPUlMgYW5kIHNldHRpbmcgdGhpcyBhdHRyaWJ1dGUgb24gdGhlIHJlc291cmNlIGhpbnQgaGFzIG5vIGVmZmVjdC4gVHJ5IGNhbGxpbmcgUmVhY3RET00ucHJlZmV0Y2hETlMoKSB3aXRoIGp1c3QgYSBzaW5nbGUgc3RyaW5nIGFyZ3VtZW50LCBgaHJlZmAuJywgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcob3B0aW9ucykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IoJ1JlYWN0RE9NLnByZWZldGNoRE5TKCk6IEV4cGVjdGVkIG9ubHkgb25lIGFyZ3VtZW50LCBgaHJlZmAsIGJ1dCBlbmNvdW50ZXJlZCAlcyBhcyBhIHNlY29uZCBhcmd1bWVudCBpbnN0ZWFkLiBUaGlzIGFyZ3VtZW50IGlzIHJlc2VydmVkIGZvciBmdXR1cmUgb3B0aW9ucyBhbmQgaXMgY3VycmVudGx5IGRpc2FsbG93ZWQuIFRyeSBjYWxsaW5nIFJlYWN0RE9NLnByZWZldGNoRE5TKCkgd2l0aCBqdXN0IGEgc2luZ2xlIHN0cmluZyBhcmd1bWVudCwgYGhyZWZgLicsIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKG9wdGlvbnMpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGhyZWYgPT09ICdzdHJpbmcnICYmIGhyZWYpIHtcbiAgICB2YXIga2V5ID0gZ2V0UmVzb3VyY2VLZXkoJ3ByZWZldGNoRE5TJywgaHJlZik7XG4gICAgdmFyIHJlc291cmNlID0gcmVzb3VyY2VzLnByZWNvbm5lY3RzTWFwLmdldChrZXkpO1xuXG4gICAgaWYgKCFyZXNvdXJjZSkge1xuICAgICAgcmVzb3VyY2UgPSB7XG4gICAgICAgIHR5cGU6ICdwcmVjb25uZWN0JyxcbiAgICAgICAgY2h1bmtzOiBbXSxcbiAgICAgICAgc3RhdGU6IE5vU3RhdGUsXG4gICAgICAgIHByb3BzOiBudWxsXG4gICAgICB9O1xuICAgICAgcmVzb3VyY2VzLnByZWNvbm5lY3RzTWFwLnNldChrZXksIHJlc291cmNlKTtcbiAgICAgIHB1c2hMaW5rSW1wbChyZXNvdXJjZS5jaHVua3MsIHtcbiAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgcmVsOiAnZG5zLXByZWZldGNoJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVzb3VyY2VzLnByZWNvbm5lY3RzLmFkZChyZXNvdXJjZSk7XG4gICAgZmx1c2hSZXNvdXJjZXMocmVxdWVzdCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHByZWNvbm5lY3QoaHJlZiwgb3B0aW9ucykge1xuXG4gIHZhciByZXF1ZXN0ID0gcmVzb2x2ZVJlcXVlc3QoKTtcblxuICBpZiAoIXJlcXVlc3QpIHtcbiAgICAvLyBJbiBhc3luYyBjb250ZXh0cyB3ZSBjYW4gc29tZXRpbWVzIHJlc29sdmUgcmVzb3VyY2VzIGZyb20gQXN5bmNMb2NhbFN0b3JhZ2UuIElmIHdlIGNhbid0IHdlIGNhbiBhbHNvXG4gICAgLy8gcG9zc2libHkgZ2V0IHRoZW0gZnJvbSB0aGUgc3RhY2sgaWYgd2UgYXJlIG5vdCBpbiBhbiBhc3luYyBjb250ZXh0LiBTaW5jZSB3ZSB3ZXJlIG5vdCBhYmxlIHRvIHJlc29sdmVcbiAgICAvLyB0aGUgcmVzb3VyY2VzIGZvciB0aGlzIGNhbGwgaW4gZWl0aGVyIGNhc2Ugd2Ugb3B0IHRvIGRvIG5vdGhpbmcuIFdlIGNhbiBjb25zaWRlciBtYWtpbmcgdGhpcyBhIHdhcm5pbmdcbiAgICAvLyBidXQgdGhlcmUgbWF5IGJlIHRpbWVzIHdoZXJlIGNhbGxpbmcgYSBmdW5jdGlvbiBvdXRzaWRlIG9mIHJlbmRlciBpcyBpbnRlbnRpb25hbCAoaS5lLiB0byB3YXJtIHVwIGRhdGFcbiAgICAvLyBmZXRjaGluZykgYW5kIHdlIGRvbid0IHdhbnQgdG8gd2FybiBpbiB0aG9zZSBjYXNlcy5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVzb3VyY2VzID0gZ2V0UmVzb3VyY2VzKHJlcXVlc3QpO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGhyZWYgIT09ICdzdHJpbmcnIHx8ICFocmVmKSB7XG4gICAgICBlcnJvcignUmVhY3RET00ucHJlY29ubmVjdCgpOiBFeHBlY3RlZCB0aGUgYGhyZWZgIGFyZ3VtZW50IChmaXJzdCkgdG8gYmUgYSBub24tZW1wdHkgc3RyaW5nIGJ1dCBlbmNvdW50ZXJlZCAlcyBpbnN0ZWFkLicsIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcoaHJlZikpO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucyAhPSBudWxsICYmIHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgZXJyb3IoJ1JlYWN0RE9NLnByZWNvbm5lY3QoKTogRXhwZWN0ZWQgdGhlIGBvcHRpb25zYCBhcmd1bWVudCAoc2Vjb25kKSB0byBiZSBhbiBvYmplY3QgYnV0IGVuY291bnRlcmVkICVzIGluc3RlYWQuIFRoZSBvbmx5IHN1cHBvcnRlZCBvcHRpb24gYXQgdGhpcyB0aW1lIGlzIGBjcm9zc09yaWdpbmAgd2hpY2ggYWNjZXB0cyBhIHN0cmluZy4nLCBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhvcHRpb25zKSk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zICE9IG51bGwgJiYgdHlwZW9mIG9wdGlvbnMuY3Jvc3NPcmlnaW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJvcignUmVhY3RET00ucHJlY29ubmVjdCgpOiBFeHBlY3RlZCB0aGUgYGNyb3NzT3JpZ2luYCBvcHRpb24gKHNlY29uZCBhcmd1bWVudCkgdG8gYmUgYSBzdHJpbmcgYnV0IGVuY291bnRlcmVkICVzIGluc3RlYWQuIFRyeSByZW1vdmluZyB0aGlzIG9wdGlvbiBvciBwYXNzaW5nIGEgc3RyaW5nIHZhbHVlIGluc3RlYWQuJywgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nT2JqZWN0Rm9yV2FybmluZyhvcHRpb25zLmNyb3NzT3JpZ2luKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBocmVmID09PSAnc3RyaW5nJyAmJiBocmVmKSB7XG4gICAgdmFyIGNyb3NzT3JpZ2luID0gb3B0aW9ucyA9PSBudWxsIHx8IHR5cGVvZiBvcHRpb25zLmNyb3NzT3JpZ2luICE9PSAnc3RyaW5nJyA/IG51bGwgOiBvcHRpb25zLmNyb3NzT3JpZ2luID09PSAndXNlLWNyZWRlbnRpYWxzJyA/ICd1c2UtY3JlZGVudGlhbHMnIDogJyc7XG4gICAgdmFyIGtleSA9IFwiW3ByZWNvbm5lY3RdW1wiICsgKGNyb3NzT3JpZ2luID09PSBudWxsID8gJ251bGwnIDogY3Jvc3NPcmlnaW4pICsgXCJdXCIgKyBocmVmO1xuICAgIHZhciByZXNvdXJjZSA9IHJlc291cmNlcy5wcmVjb25uZWN0c01hcC5nZXQoa2V5KTtcblxuICAgIGlmICghcmVzb3VyY2UpIHtcbiAgICAgIHJlc291cmNlID0ge1xuICAgICAgICB0eXBlOiAncHJlY29ubmVjdCcsXG4gICAgICAgIGNodW5rczogW10sXG4gICAgICAgIHN0YXRlOiBOb1N0YXRlLFxuICAgICAgICBwcm9wczogbnVsbFxuICAgICAgfTtcbiAgICAgIHJlc291cmNlcy5wcmVjb25uZWN0c01hcC5zZXQoa2V5LCByZXNvdXJjZSk7XG4gICAgICBwdXNoTGlua0ltcGwocmVzb3VyY2UuY2h1bmtzLCB7XG4gICAgICAgIHJlbDogJ3ByZWNvbm5lY3QnLFxuICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW5cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlc291cmNlcy5wcmVjb25uZWN0cy5hZGQocmVzb3VyY2UpO1xuICAgIGZsdXNoUmVzb3VyY2VzKHJlcXVlc3QpO1xuICB9XG59XG5mdW5jdGlvbiBwcmVsb2FkKGhyZWYsIG9wdGlvbnMpIHtcblxuICB2YXIgcmVxdWVzdCA9IHJlc29sdmVSZXF1ZXN0KCk7XG5cbiAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgLy8gSW4gYXN5bmMgY29udGV4dHMgd2UgY2FuIHNvbWV0aW1lcyByZXNvbHZlIHJlc291cmNlcyBmcm9tIEFzeW5jTG9jYWxTdG9yYWdlLiBJZiB3ZSBjYW4ndCB3ZSBjYW4gYWxzb1xuICAgIC8vIHBvc3NpYmx5IGdldCB0aGVtIGZyb20gdGhlIHN0YWNrIGlmIHdlIGFyZSBub3QgaW4gYW4gYXN5bmMgY29udGV4dC4gU2luY2Ugd2Ugd2VyZSBub3QgYWJsZSB0byByZXNvbHZlXG4gICAgLy8gdGhlIHJlc291cmNlcyBmb3IgdGhpcyBjYWxsIGluIGVpdGhlciBjYXNlIHdlIG9wdCB0byBkbyBub3RoaW5nLiBXZSBjYW4gY29uc2lkZXIgbWFraW5nIHRoaXMgYSB3YXJuaW5nXG4gICAgLy8gYnV0IHRoZXJlIG1heSBiZSB0aW1lcyB3aGVyZSBjYWxsaW5nIGEgZnVuY3Rpb24gb3V0c2lkZSBvZiByZW5kZXIgaXMgaW50ZW50aW9uYWwgKGkuZS4gdG8gd2FybSB1cCBkYXRhXG4gICAgLy8gZmV0Y2hpbmcpIGFuZCB3ZSBkb24ndCB3YW50IHRvIHdhcm4gaW4gdGhvc2UgY2FzZXMuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJlc291cmNlcyA9IGdldFJlc291cmNlcyhyZXF1ZXN0KTtcblxuICB7XG4gICAgdmFyIGVuY291bnRlcmVkID0gJyc7XG5cbiAgICBpZiAodHlwZW9mIGhyZWYgIT09ICdzdHJpbmcnIHx8ICFocmVmKSB7XG4gICAgICBlbmNvdW50ZXJlZCArPSBcIiBUaGUgYGhyZWZgIGFyZ3VtZW50IGVuY291bnRlcmVkIHdhcyBcIiArIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcoaHJlZikgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucyA9PSBudWxsIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgZW5jb3VudGVyZWQgKz0gXCIgVGhlIGBvcHRpb25zYCBhcmd1bWVudCBlbmNvdW50ZXJlZCB3YXMgXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdPYmplY3RGb3JXYXJuaW5nKG9wdGlvbnMpICsgXCIuXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5hcyAhPT0gJ3N0cmluZycgfHwgIW9wdGlvbnMuYXMpIHtcbiAgICAgIGVuY291bnRlcmVkICs9IFwiIFRoZSBgYXNgIG9wdGlvbiBlbmNvdW50ZXJlZCB3YXMgXCIgKyBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdPYmplY3RGb3JXYXJuaW5nKG9wdGlvbnMuYXMpICsgXCIuXCI7XG4gICAgfVxuXG4gICAgaWYgKGVuY291bnRlcmVkKSB7XG4gICAgICBlcnJvcignUmVhY3RET00ucHJlbG9hZCgpOiBFeHBlY3RlZCB0d28gYXJndW1lbnRzLCBhIG5vbi1lbXB0eSBgaHJlZmAgc3RyaW5nIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0IHdpdGggYW4gYGFzYCBwcm9wZXJ0eSB2YWxpZCBmb3IgYSBgPGxpbmsgcmVsPVwicHJlbG9hZFwiIGFzPVwiLi4uXCIgLz5gIHRhZy4lcycsIGVuY291bnRlcmVkKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGhyZWYgPT09ICdzdHJpbmcnICYmIGhyZWYgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgIT09IG51bGwgJiYgdHlwZW9mIG9wdGlvbnMuYXMgPT09ICdzdHJpbmcnICYmIG9wdGlvbnMuYXMpIHtcbiAgICB2YXIgYXMgPSBvcHRpb25zLmFzO1xuICAgIHZhciBrZXk7XG5cbiAgICBpZiAoYXMgPT09ICdpbWFnZScpIHtcbiAgICAgIC8vIEZvciBpbWFnZSBwcmVsb2FkcyB0aGUga2V5IGNvbnRhaW5zIGVpdGhlciB0aGUgaW1hZ2VTcmNTZXQgKyBpbWFnZVNpemVzIG9yIHRoZSBocmVmIGJ1dCBub3RcbiAgICAgIC8vIGJvdGguIFRoaXMgaXMgdG8gcHJldmVudCBpZGVudGljYWwgY2FsbHMgd2l0aCB0aGUgc2FtZSBzcmNTZXQgYW5kIHNpemVzIHRvIGJlIGR1cGxpY2F0ZWRcbiAgICAgIC8vIGJ5IHZhcnlpbmcgdGhlIGhyZWYuIHRoaXMgaXMgYW4gZWRnZSBjYXNlIGJ1dCBpdCBpcyB0aGUgbW9zdCBjb3JyZWN0IGJlaGF2aW9yLlxuICAgICAgdmFyIGltYWdlU3JjU2V0ID0gb3B0aW9ucy5pbWFnZVNyY1NldCxcbiAgICAgICAgICBpbWFnZVNpemVzID0gb3B0aW9ucy5pbWFnZVNpemVzO1xuICAgICAga2V5ID0gZ2V0SW1hZ2VQcmVsb2FkS2V5KGhyZWYsIGltYWdlU3JjU2V0LCBpbWFnZVNpemVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5ID0gZ2V0UmVzb3VyY2VLZXkoYXMsIGhyZWYpO1xuICAgIH1cblxuICAgIHZhciByZXNvdXJjZSA9IHJlc291cmNlcy5wcmVsb2Fkc01hcC5nZXQoa2V5KTtcblxuICAgIHtcbiAgICAgIHZhciBkZXZSZXNvdXJjZSA9IGdldEFzUmVzb3VyY2VERVYocmVzb3VyY2UpO1xuXG4gICAgICBpZiAoZGV2UmVzb3VyY2UpIHtcbiAgICAgICAgc3dpdGNoIChkZXZSZXNvdXJjZS5fX3Byb3ZlbmFuY2UpIHtcbiAgICAgICAgICBjYXNlICdwcmVsb2FkJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGRpZmZlcmVuY2VEZXNjcmlwdGlvbiA9IGRlc2NyaWJlRGlmZmVyZW5jZXNGb3JQcmVsb2FkcyhvcHRpb25zLCBkZXZSZXNvdXJjZS5fX29yaWdpbmFsT3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgaWYgKGRpZmZlcmVuY2VEZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIGVycm9yKCdSZWFjdERPTS5wcmVsb2FkKCk6IFRoZSBvcHRpb25zIHByb3ZpZGVkIGNvbmZsaWN0IHdpdGggYW5vdGhlciBjYWxsIHRvIGBSZWFjdERPTS5wcmVsb2FkKFwiJXNcIiwgeyBhczogXCIlc1wiLCAuLi59KWAuJyArICcgUmVhY3Qgd2lsbCBhbHdheXMgdXNlIHRoZSBvcHRpb25zIGl0IGZpcnN0IGVuY291bnRlcnMgd2hlbiBwcmVsb2FkaW5nIGEgcmVzb3VyY2UgZm9yIGEgZ2l2ZW4gYGhyZWZgIGFuZCBgYXNgIHR5cGUsIGFuZCBhbnkgbGF0ZXIgb3B0aW9ucyB3aWxsIGJlIGlnbm9yZWQgaWYgZGlmZmVyZW50LicgKyAnIFRyeSB1cGRhdGluZyBhbGwgY2FsbHMgdG8gYFJlYWN0RE9NLnByZWxvYWQoKWAgd2l0aCB0aGUgc2FtZSBgaHJlZmAgYW5kIGBhc2AgdHlwZSB0byB1c2UgdGhlIHNhbWUgb3B0aW9ucywgb3IgZWxpbWluYXRlIG9uZSBvZiB0aGUgY2FsbHMuJXMnLCBocmVmLCBhcywgZGlmZmVyZW5jZURlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnaW1wbGljaXQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgX2RpZmZlcmVuY2VEZXNjcmlwdGlvbjMgPSBkZXNjcmliZURpZmZlcmVuY2VzRm9yUHJlbG9hZE92ZXJJbXBsaWNpdFByZWxvYWQob3B0aW9ucywgZGV2UmVzb3VyY2UuX19pbXBsaWVkUHJvcHMpO1xuXG4gICAgICAgICAgICAgIGlmIChfZGlmZmVyZW5jZURlc2NyaXB0aW9uMykge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50RGVzY3JpcHRpb24gPSBhcyA9PT0gJ3N0eWxlJyA/ICc8bGluayByZWw9XCJzdHlsZXNoZWV0XCIgLi4uIC8+JyA6IGFzID09PSAnc2NyaXB0JyA/ICc8c2NyaXB0IC4uLiAvPicgOiBudWxsO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnREZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ1JlYWN0RE9NLnByZWxvYWQoKTogRm9yIGBocmVmYCBcIiVzXCIsIFRoZSBvcHRpb25zIHByb3ZpZGVkIGNvbmZsaWN0IHdpdGggcHJvcHMgb24gYSBtYXRjaGluZyAlcyBlbGVtZW50LiBXaGVuIHRoZSBwcmVsb2FkJyArICcgb3B0aW9ucyBkaXNhZ3JlZSB3aXRoIHRoZSB1bmRlcmx5aW5nIHJlc291cmNlIGl0IHVzdWFsbHkgbWVhbnMgdGhlIGJyb3dzZXIgd2lsbCBub3QgYmUgYWJsZSB0byB1c2UgdGhlIHByZWxvYWQgd2hlbiB0aGUgcmVzb3VyY2UnICsgJyBpcyBmZXRjaGVkLCBuZWdhdGluZyBhbnkgYmVuZWZpdCB0aGUgcHJlbG9hZCB3b3VsZCBwcm92aWRlLiBSZWFjdCB3aWxsIHByZWxvYWQgdGhlIHJlc291cmNlIHVzaW5nIHByb3BzIGRlcml2ZWQgZnJvbSB0aGUgcmVzb3VyY2UgaW5zdGVhZCcgKyAnIGFuZCBpZ25vcmUgdGhlIG9wdGlvbnMgcHJvdmlkZWQgdG8gdGhlIGBSZWFjdERPTS5wcmVsb2FkKClgIGNhbGwuIEluIGdlbmVyYWwsIHByZWxvYWRpbmcgaXMgdXNlZnVsIHdoZW4geW91IGV4cGVjdCB0bycgKyAnIHJlbmRlciBhIHJlc291cmNlIHNvb24gYnV0IGhhdmUgbm90IHlldCBkb25lIHNvLiBJbiB0aGlzIGNhc2Ugc2luY2UgdGhlIHVuZGVybHlpbmcgcmVzb3VyY2Ugd2FzIGFscmVhZHkgcmVuZGVyZWQgdGhlIHByZWxvYWQgY2FsbCcgKyAnIG1heSBiZSBleHRyYW5lb3VzLiBUcnkgcmVtb3ZpbmcgdGhlIGNhbGwsIG90aGVyd2lzZSB0cnkgYWRqdXN0aW5nIGJvdGggdGhlIHByb3BzIG9uIHRoZSAlcyBhbmQgdGhlIG9wdGlvbnMnICsgJyBwYXNzZWQgdG8gYFJlYWN0RE9NLnByZWxvYWQoKWAgdG8gYWdyZWUuJXMnLCBocmVmLCBlbGVtZW50RGVzY3JpcHRpb24sIGVsZW1lbnREZXNjcmlwdGlvbiwgX2RpZmZlcmVuY2VEZXNjcmlwdGlvbjMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFyZXNvdXJjZSkge1xuICAgICAgcmVzb3VyY2UgPSB7XG4gICAgICAgIHR5cGU6ICdwcmVsb2FkJyxcbiAgICAgICAgY2h1bmtzOiBbXSxcbiAgICAgICAgc3RhdGU6IE5vU3RhdGUsXG4gICAgICAgIHByb3BzOiBwcmVsb2FkUHJvcHNGcm9tUHJlbG9hZE9wdGlvbnMoaHJlZiwgYXMsIG9wdGlvbnMpXG4gICAgICB9O1xuICAgICAgcmVzb3VyY2VzLnByZWxvYWRzTWFwLnNldChrZXksIHJlc291cmNlKTtcblxuICAgICAge1xuICAgICAgICBtYXJrQXNJbXBlcmF0aXZlUmVzb3VyY2VERVYocmVzb3VyY2UsICdwcmVsb2FkJywgaHJlZiwgb3B0aW9ucywgcmVzb3VyY2UucHJvcHMpO1xuICAgICAgfVxuXG4gICAgICBwdXNoTGlua0ltcGwocmVzb3VyY2UuY2h1bmtzLCByZXNvdXJjZS5wcm9wcyk7XG4gICAgfVxuXG4gICAgaWYgKGFzID09PSAnZm9udCcpIHtcbiAgICAgIHJlc291cmNlcy5mb250UHJlbG9hZHMuYWRkKHJlc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKGFzID09PSAnaW1hZ2UnICYmIG9wdGlvbnMuZmV0Y2hQcmlvcml0eSA9PT0gJ2hpZ2gnKSB7XG4gICAgICByZXNvdXJjZXMuaGlnaEltYWdlUHJlbG9hZHMuYWRkKHJlc291cmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb3VyY2VzLmJ1bGtQcmVsb2Fkcy5hZGQocmVzb3VyY2UpO1xuICAgIH1cblxuICAgIGZsdXNoUmVzb3VyY2VzKHJlcXVlc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZWluaXQoaHJlZiwgb3B0aW9ucykge1xuXG4gIHZhciByZXF1ZXN0ID0gcmVzb2x2ZVJlcXVlc3QoKTtcblxuICBpZiAoIXJlcXVlc3QpIHtcbiAgICAvLyBJbiBhc3luYyBjb250ZXh0cyB3ZSBjYW4gc29tZXRpbWVzIHJlc29sdmUgcmVzb3VyY2VzIGZyb20gQXN5bmNMb2NhbFN0b3JhZ2UuIElmIHdlIGNhbid0IHdlIGNhbiBhbHNvXG4gICAgLy8gcG9zc2libHkgZ2V0IHRoZW0gZnJvbSB0aGUgc3RhY2sgaWYgd2UgYXJlIG5vdCBpbiBhbiBhc3luYyBjb250ZXh0LiBTaW5jZSB3ZSB3ZXJlIG5vdCBhYmxlIHRvIHJlc29sdmVcbiAgICAvLyB0aGUgcmVzb3VyY2VzIGZvciB0aGlzIGNhbGwgaW4gZWl0aGVyIGNhc2Ugd2Ugb3B0IHRvIGRvIG5vdGhpbmcuIFdlIGNhbiBjb25zaWRlciBtYWtpbmcgdGhpcyBhIHdhcm5pbmdcbiAgICAvLyBidXQgdGhlcmUgbWF5IGJlIHRpbWVzIHdoZXJlIGNhbGxpbmcgYSBmdW5jdGlvbiBvdXRzaWRlIG9mIHJlbmRlciBpcyBpbnRlbnRpb25hbCAoaS5lLiB0byB3YXJtIHVwIGRhdGFcbiAgICAvLyBmZXRjaGluZykgYW5kIHdlIGRvbid0IHdhbnQgdG8gd2FybiBpbiB0aG9zZSBjYXNlcy5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVzb3VyY2VzID0gZ2V0UmVzb3VyY2VzKHJlcXVlc3QpO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGhyZWYgIT09ICdzdHJpbmcnIHx8ICFocmVmKSB7XG4gICAgICBlcnJvcignUmVhY3RET00ucHJlaW5pdCgpOiBFeHBlY3RlZCB0aGUgYGhyZWZgIGFyZ3VtZW50IChmaXJzdCkgdG8gYmUgYSBub24tZW1wdHkgc3RyaW5nIGJ1dCBlbmNvdW50ZXJlZCAlcyBpbnN0ZWFkLicsIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcoaHJlZikpO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucyA9PSBudWxsIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgZXJyb3IoJ1JlYWN0RE9NLnByZWluaXQoKTogRXhwZWN0ZWQgdGhlIGBvcHRpb25zYCBhcmd1bWVudCAoc2Vjb25kKSB0byBiZSBhbiBvYmplY3Qgd2l0aCBhbiBgYXNgIHByb3BlcnR5IGRlc2NyaWJpbmcgdGhlIHR5cGUgb2YgcmVzb3VyY2UgdG8gYmUgcHJlaW5pdGlhbGl6ZWQgYnV0IGVuY291bnRlcmVkICVzIGluc3RlYWQuJywgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcob3B0aW9ucykpO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5hcyAhPT0gJ3N0eWxlJyAmJiBvcHRpb25zLmFzICE9PSAnc2NyaXB0Jykge1xuICAgICAgZXJyb3IoJ1JlYWN0RE9NLnByZWluaXQoKTogRXhwZWN0ZWQgdGhlIGBhc2AgcHJvcGVydHkgaW4gdGhlIGBvcHRpb25zYCBhcmd1bWVudCAoc2Vjb25kKSB0byBjb250YWluIGEgdmFsaWQgdmFsdWUgZGVzY3JpYmluZyB0aGUgdHlwZSBvZiByZXNvdXJjZSB0byBiZSBwcmVpbml0aWFsaXplZCBidXQgZW5jb3VudGVyZWQgJXMgaW5zdGVhZC4gVmFsaWQgdmFsdWVzIGZvciBgYXNgIGFyZSBcInN0eWxlXCIgYW5kIFwic2NyaXB0XCIuJywgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcob3B0aW9ucy5hcykpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgaHJlZiA9PT0gJ3N0cmluZycgJiYgaHJlZiAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgIHZhciBhcyA9IG9wdGlvbnMuYXM7XG5cbiAgICBzd2l0Y2ggKGFzKSB7XG4gICAgICBjYXNlICdzdHlsZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIga2V5ID0gZ2V0UmVzb3VyY2VLZXkoYXMsIGhyZWYpO1xuICAgICAgICAgIHZhciByZXNvdXJjZSA9IHJlc291cmNlcy5zdHlsZXNNYXAuZ2V0KGtleSk7XG4gICAgICAgICAgdmFyIHByZWNlZGVuY2UgPSBvcHRpb25zLnByZWNlZGVuY2UgfHwgJ2RlZmF1bHQnO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGRldlJlc291cmNlID0gZ2V0QXNSZXNvdXJjZURFVihyZXNvdXJjZSk7XG5cbiAgICAgICAgICAgIGlmIChkZXZSZXNvdXJjZSkge1xuICAgICAgICAgICAgICB2YXIgcmVzb3VyY2VQcm9wcyA9IHN0eWxlc2hlZXRQcm9wc0Zyb21QcmVpbml0T3B0aW9ucyhocmVmLCBwcmVjZWRlbmNlLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgICB2YXIgcHJvcHNFcXVpdmFsZW50ID0gYXNzaWduKHt9LCByZXNvdXJjZVByb3BzLCBfZGVmaW5lUHJvcGVydHkoe1xuICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IG9wdGlvbnMucHJlY2VkZW5jZVxuICAgICAgICAgICAgICB9LCAnZGF0YS1wcmVjZWRlbmNlJywgbnVsbCkpO1xuXG4gICAgICAgICAgICAgIHN3aXRjaCAoZGV2UmVzb3VyY2UuX19wcm92ZW5hbmNlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAncmVuZGVyZWQnOlxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlmZmVyZW5jZURlc2NyaXB0aW9uID0gZGVzY3JpYmVEaWZmZXJlbmNlc0ZvclByZWluaXRPdmVyU3R5bGVzaGVldCggLy8gRGlmZiB0aGUgcHJvcHMgZnJvbSB0aGUgSlNYIGVsZW1lbnQsIG5vdCB0aGUgZGVyaXZlZCByZXNvdXJjZSBwcm9wc1xuICAgICAgICAgICAgICAgICAgICBwcm9wc0VxdWl2YWxlbnQsIGRldlJlc291cmNlLl9fb3JpZ2luYWxQcm9wcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpZmZlcmVuY2VEZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdSZWFjdERPTS5wcmVpbml0KCk6IEZvciBgaHJlZmAgXCIlc1wiLCB0aGUgb3B0aW9ucyBwcm92aWRlZCBjb25mbGljdCB3aXRoIHByb3BzIGZvdW5kIG9uIGEgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIHByZWNlZGVuY2U9XCIlc1wiIGhyZWY9XCIlc1wiIC4uLi8+IHRoYXQgd2FzIGFscmVhZHkgcmVuZGVyZWQuJyArICcgUmVhY3Qgd2lsbCBhbHdheXMgdXNlIHRoZSBwcm9wcyBvciBvcHRpb25zIGl0IGZpcnN0IGVuY291bnRlcnMgZm9yIGEgaG9pc3RhYmxlIHN0eWxlc2hlZXQgZm9yIGEgZ2l2ZW4gYGhyZWZgIGFuZCBhbnkgbGF0ZXIgcHJvcHMgb3Igb3B0aW9ucyB3aWxsIGJlIGlnbm9yZWQgaWYgZGlmZmVyZW50LicgKyAnIEdlbmVyYWxseSwgUmVhY3RET00ucHJlaW5pdCgpIGlzIHVzZWZ1bCB3aGVuIHlvdSBhcmUgbm90IHlldCByZW5kZXJpbmcgYSBzdHlsZXNoZWV0IGJ1dCB5b3UgYW50aWNpcGF0ZSBpdCB3aWxsIGJlIHVzZWQgc29vbi4nICsgJyBJbiB0aGlzIGNhc2UgdGhlIHN0eWxlc2hlZXQgd2FzIGFscmVhZHkgcmVuZGVyZWQgc28gcHJlaW5pdGlhbGl6aW5nIGl0IGRvZXMgbm90IHByb3ZpZGUgYW55IGFkZGl0aW9uYWwgYmVuZWZpdC4nICsgJyBUbyByZXNvbHZlLCB0cnkgbWFraW5nIHRoZSBwcm9wcyBhbmQgb3B0aW9ucyBhZ3JlZSBiZXR3ZWVuIHRoZSA8bGluayByZWw9XCJzdHlsZXNoZWV0XCIgLi4uLz4gYW5kIHRoZSBgUmVhY3RET00ucHJlaW5pdCgpYCBjYWxsIG9yJyArICcgcmVtb3ZlIHRoZSBgUmVhY3RET00ucHJlaW5pdCgpYCBjYWxsLiVzJywgaHJlZiwgZGV2UmVzb3VyY2UuX19vcmlnaW5hbFByb3BzLnByZWNlZGVuY2UsIGhyZWYsIGRpZmZlcmVuY2VEZXNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNhc2UgJ3ByZWluaXQnOlxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2RpZmZlcmVuY2VEZXNjcmlwdGlvbjQgPSBkZXNjcmliZURpZmZlcmVuY2VzRm9yUHJlaW5pdHMoIC8vIERpZmYgdGhlIHByb3BzIGZyb20gdGhlIEpTWCBlbGVtZW50LCBub3QgdGhlIGRlcml2ZWQgcmVzb3VyY2UgcHJvcHNcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNFcXVpdmFsZW50LCBkZXZSZXNvdXJjZS5fX3Byb3BzRXF1aXZhbGVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kaWZmZXJlbmNlRGVzY3JpcHRpb240KSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ1JlYWN0RE9NLnByZWluaXQoKTogRm9yIGBocmVmYCBcIiVzXCIsIHRoZSBvcHRpb25zIHByb3ZpZGVkIGNvbmZsaWN0IHdpdGggYW5vdGhlciBjYWxsIHRvIGBSZWFjdERPTS5wcmVpbml0KFwiJXNcIiwgeyBhczogXCJzdHlsZVwiLCAuLi4gfSlgLicgKyAnIFJlYWN0IHdpbGwgYWx3YXlzIHVzZSB0aGUgb3B0aW9ucyBpdCBmaXJzdCBlbmNvdW50ZXJzIHdoZW4gcHJlaW5pdGlhbGl6aW5nIGEgaG9pc3RhYmxlIHN0eWxlc2hlZXQgZm9yIGEgZ2l2ZW4gYGhyZWZgIGFuZCBhbnkgbGF0ZXIgb3B0aW9ucyB3aWxsIGJlIGlnbm9yZWQgaWYgZGlmZmVyZW50LicgKyAnIFRyeSB1cGRhdGluZyBhbGwgY2FsbHMgdG8gYFJlYWN0RE9NLnByZWluaXQoKWAgZm9yIGEgZ2l2ZW4gYGhyZWZgIHRvIHVzZSB0aGUgc2FtZSBvcHRpb25zLCBvciBvbmx5IGNhbGwgYFJlYWN0RE9NLnByZWluaXQoKWAgb25jZSBwZXIgYGhyZWZgLiVzJywgaHJlZiwgaHJlZiwgX2RpZmZlcmVuY2VEZXNjcmlwdGlvbjQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXJlc291cmNlKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBOb1N0YXRlO1xuICAgICAgICAgICAgdmFyIHByZWxvYWRSZXNvdXJjZSA9IHJlc291cmNlcy5wcmVsb2Fkc01hcC5nZXQoa2V5KTtcblxuICAgICAgICAgICAgaWYgKHByZWxvYWRSZXNvdXJjZSAmJiBwcmVsb2FkUmVzb3VyY2Uuc3RhdGUgJiBGbHVzaGVkKSB7XG4gICAgICAgICAgICAgIHN0YXRlID0gUHJlbG9hZEZsdXNoZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc291cmNlID0ge1xuICAgICAgICAgICAgICB0eXBlOiAnc3R5bGVzaGVldCcsXG4gICAgICAgICAgICAgIGNodW5rczogW10sXG4gICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgcHJvcHM6IHN0eWxlc2hlZXRQcm9wc0Zyb21QcmVpbml0T3B0aW9ucyhocmVmLCBwcmVjZWRlbmNlLCBvcHRpb25zKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc291cmNlcy5zdHlsZXNNYXAuc2V0KGtleSwgcmVzb3VyY2UpO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG1hcmtBc0ltcGVyYXRpdmVSZXNvdXJjZURFVihyZXNvdXJjZSwgJ3ByZWluaXQnLCBocmVmLCBvcHRpb25zLCBhc3NpZ24oe30sIHJlc291cmNlLnByb3BzLCBfZGVmaW5lUHJvcGVydHkoe1xuICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IHByZWNlZGVuY2VcbiAgICAgICAgICAgICAgfSwgJ2RhdGEtcHJlY2VkZW5jZScsIHVuZGVmaW5lZCkpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHByZWNlZGVuY2VTZXQgPSByZXNvdXJjZXMucHJlY2VkZW5jZXMuZ2V0KHByZWNlZGVuY2UpO1xuXG4gICAgICAgICAgICBpZiAoIXByZWNlZGVuY2VTZXQpIHtcbiAgICAgICAgICAgICAgcHJlY2VkZW5jZVNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgcmVzb3VyY2VzLnByZWNlZGVuY2VzLnNldChwcmVjZWRlbmNlLCBwcmVjZWRlbmNlU2V0KTtcbiAgICAgICAgICAgICAgdmFyIGVtcHR5U3R5bGVSZXNvdXJjZSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3R5bGUnLFxuICAgICAgICAgICAgICAgIGNodW5rczogW10sXG4gICAgICAgICAgICAgICAgc3RhdGU6IE5vU3RhdGUsXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IHByZWNlZGVuY2UsXG4gICAgICAgICAgICAgICAgICBocmVmczogW11cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHByZWNlZGVuY2VTZXQuYWRkKGVtcHR5U3R5bGVSZXNvdXJjZSk7XG5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChyZXNvdXJjZXMuc3R5bGVQcmVjZWRlbmNlcy5oYXMocHJlY2VkZW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdSZWFjdCBjb25zdHJ1Y3RlZCBhbiBlbXB0eSBzdHlsZSByZXNvdXJjZSB3aGVuIGEgc3R5bGUgcmVzb3VyY2UgYWxyZWFkeSBleGlzdHMgZm9yIHRoaXMgcHJlY2VkZW5jZTogXCIlc1wiLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicsIHByZWNlZGVuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJlc291cmNlcy5zdHlsZVByZWNlZGVuY2VzLnNldChwcmVjZWRlbmNlLCBlbXB0eVN0eWxlUmVzb3VyY2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmVjZWRlbmNlU2V0LmFkZChyZXNvdXJjZSk7XG4gICAgICAgICAgICBmbHVzaFJlc291cmNlcyhyZXF1ZXN0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc2NyaXB0JzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBzcmMgPSBocmVmO1xuXG4gICAgICAgICAgdmFyIF9rZXkgPSBnZXRSZXNvdXJjZUtleShhcywgc3JjKTtcblxuICAgICAgICAgIHZhciBfcmVzb3VyY2UgPSByZXNvdXJjZXMuc2NyaXB0c01hcC5nZXQoX2tleSk7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2RldlJlc291cmNlID0gZ2V0QXNSZXNvdXJjZURFVihfcmVzb3VyY2UpO1xuXG4gICAgICAgICAgICBpZiAoX2RldlJlc291cmNlKSB7XG4gICAgICAgICAgICAgIHZhciBfcHJvcHNFcXVpdmFsZW50ID0gc2NyaXB0UHJvcHNGcm9tUHJlaW5pdE9wdGlvbnMoc3JjLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgICBzd2l0Y2ggKF9kZXZSZXNvdXJjZS5fX3Byb3ZlbmFuY2UpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdyZW5kZXJlZCc6XG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfZGlmZmVyZW5jZURlc2NyaXB0aW9uNSA9IGRlc2NyaWJlRGlmZmVyZW5jZXNGb3JQcmVpbml0T3ZlclNjcmlwdCggLy8gRGlmZiB0aGUgcHJvcHMgZnJvbSB0aGUgSlNYIGVsZW1lbnQsIG5vdCB0aGUgZGVyaXZlZCByZXNvdXJjZSBwcm9wc1xuICAgICAgICAgICAgICAgICAgICBfcHJvcHNFcXVpdmFsZW50LCBfZGV2UmVzb3VyY2UuX19vcmlnaW5hbFByb3BzKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoX2RpZmZlcmVuY2VEZXNjcmlwdGlvbjUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcignUmVhY3RET00ucHJlaW5pdCgpOiBGb3IgYGhyZWZgIFwiJXNcIiwgdGhlIG9wdGlvbnMgcHJvdmlkZWQgY29uZmxpY3Qgd2l0aCBwcm9wcyBmb3VuZCBvbiBhIDxzY3JpcHQgYXN5bmM9e3RydWV9IHNyYz1cIiVzXCIgLi4uLz4gdGhhdCB3YXMgYWxyZWFkeSByZW5kZXJlZC4nICsgJyBSZWFjdCB3aWxsIGFsd2F5cyB1c2UgdGhlIHByb3BzIG9yIG9wdGlvbnMgaXQgZmlyc3QgZW5jb3VudGVycyBmb3IgYSBob2lzdGFibGUgc2NyaXB0IGZvciBhIGdpdmVuIGBocmVmYCBhbmQgYW55IGxhdGVyIHByb3BzIG9yIG9wdGlvbnMgd2lsbCBiZSBpZ25vcmVkIGlmIGRpZmZlcmVudC4nICsgJyBHZW5lcmFsbHksIFJlYWN0RE9NLnByZWluaXQoKSBpcyB1c2VmdWwgd2hlbiB5b3UgYXJlIG5vdCB5ZXQgcmVuZGVyaW5nIGEgc2NyaXB0IGJ1dCB5b3UgYW50aWNpcGF0ZSBpdCB3aWxsIGJlIHVzZWQgc29vbiBhbmQgd2FudCB0byBnbyBiZXlvbmQgcHJlbG9hZGluZyBpdCBhbmQgaGF2ZSBpdCcgKyAnIGV4ZWN1dGUgZWFybHkuIEluIHRoaXMgY2FzZSB0aGUgc2NyaXB0IHdhcyBhbHJlYWR5IHJlbmRlcmVkIHNvIHByZWluaXRpYWxpemluZyBpdCBkb2VzIG5vdCBwcm92aWRlIGFueSBhZGRpdGlvbmFsIGJlbmVmaXQuJyArICcgVG8gcmVzb2x2ZSwgdHJ5IG1ha2luZyB0aGUgcHJvcHMgYW5kIG9wdGlvbnMgYWdyZWUgYmV0d2VlbiB0aGUgPHNjcmlwdCAuLi4vPiBhbmQgdGhlIGBSZWFjdERPTS5wcmVpbml0KClgIGNhbGwgb3IgcmVtb3ZlIHRoZSBgUmVhY3RET00ucHJlaW5pdCgpYCBjYWxsLiVzJywgaHJlZiwgaHJlZiwgX2RpZmZlcmVuY2VEZXNjcmlwdGlvbjUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjYXNlICdwcmVpbml0JzpcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9kaWZmZXJlbmNlRGVzY3JpcHRpb242ID0gZGVzY3JpYmVEaWZmZXJlbmNlc0ZvclByZWluaXRzKCAvLyBEaWZmIHRoZSBwcm9wcyBmcm9tIHRoZSBKU1ggZWxlbWVudCwgbm90IHRoZSBkZXJpdmVkIHJlc291cmNlIHByb3BzXG4gICAgICAgICAgICAgICAgICAgIF9wcm9wc0VxdWl2YWxlbnQsIF9kZXZSZXNvdXJjZS5fX3Byb3BzRXF1aXZhbGVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kaWZmZXJlbmNlRGVzY3JpcHRpb242KSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ1JlYWN0RE9NLnByZWluaXQoKTogRm9yIGBocmVmYCBcIiVzXCIsIHRoZSBvcHRpb25zIHByb3ZpZGVkIGNvbmZsaWN0IHdpdGggYW5vdGhlciBjYWxsIHRvIGBSZWFjdERPTS5wcmVpbml0KFwiJXNcIiwgeyBhczogXCJzY3JpcHRcIiwgLi4uIH0pYC4nICsgJyBSZWFjdCB3aWxsIGFsd2F5cyB1c2UgdGhlIG9wdGlvbnMgaXQgZmlyc3QgZW5jb3VudGVycyB3aGVuIHByZWluaXRpYWxpemluZyBhIGhvaXN0YWJsZSBzY3JpcHQgZm9yIGEgZ2l2ZW4gYGhyZWZgIGFuZCBhbnkgbGF0ZXIgb3B0aW9ucyB3aWxsIGJlIGlnbm9yZWQgaWYgZGlmZmVyZW50LicgKyAnIFRyeSB1cGRhdGluZyBhbGwgY2FsbHMgdG8gYFJlYWN0RE9NLnByZWluaXQoKWAgZm9yIGEgZ2l2ZW4gYGhyZWZgIHRvIHVzZSB0aGUgc2FtZSBvcHRpb25zLCBvciBvbmx5IGNhbGwgYFJlYWN0RE9NLnByZWluaXQoKWAgb25jZSBwZXIgYGhyZWZgLiVzJywgaHJlZiwgaHJlZiwgX2RpZmZlcmVuY2VEZXNjcmlwdGlvbjYpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIV9yZXNvdXJjZSkge1xuICAgICAgICAgICAgX3Jlc291cmNlID0ge1xuICAgICAgICAgICAgICB0eXBlOiAnc2NyaXB0JyxcbiAgICAgICAgICAgICAgY2h1bmtzOiBbXSxcbiAgICAgICAgICAgICAgc3RhdGU6IE5vU3RhdGUsXG4gICAgICAgICAgICAgIHByb3BzOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzb3VyY2VzLnNjcmlwdHNNYXAuc2V0KF9rZXksIF9yZXNvdXJjZSk7XG5cbiAgICAgICAgICAgIHZhciBfcmVzb3VyY2VQcm9wcyA9IHNjcmlwdFByb3BzRnJvbVByZWluaXRPcHRpb25zKHNyYywgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbWFya0FzSW1wZXJhdGl2ZVJlc291cmNlREVWKF9yZXNvdXJjZSwgJ3ByZWluaXQnLCBocmVmLCBvcHRpb25zLCBfcmVzb3VyY2VQcm9wcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc291cmNlcy5zY3JpcHRzLmFkZChfcmVzb3VyY2UpO1xuICAgICAgICAgICAgcHVzaFNjcmlwdEltcGwoX3Jlc291cmNlLmNodW5rcywgX3Jlc291cmNlUHJvcHMpO1xuICAgICAgICAgICAgZmx1c2hSZXNvdXJjZXMocmVxdWVzdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICB9XG59IC8vIFRoaXMgZnVuY3Rpb24gaXMgb25seSBzYWZlIHRvIGNhbGwgYXQgUmVxdWVzdCBzdGFydCB0aW1lIHNpbmNlIGl0IGFzc3VtZXNcbi8vIHRoYXQgZWFjaCBzY3JpcHQgaGFzIG5vdCBhbHJlYWR5IGJlZW4gcHJlbG9hZGVkLiBJZiB3ZSBmaW5kIGEgbmVlZCB0byBwcmVsb2FkXG4vLyBzY3JpcHRzIGF0IGFueSBvdGhlciBwb2ludCBpbiB0aW1lIHdlIHdpbGwgbmVlZCB0byBjaGVjayB3aGV0aGVyIHRoZSBwcmVsb2FkXG4vLyBhbHJlYWR5IGV4aXN0cyBhbmQgbm90IGFzc3VtZSBpdFxuXG5cbmZ1bmN0aW9uIHByZWxvYWRCb290c3RyYXBTY3JpcHQocmVzb3VyY2VzLCBzcmMsIG5vbmNlLCBpbnRlZ3JpdHksIGNyb3NzT3JpZ2luKSB7XG4gIHZhciBrZXkgPSBnZXRSZXNvdXJjZUtleSgnc2NyaXB0Jywgc3JjKTtcblxuICB7XG4gICAgaWYgKHJlc291cmNlcy5wcmVsb2Fkc01hcC5oYXMoa2V5KSkge1xuICAgICAgLy8gVGhpcyBpcyBjb2RlZCBhcyBhIFJlYWN0IGVycm9yIGJlY2F1c2UgaXQgc2hvdWxkIGJlIGltcG9zc2libGUgZm9yIGEgdXNlcnNwYWNlIHByZWxvYWQgdG8gcHJlZW1wdCB0aGlzIGNhbGxcbiAgICAgIC8vIElmIGEgdXNlcnNwYWNlIHByZWxvYWQgY2FuIHByZWVtcHQgaXQgdGhlbiB0aGlzIGFzc3VtcHRpb24gaXMgYnJva2VuIGFuZCB3ZSBuZWVkIHRvIHJlY29uc2lkZXIgdGhpcyBzdHJhdGVneVxuICAgICAgLy8gcmF0aGVyIHRoYW4gaW5zdHJ1Y3QgdGhlIHVzZXIgdG8gbm90IHByZWxvYWQgdGhlaXIgYm9vdHN0cmFwIHNjcmlwdHMgdGhlbXNlbHZlc1xuICAgICAgZXJyb3IoJ0ludGVybmFsIFJlYWN0IEVycm9yOiBSZWFjdCBleHBlY3RlZCBib290c3RyYXAgc2NyaXB0IHdpdGggc3JjIFwiJXNcIiB0byBub3QgaGF2ZSBiZWVuIHByZWxvYWRlZCBhbHJlYWR5LiBwbGVhc2UgZmlsZSBhbiBpc3N1ZScsIHNyYyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3BzID0ge1xuICAgIHJlbDogJ3ByZWxvYWQnLFxuICAgIGhyZWY6IHNyYyxcbiAgICBhczogJ3NjcmlwdCcsXG4gICAgZmV0Y2hQcmlvcml0eTogJ2xvdycsXG4gICAgbm9uY2U6IG5vbmNlLFxuICAgIGludGVncml0eTogaW50ZWdyaXR5LFxuICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpblxuICB9O1xuICB2YXIgcmVzb3VyY2UgPSB7XG4gICAgdHlwZTogJ3ByZWxvYWQnLFxuICAgIGNodW5rczogW10sXG4gICAgc3RhdGU6IE5vU3RhdGUsXG4gICAgcHJvcHM6IHByb3BzXG4gIH07XG4gIHJlc291cmNlcy5wcmVsb2Fkc01hcC5zZXQoa2V5LCByZXNvdXJjZSk7XG4gIHJlc291cmNlcy5ib290c3RyYXBTY3JpcHRzLmFkZChyZXNvdXJjZSk7XG4gIHB1c2hMaW5rSW1wbChyZXNvdXJjZS5jaHVua3MsIHByb3BzKTtcbn0gLy8gVGhpcyBmdW5jdGlvbiBpcyBvbmx5IHNhZmUgdG8gY2FsbCBhdCBSZXF1ZXN0IHN0YXJ0IHRpbWUgc2luY2UgaXQgYXNzdW1lc1xuLy8gdGhhdCBlYWNoIG1vZHVsZSBoYXMgbm90IGFscmVhZHkgYmVlbiBwcmVsb2FkZWQuIElmIHdlIGZpbmQgYSBuZWVkIHRvIHByZWxvYWRcbi8vIHNjcmlwdHMgYXQgYW55IG90aGVyIHBvaW50IGluIHRpbWUgd2Ugd2lsbCBuZWVkIHRvIGNoZWNrIHdoZXRoZXIgdGhlIHByZWxvYWRcbi8vIGFscmVhZHkgZXhpc3RzIGFuZCBub3QgYXNzdW1lIGl0XG5cblxuZnVuY3Rpb24gcHJlbG9hZEJvb3RzdHJhcE1vZHVsZShyZXNvdXJjZXMsIHNyYywgbm9uY2UsIGludGVncml0eSwgY3Jvc3NPcmlnaW4pIHtcbiAgdmFyIGtleSA9IGdldFJlc291cmNlS2V5KCdzY3JpcHQnLCBzcmMpO1xuXG4gIHtcbiAgICBpZiAocmVzb3VyY2VzLnByZWxvYWRzTWFwLmhhcyhrZXkpKSB7XG4gICAgICAvLyBUaGlzIGlzIGNvZGVkIGFzIGEgUmVhY3QgZXJyb3IgYmVjYXVzZSBpdCBzaG91bGQgYmUgaW1wb3NzaWJsZSBmb3IgYSB1c2Vyc3BhY2UgcHJlbG9hZCB0byBwcmVlbXB0IHRoaXMgY2FsbFxuICAgICAgLy8gSWYgYSB1c2Vyc3BhY2UgcHJlbG9hZCBjYW4gcHJlZW1wdCBpdCB0aGVuIHRoaXMgYXNzdW1wdGlvbiBpcyBicm9rZW4gYW5kIHdlIG5lZWQgdG8gcmVjb25zaWRlciB0aGlzIHN0cmF0ZWd5XG4gICAgICAvLyByYXRoZXIgdGhhbiBpbnN0cnVjdCB0aGUgdXNlciB0byBub3QgcHJlbG9hZCB0aGVpciBib290c3RyYXAgc2NyaXB0cyB0aGVtc2VsdmVzXG4gICAgICBlcnJvcignSW50ZXJuYWwgUmVhY3QgRXJyb3I6IFJlYWN0IGV4cGVjdGVkIGJvb3RzdHJhcCBtb2R1bGUgd2l0aCBzcmMgXCIlc1wiIHRvIG5vdCBoYXZlIGJlZW4gcHJlbG9hZGVkIGFscmVhZHkuIHBsZWFzZSBmaWxlIGFuIGlzc3VlJywgc3JjKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvcHMgPSB7XG4gICAgcmVsOiAnbW9kdWxlcHJlbG9hZCcsXG4gICAgaHJlZjogc3JjLFxuICAgIGZldGNoUHJpb3JpdHk6ICdsb3cnLFxuICAgIG5vbmNlOiBub25jZSxcbiAgICBpbnRlZ3JpdHk6IGludGVncml0eSxcbiAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW5cbiAgfTtcbiAgdmFyIHJlc291cmNlID0ge1xuICAgIHR5cGU6ICdwcmVsb2FkJyxcbiAgICBjaHVua3M6IFtdLFxuICAgIHN0YXRlOiBOb1N0YXRlLFxuICAgIHByb3BzOiBwcm9wc1xuICB9O1xuICByZXNvdXJjZXMucHJlbG9hZHNNYXAuc2V0KGtleSwgcmVzb3VyY2UpO1xuICByZXNvdXJjZXMuYm9vdHN0cmFwU2NyaXB0cy5hZGQocmVzb3VyY2UpO1xuICBwdXNoTGlua0ltcGwocmVzb3VyY2UuY2h1bmtzLCBwcm9wcyk7XG4gIHJldHVybjtcbn1cblxuZnVuY3Rpb24gaW50ZXJuYWxQcmVpbml0U2NyaXB0KHJlc291cmNlcywgc3JjLCBjaHVua3MpIHtcbiAgdmFyIGtleSA9IGdldFJlc291cmNlS2V5KCdzY3JpcHQnLCBzcmMpO1xuICB2YXIgcmVzb3VyY2UgPSByZXNvdXJjZXMuc2NyaXB0c01hcC5nZXQoa2V5KTtcblxuICBpZiAoIXJlc291cmNlKSB7XG4gICAgcmVzb3VyY2UgPSB7XG4gICAgICB0eXBlOiAnc2NyaXB0JyxcbiAgICAgIGNodW5rczogY2h1bmtzLFxuICAgICAgc3RhdGU6IE5vU3RhdGUsXG4gICAgICBwcm9wczogbnVsbFxuICAgIH07XG4gICAgcmVzb3VyY2VzLnNjcmlwdHNNYXAuc2V0KGtleSwgcmVzb3VyY2UpO1xuICAgIHJlc291cmNlcy5zY3JpcHRzLmFkZChyZXNvdXJjZSk7XG4gIH1cblxuICByZXR1cm47XG59XG5cbmZ1bmN0aW9uIHByZWxvYWRQcm9wc0Zyb21QcmVsb2FkT3B0aW9ucyhocmVmLCBhcywgb3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIHJlbDogJ3ByZWxvYWQnLFxuICAgIGFzOiBhcyxcbiAgICAvLyBUaGVyZSBpcyBhIGJ1ZyBpbiBTYWZhcmkgd2hlcmUgaW1hZ2VTcmNTZXQgaXMgbm90IHJlc3BlY3RlZCBvbiBwcmVsb2FkIGxpbmtzXG4gICAgLy8gc28gd2Ugb21pdCB0aGUgaHJlZiBoZXJlIGlmIHdlIGhhdmUgaW1hZ2VTcmNTZXQgYi9jIHNhZmFyaSB3aWxsIGxvYWQgdGhlIHdyb25nIGltYWdlLlxuICAgIC8vIFRoaXMgaGFybXMgb2xkZXIgYnJvd2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IGltYWdlU3JjU2V0IGJ5IG1ha2luZyB0aGVpciBwcmVsb2FkcyBub3Qgd29ya1xuICAgIC8vIGJ1dCB0aGlzIHBvcHVsYXRpb24gaXMgc2hyaW5raW5nIGZhc3QgYW5kIGlzIGFscmVhZHkgc21hbGwgc28gd2UgYWNjZXB0IHRoaXMgdHJhZGVvZmYuXG4gICAgaHJlZjogYXMgPT09ICdpbWFnZScgJiYgb3B0aW9ucy5pbWFnZVNyY1NldCA/IHVuZGVmaW5lZCA6IGhyZWYsXG4gICAgY3Jvc3NPcmlnaW46IGFzID09PSAnZm9udCcgPyAnJyA6IG9wdGlvbnMuY3Jvc3NPcmlnaW4sXG4gICAgaW50ZWdyaXR5OiBvcHRpb25zLmludGVncml0eSxcbiAgICB0eXBlOiBvcHRpb25zLnR5cGUsXG4gICAgbm9uY2U6IG9wdGlvbnMubm9uY2UsXG4gICAgZmV0Y2hQcmlvcml0eTogb3B0aW9ucy5mZXRjaFByaW9yaXR5LFxuICAgIGltYWdlU3JjU2V0OiBvcHRpb25zLmltYWdlU3JjU2V0LFxuICAgIGltYWdlU2l6ZXM6IG9wdGlvbnMuaW1hZ2VTaXplcyxcbiAgICByZWZlcnJlclBvbGljeTogb3B0aW9ucy5yZWZlcnJlclBvbGljeVxuICB9O1xufVxuXG5mdW5jdGlvbiBwcmVsb2FkQXNTdHlsZVByb3BzRnJvbVByb3BzKGhyZWYsIHByb3BzKSB7XG4gIHJldHVybiB7XG4gICAgcmVsOiAncHJlbG9hZCcsXG4gICAgYXM6ICdzdHlsZScsXG4gICAgaHJlZjogaHJlZixcbiAgICBjcm9zc09yaWdpbjogcHJvcHMuY3Jvc3NPcmlnaW4sXG4gICAgZmV0Y2hQcmlvcml0eTogcHJvcHMuZmV0Y2hQcmlvcml0eSxcbiAgICBpbnRlZ3JpdHk6IHByb3BzLmludGVncml0eSxcbiAgICBtZWRpYTogcHJvcHMubWVkaWEsXG4gICAgaHJlZkxhbmc6IHByb3BzLmhyZWZMYW5nLFxuICAgIHJlZmVycmVyUG9saWN5OiBwcm9wcy5yZWZlcnJlclBvbGljeVxuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZXNoZWV0UHJvcHNGcm9tUHJlaW5pdE9wdGlvbnMoaHJlZiwgcHJlY2VkZW5jZSwgb3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIHJlbDogJ3N0eWxlc2hlZXQnLFxuICAgIGhyZWY6IGhyZWYsXG4gICAgJ2RhdGEtcHJlY2VkZW5jZSc6IHByZWNlZGVuY2UsXG4gICAgY3Jvc3NPcmlnaW46IG9wdGlvbnMuY3Jvc3NPcmlnaW4sXG4gICAgaW50ZWdyaXR5OiBvcHRpb25zLmludGVncml0eSxcbiAgICBmZXRjaFByaW9yaXR5OiBvcHRpb25zLmZldGNoUHJpb3JpdHlcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVzaGVldFByb3BzRnJvbVJhd1Byb3BzKHJhd1Byb3BzKSB7XG4gIHJldHVybiBhc3NpZ24oe30sIHJhd1Byb3BzLCB7XG4gICAgJ2RhdGEtcHJlY2VkZW5jZSc6IHJhd1Byb3BzLnByZWNlZGVuY2UsXG4gICAgcHJlY2VkZW5jZTogbnVsbFxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRvcHRQcmVsb2FkUHJvcHNGb3JTdHlsZXNoZWV0UHJvcHMocmVzb3VyY2VQcm9wcywgcHJlbG9hZFByb3BzKSB7XG4gIGlmIChyZXNvdXJjZVByb3BzLmNyb3NzT3JpZ2luID09IG51bGwpIHJlc291cmNlUHJvcHMuY3Jvc3NPcmlnaW4gPSBwcmVsb2FkUHJvcHMuY3Jvc3NPcmlnaW47XG4gIGlmIChyZXNvdXJjZVByb3BzLmludGVncml0eSA9PSBudWxsKSByZXNvdXJjZVByb3BzLmludGVncml0eSA9IHByZWxvYWRQcm9wcy5pbnRlZ3JpdHk7XG59XG5cbmZ1bmN0aW9uIHNjcmlwdFByb3BzRnJvbVByZWluaXRPcHRpb25zKHNyYywgb3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIHNyYzogc3JjLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGNyb3NzT3JpZ2luOiBvcHRpb25zLmNyb3NzT3JpZ2luLFxuICAgIGludGVncml0eTogb3B0aW9ucy5pbnRlZ3JpdHksXG4gICAgbm9uY2U6IG9wdGlvbnMubm9uY2UsXG4gICAgZmV0Y2hQcmlvcml0eTogb3B0aW9ucy5mZXRjaFByaW9yaXR5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGFkb3B0UHJlbG9hZFByb3BzRm9yU2NyaXB0UHJvcHMocmVzb3VyY2VQcm9wcywgcHJlbG9hZFByb3BzKSB7XG4gIGlmIChyZXNvdXJjZVByb3BzLmNyb3NzT3JpZ2luID09IG51bGwpIHJlc291cmNlUHJvcHMuY3Jvc3NPcmlnaW4gPSBwcmVsb2FkUHJvcHMuY3Jvc3NPcmlnaW47XG4gIGlmIChyZXNvdXJjZVByb3BzLmludGVncml0eSA9PSBudWxsKSByZXNvdXJjZVByb3BzLmludGVncml0eSA9IHByZWxvYWRQcm9wcy5pbnRlZ3JpdHk7XG59XG5cbmZ1bmN0aW9uIGhvaXN0U3R5bGVSZXNvdXJjZShyZXNvdXJjZSkge1xuICB0aGlzLmFkZChyZXNvdXJjZSk7XG59XG5cbmZ1bmN0aW9uIGhvaXN0UmVzb3VyY2VzKHJlc291cmNlcywgc291cmNlKSB7XG4gIHZhciBjdXJyZW50Qm91bmRhcnlSZXNvdXJjZXMgPSByZXNvdXJjZXMuYm91bmRhcnlSZXNvdXJjZXM7XG5cbiAgaWYgKGN1cnJlbnRCb3VuZGFyeVJlc291cmNlcykge1xuICAgIHNvdXJjZS5mb3JFYWNoKGhvaXN0U3R5bGVSZXNvdXJjZSwgY3VycmVudEJvdW5kYXJ5UmVzb3VyY2VzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrQXNSZW5kZXJlZFJlc291cmNlREVWKHJlc291cmNlLCBvcmlnaW5hbFByb3BzKSB7XG4gIHtcbiAgICB2YXIgZGV2UmVzb3VyY2UgPSByZXNvdXJjZTtcblxuICAgIGlmICh0eXBlb2YgZGV2UmVzb3VyY2UuX19wcm92ZW5hbmNlID09PSAnc3RyaW5nJykge1xuICAgICAgZXJyb3IoJ1Jlc291cmNlIGFscmVhZHkgbWFya2VkIGZvciBERVYgdHlwZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICB9XG5cbiAgICBkZXZSZXNvdXJjZS5fX3Byb3ZlbmFuY2UgPSAncmVuZGVyZWQnO1xuICAgIGRldlJlc291cmNlLl9fb3JpZ2luYWxQcm9wcyA9IG9yaWdpbmFsUHJvcHM7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya0FzSW1wZXJhdGl2ZVJlc291cmNlREVWKHJlc291cmNlLCBwcm92ZW5hbmNlLCBvcmlnaW5hbEhyZWYsIG9yaWdpbmFsT3B0aW9ucywgcHJvcHNFcXVpdmFsZW50KSB7XG4gIHtcbiAgICB2YXIgZGV2UmVzb3VyY2UgPSByZXNvdXJjZTtcblxuICAgIGlmICh0eXBlb2YgZGV2UmVzb3VyY2UuX19wcm92ZW5hbmNlID09PSAnc3RyaW5nJykge1xuICAgICAgZXJyb3IoJ1Jlc291cmNlIGFscmVhZHkgbWFya2VkIGZvciBERVYgdHlwZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICB9XG5cbiAgICBkZXZSZXNvdXJjZS5fX3Byb3ZlbmFuY2UgPSBwcm92ZW5hbmNlO1xuICAgIGRldlJlc291cmNlLl9fb3JpZ2luYWxIcmVmID0gb3JpZ2luYWxIcmVmO1xuICAgIGRldlJlc291cmNlLl9fb3JpZ2luYWxPcHRpb25zID0gb3JpZ2luYWxPcHRpb25zO1xuICAgIGRldlJlc291cmNlLl9fcHJvcHNFcXVpdmFsZW50ID0gcHJvcHNFcXVpdmFsZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFzUmVzb3VyY2VERVYocmVzb3VyY2UpIHtcbiAge1xuICAgIGlmIChyZXNvdXJjZSkge1xuICAgICAgaWYgKHR5cGVvZiByZXNvdXJjZS5fX3Byb3ZlbmFuY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiByZXNvdXJjZTtcbiAgICAgIH1cblxuICAgICAgZXJyb3IoJ1Jlc291cmNlIHdhcyBub3QgbWFya2VkIGZvciBERVYgdHlwZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG52YXIgcmVxdWVzdFN0b3JhZ2UgPSBuZXcgYXN5bmNfaG9va3MuQXN5bmNMb2NhbFN0b3JhZ2UoKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0Jyk7XG52YXIgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnNlcnZlcl9jb250ZXh0Jyk7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5Jyk7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJyk7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbnZhciBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfREVGQVVMVF9WQUxVRV9OT1RfTE9BREVEID0gU3ltYm9sLmZvcigncmVhY3QuZGVmYXVsdF92YWx1ZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lO1xuXG4gIGlmIChkaXNwbGF5TmFtZSkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgfVxuXG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XG59IC8vIEtlZXAgaW4gc3luYyB3aXRoIHJlYWN0LXJlY29uY2lsZXIvZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlclxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufSAvLyBOb3RlIHRoYXQgdGhlIHJlY29uY2lsZXIgcGFja2FnZSBzaG91bGQgZ2VuZXJhbGx5IHByZWZlciB0byB1c2UgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcigpIGluc3RlYWQuXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY29udGV4dDIgPSB0eXBlO1xuICAgICAgICAgIHJldHVybiAoY29udGV4dDIuZGlzcGxheU5hbWUgfHwgY29udGV4dDIuX2dsb2JhbE5hbWUpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgLy8gaW4gc2ltcGxlIGNvbXBvbmVudHMgdG9vXG5cblxuICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgIC8vIHNpbGVuY2UgdGhlIGVycm9yLlxuICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbWF5YmVQcm9taXNlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcbiAgICAgICAgICAgICAgICAvLyBzcGxpY2UgaXQgaW4gdG8gbWFrZSB0aGUgc3RhY2sgbW9yZSByZWFkYWJsZS5cblxuXG4gICAgICAgICAgICAgICAgaWYgKGZuLmRpc3BsYXlOYW1lICYmIF9mcmFtZS5pbmNsdWRlcygnPGFub255bW91cz4nKSkge1xuICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVDbGFzc0NvbXBvbmVudEZyYW1lKGN0b3IsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoY3RvciwgdHJ1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdCQxKENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0JDEodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKGhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQ7XG5cbntcbiAgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0ID0ge307XG59XG5cbnZhciBlbXB0eUNvbnRleHRPYmplY3QgPSB7fTtcblxue1xuICBPYmplY3QuZnJlZXplKGVtcHR5Q29udGV4dE9iamVjdCk7XG59XG5cbmZ1bmN0aW9uIGdldE1hc2tlZENvbnRleHQodHlwZSwgdW5tYXNrZWRDb250ZXh0KSB7XG4gIHtcbiAgICB2YXIgY29udGV4dFR5cGVzID0gdHlwZS5jb250ZXh0VHlwZXM7XG5cbiAgICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgICAgcmV0dXJuIGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICB9XG5cbiAgICB2YXIgY29udGV4dCA9IHt9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIGNvbnRleHRUeXBlcykge1xuICAgICAgY29udGV4dFtrZXldID0gdW5tYXNrZWRDb250ZXh0W2tleV07XG4gICAgfVxuXG4gICAge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgJ1Vua25vd24nO1xuICAgICAgY2hlY2tQcm9wVHlwZXMoY29udGV4dFR5cGVzLCBjb250ZXh0LCAnY29udGV4dCcsIG5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzQ2hpbGRDb250ZXh0KGluc3RhbmNlLCB0eXBlLCBwYXJlbnRDb250ZXh0LCBjaGlsZENvbnRleHRUeXBlcykge1xuICB7XG4gICAgLy8gVE9ETyAoYnZhdWdobikgUmVwbGFjZSB0aGlzIGJlaGF2aW9yIHdpdGggYW4gaW52YXJpYW50KCkgaW4gdGhlIGZ1dHVyZS5cbiAgICAvLyBJdCBoYXMgb25seSBiZWVuIGFkZGVkIGluIEZpYmVyIHRvIG1hdGNoIHRoZSAodW5pbnRlbnRpb25hbCkgYmVoYXZpb3IgaW4gU3RhY2suXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgIGlmICghd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCclcy5jaGlsZENvbnRleHRUeXBlcyBpcyBzcGVjaWZpZWQgYnV0IHRoZXJlIGlzIG5vIGdldENoaWxkQ29udGV4dCgpIG1ldGhvZCAnICsgJ29uIHRoZSBpbnN0YW5jZS4gWW91IGNhbiBlaXRoZXIgZGVmaW5lIGdldENoaWxkQ29udGV4dCgpIG9uICVzIG9yIHJlbW92ZSAnICsgJ2NoaWxkQ29udGV4dFR5cGVzIGZyb20gaXQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkQ29udGV4dCA9IGluc3RhbmNlLmdldENoaWxkQ29udGV4dCgpO1xuXG4gICAgZm9yICh2YXIgY29udGV4dEtleSBpbiBjaGlsZENvbnRleHQpIHtcbiAgICAgIGlmICghKGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0VHlwZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8ICdVbmtub3duJykgKyBcIi5nZXRDaGlsZENvbnRleHQoKToga2V5IFxcXCJcIiArIGNvbnRleHRLZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8ICdVbmtub3duJztcbiAgICAgIGNoZWNrUHJvcFR5cGVzKGNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHQsICdjaGlsZCBjb250ZXh0JywgbmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFzc2lnbih7fSwgcGFyZW50Q29udGV4dCwgY2hpbGRDb250ZXh0KTtcbiAgfVxufVxuXG52YXIgcmVuZGVyZXJTaWdpbDtcblxue1xuICAvLyBVc2UgdGhpcyB0byBkZXRlY3QgbXVsdGlwbGUgcmVuZGVyZXJzIHVzaW5nIHRoZSBzYW1lIGNvbnRleHRcbiAgcmVuZGVyZXJTaWdpbCA9IHt9O1xufSAvLyBVc2VkIHRvIHN0b3JlIHRoZSBwYXJlbnQgcGF0aCBvZiBhbGwgY29udGV4dCBvdmVycmlkZXMgaW4gYSBzaGFyZWQgbGlua2VkIGxpc3QuXG4vLyBGb3JtaW5nIGEgcmV2ZXJzZSB0cmVlLlxuLy8gVGhlIHN0cnVjdHVyZSBvZiBhIGNvbnRleHQgc25hcHNob3QgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmaWxlLlxuLy8gQ3VycmVudGx5LCBpdCdzIGltcGxlbWVudGVkIGFzIHRyYWNraW5nIHRoZSBjdXJyZW50IGFjdGl2ZSBub2RlLlxuXG5cbnZhciByb290Q29udGV4dFNuYXBzaG90ID0gbnVsbDsgLy8gV2UgYXNzdW1lIHRoYXQgdGhpcyBydW50aW1lIG93bnMgdGhlIFwiY3VycmVudFwiIGZpZWxkIG9uIGFsbCBSZWFjdENvbnRleHQgaW5zdGFuY2VzLlxuLy8gVGhpcyBnbG9iYWwgKGFjdHVhbGx5IHRocmVhZCBsb2NhbCkgc3RhdGUgcmVwcmVzZW50cyB3aGF0IHN0YXRlIGFsbCB0aG9zZSBcImN1cnJlbnRcIixcbi8vIGZpZWxkcyBhcmUgY3VycmVudGx5IGluLlxuXG52YXIgY3VycmVudEFjdGl2ZVNuYXBzaG90ID0gbnVsbDtcblxuZnVuY3Rpb24gcG9wTm9kZShwcmV2KSB7XG4gIHtcbiAgICBwcmV2LmNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IHByZXYucGFyZW50VmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaE5vZGUobmV4dCkge1xuICB7XG4gICAgbmV4dC5jb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBuZXh0LnZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHByZXYsIG5leHQpIHtcbiAgaWYgKHByZXYgPT09IG5leHQpIDsgZWxzZSB7XG4gICAgcG9wTm9kZShwcmV2KTtcbiAgICB2YXIgcGFyZW50UHJldiA9IHByZXYucGFyZW50O1xuICAgIHZhciBwYXJlbnROZXh0ID0gbmV4dC5wYXJlbnQ7XG5cbiAgICBpZiAocGFyZW50UHJldiA9PT0gbnVsbCkge1xuICAgICAgaWYgKHBhcmVudE5leHQgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc3RhY2tzIG11c3QgcmVhY2ggdGhlIHJvb3QgYXQgdGhlIHNhbWUgdGltZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBhcmVudE5leHQgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc3RhY2tzIG11c3QgcmVhY2ggdGhlIHJvb3QgYXQgdGhlIHNhbWUgdGltZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cblxuICAgICAgcG9wVG9OZWFyZXN0Q29tbW9uQW5jZXN0b3IocGFyZW50UHJldiwgcGFyZW50TmV4dCk7XG4gICAgfSAvLyBPbiB0aGUgd2F5IGJhY2ssIHdlIHB1c2ggdGhlIG5ldyBvbmVzIHRoYXQgd2VyZW4ndCBjb21tb24uXG5cblxuICAgIHB1c2hOb2RlKG5leHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvcEFsbFByZXZpb3VzKHByZXYpIHtcbiAgcG9wTm9kZShwcmV2KTtcbiAgdmFyIHBhcmVudFByZXYgPSBwcmV2LnBhcmVudDtcblxuICBpZiAocGFyZW50UHJldiAhPT0gbnVsbCkge1xuICAgIHBvcEFsbFByZXZpb3VzKHBhcmVudFByZXYpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hBbGxOZXh0KG5leHQpIHtcbiAgdmFyIHBhcmVudE5leHQgPSBuZXh0LnBhcmVudDtcblxuICBpZiAocGFyZW50TmV4dCAhPT0gbnVsbCkge1xuICAgIHB1c2hBbGxOZXh0KHBhcmVudE5leHQpO1xuICB9XG5cbiAgcHVzaE5vZGUobmV4dCk7XG59XG5cbmZ1bmN0aW9uIHBvcFByZXZpb3VzVG9Db21tb25MZXZlbChwcmV2LCBuZXh0KSB7XG4gIHBvcE5vZGUocHJldik7XG4gIHZhciBwYXJlbnRQcmV2ID0gcHJldi5wYXJlbnQ7XG5cbiAgaWYgKHBhcmVudFByZXYgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBkZXB0aCBtdXN0IGVxdWFsIGF0IGxlYXN0IGF0IHplcm8gYmVmb3JlIHJlYWNoaW5nIHRoZSByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICB9XG5cbiAgaWYgKHBhcmVudFByZXYuZGVwdGggPT09IG5leHQuZGVwdGgpIHtcbiAgICAvLyBXZSBmb3VuZCB0aGUgc2FtZSBsZXZlbC4gTm93IHdlIGp1c3QgbmVlZCB0byBmaW5kIGEgc2hhcmVkIGFuY2VzdG9yLlxuICAgIHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHBhcmVudFByZXYsIG5leHQpO1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIG11c3Qgc3RpbGwgYmUgZGVlcGVyLlxuICAgIHBvcFByZXZpb3VzVG9Db21tb25MZXZlbChwYXJlbnRQcmV2LCBuZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BOZXh0VG9Db21tb25MZXZlbChwcmV2LCBuZXh0KSB7XG4gIHZhciBwYXJlbnROZXh0ID0gbmV4dC5wYXJlbnQ7XG5cbiAgaWYgKHBhcmVudE5leHQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBkZXB0aCBtdXN0IGVxdWFsIGF0IGxlYXN0IGF0IHplcm8gYmVmb3JlIHJlYWNoaW5nIHRoZSByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICB9XG5cbiAgaWYgKHByZXYuZGVwdGggPT09IHBhcmVudE5leHQuZGVwdGgpIHtcbiAgICAvLyBXZSBmb3VuZCB0aGUgc2FtZSBsZXZlbC4gTm93IHdlIGp1c3QgbmVlZCB0byBmaW5kIGEgc2hhcmVkIGFuY2VzdG9yLlxuICAgIHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHByZXYsIHBhcmVudE5leHQpO1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIG11c3Qgc3RpbGwgYmUgZGVlcGVyLlxuICAgIHBvcE5leHRUb0NvbW1vbkxldmVsKHByZXYsIHBhcmVudE5leHQpO1xuICB9XG5cbiAgcHVzaE5vZGUobmV4dCk7XG59IC8vIFBlcmZvcm0gY29udGV4dCBzd2l0Y2hpbmcgdG8gdGhlIG5ldyBzbmFwc2hvdC5cbi8vIFRvIG1ha2UgaXQgY2hlYXAgdG8gcmVhZCBtYW55IGNvbnRleHRzLCB3aGlsZSBub3Qgc3VzcGVuZGluZywgd2UgbWFrZSB0aGUgc3dpdGNoIGVhZ2VybHkgYnlcbi8vIHVwZGF0aW5nIGFsbCB0aGUgY29udGV4dCdzIGN1cnJlbnQgdmFsdWVzLiBUaGF0IHdheSByZWFkcywgYWx3YXlzIGp1c3QgcmVhZCB0aGUgY3VycmVudCB2YWx1ZS5cbi8vIEF0IHRoZSBjb3N0IG9mIHVwZGF0aW5nIGNvbnRleHRzIGV2ZW4gaWYgdGhleSdyZSBuZXZlciByZWFkIGJ5IHRoaXMgc3VidHJlZS5cblxuXG5mdW5jdGlvbiBzd2l0Y2hDb250ZXh0KG5ld1NuYXBzaG90KSB7XG4gIC8vIFRoZSBiYXNpYyBhbGdvcml0aG0gd2UgbmVlZCB0byBkbyBpcyB0byBwb3AgYmFjayBhbnkgY29udGV4dHMgdGhhdCBhcmUgbm8gbG9uZ2VyIG9uIHRoZSBzdGFjay5cbiAgLy8gV2UgYWxzbyBuZWVkIHRvIHVwZGF0ZSBhbnkgbmV3IGNvbnRleHRzIHRoYXQgYXJlIG5vdyBvbiB0aGUgc3RhY2sgd2l0aCB0aGUgZGVlcGVzdCB2YWx1ZS5cbiAgLy8gVGhlIGVhc2llc3Qgd2F5IHRvIHVwZGF0ZSBuZXcgY29udGV4dHMgaXMgdG8ganVzdCByZWFwcGx5IHRoZW0gaW4gcmV2ZXJzZSBvcmRlciBmcm9tIHRoZVxuICAvLyBwZXJzcGVjdGl2ZSBvZiB0aGUgYmFja3BvaW50ZXJzLiBUbyBhdm9pZCBhbGxvY2F0aW5nIGEgbG90IHdoZW4gc3dpdGNoaW5nLCB3ZSB1c2UgdGhlIHN0YWNrXG4gIC8vIGZvciB0aGF0LiBUaGVyZWZvcmUgdGhpcyBhbGdvcml0aG0gaXMgcmVjdXJzaXZlLlxuICAvLyAxKSBGaXJzdCB3ZSBwb3Agd2hpY2ggZXZlciBzbmFwc2hvdCB0cmVlIHdhcyBkZWVwZXN0LiBQb3BwaW5nIG9sZCBjb250ZXh0cyBhcyB3ZSBnby5cbiAgLy8gMikgVGhlbiB3ZSBmaW5kIHRoZSBuZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBmcm9tIHRoZXJlLiBQb3BwaW5nIG9sZCBjb250ZXh0cyBhcyB3ZSBnby5cbiAgLy8gMykgVGhlbiB3ZSByZWFwcGx5IG5ldyBjb250ZXh0cyBvbiB0aGUgd2F5IGJhY2sgdXAgdGhlIHN0YWNrLlxuICB2YXIgcHJldiA9IGN1cnJlbnRBY3RpdmVTbmFwc2hvdDtcbiAgdmFyIG5leHQgPSBuZXdTbmFwc2hvdDtcblxuICBpZiAocHJldiAhPT0gbmV4dCkge1xuICAgIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogVGhpcyBoYXMgdG8gYmUgbm9uLW51bGwgc2luY2UgaXQncyBub3QgZXF1YWwgdG8gcHJldi5cbiAgICAgIHB1c2hBbGxOZXh0KG5leHQpO1xuICAgIH0gZWxzZSBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgICAgcG9wQWxsUHJldmlvdXMocHJldik7XG4gICAgfSBlbHNlIGlmIChwcmV2LmRlcHRoID09PSBuZXh0LmRlcHRoKSB7XG4gICAgICBwb3BUb05lYXJlc3RDb21tb25BbmNlc3RvcihwcmV2LCBuZXh0KTtcbiAgICB9IGVsc2UgaWYgKHByZXYuZGVwdGggPiBuZXh0LmRlcHRoKSB7XG4gICAgICBwb3BQcmV2aW91c1RvQ29tbW9uTGV2ZWwocHJldiwgbmV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcE5leHRUb0NvbW1vbkxldmVsKHByZXYsIG5leHQpO1xuICAgIH1cblxuICAgIGN1cnJlbnRBY3RpdmVTbmFwc2hvdCA9IG5leHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHB1c2hQcm92aWRlcihjb250ZXh0LCBuZXh0VmFsdWUpIHtcbiAgdmFyIHByZXZWYWx1ZTtcblxuICB7XG4gICAgcHJldlZhbHVlID0gY29udGV4dC5fY3VycmVudFZhbHVlO1xuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IG5leHRWYWx1ZTtcblxuICAgIHtcbiAgICAgIGlmIChjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgIT09IHVuZGVmaW5lZCAmJiBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgIT09IG51bGwgJiYgY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSByZW5kZXJlclNpZ2lsKSB7XG4gICAgICAgIGVycm9yKCdEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgJyArICdzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLicpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSByZW5kZXJlclNpZ2lsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcmV2Tm9kZSA9IGN1cnJlbnRBY3RpdmVTbmFwc2hvdDtcbiAgdmFyIG5ld05vZGUgPSB7XG4gICAgcGFyZW50OiBwcmV2Tm9kZSxcbiAgICBkZXB0aDogcHJldk5vZGUgPT09IG51bGwgPyAwIDogcHJldk5vZGUuZGVwdGggKyAxLFxuICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgcGFyZW50VmFsdWU6IHByZXZWYWx1ZSxcbiAgICB2YWx1ZTogbmV4dFZhbHVlXG4gIH07XG4gIGN1cnJlbnRBY3RpdmVTbmFwc2hvdCA9IG5ld05vZGU7XG4gIHJldHVybiBuZXdOb2RlO1xufVxuZnVuY3Rpb24gcG9wUHJvdmlkZXIoY29udGV4dCkge1xuICB2YXIgcHJldlNuYXBzaG90ID0gY3VycmVudEFjdGl2ZVNuYXBzaG90O1xuXG4gIGlmIChwcmV2U25hcHNob3QgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyaWVkIHRvIHBvcCBhIENvbnRleHQgYXQgdGhlIHJvb3Qgb2YgdGhlIGFwcC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAocHJldlNuYXBzaG90LmNvbnRleHQgIT09IGNvbnRleHQpIHtcbiAgICAgIGVycm9yKCdUaGUgcGFyZW50IGNvbnRleHQgaXMgbm90IHRoZSBleHBlY3RlZCBjb250ZXh0LiBUaGlzIGlzIHByb2JhYmx5IGEgYnVnIGluIFJlYWN0LicpO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICB2YXIgdmFsdWUgPSBwcmV2U25hcHNob3QucGFyZW50VmFsdWU7XG5cbiAgICBpZiAodmFsdWUgPT09IFJFQUNUX1NFUlZFUl9DT05URVhUX0RFRkFVTFRfVkFMVUVfTk9UX0xPQURFRCkge1xuICAgICAgcHJldlNuYXBzaG90LmNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IHByZXZTbmFwc2hvdC5jb250ZXh0Ll9kZWZhdWx0VmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZXZTbmFwc2hvdC5jb250ZXh0Ll9jdXJyZW50VmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAoY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSB1bmRlZmluZWQgJiYgY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSBudWxsICYmIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAhPT0gcmVuZGVyZXJTaWdpbCkge1xuICAgICAgICBlcnJvcignRGV0ZWN0ZWQgbXVsdGlwbGUgcmVuZGVyZXJzIGNvbmN1cnJlbnRseSByZW5kZXJpbmcgdGhlICcgKyAnc2FtZSBjb250ZXh0IHByb3ZpZGVyLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC4nKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gcmVuZGVyZXJTaWdpbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3VycmVudEFjdGl2ZVNuYXBzaG90ID0gcHJldlNuYXBzaG90LnBhcmVudDtcbn1cbmZ1bmN0aW9uIGdldEFjdGl2ZUNvbnRleHQoKSB7XG4gIHJldHVybiBjdXJyZW50QWN0aXZlU25hcHNob3Q7XG59XG5mdW5jdGlvbiByZWFkQ29udGV4dCQxKGNvbnRleHQpIHtcbiAgdmFyIHZhbHVlID0gY29udGV4dC5fY3VycmVudFZhbHVlIDtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG1vZHVsZSBpcyBjdXJyZW50bHkgc2hhcmVkIGFuZCBhc3N1bWVkIHRvIGJlIHN0YXRlbGVzcy5cbiAqIElmIHRoaXMgYmVjb21lcyBhbiBhY3R1YWwgTWFwLCB0aGF0IHdpbGwgYnJlYWsuXG4gKi9cbmZ1bmN0aW9uIGdldChrZXkpIHtcbiAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbHM7XG59XG5mdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICBrZXkuX3JlYWN0SW50ZXJuYWxzID0gdmFsdWU7XG59XG5cbnZhciBkaWRXYXJuQWJvdXROb29wVXBkYXRlRm9yQ29tcG9uZW50ID0ge307XG52YXIgZGlkV2FybkFib3V0RGVwcmVjYXRlZFdpbGxNb3VudCA9IHt9O1xudmFyIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZTtcbnZhciBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGU7XG52YXIgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZTtcbnZhciBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGU7XG52YXIgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGU7XG52YXIgZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXM7XG52YXIgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlO1xudmFyIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjaztcblxue1xuICBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrID0gbmV3IFNldCgpO1xufVxuXG5mdW5jdGlvbiB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIGlmIChjYWxsYmFjayA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIga2V5ID0gY2FsbGVyTmFtZSArICdfJyArIGNhbGxiYWNrO1xuXG4gICAgaWYgKCFkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suaGFzKGtleSkpIHtcbiAgICAgIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5hZGQoa2V5KTtcblxuICAgICAgZXJyb3IoJyVzKC4uLik6IEV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjYWxsZXJOYW1lLCBjYWxsYmFjayk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5PblVuZGVmaW5lZERlcml2ZWRTdGF0ZSh0eXBlLCBwYXJ0aWFsU3RhdGUpIHtcbiAge1xuICAgIGlmIChwYXJ0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGVycm9yKCclcy5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKTogQSB2YWxpZCBzdGF0ZSBvYmplY3QgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuICcgKyAnWW91IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLicsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICB7XG4gICAgdmFyIF9jb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gX2NvbnN0cnVjdG9yICYmIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShfY29uc3RydWN0b3IpIHx8ICdSZWFjdENsYXNzJztcbiAgICB2YXIgd2FybmluZ0tleSA9IGNvbXBvbmVudE5hbWUgKyAnLicgKyBjYWxsZXJOYW1lO1xuXG4gICAgaWYgKGRpZFdhcm5BYm91dE5vb3BVcGRhdGVGb3JDb21wb25lbnRbd2FybmluZ0tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlcnJvcignJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb3V0c2lkZSBjb21wb25lbnRXaWxsTW91bnQoKSBvbiB0aGUgc2VydmVyLiAnICsgJ1RoaXMgaXMgYSBuby1vcC5cXG5cXG5QbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICBkaWRXYXJuQWJvdXROb29wVXBkYXRlRm9yQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgfVxufVxuXG52YXIgY2xhc3NDb21wb25lbnRVcGRhdGVyID0ge1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICAvLyAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGludGVybmFscyA9IGdldChpbnN0KTtcblxuICAgIGlmIChpbnRlcm5hbHMucXVldWUgPT09IG51bGwpIHtcbiAgICAgIHdhcm5Ob29wKGluc3QsICdzZXRTdGF0ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcm5hbHMucXVldWUucHVzaChwYXlsb2FkKTtcblxuICAgICAge1xuICAgICAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBpbnRlcm5hbHMgPSBnZXQoaW5zdCk7XG4gICAgaW50ZXJuYWxzLnJlcGxhY2UgPSB0cnVlO1xuICAgIGludGVybmFscy5xdWV1ZSA9IFtwYXlsb2FkXTtcblxuICAgIHtcbiAgICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvLyAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKGluc3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGludGVybmFscyA9IGdldChpbnN0KTtcblxuICAgIGlmIChpbnRlcm5hbHMucXVldWUgPT09IG51bGwpIHtcbiAgICAgIHdhcm5Ob29wKGluc3QsICdmb3JjZVVwZGF0ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMoaW5zdGFuY2UsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgcHJldlN0YXRlLCBuZXh0UHJvcHMpIHtcbiAgdmFyIHBhcnRpYWxTdGF0ZSA9IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSk7XG5cbiAge1xuICAgIHdhcm5PblVuZGVmaW5lZERlcml2ZWRTdGF0ZShjdG9yLCBwYXJ0aWFsU3RhdGUpO1xuICB9IC8vIE1lcmdlIHRoZSBwYXJ0aWFsIHN0YXRlIGFuZCB0aGUgcHJldmlvdXMgc3RhdGUuXG5cblxuICB2YXIgbmV3U3RhdGUgPSBwYXJ0aWFsU3RhdGUgPT09IG51bGwgfHwgcGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQgPyBwcmV2U3RhdGUgOiBhc3NpZ24oe30sIHByZXZTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKGN0b3IsIHByb3BzLCBtYXNrZWRMZWdhY3lDb250ZXh0KSB7XG4gIHZhciBjb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuICB2YXIgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuXG4gIHtcbiAgICBpZiAoJ2NvbnRleHRUeXBlJyBpbiBjdG9yKSB7XG4gICAgICB2YXIgaXNWYWxpZCA9IC8vIEFsbG93IG51bGwgZm9yIGNvbmRpdGlvbmFsIGRlY2xhcmF0aW9uXG4gICAgICBjb250ZXh0VHlwZSA9PT0gbnVsbCB8fCBjb250ZXh0VHlwZSAhPT0gdW5kZWZpbmVkICYmIGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgJiYgY29udGV4dFR5cGUuX2NvbnRleHQgPT09IHVuZGVmaW5lZDsgLy8gTm90IGEgPENvbnRleHQuQ29uc3VtZXI+XG5cbiAgICAgIGlmICghaXNWYWxpZCAmJiAhZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmhhcyhjdG9yKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuYWRkKGN0b3IpO1xuICAgICAgICB2YXIgYWRkZW5kdW0gPSAnJztcblxuICAgICAgICBpZiAoY29udGV4dFR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gdW5kZWZpbmVkLiAnICsgJ1RoaXMgY2FuIGJlIGNhdXNlZCBieSBhIHR5cG8gb3IgYnkgbWl4aW5nIHVwIG5hbWVkIGFuZCBkZWZhdWx0IGltcG9ydHMuICcgKyAnVGhpcyBjYW4gYWxzbyBoYXBwZW4gZHVlIHRvIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSwgc28gJyArICd0cnkgbW92aW5nIHRoZSBjcmVhdGVDb250ZXh0KCkgY2FsbCB0byBhIHNlcGFyYXRlIGZpbGUuJztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29udGV4dFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhICcgKyB0eXBlb2YgY29udGV4dFR5cGUgKyAnLic7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Qcm92aWRlciBpbnN0ZWFkPyc7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dFR5cGUuX2NvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIDxDb250ZXh0LkNvbnN1bWVyPlxuICAgICAgICAgIGFkZGVuZHVtID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIHRoZSBDb250ZXh0LkNvbnN1bWVyIGluc3RlYWQ/JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGFuIG9iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjb250ZXh0VHlwZSkuam9pbignLCAnKSArICd9Lic7XG4gICAgICAgIH1cblxuICAgICAgICBlcnJvcignJXMgZGVmaW5lcyBhbiBpbnZhbGlkIGNvbnRleHRUeXBlLiAnICsgJ2NvbnRleHRUeXBlIHNob3VsZCBwb2ludCB0byB0aGUgQ29udGV4dCBvYmplY3QgcmV0dXJuZWQgYnkgUmVhY3QuY3JlYXRlQ29udGV4dCgpLiVzJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnLCBhZGRlbmR1bSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICBjb250ZXh0ID0gcmVhZENvbnRleHQkMShjb250ZXh0VHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dCA9IG1hc2tlZExlZ2FjeUNvbnRleHQ7XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSBuZXcgY3Rvcihwcm9wcywgY29udGV4dCk7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgKGluc3RhbmNlLnN0YXRlID09PSBudWxsIHx8IGluc3RhbmNlLnN0YXRlID09PSB1bmRlZmluZWQpKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZXJyb3IoJ2Alc2AgdXNlcyBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBidXQgaXRzIGluaXRpYWwgc3RhdGUgaXMgJyArICclcy4gVGhpcyBpcyBub3QgcmVjb21tZW5kZWQuIEluc3RlYWQsIGRlZmluZSB0aGUgaW5pdGlhbCBzdGF0ZSBieSAnICsgJ2Fzc2lnbmluZyBhbiBvYmplY3QgdG8gYHRoaXMuc3RhdGVgIGluIHRoZSBjb25zdHJ1Y3RvciBvZiBgJXNgLiAnICsgJ1RoaXMgZW5zdXJlcyB0aGF0IGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGFyZ3VtZW50cyBoYXZlIGEgY29uc2lzdGVudCBzaGFwZS4nLCBjb21wb25lbnROYW1lLCBpbnN0YW5jZS5zdGF0ZSA9PT0gbnVsbCA/ICdudWxsJyA6ICd1bmRlZmluZWQnLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9IC8vIElmIG5ldyBjb21wb25lbnQgQVBJcyBhcmUgZGVmaW5lZCwgXCJ1bnNhZmVcIiBsaWZlY3ljbGVzIHdvbid0IGJlIGNhbGxlZC5cbiAgICAvLyBXYXJuIGFib3V0IHRoZXNlIGxpZmVjeWNsZXMgaWYgdGhleSBhcmUgcHJlc2VudC5cbiAgICAvLyBEb24ndCB3YXJuIGFib3V0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgbWV0aG9kcyB0aG91Z2guXG5cblxuICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgZm91bmRXaWxsTW91bnROYW1lID0gbnVsbDtcbiAgICAgIHZhciBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gbnVsbDtcbiAgICAgIHZhciBmb3VuZFdpbGxVcGRhdGVOYW1lID0gbnVsbDtcblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgZm91bmRXaWxsTW91bnROYW1lID0gJ2NvbXBvbmVudFdpbGxNb3VudCc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvdW5kV2lsbE1vdW50TmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9ICdjb21wb25lbnRXaWxsVXBkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSAnVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm91bmRXaWxsTW91bnROYW1lICE9PSBudWxsIHx8IGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgIT09IG51bGwgfHwgZm91bmRXaWxsVXBkYXRlTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgICAgdmFyIG5ld0FwaU5hbWUgPSB0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgPyAnZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCknIDogJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlKCknO1xuXG4gICAgICAgIGlmICghZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5oYXMoX2NvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgICAgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5hZGQoX2NvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgICAgZXJyb3IoJ1Vuc2FmZSBsZWdhY3kgbGlmZWN5Y2xlcyB3aWxsIG5vdCBiZSBjYWxsZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgbmV3IGNvbXBvbmVudCBBUElzLlxcblxcbicgKyAnJXMgdXNlcyAlcyBidXQgYWxzbyBjb250YWlucyB0aGUgZm9sbG93aW5nIGxlZ2FjeSBsaWZlY3ljbGVzOiVzJXMlc1xcblxcbicgKyAnVGhlIGFib3ZlIGxpZmVjeWNsZXMgc2hvdWxkIGJlIHJlbW92ZWQuIExlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6XFxuJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzJywgX2NvbXBvbmVudE5hbWUsIG5ld0FwaU5hbWUsIGZvdW5kV2lsbE1vdW50TmFtZSAhPT0gbnVsbCA/IFwiXFxuICBcIiArIGZvdW5kV2lsbE1vdW50TmFtZSA6ICcnLCBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lICE9PSBudWxsID8gXCJcXG4gIFwiICsgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA6ICcnLCBmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsID8gXCJcXG4gIFwiICsgZm91bmRXaWxsVXBkYXRlTmFtZSA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tDbGFzc0luc3RhbmNlKGluc3RhbmNlLCBjdG9yLCBuZXdQcm9wcykge1xuICB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG4gICAgdmFyIHJlbmRlclByZXNlbnQgPSBpbnN0YW5jZS5yZW5kZXI7XG5cbiAgICBpZiAoIXJlbmRlclByZXNlbnQpIHtcbiAgICAgIGlmIChjdG9yLnByb3RvdHlwZSAmJiB0eXBlb2YgY3Rvci5wcm90b3R5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVycm9yKCclcyguLi4pOiBObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlIHJldHVybmVkIGNvbXBvbmVudCAnICsgJ2luc3RhbmNlOiBkaWQgeW91IGFjY2lkZW50YWxseSByZXR1cm4gYW4gb2JqZWN0IGZyb20gdGhlIGNvbnN0cnVjdG9yPycsIG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IoJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IHlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gZGVmaW5lIGByZW5kZXJgLicsIG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUgJiYgIWluc3RhbmNlLmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCAmJiAhaW5zdGFuY2Uuc3RhdGUpIHtcbiAgICAgIGVycm9yKCdnZXRJbml0aWFsU3RhdGUgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGRlZmluZSBhIHN0YXRlIHByb3BlcnR5IGluc3RlYWQ/JywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmdldERlZmF1bHRQcm9wcyAmJiAhaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ1VzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLnByb3BUeXBlcykge1xuICAgICAgZXJyb3IoJ3Byb3BUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIHByb3BUeXBlcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5jb250ZXh0VHlwZSkge1xuICAgICAgZXJyb3IoJ2NvbnRleHRUeXBlIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGUgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAoaW5zdGFuY2UuY29udGV4dFR5cGVzKSB7XG4gICAgICAgIGVycm9yKCdjb250ZXh0VHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZXMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGN0b3IuY29udGV4dFR5cGUgJiYgY3Rvci5jb250ZXh0VHlwZXMgJiYgIWRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzLmhhcyhjdG9yKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcy5hZGQoY3Rvcik7XG5cbiAgICAgICAgZXJyb3IoJyVzIGRlY2xhcmVzIGJvdGggY29udGV4dFR5cGVzIGFuZCBjb250ZXh0VHlwZSBzdGF0aWMgcHJvcGVydGllcy4gJyArICdUaGUgbGVnYWN5IGNvbnRleHRUeXBlcyBwcm9wZXJ0eSB3aWxsIGJlIGlnbm9yZWQuJywgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRTaG91bGRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoY3Rvci5wcm90b3R5cGUgJiYgY3Rvci5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgJiYgdHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpLiAnICsgJ3Nob3VsZENvbXBvbmVudFVwZGF0ZSBzaG91bGQgbm90IGJlIHVzZWQgd2hlbiBleHRlbmRpbmcgUmVhY3QuUHVyZUNvbXBvbmVudC4gJyArICdQbGVhc2UgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgaXMgdXNlZC4nLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0EgcHVyZSBjb21wb25lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkVW5tb3VudCgpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0RpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsVW5tb3VudCgpPycsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFJlY2VpdmVQcm9wcygpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0lmIHlvdSBtZWFudCB0byB1cGRhdGUgdGhlIHN0YXRlIGluIHJlc3BvbnNlIHRvIGNoYW5naW5nIHByb3BzLCAnICsgJ3VzZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkuIElmIHlvdSBtZWFudCB0byBmZXRjaCBkYXRhIG9yICcgKyAncnVuIHNpZGUtZWZmZWN0cyBvciBtdXRhdGlvbnMgYWZ0ZXIgUmVhY3QgaGFzIHVwZGF0ZWQgdGhlIFVJLCB1c2UgY29tcG9uZW50RGlkVXBkYXRlKCkuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBoYXNNdXRhdGVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wcyAhPT0gbmV3UHJvcHM7XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMgIT09IHVuZGVmaW5lZCAmJiBoYXNNdXRhdGVkUHJvcHMpIHtcbiAgICAgIGVycm9yKCclcyguLi4pOiBXaGVuIGNhbGxpbmcgc3VwZXIoKSBpbiBgJXNgLCBtYWtlIHN1cmUgdG8gcGFzcyAnICsgXCJ1cCB0aGUgc2FtZSBwcm9wcyB0aGF0IHlvdXIgY29tcG9uZW50J3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC5cIiwgbmFtZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZXJyb3IoJ1NldHRpbmcgZGVmYXVsdFByb3BzIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgaWdub3JlZC4nICsgJyBJbnN0ZWFkLCBkZWZpbmUgZGVmYXVsdFByb3BzIGFzIGEgc3RhdGljIHByb3BlcnR5IG9uICVzLicsIG5hbWUsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJyAmJiAhZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmhhcyhjdG9yKSkge1xuICAgICAgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmFkZChjdG9yKTtcblxuICAgICAgZXJyb3IoJyVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIHNob3VsZCBiZSB1c2VkIHdpdGggY29tcG9uZW50RGlkVXBkYXRlKCkuICcgKyAnVGhpcyBjb21wb25lbnQgZGVmaW5lcyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIG9ubHkuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzOiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAnICsgJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXM6IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcigpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjdG9yLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgaXMgZGVmaW5lZCBhcyBhIHN0YXRpYyBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGFuIGluc3RhbmNlIG1ldGhvZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcblxuICAgIGlmIChzdGF0ZSAmJiAodHlwZW9mIHN0YXRlICE9PSAnb2JqZWN0JyB8fCBpc0FycmF5KHN0YXRlKSkpIHtcbiAgICAgIGVycm9yKCclcy5zdGF0ZTogbXVzdCBiZSBzZXQgdG8gYW4gb2JqZWN0IG9yIG51bGwnLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY3Rvci5jaGlsZENvbnRleHRUeXBlcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGVycm9yKCclcy5nZXRDaGlsZENvbnRleHQoKTogY2hpbGRDb250ZXh0VHlwZXMgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvICcgKyAndXNlIGdldENoaWxkQ29udGV4dCgpLicsIG5hbWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHR5cGUsIGluc3RhbmNlKSB7XG4gIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgaWYgKGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8ICdVbmtub3duJztcblxuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dERlcHJlY2F0ZWRXaWxsTW91bnRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICB3YXJuKCAvLyBrZWVwIHRoaXMgd2FybmluZyBpbiBzeW5jIHdpdGggUmVhY3RTdHJpY3RNb2RlV2FybmluZy5qc1xuICAgICAgICAgICdjb21wb25lbnRXaWxsTW91bnQgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGNvZGUgZnJvbSBjb21wb25lbnRXaWxsTW91bnQgdG8gY29tcG9uZW50RGlkTW91bnQgKHByZWZlcnJlZCBpbiBtb3N0IGNhc2VzKSAnICsgJ29yIHRoZSBjb25zdHJ1Y3Rvci5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZFdpbGxNb3VudFtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgfVxuXG4gIGlmIChvbGRTdGF0ZSAhPT0gaW5zdGFuY2Uuc3RhdGUpIHtcbiAgICB7XG4gICAgICBlcnJvcignJXMuY29tcG9uZW50V2lsbE1vdW50KCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byB0aGlzLnN0YXRlIGlzICcgKyBcImRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIiArICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgfVxuXG4gICAgY2xhc3NDb21wb25lbnRVcGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoaW5zdGFuY2UsIGluc3RhbmNlLnN0YXRlLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzVXBkYXRlUXVldWUoaW50ZXJuYWxJbnN0YW5jZSwgaW5zdCwgcHJvcHMsIG1hc2tlZExlZ2FjeUNvbnRleHQpIHtcbiAgaWYgKGludGVybmFsSW5zdGFuY2UucXVldWUgIT09IG51bGwgJiYgaW50ZXJuYWxJbnN0YW5jZS5xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgdmFyIG9sZFF1ZXVlID0gaW50ZXJuYWxJbnN0YW5jZS5xdWV1ZTtcbiAgICB2YXIgb2xkUmVwbGFjZSA9IGludGVybmFsSW5zdGFuY2UucmVwbGFjZTtcbiAgICBpbnRlcm5hbEluc3RhbmNlLnF1ZXVlID0gbnVsbDtcbiAgICBpbnRlcm5hbEluc3RhbmNlLnJlcGxhY2UgPSBmYWxzZTtcblxuICAgIGlmIChvbGRSZXBsYWNlICYmIG9sZFF1ZXVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaW5zdC5zdGF0ZSA9IG9sZFF1ZXVlWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbmV4dFN0YXRlID0gb2xkUmVwbGFjZSA/IG9sZFF1ZXVlWzBdIDogaW5zdC5zdGF0ZTtcbiAgICAgIHZhciBkb250TXV0YXRlID0gdHJ1ZTtcblxuICAgICAgZm9yICh2YXIgaSA9IG9sZFJlcGxhY2UgPyAxIDogMDsgaSA8IG9sZFF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0aWFsID0gb2xkUXVldWVbaV07XG4gICAgICAgIHZhciBwYXJ0aWFsU3RhdGUgPSB0eXBlb2YgcGFydGlhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcnRpYWwuY2FsbChpbnN0LCBuZXh0U3RhdGUsIHByb3BzLCBtYXNrZWRMZWdhY3lDb250ZXh0KSA6IHBhcnRpYWw7XG5cbiAgICAgICAgaWYgKHBhcnRpYWxTdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKGRvbnRNdXRhdGUpIHtcbiAgICAgICAgICAgIGRvbnRNdXRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIG5leHRTdGF0ZSA9IGFzc2lnbih7fSwgbmV4dFN0YXRlLCBwYXJ0aWFsU3RhdGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhc3NpZ24obmV4dFN0YXRlLCBwYXJ0aWFsU3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbnN0LnN0YXRlID0gbmV4dFN0YXRlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpbnRlcm5hbEluc3RhbmNlLnF1ZXVlID0gbnVsbDtcbiAgfVxufSAvLyBJbnZva2VzIHRoZSBtb3VudCBsaWZlLWN5Y2xlcyBvbiBhIHByZXZpb3VzbHkgbmV2ZXIgcmVuZGVyZWQgaW5zdGFuY2UuXG5cblxuZnVuY3Rpb24gbW91bnRDbGFzc0luc3RhbmNlKGluc3RhbmNlLCBjdG9yLCBuZXdQcm9wcywgbWFza2VkTGVnYWN5Q29udGV4dCkge1xuICB7XG4gICAgY2hlY2tDbGFzc0luc3RhbmNlKGluc3RhbmNlLCBjdG9yLCBuZXdQcm9wcyk7XG4gIH1cblxuICB2YXIgaW5pdGlhbFN0YXRlID0gaW5zdGFuY2Uuc3RhdGUgIT09IHVuZGVmaW5lZCA/IGluc3RhbmNlLnN0YXRlIDogbnVsbDtcbiAgaW5zdGFuY2UudXBkYXRlciA9IGNsYXNzQ29tcG9uZW50VXBkYXRlcjtcbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSBpbml0aWFsU3RhdGU7IC8vIFdlIGRvbid0IGJvdGhlciBpbml0aWFsaXppbmcgdGhlIHJlZnMgb2JqZWN0IG9uIHRoZSBzZXJ2ZXIsIHNpbmNlIHdlJ3JlIG5vdCBnb2luZyB0byByZXNvbHZlIHRoZW0gYW55d2F5LlxuICAvLyBUaGUgaW50ZXJuYWwgaW5zdGFuY2Ugd2lsbCBiZSB1c2VkIHRvIG1hbmFnZSB1cGRhdGVzIHRoYXQgaGFwcGVuIGR1cmluZyB0aGlzIG1vdW50LlxuXG4gIHZhciBpbnRlcm5hbEluc3RhbmNlID0ge1xuICAgIHF1ZXVlOiBbXSxcbiAgICByZXBsYWNlOiBmYWxzZVxuICB9O1xuICBzZXQoaW5zdGFuY2UsIGludGVybmFsSW5zdGFuY2UpO1xuICB2YXIgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IHJlYWRDb250ZXh0JDEoY29udGV4dFR5cGUpO1xuICB9IGVsc2Uge1xuICAgIGluc3RhbmNlLmNvbnRleHQgPSBtYXNrZWRMZWdhY3lDb250ZXh0O1xuICB9XG5cbiAge1xuICAgIGlmIChpbnN0YW5jZS5zdGF0ZSA9PT0gbmV3UHJvcHMpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlLmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdG8gYXNzaWduIHByb3BzIGRpcmVjdGx5IHRvIHN0YXRlICcgKyBcImJlY2F1c2UgdXBkYXRlcyB0byBwcm9wcyB3b24ndCBiZSByZWZsZWN0ZWQgaW4gc3RhdGUuIFwiICsgJ0luIG1vc3QgY2FzZXMsIGl0IGlzIGJldHRlciB0byB1c2UgcHJvcHMgZGlyZWN0bHkuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2Uuc3RhdGUgPSBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyhpbnN0YW5jZSwgY3RvciwgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLCBpbml0aWFsU3RhdGUsIG5ld1Byb3BzKTtcbiAgfSAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cblxuXG4gIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICE9PSAnZnVuY3Rpb24nICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSkge1xuICAgIGNhbGxDb21wb25lbnRXaWxsTW91bnQoY3RvciwgaW5zdGFuY2UpOyAvLyBJZiB3ZSBoYWQgYWRkaXRpb25hbCBzdGF0ZSB1cGRhdGVzIGR1cmluZyB0aGlzIGxpZmUtY3ljbGUsIGxldCdzXG4gICAgLy8gcHJvY2VzcyB0aGVtIG5vdy5cblxuICAgIHByb2Nlc3NVcGRhdGVRdWV1ZShpbnRlcm5hbEluc3RhbmNlLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG1hc2tlZExlZ2FjeUNvbnRleHQpO1xuICB9XG59XG5cbi8vIElkcyBhcmUgYmFzZSAzMiBzdHJpbmdzIHdob3NlIGJpbmFyeSByZXByZXNlbnRhdGlvbiBjb3JyZXNwb25kcyB0byB0aGVcbi8vIHBvc2l0aW9uIG9mIGEgbm9kZSBpbiBhIHRyZWUuXG4vLyBFdmVyeSB0aW1lIHRoZSB0cmVlIGZvcmtzIGludG8gbXVsdGlwbGUgY2hpbGRyZW4sIHdlIGFkZCBhZGRpdGlvbmFsIGJpdHMgdG9cbi8vIHRoZSBsZWZ0IG9mIHRoZSBzZXF1ZW5jZSB0aGF0IHJlcHJlc2VudCB0aGUgcG9zaXRpb24gb2YgdGhlIGNoaWxkIHdpdGhpbiB0aGVcbi8vIGN1cnJlbnQgbGV2ZWwgb2YgY2hpbGRyZW4uXG4vL1xuLy8gICAgICAwMDEwMSAgICAgICAwMDAxMDAwMTAxMTAxMDEwMVxuLy8gICAgICDilbDilIDilKzilIDila8gICAgICAg4pWw4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pWvXG4vLyAgIEZvcmsgNSBvZiAyMCAgICAgICBQYXJlbnQgaWRcbi8vXG4vLyBUaGUgbGVhZGluZyAwcyBhcmUgaW1wb3J0YW50LiBJbiB0aGUgYWJvdmUgZXhhbXBsZSwgeW91IG9ubHkgbmVlZCAzIGJpdHMgdG9cbi8vIHJlcHJlc2VudCBzbG90IDUuIEhvd2V2ZXIsIHlvdSBuZWVkIDUgYml0cyB0byByZXByZXNlbnQgYWxsIHRoZSBmb3JrcyBhdFxuLy8gdGhlIGN1cnJlbnQgbGV2ZWwsIHNvIHdlIG11c3QgYWNjb3VudCBmb3IgdGhlIGVtcHR5IGJpdHMgYXQgdGhlIGVuZC5cbi8vXG4vLyBGb3IgdGhpcyBzYW1lIHJlYXNvbiwgc2xvdHMgYXJlIDEtaW5kZXhlZCBpbnN0ZWFkIG9mIDAtaW5kZXhlZC4gT3RoZXJ3aXNlLFxuLy8gdGhlIHplcm90aCBpZCBhdCBhIGxldmVsIHdvdWxkIGJlIGluZGlzdGluZ3Vpc2hhYmxlIGZyb20gaXRzIHBhcmVudC5cbi8vXG4vLyBJZiBhIG5vZGUgaGFzIG9ubHkgb25lIGNoaWxkLCBhbmQgZG9lcyBub3QgbWF0ZXJpYWxpemUgYW4gaWQgKGkuZS4gZG9lcyBub3Rcbi8vIGNvbnRhaW4gYSB1c2VJZCBob29rKSwgdGhlbiB3ZSBkb24ndCBuZWVkIHRvIGFsbG9jYXRlIGFueSBzcGFjZSBpbiB0aGVcbi8vIHNlcXVlbmNlLiBJdCdzIHRyZWF0ZWQgYXMgYSB0cmFuc3BhcmVudCBpbmRpcmVjdGlvbi4gRm9yIGV4YW1wbGUsIHRoZXNlIHR3b1xuLy8gdHJlZXMgcHJvZHVjZSB0aGUgc2FtZSBpZHM6XG4vL1xuLy8gPD4gICAgICAgICAgICAgICAgICAgICAgICAgIDw+XG4vLyAgIDxJbmRpcmVjdGlvbj4gICAgICAgICAgICAgICA8QSAvPlxuLy8gICAgIDxBIC8+ICAgICAgICAgICAgICAgICAgICAgPEIgLz5cbi8vICAgPC9JbmRpcmVjdGlvbj4gICAgICAgICAgICA8Lz5cbi8vICAgPEIgLz5cbi8vIDwvPlxuLy9cbi8vIEhvd2V2ZXIsIHdlIGNhbm5vdCBza2lwIGFueSBub2RlIHRoYXQgbWF0ZXJpYWxpemVzIGFuIGlkLiBPdGhlcndpc2UsIGEgcGFyZW50XG4vLyBpZCB0aGF0IGRvZXMgbm90IGZvcmsgd291bGQgYmUgaW5kaXN0aW5ndWlzaGFibGUgZnJvbSBpdHMgY2hpbGQgaWQuIEZvclxuLy8gZXhhbXBsZSwgdGhpcyB0cmVlIGRvZXMgbm90IGZvcmssIGJ1dCB0aGUgcGFyZW50IGFuZCBjaGlsZCBtdXN0IGhhdmVcbi8vIGRpZmZlcmVudCBpZHMuXG4vL1xuLy8gPFBhcmVudD5cbi8vICAgPENoaWxkIC8+XG4vLyA8L1BhcmVudD5cbi8vXG4vLyBUbyBoYW5kbGUgdGhpcyBzY2VuYXJpbywgZXZlcnkgdGltZSB3ZSBtYXRlcmlhbGl6ZSBhbiBpZCwgd2UgYWxsb2NhdGUgYVxuLy8gbmV3IGxldmVsIHdpdGggYSBzaW5nbGUgc2xvdC4gWW91IGNhbiB0aGluayBvZiB0aGlzIGFzIGEgZm9yayB3aXRoIG9ubHkgb25lXG4vLyBwcm9uZywgb3IgYW4gYXJyYXkgb2YgY2hpbGRyZW4gd2l0aCBsZW5ndGggMS5cbi8vXG4vLyBJdCdzIHBvc3NpYmxlIGZvciB0aGUgc2l6ZSBvZiB0aGUgc2VxdWVuY2UgdG8gZXhjZWVkIDMyIGJpdHMsIHRoZSBtYXhcbi8vIHNpemUgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucy4gV2hlbiB0aGlzIGhhcHBlbnMsIHdlIG1ha2UgbW9yZSByb29tIGJ5XG4vLyBjb252ZXJ0aW5nIHRoZSByaWdodCBwYXJ0IG9mIHRoZSBpZCB0byBhIHN0cmluZyBhbmQgc3RvcmluZyBpdCBpbiBhbiBvdmVyZmxvd1xuLy8gdmFyaWFibGUuIFdlIHVzZSBhIGJhc2UgMzIgc3RyaW5nIHJlcHJlc2VudGF0aW9uLCBiZWNhdXNlIDMyIGlzIHRoZSBsYXJnZXN0XG4vLyBwb3dlciBvZiAyIHRoYXQgaXMgc3VwcG9ydGVkIGJ5IHRvU3RyaW5nKCkuIFdlIHdhbnQgdGhlIGJhc2UgdG8gYmUgbGFyZ2Ugc29cbi8vIHRoYXQgdGhlIHJlc3VsdGluZyBpZHMgYXJlIGNvbXBhY3QsIGFuZCB3ZSB3YW50IHRoZSBiYXNlIHRvIGJlIGEgcG93ZXIgb2YgMlxuLy8gYmVjYXVzZSBldmVyeSBsb2cyKGJhc2UpIGJpdHMgY29ycmVzcG9uZHMgdG8gYSBzaW5nbGUgY2hhcmFjdGVyLCBpLmUuIGV2ZXJ5XG4vLyBsb2cyKDMyKSA9IDUgYml0cy4gVGhhdCBtZWFucyB3ZSBjYW4gbG9wIGJpdHMgb2ZmIHRoZSBlbmQgNSBhdCBhIHRpbWUgd2l0aG91dFxuLy8gYWZmZWN0aW5nIHRoZSBmaW5hbCByZXN1bHQuXG52YXIgZW1wdHlUcmVlQ29udGV4dCA9IHtcbiAgaWQ6IDEsXG4gIG92ZXJmbG93OiAnJ1xufTtcbmZ1bmN0aW9uIGdldFRyZWVJZChjb250ZXh0KSB7XG4gIHZhciBvdmVyZmxvdyA9IGNvbnRleHQub3ZlcmZsb3c7XG4gIHZhciBpZFdpdGhMZWFkaW5nQml0ID0gY29udGV4dC5pZDtcbiAgdmFyIGlkID0gaWRXaXRoTGVhZGluZ0JpdCAmIH5nZXRMZWFkaW5nQml0KGlkV2l0aExlYWRpbmdCaXQpO1xuICByZXR1cm4gaWQudG9TdHJpbmcoMzIpICsgb3ZlcmZsb3c7XG59XG5mdW5jdGlvbiBwdXNoVHJlZUNvbnRleHQoYmFzZUNvbnRleHQsIHRvdGFsQ2hpbGRyZW4sIGluZGV4KSB7XG4gIHZhciBiYXNlSWRXaXRoTGVhZGluZ0JpdCA9IGJhc2VDb250ZXh0LmlkO1xuICB2YXIgYmFzZU92ZXJmbG93ID0gYmFzZUNvbnRleHQub3ZlcmZsb3c7IC8vIFRoZSBsZWZ0bW9zdCAxIG1hcmtzIHRoZSBlbmQgb2YgdGhlIHNlcXVlbmNlLCBub24taW5jbHVzaXZlLiBJdCdzIG5vdCBwYXJ0XG4gIC8vIG9mIHRoZSBpZDsgd2UgdXNlIGl0IHRvIGFjY291bnQgZm9yIGxlYWRpbmcgMHMuXG5cbiAgdmFyIGJhc2VMZW5ndGggPSBnZXRCaXRMZW5ndGgoYmFzZUlkV2l0aExlYWRpbmdCaXQpIC0gMTtcbiAgdmFyIGJhc2VJZCA9IGJhc2VJZFdpdGhMZWFkaW5nQml0ICYgfigxIDw8IGJhc2VMZW5ndGgpO1xuICB2YXIgc2xvdCA9IGluZGV4ICsgMTtcbiAgdmFyIGxlbmd0aCA9IGdldEJpdExlbmd0aCh0b3RhbENoaWxkcmVuKSArIGJhc2VMZW5ndGg7IC8vIDMwIGlzIHRoZSBtYXggbGVuZ3RoIHdlIGNhbiBzdG9yZSB3aXRob3V0IG92ZXJmbG93aW5nLCB0YWtpbmcgaW50b1xuICAvLyBjb25zaWRlcmF0aW9uIHRoZSBsZWFkaW5nIDEgd2UgdXNlIHRvIG1hcmsgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UuXG5cbiAgaWYgKGxlbmd0aCA+IDMwKSB7XG4gICAgLy8gV2Ugb3ZlcmZsb3dlZCB0aGUgYml0d2lzZS1zYWZlIHJhbmdlLiBGYWxsIGJhY2sgdG8gc2xvd2VyIGFsZ29yaXRobS5cbiAgICAvLyBUaGlzIGJyYW5jaCBhc3N1bWVzIHRoZSBsZW5ndGggb2YgdGhlIGJhc2UgaWQgaXMgZ3JlYXRlciB0aGFuIDU7IGl0IHdvbid0XG4gICAgLy8gd29yayBmb3Igc21hbGxlciBpZHMsIGJlY2F1c2UgeW91IG5lZWQgNSBiaXRzIHBlciBjaGFyYWN0ZXIuXG4gICAgLy9cbiAgICAvLyBXZSBlbmNvZGUgdGhlIGlkIGluIG11bHRpcGxlIHN0ZXBzOiBmaXJzdCB0aGUgYmFzZSBpZCwgdGhlbiB0aGVcbiAgICAvLyByZW1haW5pbmcgZGlnaXRzLlxuICAgIC8vXG4gICAgLy8gRWFjaCA1IGJpdCBzZXF1ZW5jZSBjb3JyZXNwb25kcyB0byBhIHNpbmdsZSBiYXNlIDMyIGNoYXJhY3Rlci4gU28gZm9yXG4gICAgLy8gZXhhbXBsZSwgaWYgdGhlIGN1cnJlbnQgaWQgaXMgMjMgYml0cyBsb25nLCB3ZSBjYW4gY29udmVydCAyMCBvZiB0aG9zZVxuICAgIC8vIGJpdHMgaW50byBhIHN0cmluZyBvZiA0IGNoYXJhY3RlcnMsIHdpdGggMyBiaXRzIGxlZnQgb3Zlci5cbiAgICAvL1xuICAgIC8vIEZpcnN0IGNhbGN1bGF0ZSBob3cgbWFueSBiaXRzIGluIHRoZSBiYXNlIGlkIHJlcHJlc2VudCBhIGNvbXBsZXRlXG4gICAgLy8gc2VxdWVuY2Ugb2YgY2hhcmFjdGVycy5cbiAgICB2YXIgbnVtYmVyT2ZPdmVyZmxvd0JpdHMgPSBiYXNlTGVuZ3RoIC0gYmFzZUxlbmd0aCAlIDU7IC8vIFRoZW4gY3JlYXRlIGEgYml0bWFzayB0aGF0IHNlbGVjdHMgb25seSB0aG9zZSBiaXRzLlxuXG4gICAgdmFyIG5ld092ZXJmbG93Qml0cyA9ICgxIDw8IG51bWJlck9mT3ZlcmZsb3dCaXRzKSAtIDE7IC8vIFNlbGVjdCB0aGUgYml0cywgYW5kIGNvbnZlcnQgdGhlbSB0byBhIGJhc2UgMzIgc3RyaW5nLlxuXG4gICAgdmFyIG5ld092ZXJmbG93ID0gKGJhc2VJZCAmIG5ld092ZXJmbG93Qml0cykudG9TdHJpbmcoMzIpOyAvLyBOb3cgd2UgY2FuIHJlbW92ZSB0aG9zZSBiaXRzIGZyb20gdGhlIGJhc2UgaWQuXG5cbiAgICB2YXIgcmVzdE9mQmFzZUlkID0gYmFzZUlkID4+IG51bWJlck9mT3ZlcmZsb3dCaXRzO1xuICAgIHZhciByZXN0T2ZCYXNlTGVuZ3RoID0gYmFzZUxlbmd0aCAtIG51bWJlck9mT3ZlcmZsb3dCaXRzOyAvLyBGaW5hbGx5LCBlbmNvZGUgdGhlIHJlc3Qgb2YgdGhlIGJpdHMgdXNpbmcgdGhlIG5vcm1hbCBhbGdvcml0aG0uIEJlY2F1c2VcbiAgICAvLyB3ZSBtYWRlIG1vcmUgcm9vbSwgdGhpcyB0aW1lIGl0IHdvbid0IG92ZXJmbG93LlxuXG4gICAgdmFyIHJlc3RPZkxlbmd0aCA9IGdldEJpdExlbmd0aCh0b3RhbENoaWxkcmVuKSArIHJlc3RPZkJhc2VMZW5ndGg7XG4gICAgdmFyIHJlc3RPZk5ld0JpdHMgPSBzbG90IDw8IHJlc3RPZkJhc2VMZW5ndGg7XG4gICAgdmFyIGlkID0gcmVzdE9mTmV3Qml0cyB8IHJlc3RPZkJhc2VJZDtcbiAgICB2YXIgb3ZlcmZsb3cgPSBuZXdPdmVyZmxvdyArIGJhc2VPdmVyZmxvdztcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IDEgPDwgcmVzdE9mTGVuZ3RoIHwgaWQsXG4gICAgICBvdmVyZmxvdzogb3ZlcmZsb3dcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIE5vcm1hbCBwYXRoXG4gICAgdmFyIG5ld0JpdHMgPSBzbG90IDw8IGJhc2VMZW5ndGg7XG5cbiAgICB2YXIgX2lkID0gbmV3Qml0cyB8IGJhc2VJZDtcblxuICAgIHZhciBfb3ZlcmZsb3cgPSBiYXNlT3ZlcmZsb3c7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiAxIDw8IGxlbmd0aCB8IF9pZCxcbiAgICAgIG92ZXJmbG93OiBfb3ZlcmZsb3dcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEJpdExlbmd0aChudW1iZXIpIHtcbiAgcmV0dXJuIDMyIC0gY2x6MzIobnVtYmVyKTtcbn1cblxuZnVuY3Rpb24gZ2V0TGVhZGluZ0JpdChpZCkge1xuICByZXR1cm4gMSA8PCBnZXRCaXRMZW5ndGgoaWQpIC0gMTtcbn0gLy8gVE9ETzogTWF0aC5jbHozMiBpcyBzdXBwb3J0ZWQgaW4gTm9kZSAxMisuIE1heWJlIHdlIGNhbiBkcm9wIHRoZSBmYWxsYmFjay5cblxuXG52YXIgY2x6MzIgPSBNYXRoLmNsejMyID8gTWF0aC5jbHozMiA6IGNsejMyRmFsbGJhY2s7IC8vIENvdW50IGxlYWRpbmcgemVyb3MuXG4vLyBCYXNlZCBvbjpcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvY2x6MzJcblxudmFyIGxvZyA9IE1hdGgubG9nO1xudmFyIExOMiA9IE1hdGguTE4yO1xuXG5mdW5jdGlvbiBjbHozMkZhbGxiYWNrKHgpIHtcbiAgdmFyIGFzVWludCA9IHggPj4+IDA7XG5cbiAgaWYgKGFzVWludCA9PT0gMCkge1xuICAgIHJldHVybiAzMjtcbiAgfVxuXG4gIHJldHVybiAzMSAtIChsb2coYXNVaW50KSAvIExOMiB8IDApIHwgMDtcbn1cblxuLy8gQ29ycmVzcG9uZHMgdG8gUmVhY3RGaWJlcldha2VhYmxlIGFuZCBSZWFjdEZsaWdodFdha2VhYmxlIG1vZHVsZXMuIEdlbmVyYWxseSxcbi8vIGNoYW5nZXMgdG8gb25lIG1vZHVsZSBzaG91bGQgYmUgcmVmbGVjdGVkIGluIHRoZSBvdGhlcnMuXG4vLyBUT0RPOiBSZW5hbWUgdGhpcyBtb2R1bGUgYW5kIHRoZSBjb3JyZXNwb25kaW5nIEZpYmVyIG9uZSB0byBcIlRoZW5hYmxlXCJcbi8vIGluc3RlYWQgb2YgXCJXYWtlYWJsZVwiLiBPciBzb21lIG90aGVyIG1vcmUgYXBwcm9wcmlhdGUgbmFtZS5cbi8vIEFuIGVycm9yIHRoYXQgaXMgdGhyb3duIChlLmcuIGJ5IGB1c2VgKSB0byB0cmlnZ2VyIFN1c3BlbnNlLiBJZiB3ZVxuLy8gZGV0ZWN0IHRoaXMgaXMgY2F1Z2h0IGJ5IHVzZXJzcGFjZSwgd2UnbGwgbG9nIGEgd2FybmluZyBpbiBkZXZlbG9wbWVudC5cbnZhciBTdXNwZW5zZUV4Y2VwdGlvbiA9IG5ldyBFcnJvcihcIlN1c3BlbnNlIEV4Y2VwdGlvbjogVGhpcyBpcyBub3QgYSByZWFsIGVycm9yISBJdCdzIGFuIGltcGxlbWVudGF0aW9uIFwiICsgJ2RldGFpbCBvZiBgdXNlYCB0byBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgcmVuZGVyLiBZb3UgbXVzdCBlaXRoZXIgJyArICdyZXRocm93IGl0IGltbWVkaWF0ZWx5LCBvciBtb3ZlIHRoZSBgdXNlYCBjYWxsIG91dHNpZGUgb2YgdGhlICcgKyAnYHRyeS9jYXRjaGAgYmxvY2suIENhcHR1cmluZyB3aXRob3V0IHJldGhyb3dpbmcgd2lsbCBsZWFkIHRvICcgKyAndW5leHBlY3RlZCBiZWhhdmlvci5cXG5cXG4nICsgJ1RvIGhhbmRsZSBhc3luYyBlcnJvcnMsIHdyYXAgeW91ciBjb21wb25lbnQgaW4gYW4gZXJyb3IgYm91bmRhcnksIG9yICcgKyBcImNhbGwgdGhlIHByb21pc2UncyBgLmNhdGNoYCBtZXRob2QgYW5kIHBhc3MgdGhlIHJlc3VsdCB0byBgdXNlYFwiKTtcbmZ1bmN0aW9uIGNyZWF0ZVRoZW5hYmxlU3RhdGUoKSB7XG4gIC8vIFRoZSBUaGVuYWJsZVN0YXRlIGlzIGNyZWF0ZWQgdGhlIGZpcnN0IHRpbWUgYSBjb21wb25lbnQgc3VzcGVuZHMuIElmIGl0XG4gIC8vIHN1c3BlbmRzIGFnYWluLCB3ZSdsbCByZXVzZSB0aGUgc2FtZSBzdGF0ZS5cbiAgcmV0dXJuIFtdO1xufVxuXG5mdW5jdGlvbiBub29wJDIoKSB7fVxuXG5mdW5jdGlvbiB0cmFja1VzZWRUaGVuYWJsZSh0aGVuYWJsZVN0YXRlLCB0aGVuYWJsZSwgaW5kZXgpIHtcbiAgdmFyIHByZXZpb3VzID0gdGhlbmFibGVTdGF0ZVtpbmRleF07XG5cbiAgaWYgKHByZXZpb3VzID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGVuYWJsZVN0YXRlLnB1c2godGhlbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIGlmIChwcmV2aW91cyAhPT0gdGhlbmFibGUpIHtcbiAgICAgIC8vIFJldXNlIHRoZSBwcmV2aW91cyB0aGVuYWJsZSwgYW5kIGRyb3AgdGhlIG5ldyBvbmUuIFdlIGNhbiBhc3N1bWVcbiAgICAgIC8vIHRoZXkgcmVwcmVzZW50IHRoZSBzYW1lIHZhbHVlLCBiZWNhdXNlIGNvbXBvbmVudHMgYXJlIGlkZW1wb3RlbnQuXG4gICAgICAvLyBBdm9pZCBhbiB1bmhhbmRsZWQgcmVqZWN0aW9uIGVycm9ycyBmb3IgdGhlIFByb21pc2VzIHRoYXQgd2UnbGxcbiAgICAgIC8vIGludGVudGlvbmFsbHkgaWdub3JlLlxuICAgICAgdGhlbmFibGUudGhlbihub29wJDIsIG5vb3AkMik7XG4gICAgICB0aGVuYWJsZSA9IHByZXZpb3VzO1xuICAgIH1cbiAgfSAvLyBXZSB1c2UgYW4gZXhwYW5kbyB0byB0cmFjayB0aGUgc3RhdHVzIGFuZCByZXN1bHQgb2YgYSB0aGVuYWJsZSBzbyB0aGF0IHdlXG4gIC8vIGNhbiBzeW5jaHJvbm91c2x5IHVud3JhcCB0aGUgdmFsdWUuIFRoaW5rIG9mIHRoaXMgYXMgYW4gZXh0ZW5zaW9uIG9mIHRoZVxuICAvLyBQcm9taXNlIEFQSSwgb3IgYSBjdXN0b20gaW50ZXJmYWNlIHRoYXQgaXMgYSBzdXBlcnNldCBvZiBUaGVuYWJsZS5cbiAgLy9cbiAgLy8gSWYgdGhlIHRoZW5hYmxlIGRvZXNuJ3QgaGF2ZSBhIHN0YXR1cywgc2V0IGl0IHRvIFwicGVuZGluZ1wiIGFuZCBhdHRhY2hcbiAgLy8gYSBsaXN0ZW5lciB0aGF0IHdpbGwgdXBkYXRlIGl0cyBzdGF0dXMgYW5kIHJlc3VsdCB3aGVuIGl0IHJlc29sdmVzLlxuXG5cbiAgc3dpdGNoICh0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICBjYXNlICdmdWxmaWxsZWQnOlxuICAgICAge1xuICAgICAgICB2YXIgZnVsZmlsbGVkVmFsdWUgPSB0aGVuYWJsZS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIGZ1bGZpbGxlZFZhbHVlO1xuICAgICAgfVxuXG4gICAgY2FzZSAncmVqZWN0ZWQnOlxuICAgICAge1xuICAgICAgICB2YXIgcmVqZWN0ZWRFcnJvciA9IHRoZW5hYmxlLnJlYXNvbjtcbiAgICAgICAgdGhyb3cgcmVqZWN0ZWRFcnJvcjtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhlbmFibGUuc3RhdHVzID09PSAnc3RyaW5nJykgOyBlbHNlIHtcbiAgICAgICAgICB2YXIgcGVuZGluZ1RoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgcGVuZGluZ1RoZW5hYmxlLnN0YXR1cyA9ICdwZW5kaW5nJztcbiAgICAgICAgICBwZW5kaW5nVGhlbmFibGUudGhlbihmdW5jdGlvbiAoZnVsZmlsbGVkVmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGVuYWJsZS5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgICB2YXIgZnVsZmlsbGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgICAgZnVsZmlsbGVkVGhlbmFibGUuc3RhdHVzID0gJ2Z1bGZpbGxlZCc7XG4gICAgICAgICAgICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnZhbHVlID0gZnVsZmlsbGVkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAodGhlbmFibGUuc3RhdHVzID09PSAncGVuZGluZycpIHtcbiAgICAgICAgICAgICAgdmFyIHJlamVjdGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgICAgcmVqZWN0ZWRUaGVuYWJsZS5zdGF0dXMgPSAncmVqZWN0ZWQnO1xuICAgICAgICAgICAgICByZWplY3RlZFRoZW5hYmxlLnJlYXNvbiA9IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pOyAvLyBDaGVjayBvbmUgbW9yZSB0aW1lIGluIGNhc2UgdGhlIHRoZW5hYmxlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcblxuICAgICAgICAgIHN3aXRjaCAodGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlICdmdWxmaWxsZWQnOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bGZpbGxlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bGZpbGxlZFRoZW5hYmxlLnZhbHVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ3JlamVjdGVkJzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciByZWplY3RlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICAgICAgdGhyb3cgcmVqZWN0ZWRUaGVuYWJsZS5yZWFzb247XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gU3VzcGVuZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhyb3dpbmcgaGVyZSBpcyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgdGhhdCBhbGxvd3MgdXMgdG8gdW53aW5kIHRoZVxuICAgICAgICAvLyBjYWxsIHN0YWNrLiBCdXQgd2Ugc2hvdWxkbid0IGFsbG93IGl0IHRvIGxlYWsgaW50byB1c2Vyc3BhY2UuIFRocm93IGFuXG4gICAgICAgIC8vIG9wYXF1ZSBwbGFjZWhvbGRlciB2YWx1ZSBpbnN0ZWFkIG9mIHRoZSBhY3R1YWwgdGhlbmFibGUuIElmIGl0IGRvZXNuJ3RcbiAgICAgICAgLy8gZ2V0IGNhcHR1cmVkIGJ5IHRoZSB3b3JrIGxvb3AsIGxvZyBhIHdhcm5pbmcsIGJlY2F1c2UgdGhhdCBtZWFuc1xuICAgICAgICAvLyBzb21ldGhpbmcgaW4gdXNlcnNwYWNlIG11c3QgaGF2ZSBjYXVnaHQgaXQuXG5cblxuICAgICAgICBzdXNwZW5kZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICB0aHJvdyBTdXNwZW5zZUV4Y2VwdGlvbjtcbiAgICAgIH1cbiAgfVxufSAvLyBUaGlzIGlzIHVzZWQgdG8gdHJhY2sgdGhlIGFjdHVhbCB0aGVuYWJsZSB0aGF0IHN1c3BlbmRlZCBzbyBpdCBjYW4gYmVcbi8vIHBhc3NlZCB0byB0aGUgcmVzdCBvZiB0aGUgU3VzcGVuc2UgaW1wbGVtZW50YXRpb24g4oCUIHdoaWNoLCBmb3IgaGlzdG9yaWNhbFxuLy8gcmVhc29ucywgZXhwZWN0cyB0byByZWNlaXZlIGEgdGhlbmFibGUuXG5cbnZhciBzdXNwZW5kZWRUaGVuYWJsZSA9IG51bGw7XG5mdW5jdGlvbiBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpIHtcbiAgLy8gVGhpcyBpcyBjYWxsZWQgcmlnaHQgYWZ0ZXIgYHVzZWAgc3VzcGVuZHMgYnkgdGhyb3dpbmcgYW4gZXhjZXB0aW9uLiBgdXNlYFxuICAvLyB0aHJvd3MgYW4gb3BhcXVlIHZhbHVlIGluc3RlYWQgb2YgdGhlIHRoZW5hYmxlIGl0c2VsZiBzbyB0aGF0IGl0IGNhbid0IGJlXG4gIC8vIGNhdWdodCBpbiB1c2Vyc3BhY2UuIFRoZW4gdGhlIHdvcmsgbG9vcCBhY2Nlc3NlcyB0aGUgYWN0dWFsIHRoZW5hYmxlIHVzaW5nXG4gIC8vIHRoaXMgZnVuY3Rpb24uXG4gIGlmIChzdXNwZW5kZWRUaGVuYWJsZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYSBzdXNwZW5kZWQgdGhlbmFibGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlICcgKyAnYW4gaXNzdWUuJyk7XG4gIH1cblxuICB2YXIgdGhlbmFibGUgPSBzdXNwZW5kZWRUaGVuYWJsZTtcbiAgc3VzcGVuZGVkVGhlbmFibGUgPSBudWxsO1xuICByZXR1cm4gdGhlbmFibGU7XG59XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgO1xufVxuXG52YXIgb2JqZWN0SXMgPSAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG50eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaXM7XG5cbnZhciBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSBudWxsO1xudmFyIGN1cnJlbnRseVJlbmRlcmluZ1Rhc2sgPSBudWxsO1xudmFyIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbnZhciB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsOyAvLyBXaGV0aGVyIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2sgaXMgYSByZS1yZW5kZXJlZCBob29rXG5cbnZhciBpc1JlUmVuZGVyID0gZmFsc2U7IC8vIFdoZXRoZXIgYW4gdXBkYXRlIHdhcyBzY2hlZHVsZWQgZHVyaW5nIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIHJlbmRlciBwYXNzLlxuXG52YXIgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlOyAvLyBDb3VudHMgdGhlIG51bWJlciBvZiB1c2VJZCBob29rcyBpbiB0aGlzIGNvbXBvbmVudFxuXG52YXIgbG9jYWxJZENvdW50ZXIgPSAwOyAvLyBDb3VudHMgdGhlIG51bWJlciBvZiB1c2UodGhlbmFibGUpIGNhbGxzIGluIHRoaXMgY29tcG9uZW50XG5cbnZhciB0aGVuYWJsZUluZGV4Q291bnRlciA9IDA7XG52YXIgdGhlbmFibGVTdGF0ZSA9IG51bGw7IC8vIExhemlseSBjcmVhdGVkIG1hcCBvZiByZW5kZXItcGhhc2UgdXBkYXRlc1xuXG52YXIgcmVuZGVyUGhhc2VVcGRhdGVzID0gbnVsbDsgLy8gQ291bnRlciB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzLlxuXG52YXIgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xudmFyIFJFX1JFTkRFUl9MSU1JVCA9IDI1O1xudmFyIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlOyAvLyBJbiBERVYsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnRseSBleGVjdXRpbmcgcHJpbWl0aXZlIGhvb2tcblxudmFyIGN1cnJlbnRIb29rTmFtZUluRGV2O1xuXG5mdW5jdGlvbiByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCkge1xuICBpZiAoY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yJyArICcgb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4nICsgJzEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbicgKyAnMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbicgKyAnMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcbicgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uJyk7XG4gIH1cblxuICB7XG4gICAgaWYgKGlzSW5Ib29rVXNlckNvZGVJbkRldikge1xuICAgICAgZXJyb3IoJ0RvIG5vdCBjYWxsIEhvb2tzIGluc2lkZSB1c2VFZmZlY3QoLi4uKSwgdXNlTWVtbyguLi4pLCBvciBvdGhlciBidWlsdC1pbiBIb29rcy4gJyArICdZb3UgY2FuIG9ubHkgY2FsbCBIb29rcyBhdCB0aGUgdG9wIGxldmVsIG9mIHlvdXIgUmVhY3QgZnVuY3Rpb24uICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ydWxlcy1vZi1ob29rcycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQ7XG59XG5cbmZ1bmN0aW9uIGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpIHtcbiAgaWYgKHByZXZEZXBzID09PSBudWxsKSB7XG4gICAge1xuICAgICAgZXJyb3IoJyVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgbm90IGR1cmluZyAnICsgJ3RoZSBwcmV2aW91cyByZW5kZXIuIEV2ZW4gdGhvdWdoIHRoZSBmaW5hbCBhcmd1bWVudCBpcyBvcHRpb25hbCwgJyArICdpdHMgdHlwZSBjYW5ub3QgY2hhbmdlIGJldHdlZW4gcmVuZGVycy4nLCBjdXJyZW50SG9va05hbWVJbkRldik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAge1xuICAgIC8vIERvbid0IGJvdGhlciBjb21wYXJpbmcgbGVuZ3RocyBpbiBwcm9kIGJlY2F1c2UgdGhlc2UgYXJyYXlzIHNob3VsZCBiZVxuICAgIC8vIHBhc3NlZCBpbmxpbmUuXG4gICAgaWYgKG5leHREZXBzLmxlbmd0aCAhPT0gcHJldkRlcHMubGVuZ3RoKSB7XG4gICAgICBlcnJvcignVGhlIGZpbmFsIGFyZ3VtZW50IHBhc3NlZCB0byAlcyBjaGFuZ2VkIHNpemUgYmV0d2VlbiByZW5kZXJzLiBUaGUgJyArICdvcmRlciBhbmQgc2l6ZSBvZiB0aGlzIGFycmF5IG11c3QgcmVtYWluIGNvbnN0YW50LlxcblxcbicgKyAnUHJldmlvdXM6ICVzXFxuJyArICdJbmNvbWluZzogJXMnLCBjdXJyZW50SG9va05hbWVJbkRldiwgXCJbXCIgKyBuZXh0RGVwcy5qb2luKCcsICcpICsgXCJdXCIsIFwiW1wiICsgcHJldkRlcHMuam9pbignLCAnKSArIFwiXVwiKTtcbiAgICB9XG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZEZXBzLmxlbmd0aCAmJiBpIDwgbmV4dERlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICBpZiAob2JqZWN0SXMobmV4dERlcHNbaV0sIHByZXZEZXBzW2ldKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhvb2soKSB7XG4gIGlmIChudW1iZXJPZlJlUmVuZGVycyA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbmRlcmVkIG1vcmUgaG9va3MgdGhhbiBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlcicpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtZW1vaXplZFN0YXRlOiBudWxsLFxuICAgIHF1ZXVlOiBudWxsLFxuICAgIG5leHQ6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICBpZiAod29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgaG9vayBpbiB0aGUgbGlzdFxuICAgIGlmIChmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9PT0gbnVsbCkge1xuICAgICAgaXNSZVJlbmRlciA9IGZhbHNlO1xuICAgICAgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVIb29rKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXJlJ3MgYWxyZWFkeSBhIHdvcmstaW4tcHJvZ3Jlc3MuIFJldXNlIGl0LlxuICAgICAgaXNSZVJlbmRlciA9IHRydWU7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBmaXJzdFdvcmtJblByb2dyZXNzSG9vaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID09PSBudWxsKSB7XG4gICAgICBpc1JlUmVuZGVyID0gZmFsc2U7IC8vIEFwcGVuZCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0XG5cbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gY3JlYXRlSG9vaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSdzIGFscmVhZHkgYSB3b3JrLWluLXByb2dyZXNzLiBSZXVzZSBpdC5cbiAgICAgIGlzUmVSZW5kZXIgPSB0cnVlO1xuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vaztcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRvVXNlSG9va3ModGFzaywgY29tcG9uZW50SWRlbnRpdHksIHByZXZUaGVuYWJsZVN0YXRlKSB7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IGNvbXBvbmVudElkZW50aXR5O1xuICBjdXJyZW50bHlSZW5kZXJpbmdUYXNrID0gdGFzaztcblxuICB7XG4gICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gIH0gLy8gVGhlIGZvbGxvd2luZyBzaG91bGQgaGF2ZSBhbHJlYWR5IGJlZW4gcmVzZXRcbiAgLy8gZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuICAvLyBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gIC8vIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbiAgLy8gcmVuZGVyUGhhc2VVcGRhdGVzID0gbnVsbDtcbiAgLy8gd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblxuXG4gIGxvY2FsSWRDb3VudGVyID0gMDtcbiAgdGhlbmFibGVJbmRleENvdW50ZXIgPSAwO1xuICB0aGVuYWJsZVN0YXRlID0gcHJldlRoZW5hYmxlU3RhdGU7XG59XG5mdW5jdGlvbiBmaW5pc2hIb29rcyhDb21wb25lbnQsIHByb3BzLCBjaGlsZHJlbiwgcmVmT3JDb250ZXh0KSB7XG4gIC8vIFRoaXMgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgZXZlcnkgZnVuY3Rpb24gY29tcG9uZW50IHRvIHByZXZlbnQgaG9va3MgZnJvbVxuICAvLyBiZWluZyB1c2VkIGluIGNsYXNzZXMuXG4gIHdoaWxlIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlKSB7XG4gICAgLy8gVXBkYXRlcyB3ZXJlIHNjaGVkdWxlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS4gVGhleSBhcmUgc3RvcmVkIGluXG4gICAgLy8gdGhlIGByZW5kZXJQaGFzZVVwZGF0ZXNgIG1hcC4gQ2FsbCB0aGUgY29tcG9uZW50IGFnYWluLCByZXVzaW5nIHRoZVxuICAgIC8vIHdvcmstaW4tcHJvZ3Jlc3MgaG9va3MgYW5kIGFwcGx5aW5nIHRoZSBhZGRpdGlvbmFsIHVwZGF0ZXMgb24gdG9wLiBLZWVwXG4gICAgLy8gcmVzdGFydGluZyB1bnRpbCBubyBtb3JlIHVwZGF0ZXMgYXJlIHNjaGVkdWxlZC5cbiAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gICAgbG9jYWxJZENvdW50ZXIgPSAwO1xuICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMDtcbiAgICBudW1iZXJPZlJlUmVuZGVycyArPSAxOyAvLyBTdGFydCBvdmVyIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdFxuXG4gICAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgICBjaGlsZHJlbiA9IENvbXBvbmVudChwcm9wcywgcmVmT3JDb250ZXh0KTtcbiAgfVxuXG4gIHJlc2V0SG9va3NTdGF0ZSgpO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5mdW5jdGlvbiBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKCkge1xuICB2YXIgc3RhdGUgPSB0aGVuYWJsZVN0YXRlO1xuICB0aGVuYWJsZVN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gY2hlY2tEaWRSZW5kZXJJZEhvb2soKSB7XG4gIC8vIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciBldmVyeSBmaW5pc2hIb29rcyBjYWxsLlxuICAvLyBDb25jZXB0dWFsbHksIGl0J3MgcGFydCBvZiB0aGUgcmV0dXJuIHZhbHVlIG9mIGZpbmlzaEhvb2tzOyBpdCdzIG9ubHkgYVxuICAvLyBzZXBhcmF0ZSBmdW5jdGlvbiB0byBhdm9pZCB1c2luZyBhbiBhcnJheSB0dXBsZS5cbiAgdmFyIGRpZFJlbmRlcklkSG9vayA9IGxvY2FsSWRDb3VudGVyICE9PSAwO1xuICByZXR1cm4gZGlkUmVuZGVySWRIb29rO1xufSAvLyBSZXNldCB0aGUgaW50ZXJuYWwgaG9va3Mgc3RhdGUgaWYgYW4gZXJyb3Igb2NjdXJzIHdoaWxlIHJlbmRlcmluZyBhIGNvbXBvbmVudFxuXG5mdW5jdGlvbiByZXNldEhvb2tzU3RhdGUoKSB7XG4gIHtcbiAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTtcbiAgfVxuXG4gIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IG51bGw7XG4gIGN1cnJlbnRseVJlbmRlcmluZ1Rhc2sgPSBudWxsO1xuICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xuICByZW5kZXJQaGFzZVVwZGF0ZXMgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xufVxuXG5mdW5jdGlvbiByZWFkQ29udGV4dChjb250ZXh0KSB7XG4gIHtcbiAgICBpZiAoaXNJbkhvb2tVc2VyQ29kZUluRGV2KSB7XG4gICAgICBlcnJvcignQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gJyArICdJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnICsgJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnICsgJ2luc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRDb250ZXh0JDEoY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIHVzZUNvbnRleHQoY29udGV4dCkge1xuICB7XG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gIH1cblxuICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHJldHVybiByZWFkQ29udGV4dCQxKGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBiYXNpY1N0YXRlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV06IEZsb3cgZG9lc24ndCBsaWtlIG1peGVkIHR5cGVzXG4gIHJldHVybiB0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nID8gYWN0aW9uKHN0YXRlKSA6IGFjdGlvbjtcbn1cblxuZnVuY3Rpb24gdXNlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHtcbiAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gIH1cblxuICByZXR1cm4gdXNlUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlciwgLy8gdXNlUmVkdWNlciBoYXMgYSBzcGVjaWFsIGNhc2UgdG8gc3VwcG9ydCBsYXp5IHVzZVN0YXRlIGluaXRpYWxpemVyc1xuICBpbml0aWFsU3RhdGUpO1xufVxuZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHtcbiAgICBpZiAocmVkdWNlciAhPT0gYmFzaWNTdGF0ZVJlZHVjZXIpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgIH1cbiAgfVxuXG4gIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG5cbiAgaWYgKGlzUmVSZW5kZXIpIHtcbiAgICAvLyBUaGlzIGlzIGEgcmUtcmVuZGVyLiBBcHBseSB0aGUgbmV3IHJlbmRlciBwaGFzZSB1cGRhdGVzIHRvIHRoZSBwcmV2aW91c1xuICAgIC8vIGN1cnJlbnQgaG9vay5cbiAgICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sucXVldWU7XG4gICAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2g7XG5cbiAgICBpZiAocmVuZGVyUGhhc2VVcGRhdGVzICE9PSBudWxsKSB7XG4gICAgICAvLyBSZW5kZXIgcGhhc2UgdXBkYXRlcyBhcmUgc3RvcmVkIGluIGEgbWFwIG9mIHF1ZXVlIC0+IGxpbmtlZCBsaXN0XG4gICAgICB2YXIgZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IHJlbmRlclBoYXNlVXBkYXRlcy5nZXQocXVldWUpO1xuXG4gICAgICBpZiAoZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgICByZW5kZXJQaGFzZVVwZGF0ZXMuZGVsZXRlKHF1ZXVlKTsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cbiAgICAgICAgdmFyIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIHZhciB1cGRhdGUgPSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvLyBQcm9jZXNzIHRoaXMgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gV2UgZG9uJ3QgaGF2ZSB0byBjaGVjayB0aGVcbiAgICAgICAgICAvLyBwcmlvcml0eSBiZWNhdXNlIGl0IHdpbGwgYWx3YXlzIGJlIHRoZSBzYW1lIGFzIHRoZSBjdXJyZW50XG4gICAgICAgICAgLy8gcmVuZGVyJ3MuXG4gICAgICAgICAgdmFyIGFjdGlvbiA9IHVwZGF0ZS5hY3Rpb247XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5ld1N0YXRlID0gcmVkdWNlcihuZXdTdGF0ZSwgYWN0aW9uKTtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlO1xuICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gd2UgYmFpbCBvdXQgd2hlbiB3ZSBnZXQgYSBudWxsXG5cblxuICAgICAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgICAgICB9IHdoaWxlICh1cGRhdGUgIT09IG51bGwpOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIHJldHVybiBbbmV3U3RhdGUsIGRpc3BhdGNoXTtcbiAgICAgIH1cbiAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICByZXR1cm4gW3dvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLCBkaXNwYXRjaF07XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaW5pdGlhbFN0YXRlO1xuXG4gICAgaWYgKHJlZHVjZXIgPT09IGJhc2ljU3RhdGVSZWR1Y2VyKSB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGB1c2VTdGF0ZWAuXG4gICAgICBpbml0aWFsU3RhdGUgPSB0eXBlb2YgaW5pdGlhbEFyZyA9PT0gJ2Z1bmN0aW9uJyA/IGluaXRpYWxBcmcoKSA6IGluaXRpYWxBcmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluaXRpYWxTdGF0ZSA9IGluaXQgIT09IHVuZGVmaW5lZCA/IGluaXQoaW5pdGlhbEFyZykgOiBpbml0aWFsQXJnO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlO1xuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gaW5pdGlhbFN0YXRlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuICAgIHZhciBfcXVldWUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sucXVldWUgPSB7XG4gICAgICBsYXN0OiBudWxsLFxuICAgICAgZGlzcGF0Y2g6IG51bGxcbiAgICB9O1xuXG4gICAgdmFyIF9kaXNwYXRjaCA9IF9xdWV1ZS5kaXNwYXRjaCA9IGRpc3BhdGNoQWN0aW9uLmJpbmQobnVsbCwgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50LCBfcXVldWUpOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgcmV0dXJuIFt3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSwgX2Rpc3BhdGNoXTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VNZW1vKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzSG9vayAhPT0gbnVsbCkge1xuICAgIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZTtcblxuICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChuZXh0RGVwcyAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcHJldkRlcHMgPSBwcmV2U3RhdGVbMV07XG5cbiAgICAgICAgaWYgKGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXZTdGF0ZVswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSB0cnVlO1xuICB9XG5cbiAgdmFyIG5leHRWYWx1ZSA9IG5leHRDcmVhdGUoKTtcblxuICB7XG4gICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IFtuZXh0VmFsdWUsIG5leHREZXBzXTtcbiAgcmV0dXJuIG5leHRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gdXNlUmVmKGluaXRpYWxWYWx1ZSkge1xuICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgcHJldmlvdXNSZWYgPSB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAocHJldmlvdXNSZWYgPT09IG51bGwpIHtcbiAgICB2YXIgcmVmID0ge1xuICAgICAgY3VycmVudDogaW5pdGlhbFZhbHVlXG4gICAgfTtcblxuICAgIHtcbiAgICAgIE9iamVjdC5zZWFsKHJlZik7XG4gICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSByZWY7XG4gICAgcmV0dXJuIHJlZjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJldmlvdXNSZWY7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hBY3Rpb24oY29tcG9uZW50SWRlbnRpdHksIHF1ZXVlLCBhY3Rpb24pIHtcbiAgaWYgKG51bWJlck9mUmVSZW5kZXJzID49IFJFX1JFTkRFUl9MSU1JVCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVG9vIG1hbnkgcmUtcmVuZGVycy4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgcmVuZGVycyB0byBwcmV2ZW50ICcgKyAnYW4gaW5maW5pdGUgbG9vcC4nKTtcbiAgfVxuXG4gIGlmIChjb21wb25lbnRJZGVudGl0eSA9PT0gY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlbmRlciBwaGFzZSB1cGRhdGUuIFN0YXNoIGl0IGluIGEgbGF6aWx5LWNyZWF0ZWQgbWFwIG9mXG4gICAgLy8gcXVldWUgLT4gbGlua2VkIGxpc3Qgb2YgdXBkYXRlcy4gQWZ0ZXIgdGhpcyByZW5kZXIgcGFzcywgd2UnbGwgcmVzdGFydFxuICAgIC8vIGFuZCBhcHBseSB0aGUgc3Rhc2hlZCB1cGRhdGVzIG9uIHRvcCBvZiB0aGUgd29yay1pbi1wcm9ncmVzcyBob29rLlxuICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSB0cnVlO1xuICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKHJlbmRlclBoYXNlVXBkYXRlcyA9PT0gbnVsbCkge1xuICAgICAgcmVuZGVyUGhhc2VVcGRhdGVzID0gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIHZhciBmaXJzdFJlbmRlclBoYXNlVXBkYXRlID0gcmVuZGVyUGhhc2VVcGRhdGVzLmdldChxdWV1ZSk7XG5cbiAgICBpZiAoZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgIHJlbmRlclBoYXNlVXBkYXRlcy5zZXQocXVldWUsIHVwZGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFwcGVuZCB0aGUgdXBkYXRlIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gICAgICB2YXIgbGFzdFJlbmRlclBoYXNlVXBkYXRlID0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZTtcblxuICAgICAgd2hpbGUgKGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0O1xuICAgICAgfVxuXG4gICAgICBsYXN0UmVuZGVyUGhhc2VVcGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgcmV0dXJuIHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWxsYmFjaztcbiAgfSwgZGVwcyk7XG59XG5cbmZ1bmN0aW9uIHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gIGlmIChnZXRTZXJ2ZXJTbmFwc2hvdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGdldFNlcnZlclNuYXBzaG90LCB3aGljaCBpcyByZXF1aXJlZCBmb3IgJyArICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gV2lsbCByZXZlcnQgdG8gY2xpZW50IHJlbmRlcmluZy4nKTtcbiAgfVxuXG4gIHJldHVybiBnZXRTZXJ2ZXJTbmFwc2hvdCgpO1xufVxuXG5mdW5jdGlvbiB1c2VEZWZlcnJlZFZhbHVlKHZhbHVlKSB7XG4gIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB1bnN1cHBvcnRlZFN0YXJ0VHJhbnNpdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdzdGFydFRyYW5zaXRpb24gY2Fubm90IGJlIGNhbGxlZCBkdXJpbmcgc2VydmVyIHJlbmRlcmluZy4nKTtcbn1cblxuZnVuY3Rpb24gdXNlVHJhbnNpdGlvbigpIHtcbiAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICByZXR1cm4gW2ZhbHNlLCB1bnN1cHBvcnRlZFN0YXJ0VHJhbnNpdGlvbl07XG59XG5cbmZ1bmN0aW9uIHVzZUlkKCkge1xuICB2YXIgdGFzayA9IGN1cnJlbnRseVJlbmRlcmluZ1Rhc2s7XG4gIHZhciB0cmVlSWQgPSBnZXRUcmVlSWQodGFzay50cmVlQ29udGV4dCk7XG4gIHZhciByZXNwb25zZVN0YXRlID0gY3VycmVudFJlc3BvbnNlU3RhdGU7XG5cbiAgaWYgKHJlc3BvbnNlU3RhdGUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LicpO1xuICB9XG5cbiAgdmFyIGxvY2FsSWQgPSBsb2NhbElkQ291bnRlcisrO1xuICByZXR1cm4gbWFrZUlkKHJlc3BvbnNlU3RhdGUsIHRyZWVJZCwgbG9jYWxJZCk7XG59XG5cbmZ1bmN0aW9uIHVzZSh1c2FibGUpIHtcbiAgaWYgKHVzYWJsZSAhPT0gbnVsbCAmJiB0eXBlb2YgdXNhYmxlID09PSAnb2JqZWN0Jykge1xuICAgIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgICBpZiAodHlwZW9mIHVzYWJsZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgdGhlbmFibGUuXG4gICAgICB2YXIgdGhlbmFibGUgPSB1c2FibGU7XG4gICAgICByZXR1cm4gdW53cmFwVGhlbmFibGUodGhlbmFibGUpO1xuICAgIH0gZWxzZSBpZiAodXNhYmxlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdXNhYmxlLiQkdHlwZW9mID09PSBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHVzYWJsZTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICB0aHJvdyBuZXcgRXJyb3IoJ0FuIHVuc3VwcG9ydGVkIHR5cGUgd2FzIHBhc3NlZCB0byB1c2UoKTogJyArIFN0cmluZyh1c2FibGUpKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwVGhlbmFibGUodGhlbmFibGUpIHtcbiAgdmFyIGluZGV4ID0gdGhlbmFibGVJbmRleENvdW50ZXI7XG4gIHRoZW5hYmxlSW5kZXhDb3VudGVyICs9IDE7XG5cbiAgaWYgKHRoZW5hYmxlU3RhdGUgPT09IG51bGwpIHtcbiAgICB0aGVuYWJsZVN0YXRlID0gY3JlYXRlVGhlbmFibGVTdGF0ZSgpO1xuICB9XG5cbiAgcmV0dXJuIHRyYWNrVXNlZFRoZW5hYmxlKHRoZW5hYmxlU3RhdGUsIHRoZW5hYmxlLCBpbmRleCk7XG59XG5cbmZ1bmN0aW9uIHVuc3VwcG9ydGVkUmVmcmVzaCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdDYWNoZSBjYW5ub3QgYmUgcmVmcmVzaGVkIGR1cmluZyBzZXJ2ZXIgcmVuZGVyaW5nLicpO1xufVxuXG5mdW5jdGlvbiB1c2VDYWNoZVJlZnJlc2goKSB7XG4gIHJldHVybiB1bnN1cHBvcnRlZFJlZnJlc2g7XG59XG5cbmZ1bmN0aW9uIG5vb3AkMSgpIHt9XG5cbnZhciBIb29rc0Rpc3BhdGNoZXIgPSB7XG4gIHJlYWRDb250ZXh0OiByZWFkQ29udGV4dCxcbiAgdXNlOiB1c2UsXG4gIHVzZUNvbnRleHQ6IHVzZUNvbnRleHQsXG4gIHVzZU1lbW86IHVzZU1lbW8sXG4gIHVzZVJlZHVjZXI6IHVzZVJlZHVjZXIsXG4gIHVzZVJlZjogdXNlUmVmLFxuICB1c2VTdGF0ZTogdXNlU3RhdGUsXG4gIHVzZUluc2VydGlvbkVmZmVjdDogbm9vcCQxLFxuICB1c2VMYXlvdXRFZmZlY3Q6IG5vb3AkMSxcbiAgdXNlQ2FsbGJhY2s6IHVzZUNhbGxiYWNrLFxuICAvLyB1c2VJbXBlcmF0aXZlSGFuZGxlIGlzIG5vdCBydW4gaW4gdGhlIHNlcnZlciBlbnZpcm9ubWVudFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBub29wJDEsXG4gIC8vIEVmZmVjdHMgYXJlIG5vdCBydW4gaW4gdGhlIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgdXNlRWZmZWN0OiBub29wJDEsXG4gIC8vIERlYnVnZ2luZyBlZmZlY3RcbiAgdXNlRGVidWdWYWx1ZTogbm9vcCQxLFxuICB1c2VEZWZlcnJlZFZhbHVlOiB1c2VEZWZlcnJlZFZhbHVlLFxuICB1c2VUcmFuc2l0aW9uOiB1c2VUcmFuc2l0aW9uLFxuICB1c2VJZDogdXNlSWQsXG4gIC8vIFN1YnNjcmlwdGlvbnMgYXJlIG5vdCBzZXR1cCBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgdXNlU3luY0V4dGVybmFsU3RvcmU6IHVzZVN5bmNFeHRlcm5hbFN0b3JlXG59O1xuXG57XG4gIEhvb2tzRGlzcGF0Y2hlci51c2VDYWNoZVJlZnJlc2ggPSB1c2VDYWNoZVJlZnJlc2g7XG59XG5cbnZhciBjdXJyZW50UmVzcG9uc2VTdGF0ZSA9IG51bGw7XG5mdW5jdGlvbiBzZXRDdXJyZW50UmVzcG9uc2VTdGF0ZShyZXNwb25zZVN0YXRlKSB7XG4gIGN1cnJlbnRSZXNwb25zZVN0YXRlID0gcmVzcG9uc2VTdGF0ZTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2FjaGVTaWduYWwoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkLicpO1xufVxuXG5mdW5jdGlvbiBnZXRDYWNoZUZvclR5cGUocmVzb3VyY2VUeXBlKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkLicpO1xufVxuXG52YXIgRGVmYXVsdENhY2hlRGlzcGF0Y2hlciA9IHtcbiAgZ2V0Q2FjaGVTaWduYWw6IGdldENhY2hlU2lnbmFsLFxuICBnZXRDYWNoZUZvclR5cGU6IGdldENhY2hlRm9yVHlwZVxufTtcblxuZnVuY3Rpb24gZ2V0U3RhY2tCeUNvbXBvbmVudFN0YWNrTm9kZShjb21wb25lbnRTdGFjaykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAgdmFyIG5vZGUgPSBjb21wb25lbnRTdGFjaztcblxuICAgIGRvIHtcbiAgICAgIHN3aXRjaCAobm9kZS50YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGluZm8gKz0gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobm9kZS50eXBlLCBudWxsLCBudWxsKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaW5mbyArPSBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUobm9kZS50eXBlLCBudWxsLCBudWxsKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgaW5mbyArPSBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUobm9kZS50eXBlLCBudWxsLCBudWxsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gd2UgYmFpbCBvdXQgd2hlbiB3ZSBnZXQgYSBudWxsXG5cblxuICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIH0gd2hpbGUgKG5vZGUpO1xuXG4gICAgcmV0dXJuIGluZm87XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICByZXR1cm4gJ1xcbkVycm9yIGdlbmVyYXRpbmcgc3RhY2s6ICcgKyB4Lm1lc3NhZ2UgKyAnXFxuJyArIHguc3RhY2s7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIFJlYWN0Q3VycmVudENhY2hlID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50Q2FjaGU7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUEVORElORyA9IDA7XG52YXIgQ09NUExFVEVEID0gMTtcbnZhciBGTFVTSEVEID0gMjtcbnZhciBBQk9SVEVEID0gMztcbnZhciBFUlJPUkVEID0gNDtcbnZhciBPUEVOID0gMDtcbnZhciBDTE9TSU5HID0gMTtcbnZhciBDTE9TRUQgPSAyOyAvLyBUaGlzIGlzIGEgZGVmYXVsdCBoZXVyaXN0aWMgZm9yIGhvdyB0byBzcGxpdCB1cCB0aGUgSFRNTCBjb250ZW50IGludG8gcHJvZ3Jlc3NpdmVcbi8vIGxvYWRpbmcuIE91ciBnb2FsIGlzIHRvIGJlIGFibGUgdG8gZGlzcGxheSBhZGRpdGlvbmFsIG5ldyBjb250ZW50IGFib3V0IGV2ZXJ5IDUwMG1zLlxuLy8gRmFzdGVyIHRoYW4gdGhhdCBpcyB1bm5lY2Vzc2FyeSBhbmQgc2hvdWxkIGJlIHRocm90dGxlZCBvbiB0aGUgY2xpZW50LiBJdCBhbHNvXG4vLyBhZGRzIHVubmVjZXNzYXJ5IG92ZXJoZWFkIHRvIGRvIG1vcmUgc3BsaXRzLiBXZSBkb24ndCBrbm93IGlmIGl0J3MgYSBoaWdoZXIgb3IgbG93ZXJcbi8vIGVuZCBkZXZpY2UgYnV0IGhpZ2hlciBlbmQgc3VmZmVyIGxlc3MgZnJvbSB0aGUgb3ZlcmhlYWQgdGhhbiBsb3dlciBlbmQgZG9lcyBmcm9tXG4vLyBub3QgZ2V0dGluZyBzbWFsbCBlbm91Z2ggcGllY2VzLiBXZSBlcnJvciBvbiB0aGUgc2lkZSBvZiBsb3cgZW5kLlxuLy8gV2UgYmFzZSB0aGlzIG9uIGxvdyBlbmQgM0cgc3BlZWRzIHdoaWNoIGlzIGFib3V0IDUwMGtiaXRzIHBlciBzZWNvbmQuIFdlIGFzc3VtZVxuLy8gdGhhdCB0aGVyZSBjYW4gYmUgYSByZWFzb25hYmxlIGRyb3Agb2ZmIGZyb20gbWF4IGJhbmR3aWR0aCB3aGljaCBsZWF2ZXMgeW91IHdpdGhcbi8vIGFzIGxpdHRsZSBhcyA4MCUuIFdlIGNhbiByZWNlaXZlIGhhbGYgb2YgdGhhdCBlYWNoIDUwMG1zIC0gYXQgYmVzdC4gSW4gcHJhY3RpY2UsXG4vLyBhIGxpdHRsZSBiYW5kd2lkdGggaXMgbG9zdCB0byBwcm9jZXNzaW5nIGFuZCBjb250ZW50aW9uIC0gZS5nLiBDU1MgYW5kIGltYWdlcyB0aGF0XG4vLyBhcmUgZG93bmxvYWRlZCBhbG9uZyB3aXRoIHRoZSBtYWluIGNvbnRlbnQuIFNvIHdlIGVzdGltYXRlIGFib3V0IGhhbGYgb2YgdGhhdCB0byBiZVxuLy8gdGhlIGxvd2VyIGVuZCB0aHJvdWdocHV0LiBJbiBvdGhlciB3b3Jkcywgd2UgZXhwZWN0IHRoYXQgeW91IGNhbiBhdCBsZWFzdCBzaG93XG4vLyBhYm91dCAxMi41a2Igb2YgY29udGVudCBwZXIgNTAwbXMuIE5vdCBjb3VudGluZyBzdGFydGluZyBsYXRlbmN5IGZvciB0aGUgZmlyc3Rcbi8vIHBhaW50LlxuLy8gNTAwICogMTAyNCAvIDggKiAuOCAqIDAuNSAvIDJcblxudmFyIERFRkFVTFRfUFJPR1JFU1NJVkVfQ0hVTktfU0laRSA9IDEyODAwO1xuXG5mdW5jdGlvbiBkZWZhdWx0RXJyb3JIYW5kbGVyKGVycm9yKSB7XG4gIGNvbnNvbGVbJ2Vycm9yJ10oZXJyb3IpOyAvLyBEb24ndCB0cmFuc2Zvcm0gdG8gb3VyIHdyYXBwZXJcblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3QoY2hpbGRyZW4sIHJlc291cmNlcywgcmVzcG9uc2VTdGF0ZSwgcm9vdEZvcm1hdENvbnRleHQsIHByb2dyZXNzaXZlQ2h1bmtTaXplLCBvbkVycm9yLCBvbkFsbFJlYWR5LCBvblNoZWxsUmVhZHksIG9uU2hlbGxFcnJvciwgb25GYXRhbEVycm9yKSB7XG4gIHByZXBhcmVIb3N0RGlzcGF0Y2hlcigpO1xuICB2YXIgcGluZ2VkVGFza3MgPSBbXTtcbiAgdmFyIGFib3J0U2V0ID0gbmV3IFNldCgpO1xuICB2YXIgcmVxdWVzdCA9IHtcbiAgICBkZXN0aW5hdGlvbjogbnVsbCxcbiAgICBmbHVzaFNjaGVkdWxlZDogZmFsc2UsXG4gICAgcmVzcG9uc2VTdGF0ZTogcmVzcG9uc2VTdGF0ZSxcbiAgICBwcm9ncmVzc2l2ZUNodW5rU2l6ZTogcHJvZ3Jlc3NpdmVDaHVua1NpemUgPT09IHVuZGVmaW5lZCA/IERFRkFVTFRfUFJPR1JFU1NJVkVfQ0hVTktfU0laRSA6IHByb2dyZXNzaXZlQ2h1bmtTaXplLFxuICAgIHN0YXR1czogT1BFTixcbiAgICBmYXRhbEVycm9yOiBudWxsLFxuICAgIG5leHRTZWdtZW50SWQ6IDAsXG4gICAgYWxsUGVuZGluZ1Rhc2tzOiAwLFxuICAgIHBlbmRpbmdSb290VGFza3M6IDAsXG4gICAgcmVzb3VyY2VzOiByZXNvdXJjZXMsXG4gICAgY29tcGxldGVkUm9vdFNlZ21lbnQ6IG51bGwsXG4gICAgYWJvcnRhYmxlVGFza3M6IGFib3J0U2V0LFxuICAgIHBpbmdlZFRhc2tzOiBwaW5nZWRUYXNrcyxcbiAgICBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXM6IFtdLFxuICAgIGNvbXBsZXRlZEJvdW5kYXJpZXM6IFtdLFxuICAgIHBhcnRpYWxCb3VuZGFyaWVzOiBbXSxcbiAgICBvbkVycm9yOiBvbkVycm9yID09PSB1bmRlZmluZWQgPyBkZWZhdWx0RXJyb3JIYW5kbGVyIDogb25FcnJvcixcbiAgICBvbkFsbFJlYWR5OiBvbkFsbFJlYWR5ID09PSB1bmRlZmluZWQgPyBub29wIDogb25BbGxSZWFkeSxcbiAgICBvblNoZWxsUmVhZHk6IG9uU2hlbGxSZWFkeSA9PT0gdW5kZWZpbmVkID8gbm9vcCA6IG9uU2hlbGxSZWFkeSxcbiAgICBvblNoZWxsRXJyb3I6IG9uU2hlbGxFcnJvciA9PT0gdW5kZWZpbmVkID8gbm9vcCA6IG9uU2hlbGxFcnJvcixcbiAgICBvbkZhdGFsRXJyb3I6IG9uRmF0YWxFcnJvciA9PT0gdW5kZWZpbmVkID8gbm9vcCA6IG9uRmF0YWxFcnJvclxuICB9OyAvLyBUaGlzIHNlZ21lbnQgcmVwcmVzZW50cyB0aGUgcm9vdCBmYWxsYmFjay5cblxuICB2YXIgcm9vdFNlZ21lbnQgPSBjcmVhdGVQZW5kaW5nU2VnbWVudChyZXF1ZXN0LCAwLCBudWxsLCByb290Rm9ybWF0Q29udGV4dCwgLy8gUm9vdCBzZWdtZW50cyBhcmUgbmV2ZXIgZW1iZWRkZWQgaW4gVGV4dCBvbiBlaXRoZXIgZWRnZVxuICBmYWxzZSwgZmFsc2UpOyAvLyBUaGVyZSBpcyBubyBwYXJlbnQgc28gY29uY2VwdHVhbGx5LCB3ZSdyZSB1bmJsb2NrZWQgdG8gZmx1c2ggdGhpcyBzZWdtZW50LlxuXG4gIHJvb3RTZWdtZW50LnBhcmVudEZsdXNoZWQgPSB0cnVlO1xuICB2YXIgcm9vdFRhc2sgPSBjcmVhdGVUYXNrKHJlcXVlc3QsIG51bGwsIGNoaWxkcmVuLCBudWxsLCByb290U2VnbWVudCwgYWJvcnRTZXQsIGVtcHR5Q29udGV4dE9iamVjdCwgcm9vdENvbnRleHRTbmFwc2hvdCwgZW1wdHlUcmVlQ29udGV4dCk7XG4gIHBpbmdlZFRhc2tzLnB1c2gocm9vdFRhc2spO1xuICByZXR1cm4gcmVxdWVzdDtcbn1cbnZhciBjdXJyZW50UmVxdWVzdCA9IG51bGw7XG5mdW5jdGlvbiByZXNvbHZlUmVxdWVzdCgpIHtcbiAgaWYgKGN1cnJlbnRSZXF1ZXN0KSByZXR1cm4gY3VycmVudFJlcXVlc3Q7XG5cbiAge1xuICAgIHZhciBzdG9yZSA9IHJlcXVlc3RTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgaWYgKHN0b3JlKSByZXR1cm4gc3RvcmU7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcGluZ1Rhc2socmVxdWVzdCwgdGFzaykge1xuICB2YXIgcGluZ2VkVGFza3MgPSByZXF1ZXN0LnBpbmdlZFRhc2tzO1xuICBwaW5nZWRUYXNrcy5wdXNoKHRhc2spO1xuXG4gIGlmIChyZXF1ZXN0LnBpbmdlZFRhc2tzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPSByZXF1ZXN0LmRlc3RpbmF0aW9uICE9PSBudWxsO1xuICAgIHNjaGVkdWxlV29yayhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybVdvcmsocmVxdWVzdCk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShyZXF1ZXN0LCBmYWxsYmFja0Fib3J0YWJsZVRhc2tzKSB7XG4gIHJldHVybiB7XG4gICAgaWQ6IFVOSU5JVElBTElaRURfU1VTUEVOU0VfQk9VTkRBUllfSUQsXG4gICAgcm9vdFNlZ21lbnRJRDogLTEsXG4gICAgcGFyZW50Rmx1c2hlZDogZmFsc2UsXG4gICAgcGVuZGluZ1Rhc2tzOiAwLFxuICAgIGZvcmNlQ2xpZW50UmVuZGVyOiBmYWxzZSxcbiAgICBjb21wbGV0ZWRTZWdtZW50czogW10sXG4gICAgYnl0ZVNpemU6IDAsXG4gICAgZmFsbGJhY2tBYm9ydGFibGVUYXNrczogZmFsbGJhY2tBYm9ydGFibGVUYXNrcyxcbiAgICBlcnJvckRpZ2VzdDogbnVsbCxcbiAgICByZXNvdXJjZXM6IGNyZWF0ZUJvdW5kYXJ5UmVzb3VyY2VzKClcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGFzayhyZXF1ZXN0LCB0aGVuYWJsZVN0YXRlLCBub2RlLCBibG9ja2VkQm91bmRhcnksIGJsb2NrZWRTZWdtZW50LCBhYm9ydFNldCwgbGVnYWN5Q29udGV4dCwgY29udGV4dCwgdHJlZUNvbnRleHQpIHtcbiAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MrKztcblxuICBpZiAoYmxvY2tlZEJvdW5kYXJ5ID09PSBudWxsKSB7XG4gICAgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzKys7XG4gIH0gZWxzZSB7XG4gICAgYmxvY2tlZEJvdW5kYXJ5LnBlbmRpbmdUYXNrcysrO1xuICB9XG5cbiAgdmFyIHRhc2sgPSB7XG4gICAgbm9kZTogbm9kZSxcbiAgICBwaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcGluZ1Rhc2socmVxdWVzdCwgdGFzayk7XG4gICAgfSxcbiAgICBibG9ja2VkQm91bmRhcnk6IGJsb2NrZWRCb3VuZGFyeSxcbiAgICBibG9ja2VkU2VnbWVudDogYmxvY2tlZFNlZ21lbnQsXG4gICAgYWJvcnRTZXQ6IGFib3J0U2V0LFxuICAgIGxlZ2FjeUNvbnRleHQ6IGxlZ2FjeUNvbnRleHQsXG4gICAgY29udGV4dDogY29udGV4dCxcbiAgICB0cmVlQ29udGV4dDogdHJlZUNvbnRleHQsXG4gICAgdGhlbmFibGVTdGF0ZTogdGhlbmFibGVTdGF0ZVxuICB9O1xuXG4gIHtcbiAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gbnVsbDtcbiAgfVxuXG4gIGFib3J0U2V0LmFkZCh0YXNrKTtcbiAgcmV0dXJuIHRhc2s7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBlbmRpbmdTZWdtZW50KHJlcXVlc3QsIGluZGV4LCBib3VuZGFyeSwgZm9ybWF0Q29udGV4dCwgbGFzdFB1c2hlZFRleHQsIHRleHRFbWJlZGRlZCkge1xuICByZXR1cm4ge1xuICAgIHN0YXR1czogUEVORElORyxcbiAgICBpZDogLTEsXG4gICAgLy8gbGF6aWx5IGFzc2lnbmVkIGxhdGVyXG4gICAgaW5kZXg6IGluZGV4LFxuICAgIHBhcmVudEZsdXNoZWQ6IGZhbHNlLFxuICAgIGNodW5rczogW10sXG4gICAgY2hpbGRyZW46IFtdLFxuICAgIGZvcm1hdENvbnRleHQ6IGZvcm1hdENvbnRleHQsXG4gICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgIGxhc3RQdXNoZWRUZXh0OiBsYXN0UHVzaGVkVGV4dCxcbiAgICB0ZXh0RW1iZWRkZWQ6IHRleHRFbWJlZGRlZFxuICB9O1xufSAvLyBERVYtb25seSBnbG9iYWwgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIHRhc2tcblxuXG52YXIgY3VycmVudFRhc2tJbkRFViA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRTdGFja0luREVWKCkge1xuICB7XG4gICAgaWYgKGN1cnJlbnRUYXNrSW5ERVYgPT09IG51bGwgfHwgY3VycmVudFRhc2tJbkRFVi5jb21wb25lbnRTdGFjayA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRTdGFja0J5Q29tcG9uZW50U3RhY2tOb2RlKGN1cnJlbnRUYXNrSW5ERVYuY29tcG9uZW50U3RhY2spO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hCdWlsdEluQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrLCB0eXBlKSB7XG4gIHtcbiAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0ge1xuICAgICAgdGFnOiAwLFxuICAgICAgcGFyZW50OiB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgdHlwZTogdHlwZVxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaEZ1bmN0aW9uQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrLCB0eXBlKSB7XG4gIHtcbiAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0ge1xuICAgICAgdGFnOiAxLFxuICAgICAgcGFyZW50OiB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgdHlwZTogdHlwZVxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaENsYXNzQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrLCB0eXBlKSB7XG4gIHtcbiAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0ge1xuICAgICAgdGFnOiAyLFxuICAgICAgcGFyZW50OiB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgdHlwZTogdHlwZVxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKSB7XG4gIHtcbiAgICBpZiAodGFzay5jb21wb25lbnRTdGFjayA9PT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWRseSBwb3BwZWQgdG9vIG1hbnkgc3RhY2sgZnJhbWVzLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gdGFzay5jb21wb25lbnRTdGFjay5wYXJlbnQ7XG4gICAgfVxuICB9XG59IC8vIHN0YXNoIHRoZSBjb21wb25lbnQgc3RhY2sgb2YgYW4gdW53aW5kaW5nIGVycm9yIHVudGlsIGl0IGlzIHByb2Nlc3NlZFxuXG5cbnZhciBsYXN0Qm91bmRhcnlFcnJvckNvbXBvbmVudFN0YWNrRGV2ID0gbnVsbDtcblxuZnVuY3Rpb24gY2FwdHVyZUJvdW5kYXJ5RXJyb3JEZXRhaWxzRGV2KGJvdW5kYXJ5LCBlcnJvcikge1xuICB7XG4gICAgdmFyIGVycm9yTWVzc2FnZTtcblxuICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvcjtcbiAgICB9IGVsc2UgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gICAgICBlcnJvck1lc3NhZ2UgPSBTdHJpbmcoZXJyb3IpO1xuICAgIH1cblxuICAgIHZhciBlcnJvckNvbXBvbmVudFN0YWNrID0gbGFzdEJvdW5kYXJ5RXJyb3JDb21wb25lbnRTdGFja0RldiB8fCBnZXRDdXJyZW50U3RhY2tJbkRFVigpO1xuICAgIGxhc3RCb3VuZGFyeUVycm9yQ29tcG9uZW50U3RhY2tEZXYgPSBudWxsO1xuICAgIGJvdW5kYXJ5LmVycm9yTWVzc2FnZSA9IGVycm9yTWVzc2FnZTtcbiAgICBib3VuZGFyeS5lcnJvckNvbXBvbmVudFN0YWNrID0gZXJyb3JDb21wb25lbnRTdGFjaztcbiAgfVxufVxuXG5mdW5jdGlvbiBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yKSB7XG4gIC8vIElmIHRoaXMgY2FsbGJhY2sgZXJyb3JzLCB3ZSBpbnRlbnRpb25hbGx5IGxldCB0aGF0IGVycm9yIGJ1YmJsZSB1cCB0byBiZWNvbWUgYSBmYXRhbCBlcnJvclxuICAvLyBzbyB0aGF0IHNvbWVvbmUgZml4ZXMgdGhlIGVycm9yIHJlcG9ydGluZyBpbnN0ZWFkIG9mIGhpZGluZyBpdC5cbiAgdmFyIGVycm9yRGlnZXN0ID0gcmVxdWVzdC5vbkVycm9yKGVycm9yKTtcblxuICBpZiAoZXJyb3JEaWdlc3QgIT0gbnVsbCAmJiB0eXBlb2YgZXJyb3JEaWdlc3QgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJvbkVycm9yIHJldHVybmVkIHNvbWV0aGluZyB3aXRoIGEgdHlwZSBvdGhlciB0aGFuIFxcXCJzdHJpbmdcXFwiLiBvbkVycm9yIHNob3VsZCByZXR1cm4gYSBzdHJpbmcgYW5kIG1heSByZXR1cm4gbnVsbCBvciB1bmRlZmluZWQgYnV0IG11c3Qgbm90IHJldHVybiBhbnl0aGluZyBlbHNlLiBJdCByZWNlaXZlZCBzb21ldGhpbmcgb2YgdHlwZSBcXFwiXCIgKyB0eXBlb2YgZXJyb3JEaWdlc3QgKyBcIlxcXCIgaW5zdGVhZFwiKTtcbiAgfVxuXG4gIHJldHVybiBlcnJvckRpZ2VzdDtcbn1cblxuZnVuY3Rpb24gZmF0YWxFcnJvcihyZXF1ZXN0LCBlcnJvcikge1xuICAvLyBUaGlzIGlzIGNhbGxlZCBvdXRzaWRlIGVycm9yIGhhbmRsaW5nIGNvZGUgc3VjaCBhcyBpZiB0aGUgcm9vdCBlcnJvcnMgb3V0c2lkZVxuICAvLyBhIHN1c3BlbnNlIGJvdW5kYXJ5IG9yIGlmIHRoZSByb290IHN1c3BlbnNlIGJvdW5kYXJ5J3MgZmFsbGJhY2sgZXJyb3JzLlxuICAvLyBJdCdzIGFsc28gY2FsbGVkIGlmIFJlYWN0IGl0c2VsZiBvciBpdHMgaG9zdCBjb25maWdzIGVycm9ycy5cbiAgdmFyIG9uU2hlbGxFcnJvciA9IHJlcXVlc3Qub25TaGVsbEVycm9yO1xuICBvblNoZWxsRXJyb3IoZXJyb3IpO1xuICB2YXIgb25GYXRhbEVycm9yID0gcmVxdWVzdC5vbkZhdGFsRXJyb3I7XG4gIG9uRmF0YWxFcnJvcihlcnJvcik7XG5cbiAgaWYgKHJlcXVlc3QuZGVzdGluYXRpb24gIT09IG51bGwpIHtcbiAgICByZXF1ZXN0LnN0YXR1cyA9IENMT1NFRDtcbiAgICBjbG9zZVdpdGhFcnJvcihyZXF1ZXN0LmRlc3RpbmF0aW9uLCBlcnJvcik7XG4gIH0gZWxzZSB7XG4gICAgcmVxdWVzdC5zdGF0dXMgPSBDTE9TSU5HO1xuICAgIHJlcXVlc3QuZmF0YWxFcnJvciA9IGVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlclN1c3BlbnNlQm91bmRhcnkocmVxdWVzdCwgdGFzaywgcHJvcHMpIHtcbiAgcHVzaEJ1aWx0SW5Db21wb25lbnRTdGFja0luREVWKHRhc2ssICdTdXNwZW5zZScpO1xuICB2YXIgcGFyZW50Qm91bmRhcnkgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeTtcbiAgdmFyIHBhcmVudFNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50OyAvLyBFYWNoIHRpbWUgd2UgZW50ZXIgYSBzdXNwZW5zZSBib3VuZGFyeSwgd2Ugc3BsaXQgb3V0IGludG8gYSBuZXcgc2VnbWVudCBmb3JcbiAgLy8gdGhlIGZhbGxiYWNrIHNvIHRoYXQgd2UgY2FuIGxhdGVyIHJlcGxhY2UgdGhhdCBzZWdtZW50IHdpdGggdGhlIGNvbnRlbnQuXG4gIC8vIFRoaXMgYWxzbyBsZXRzIHVzIHNwbGl0IG91dCB0aGUgbWFpbiBjb250ZW50IGV2ZW4gaWYgaXQgZG9lc24ndCBzdXNwZW5kLFxuICAvLyBpbiBjYXNlIGl0IGVuZHMgdXAgZ2VuZXJhdGluZyBhIGxhcmdlIHN1YnRyZWUgb2YgY29udGVudC5cblxuICB2YXIgZmFsbGJhY2sgPSBwcm9wcy5mYWxsYmFjaztcbiAgdmFyIGNvbnRlbnQgPSBwcm9wcy5jaGlsZHJlbjtcbiAgdmFyIGZhbGxiYWNrQWJvcnRTZXQgPSBuZXcgU2V0KCk7XG4gIHZhciBuZXdCb3VuZGFyeSA9IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkocmVxdWVzdCwgZmFsbGJhY2tBYm9ydFNldCk7XG4gIHZhciBpbnNlcnRpb25JbmRleCA9IHBhcmVudFNlZ21lbnQuY2h1bmtzLmxlbmd0aDsgLy8gVGhlIGNoaWxkcmVuIG9mIHRoZSBib3VuZGFyeSBzZWdtZW50IGlzIGFjdHVhbGx5IHRoZSBmYWxsYmFjay5cblxuICB2YXIgYm91bmRhcnlTZWdtZW50ID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQocmVxdWVzdCwgaW5zZXJ0aW9uSW5kZXgsIG5ld0JvdW5kYXJ5LCBwYXJlbnRTZWdtZW50LmZvcm1hdENvbnRleHQsIC8vIGJvdW5kYXJpZXMgbmV2ZXIgcmVxdWlyZSB0ZXh0IGVtYmVkZGluZyBhdCB0aGVpciBlZGdlcyBiZWNhdXNlIGNvbW1lbnQgbm9kZXMgYm91bmQgdGhlbVxuICBmYWxzZSwgZmFsc2UpO1xuICBwYXJlbnRTZWdtZW50LmNoaWxkcmVuLnB1c2goYm91bmRhcnlTZWdtZW50KTsgLy8gVGhlIHBhcmVudFNlZ21lbnQgaGFzIGEgY2hpbGQgU2VnbWVudCBhdCB0aGlzIGluZGV4IHNvIHdlIHJlc2V0IHRoZSBsYXN0UHVzaGVkVGV4dCBtYXJrZXIgb24gdGhlIHBhcmVudFxuXG4gIHBhcmVudFNlZ21lbnQubGFzdFB1c2hlZFRleHQgPSBmYWxzZTsgLy8gVGhpcyBzZWdtZW50IGlzIHRoZSBhY3R1YWwgY2hpbGQgY29udGVudC4gV2UgY2FuIHN0YXJ0IHJlbmRlcmluZyB0aGF0IGltbWVkaWF0ZWx5LlxuXG4gIHZhciBjb250ZW50Um9vdFNlZ21lbnQgPSBjcmVhdGVQZW5kaW5nU2VnbWVudChyZXF1ZXN0LCAwLCBudWxsLCBwYXJlbnRTZWdtZW50LmZvcm1hdENvbnRleHQsIC8vIGJvdW5kYXJpZXMgbmV2ZXIgcmVxdWlyZSB0ZXh0IGVtYmVkZGluZyBhdCB0aGVpciBlZGdlcyBiZWNhdXNlIGNvbW1lbnQgbm9kZXMgYm91bmQgdGhlbVxuICBmYWxzZSwgZmFsc2UpOyAvLyBXZSBtYXJrIHRoZSByb290IHNlZ21lbnQgYXMgaGF2aW5nIGl0cyBwYXJlbnQgZmx1c2hlZC4gSXQncyBub3QgcmVhbGx5IGZsdXNoZWQgYnV0IHRoZXJlIGlzXG4gIC8vIG5vIHBhcmVudCBzZWdtZW50IHNvIHRoZXJlJ3Mgbm90aGluZyB0byB3YWl0IG9uLlxuXG4gIGNvbnRlbnRSb290U2VnbWVudC5wYXJlbnRGbHVzaGVkID0gdHJ1ZTsgLy8gQ3VycmVudGx5IHRoaXMgaXMgcnVubmluZyBzeW5jaHJvbm91c2x5LiBXZSBjb3VsZCBpbnN0ZWFkIHNjaGVkdWxlIHRoaXMgdG8gcGluZ2VkVGFza3MuXG4gIC8vIEkgc3VzcGVjdCB0aGF0IHRoZXJlIG1pZ2h0IGJlIHNvbWUgZWZmaWNpZW5jeSBiZW5lZml0cyBmcm9tIG5vdCBjcmVhdGluZyB0aGUgc3VzcGVuZGVkIHRhc2tcbiAgLy8gYW5kIGluc3RlYWQganVzdCB1c2luZyB0aGUgc3RhY2sgaWYgcG9zc2libGUuXG4gIC8vIFRPRE86IENhbGwgdGhpcyBkaXJlY3RseSBpbnN0ZWFkIG9mIG1lc3Npbmcgd2l0aCBzYXZpbmcgYW5kIHJlc3RvcmluZyBjb250ZXh0cy5cbiAgLy8gV2UgY2FuIHJldXNlIHRoZSBjdXJyZW50IGNvbnRleHQgYW5kIHRhc2sgdG8gcmVuZGVyIHRoZSBjb250ZW50IGltbWVkaWF0ZWx5IHdpdGhvdXRcbiAgLy8gY29udGV4dCBzd2l0Y2hpbmcuIFdlIGp1c3QgbmVlZCB0byB0ZW1wb3JhcmlseSBzd2l0Y2ggd2hpY2ggYm91bmRhcnkgYW5kIHdoaWNoIHNlZ21lbnRcbiAgLy8gd2UncmUgd3JpdGluZyB0by4gSWYgc29tZXRoaW5nIHN1c3BlbmRzLCBpdCdsbCBzcGF3biBuZXcgc3VzcGVuZGVkIHRhc2sgd2l0aCB0aGF0IGNvbnRleHQuXG5cbiAgdGFzay5ibG9ja2VkQm91bmRhcnkgPSBuZXdCb3VuZGFyeTtcbiAgdGFzay5ibG9ja2VkU2VnbWVudCA9IGNvbnRlbnRSb290U2VnbWVudDtcblxuICB7XG4gICAgc2V0Q3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlSZXNvdXJjZXNUYXJnZXQocmVxdWVzdC5yZXNvdXJjZXMsIG5ld0JvdW5kYXJ5LnJlc291cmNlcyk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFdlIHVzZSB0aGUgc2FmZSBmb3JtIGJlY2F1c2Ugd2UgZG9uJ3QgaGFuZGxlIHN1c3BlbmRpbmcgaGVyZS4gT25seSBlcnJvciBoYW5kbGluZy5cbiAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNvbnRlbnQpO1xuICAgIHB1c2hTZWdtZW50RmluYWxlKGNvbnRlbnRSb290U2VnbWVudC5jaHVua3MsIHJlcXVlc3QucmVzcG9uc2VTdGF0ZSwgY29udGVudFJvb3RTZWdtZW50Lmxhc3RQdXNoZWRUZXh0LCBjb250ZW50Um9vdFNlZ21lbnQudGV4dEVtYmVkZGVkKTtcbiAgICBjb250ZW50Um9vdFNlZ21lbnQuc3RhdHVzID0gQ09NUExFVEVEO1xuICAgIHF1ZXVlQ29tcGxldGVkU2VnbWVudChuZXdCb3VuZGFyeSwgY29udGVudFJvb3RTZWdtZW50KTtcblxuICAgIGlmIChuZXdCb3VuZGFyeS5wZW5kaW5nVGFza3MgPT09IDApIHtcbiAgICAgIC8vIFRoaXMgbXVzdCBoYXZlIGJlZW4gdGhlIGxhc3Qgc2VnbWVudCB3ZSB3ZXJlIHdhaXRpbmcgb24uIFRoaXMgYm91bmRhcnkgaXMgbm93IGNvbXBsZXRlLlxuICAgICAgLy8gVGhlcmVmb3JlIHdlIHdvbid0IG5lZWQgdGhlIGZhbGxiYWNrLiBXZSBlYXJseSByZXR1cm4gc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGNyZWF0ZVxuICAgICAgLy8gdGhlIGZhbGxiYWNrLlxuICAgICAgcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29udGVudFJvb3RTZWdtZW50LnN0YXR1cyA9IEVSUk9SRUQ7XG4gICAgbmV3Qm91bmRhcnkuZm9yY2VDbGllbnRSZW5kZXIgPSB0cnVlO1xuICAgIG5ld0JvdW5kYXJ5LmVycm9yRGlnZXN0ID0gbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG5cbiAgICB7XG4gICAgICBjYXB0dXJlQm91bmRhcnlFcnJvckRldGFpbHNEZXYobmV3Qm91bmRhcnksIGVycm9yKTtcbiAgICB9IC8vIFdlIGRvbid0IG5lZWQgdG8gZGVjcmVtZW50IGFueSB0YXNrIG51bWJlcnMgYmVjYXVzZSB3ZSBkaWRuJ3Qgc3Bhd24gYW55IG5ldyB0YXNrLlxuICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gc2NoZWR1bGUgYW55IHRhc2sgYmVjYXVzZSB3ZSBrbm93IHRoZSBwYXJlbnQgaGFzIHdyaXR0ZW4geWV0LlxuICAgIC8vIFdlIGRvIG5lZWQgdG8gZmFsbHRocm91Z2ggdG8gY3JlYXRlIHRoZSBmYWxsYmFjayB0aG91Z2guXG5cbiAgfSBmaW5hbGx5IHtcbiAgICB7XG4gICAgICBzZXRDdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeVJlc291cmNlc1RhcmdldChyZXF1ZXN0LnJlc291cmNlcywgcGFyZW50Qm91bmRhcnkgPyBwYXJlbnRCb3VuZGFyeS5yZXNvdXJjZXMgOiBudWxsKTtcbiAgICB9XG5cbiAgICB0YXNrLmJsb2NrZWRCb3VuZGFyeSA9IHBhcmVudEJvdW5kYXJ5O1xuICAgIHRhc2suYmxvY2tlZFNlZ21lbnQgPSBwYXJlbnRTZWdtZW50O1xuICB9IC8vIFdlIGNyZWF0ZSBzdXNwZW5kZWQgdGFzayBmb3IgdGhlIGZhbGxiYWNrIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byBhY3R1YWxseSB3b3JrXG4gIC8vIG9uIGl0IHlldCBpbiBjYXNlIHdlIGZpbmlzaCB0aGUgbWFpbiBjb250ZW50LCBzbyB3ZSBxdWV1ZSBmb3IgbGF0ZXIuXG5cblxuICB2YXIgc3VzcGVuZGVkRmFsbGJhY2tUYXNrID0gY3JlYXRlVGFzayhyZXF1ZXN0LCBudWxsLCBmYWxsYmFjaywgcGFyZW50Qm91bmRhcnksIGJvdW5kYXJ5U2VnbWVudCwgZmFsbGJhY2tBYm9ydFNldCwgdGFzay5sZWdhY3lDb250ZXh0LCB0YXNrLmNvbnRleHQsIHRhc2sudHJlZUNvbnRleHQpO1xuXG4gIHtcbiAgICBzdXNwZW5kZWRGYWxsYmFja1Rhc2suY29tcG9uZW50U3RhY2sgPSB0YXNrLmNvbXBvbmVudFN0YWNrO1xuICB9IC8vIFRPRE86IFRoaXMgc2hvdWxkIGJlIHF1ZXVlZCBhdCBhIHNlcGFyYXRlIGxvd2VyIHByaW9yaXR5IHF1ZXVlIHNvIHRoYXQgd2Ugb25seSB3b3JrXG4gIC8vIG9uIHByZXBhcmluZyBmYWxsYmFja3MgaWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBtYWluIGNvbnRlbnQgdG8gdGFzayBvbi5cblxuXG4gIHJlcXVlc3QucGluZ2VkVGFza3MucHVzaChzdXNwZW5kZWRGYWxsYmFja1Rhc2spO1xuICBwb3BDb21wb25lbnRTdGFja0luREVWKHRhc2spO1xufVxuXG5mdW5jdGlvbiByZW5kZXJIb3N0RWxlbWVudChyZXF1ZXN0LCB0YXNrLCB0eXBlLCBwcm9wcykge1xuICBwdXNoQnVpbHRJbkNvbXBvbmVudFN0YWNrSW5ERVYodGFzaywgdHlwZSk7XG4gIHZhciBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcbiAgdmFyIGNoaWxkcmVuID0gcHVzaFN0YXJ0SW5zdGFuY2Uoc2VnbWVudC5jaHVua3MsIHR5cGUsIHByb3BzLCByZXF1ZXN0LnJlc291cmNlcywgcmVxdWVzdC5yZXNwb25zZVN0YXRlLCBzZWdtZW50LmZvcm1hdENvbnRleHQsIHNlZ21lbnQubGFzdFB1c2hlZFRleHQpO1xuICBzZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gZmFsc2U7XG4gIHZhciBwcmV2Q29udGV4dCA9IHNlZ21lbnQuZm9ybWF0Q29udGV4dDtcbiAgc2VnbWVudC5mb3JtYXRDb250ZXh0ID0gZ2V0Q2hpbGRGb3JtYXRDb250ZXh0KHByZXZDb250ZXh0LCB0eXBlLCBwcm9wcyk7IC8vIFdlIHVzZSB0aGUgbm9uLWRlc3RydWN0aXZlIGZvcm0gYmVjYXVzZSBpZiBzb21ldGhpbmcgc3VzcGVuZHMsIHdlIHN0aWxsXG4gIC8vIG5lZWQgdG8gcG9wIGJhY2sgdXAgYW5kIGZpbmlzaCB0aGlzIHN1YnRyZWUgb2YgSFRNTC5cblxuICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuKTsgLy8gV2UgZXhwZWN0IHRoYXQgZXJyb3JzIHdpbGwgZmF0YWwgdGhlIHdob2xlIHRhc2sgYW5kIHRoYXQgd2UgZG9uJ3QgbmVlZFxuICAvLyB0aGUgY29ycmVjdCBjb250ZXh0LiBUaGVyZWZvcmUgdGhpcyBpcyBub3QgaW4gYSBmaW5hbGx5LlxuXG4gIHNlZ21lbnQuZm9ybWF0Q29udGV4dCA9IHByZXZDb250ZXh0O1xuICBwdXNoRW5kSW5zdGFuY2Uoc2VnbWVudC5jaHVua3MsIHR5cGUsIHByb3BzLCByZXF1ZXN0LnJlc3BvbnNlU3RhdGUsIHByZXZDb250ZXh0KTtcbiAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9IGZhbHNlO1xuICBwb3BDb21wb25lbnRTdGFja0luREVWKHRhc2spO1xufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHJldHVybiBDb21wb25lbnQucHJvdG90eXBlICYmIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudDtcbn1cblxuZnVuY3Rpb24gcmVuZGVyV2l0aEhvb2tzKHJlcXVlc3QsIHRhc2ssIHByZXZUaGVuYWJsZVN0YXRlLCBDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcpIHtcbiAgdmFyIGNvbXBvbmVudElkZW50aXR5ID0ge307XG4gIHByZXBhcmVUb1VzZUhvb2tzKHRhc2ssIGNvbXBvbmVudElkZW50aXR5LCBwcmV2VGhlbmFibGVTdGF0ZSk7XG4gIHZhciByZXN1bHQgPSBDb21wb25lbnQocHJvcHMsIHNlY29uZEFyZyk7XG4gIHJldHVybiBmaW5pc2hIb29rcyhDb21wb25lbnQsIHByb3BzLCByZXN1bHQsIHNlY29uZEFyZyk7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaENsYXNzQ29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIGluc3RhbmNlLCBDb21wb25lbnQsIHByb3BzKSB7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSBpbnN0YW5jZS5yZW5kZXIoKTtcblxuICB7XG4gICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBwcm9wcykge1xuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKSB7XG4gICAgICAgIGVycm9yKCdJdCBsb29rcyBsaWtlICVzIGlzIHJlYXNzaWduaW5nIGl0cyBvd24gYHRoaXMucHJvcHNgIHdoaWxlIHJlbmRlcmluZy4gJyArICdUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIGNhbiBsZWFkIHRvIGNvbmZ1c2luZyBidWdzLicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdhIGNvbXBvbmVudCcpO1xuICAgICAgfVxuXG4gICAgICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgdmFyIGNoaWxkQ29udGV4dFR5cGVzID0gQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzO1xuXG4gICAgaWYgKGNoaWxkQ29udGV4dFR5cGVzICE9PSBudWxsICYmIGNoaWxkQ29udGV4dFR5cGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBwcmV2aW91c0NvbnRleHQgPSB0YXNrLmxlZ2FjeUNvbnRleHQ7XG4gICAgICB2YXIgbWVyZ2VkQ29udGV4dCA9IHByb2Nlc3NDaGlsZENvbnRleHQoaW5zdGFuY2UsIENvbXBvbmVudCwgcHJldmlvdXNDb250ZXh0LCBjaGlsZENvbnRleHRUeXBlcyk7XG4gICAgICB0YXNrLmxlZ2FjeUNvbnRleHQgPSBtZXJnZWRDb250ZXh0O1xuICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG51bGwsIG5leHRDaGlsZHJlbik7XG4gICAgICB0YXNrLmxlZ2FjeUNvbnRleHQgPSBwcmV2aW91c0NvbnRleHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG51bGwsIG5leHRDaGlsZHJlbik7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNsYXNzQ29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIENvbXBvbmVudCwgcHJvcHMpIHtcbiAgcHVzaENsYXNzQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrLCBDb21wb25lbnQpO1xuICB2YXIgbWFza2VkQ29udGV4dCA9IGdldE1hc2tlZENvbnRleHQoQ29tcG9uZW50LCB0YXNrLmxlZ2FjeUNvbnRleHQpIDtcbiAgdmFyIGluc3RhbmNlID0gY29uc3RydWN0Q2xhc3NJbnN0YW5jZShDb21wb25lbnQsIHByb3BzLCBtYXNrZWRDb250ZXh0KTtcbiAgbW91bnRDbGFzc0luc3RhbmNlKGluc3RhbmNlLCBDb21wb25lbnQsIHByb3BzLCBtYXNrZWRDb250ZXh0KTtcbiAgZmluaXNoQ2xhc3NDb21wb25lbnQocmVxdWVzdCwgdGFzaywgaW5zdGFuY2UsIENvbXBvbmVudCwgcHJvcHMpO1xuICBwb3BDb21wb25lbnRTdGFja0luREVWKHRhc2spO1xufVxuXG52YXIgZGlkV2FybkFib3V0QmFkQ2xhc3MgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50ID0ge307XG52YXIgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG52YXIgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9O1xudmFyIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgPSBmYWxzZTtcbnZhciBkaWRXYXJuQWJvdXREZWZhdWx0UHJvcHNPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG52YXIgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IGZhbHNlO1xudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbnZhciBoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIgPSBmYWxzZTsgLy8gVGhpcyB3b3VsZCB0eXBpY2FsbHkgYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgYnV0IHdlIHN0aWxsIHN1cHBvcnQgbW9kdWxlIHBhdHRlcm5cbi8vIGNvbXBvbmVudHMgZm9yIHNvbWUgcmVhc29uLlxuXG5mdW5jdGlvbiByZW5kZXJJbmRldGVybWluYXRlQ29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIHByZXZUaGVuYWJsZVN0YXRlLCBDb21wb25lbnQsIHByb3BzKSB7XG4gIHZhciBsZWdhY3lDb250ZXh0O1xuXG4gIHtcbiAgICBsZWdhY3lDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dChDb21wb25lbnQsIHRhc2subGVnYWN5Q29udGV4dCk7XG4gIH1cblxuICBwdXNoRnVuY3Rpb25Db21wb25lbnRTdGFja0luREVWKHRhc2ssIENvbXBvbmVudCk7XG5cbiAge1xuICAgIGlmIChDb21wb25lbnQucHJvdG90eXBlICYmIHR5cGVvZiBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciB2YWx1ZSA9IHJlbmRlcldpdGhIb29rcyhyZXF1ZXN0LCB0YXNrLCBwcmV2VGhlbmFibGVTdGF0ZSwgQ29tcG9uZW50LCBwcm9wcywgbGVnYWN5Q29udGV4dCk7XG4gIHZhciBoYXNJZCA9IGNoZWNrRGlkUmVuZGVySWRIb29rKCk7XG5cbiAge1xuICAgIC8vIFN1cHBvcnQgZm9yIG1vZHVsZSBjb21wb25lbnRzIGlzIGRlcHJlY2F0ZWQgYW5kIGlzIHJlbW92ZWQgYmVoaW5kIGEgZmxhZy5cbiAgICAvLyBXaGV0aGVyIG9yIG5vdCBpdCB3b3VsZCBjcmFzaCBsYXRlciwgd2Ugd2FudCB0byBzaG93IGEgZ29vZCBtZXNzYWdlIGluIERFViBmaXJzdC5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUucmVuZGVyID09PSAnZnVuY3Rpb24nICYmIHZhbHVlLiQkdHlwZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBiZSBhIGZ1bmN0aW9uIGNvbXBvbmVudCB0aGF0IHJldHVybnMgYSBjbGFzcyBpbnN0YW5jZS4gJyArICdDaGFuZ2UgJXMgdG8gYSBjbGFzcyB0aGF0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuICcgKyBcIklmIHlvdSBjYW4ndCB1c2UgYSBjbGFzcyB0cnkgYXNzaWduaW5nIHRoZSBwcm90b3R5cGUgb24gdGhlIGZ1bmN0aW9uIGFzIGEgd29ya2Fyb3VuZC4gXCIgKyBcImAlcy5wcm90b3R5cGUgPSBSZWFjdC5Db21wb25lbnQucHJvdG90eXBlYC4gRG9uJ3QgdXNlIGFuIGFycm93IGZ1bmN0aW9uIHNpbmNlIGl0IFwiICsgJ2Nhbm5vdCBiZSBjYWxsZWQgd2l0aCBgbmV3YCBieSBSZWFjdC4nLCBfY29tcG9uZW50TmFtZSwgX2NvbXBvbmVudE5hbWUsIF9jb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCAvLyBSdW4gdGhlc2UgY2hlY2tzIGluIHByb2R1Y3Rpb24gb25seSBpZiB0aGUgZmxhZyBpcyBvZmYuXG4gIC8vIEV2ZW50dWFsbHkgd2UnbGwgZGVsZXRlIHRoaXMgYnJhbmNoIGFsdG9nZXRoZXIuXG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZS4kJHR5cGVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAge1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lMiA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lMl0pIHtcbiAgICAgICAgZXJyb3IoJ1RoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgdGhhdCByZXR1cm5zIGEgY2xhc3MgaW5zdGFuY2UuICcgKyAnQ2hhbmdlICVzIHRvIGEgY2xhc3MgdGhhdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLiAnICsgXCJJZiB5b3UgY2FuJ3QgdXNlIGEgY2xhc3MgdHJ5IGFzc2lnbmluZyB0aGUgcHJvdG90eXBlIG9uIHRoZSBmdW5jdGlvbiBhcyBhIHdvcmthcm91bmQuIFwiICsgXCJgJXMucHJvdG90eXBlID0gUmVhY3QuQ29tcG9uZW50LnByb3RvdHlwZWAuIERvbid0IHVzZSBhbiBhcnJvdyBmdW5jdGlvbiBzaW5jZSBpdCBcIiArICdjYW5ub3QgYmUgY2FsbGVkIHdpdGggYG5ld2AgYnkgUmVhY3QuJywgX2NvbXBvbmVudE5hbWUyLCBfY29tcG9uZW50TmFtZTIsIF9jb21wb25lbnROYW1lMik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTJdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtb3VudENsYXNzSW5zdGFuY2UodmFsdWUsIENvbXBvbmVudCwgcHJvcHMsIGxlZ2FjeUNvbnRleHQpO1xuICAgIGZpbmlzaENsYXNzQ29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIHZhbHVlLCBDb21wb25lbnQsIHByb3BzKTtcbiAgfSBlbHNlIHtcblxuICAgIHtcbiAgICAgIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldihDb21wb25lbnQpO1xuICAgIH0gLy8gV2UncmUgbm93IHN1Y2Nlc3NmdWxseSBwYXN0IHRoaXMgdGFzaywgYW5kIHdlIGRvbid0IGhhdmUgdG8gcG9wIGJhY2sgdG9cbiAgICAvLyB0aGUgcHJldmlvdXMgdGFzayBldmVyeSBhZ2Fpbiwgc28gd2UgY2FuIHVzZSB0aGUgZGVzdHJ1Y3RpdmUgcmVjdXJzaXZlIGZvcm0uXG5cblxuICAgIGlmIChoYXNJZCkge1xuICAgICAgLy8gVGhpcyBjb21wb25lbnQgbWF0ZXJpYWxpemVkIGFuIGlkLiBXZSB0cmVhdCB0aGlzIGFzIGl0cyBvd24gbGV2ZWwsIHdpdGhcbiAgICAgIC8vIGEgc2luZ2xlIFwiY2hpbGRcIiBzbG90LlxuICAgICAgdmFyIHByZXZUcmVlQ29udGV4dCA9IHRhc2sudHJlZUNvbnRleHQ7XG4gICAgICB2YXIgdG90YWxDaGlsZHJlbiA9IDE7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdGFzay50cmVlQ29udGV4dCA9IHB1c2hUcmVlQ29udGV4dChwcmV2VHJlZUNvbnRleHQsIHRvdGFsQ2hpbGRyZW4sIGluZGV4KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG51bGwsIHZhbHVlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRhc2sudHJlZUNvbnRleHQgPSBwcmV2VHJlZUNvbnRleHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBudWxsLCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KENvbXBvbmVudCkge1xuICB7XG4gICAgaWYgKENvbXBvbmVudCkge1xuICAgICAgaWYgKENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcykge1xuICAgICAgICBlcnJvcignJXMoLi4uKTogY2hpbGRDb250ZXh0VHlwZXMgY2Fubm90IGJlIGRlZmluZWQgb24gYSBmdW5jdGlvbiBjb21wb25lbnQuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoQ29tcG9uZW50LmRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXREZWZhdWx0UHJvcHNPbkZ1bmN0aW9uQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCclczogU3VwcG9ydCBmb3IgZGVmYXVsdFByb3BzIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIGZ1bmN0aW9uIGNvbXBvbmVudHMgJyArICdpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBVc2UgSmF2YVNjcmlwdCBkZWZhdWx0IHBhcmFtZXRlcnMgaW5zdGVhZC4nLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXREZWZhdWx0UHJvcHNPbkZ1bmN0aW9uQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZTMgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTNdKSB7XG4gICAgICAgIGVycm9yKCclczogRnVuY3Rpb24gY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuJywgX2NvbXBvbmVudE5hbWUzKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lM10gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgQ29tcG9uZW50LmNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBDb21wb25lbnQuY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZTQgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lNF0pIHtcbiAgICAgICAgZXJyb3IoJyVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGNvbnRleHRUeXBlLicsIF9jb21wb25lbnROYW1lNCk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lNF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgYmFzZVByb3BzKSB7XG4gIGlmIChDb21wb25lbnQgJiYgQ29tcG9uZW50LmRlZmF1bHRQcm9wcykge1xuICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wcy4gVGFrZW4gZnJvbSBSZWFjdEVsZW1lbnRcbiAgICB2YXIgcHJvcHMgPSBhc3NpZ24oe30sIGJhc2VQcm9wcyk7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IENvbXBvbmVudC5kZWZhdWx0UHJvcHM7XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwcm9wcztcbiAgfVxuXG4gIHJldHVybiBiYXNlUHJvcHM7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckZvcndhcmRSZWYocmVxdWVzdCwgdGFzaywgcHJldlRoZW5hYmxlU3RhdGUsIHR5cGUsIHByb3BzLCByZWYpIHtcbiAgcHVzaEZ1bmN0aW9uQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrLCB0eXBlLnJlbmRlcik7XG4gIHZhciBjaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rcyhyZXF1ZXN0LCB0YXNrLCBwcmV2VGhlbmFibGVTdGF0ZSwgdHlwZS5yZW5kZXIsIHByb3BzLCByZWYpO1xuICB2YXIgaGFzSWQgPSBjaGVja0RpZFJlbmRlcklkSG9vaygpO1xuXG4gIGlmIChoYXNJZCkge1xuICAgIC8vIFRoaXMgY29tcG9uZW50IG1hdGVyaWFsaXplZCBhbiBpZC4gV2UgdHJlYXQgdGhpcyBhcyBpdHMgb3duIGxldmVsLCB3aXRoXG4gICAgLy8gYSBzaW5nbGUgXCJjaGlsZFwiIHNsb3QuXG4gICAgdmFyIHByZXZUcmVlQ29udGV4dCA9IHRhc2sudHJlZUNvbnRleHQ7XG4gICAgdmFyIHRvdGFsQ2hpbGRyZW4gPSAxO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdGFzay50cmVlQ29udGV4dCA9IHB1c2hUcmVlQ29udGV4dChwcmV2VHJlZUNvbnRleHQsIHRvdGFsQ2hpbGRyZW4sIGluZGV4KTtcblxuICAgIHRyeSB7XG4gICAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbnVsbCwgY2hpbGRyZW4pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHJldlRyZWVDb250ZXh0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbnVsbCwgY2hpbGRyZW4pO1xuICB9XG5cbiAgcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyTWVtbyhyZXF1ZXN0LCB0YXNrLCBwcmV2VGhlbmFibGVTdGF0ZSwgdHlwZSwgcHJvcHMsIHJlZikge1xuICB2YXIgaW5uZXJUeXBlID0gdHlwZS50eXBlO1xuICB2YXIgcmVzb2x2ZWRQcm9wcyA9IHJlc29sdmVEZWZhdWx0UHJvcHMoaW5uZXJUeXBlLCBwcm9wcyk7XG4gIHJlbmRlckVsZW1lbnQocmVxdWVzdCwgdGFzaywgcHJldlRoZW5hYmxlU3RhdGUsIGlubmVyVHlwZSwgcmVzb2x2ZWRQcm9wcywgcmVmKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyQ29udGV4dENvbnN1bWVyKHJlcXVlc3QsIHRhc2ssIGNvbnRleHQsIHByb3BzKSB7XG4gIC8vIFRoZSBsb2dpYyBiZWxvdyBmb3IgQ29udGV4dCBkaWZmZXJzIGRlcGVuZGluZyBvbiBQUk9EIG9yIERFViBtb2RlLiBJblxuICAvLyBERVYgbW9kZSwgd2UgY3JlYXRlIGEgc2VwYXJhdGUgb2JqZWN0IGZvciBDb250ZXh0LkNvbnN1bWVyIHRoYXQgYWN0c1xuICAvLyBsaWtlIGEgcHJveHkgdG8gQ29udGV4dC4gVGhpcyBwcm94eSBvYmplY3QgYWRkcyB1bm5lY2Vzc2FyeSBjb2RlIGluIFBST0RcbiAgLy8gc28gd2UgdXNlIHRoZSBvbGQgYmVoYXZpb3VyIChDb250ZXh0LkNvbnN1bWVyIHJlZmVyZW5jZXMgQ29udGV4dCkgdG9cbiAgLy8gcmVkdWNlIHNpemUgYW5kIG92ZXJoZWFkLiBUaGUgc2VwYXJhdGUgb2JqZWN0IHJlZmVyZW5jZXMgY29udGV4dCB2aWFcbiAgLy8gYSBwcm9wZXJ0eSBjYWxsZWQgXCJfY29udGV4dFwiLCB3aGljaCBhbHNvIGdpdmVzIHVzIHRoZSBhYmlsaXR5IHRvIGNoZWNrXG4gIC8vIGluIERFViBtb2RlIGlmIHRoaXMgcHJvcGVydHkgZXhpc3RzIG9yIG5vdCBhbmQgd2FybiBpZiBpdCBkb2VzIG5vdC5cbiAge1xuICAgIGlmIChjb250ZXh0Ll9jb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFRoaXMgbWF5IGJlIGJlY2F1c2UgaXQncyBhIENvbnRleHQgKHJhdGhlciB0aGFuIGEgQ29uc3VtZXIpLlxuICAgICAgLy8gT3IgaXQgbWF5IGJlIGJlY2F1c2UgaXQncyBvbGRlciBSZWFjdCB3aGVyZSB0aGV5J3JlIHRoZSBzYW1lIHRoaW5nLlxuICAgICAgLy8gV2Ugb25seSB3YW50IHRvIHdhcm4gaWYgd2UncmUgc3VyZSBpdCdzIGEgbmV3IFJlYWN0LlxuICAgICAgaWYgKGNvbnRleHQgIT09IGNvbnRleHQuQ29uc3VtZXIpIHtcbiAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIpIHtcbiAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIgPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dD4gZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Db25zdW1lcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0ID0gY29udGV4dC5fY29udGV4dDtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVuZGVyID0gcHJvcHMuY2hpbGRyZW47XG5cbiAge1xuICAgIGlmICh0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignQSBjb250ZXh0IGNvbnN1bWVyIHdhcyByZW5kZXJlZCB3aXRoIG11bHRpcGxlIGNoaWxkcmVuLCBvciBhIGNoaWxkICcgKyBcInRoYXQgaXNuJ3QgYSBmdW5jdGlvbi4gQSBjb250ZXh0IGNvbnN1bWVyIGV4cGVjdHMgYSBzaW5nbGUgY2hpbGQgXCIgKyAndGhhdCBpcyBhIGZ1bmN0aW9uLiBJZiB5b3UgZGlkIHBhc3MgYSBmdW5jdGlvbiwgbWFrZSBzdXJlIHRoZXJlICcgKyAnaXMgbm8gdHJhaWxpbmcgb3IgbGVhZGluZyB3aGl0ZXNwYWNlIGFyb3VuZCBpdC4nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV3VmFsdWUgPSByZWFkQ29udGV4dCQxKGNvbnRleHQpO1xuICB2YXIgbmV3Q2hpbGRyZW4gPSByZW5kZXIobmV3VmFsdWUpO1xuICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbnVsbCwgbmV3Q2hpbGRyZW4pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJDb250ZXh0UHJvdmlkZXIocmVxdWVzdCwgdGFzaywgdHlwZSwgcHJvcHMpIHtcbiAgdmFyIGNvbnRleHQgPSB0eXBlLl9jb250ZXh0O1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gIHZhciBwcmV2U25hcHNob3Q7XG5cbiAge1xuICAgIHByZXZTbmFwc2hvdCA9IHRhc2suY29udGV4dDtcbiAgfVxuXG4gIHRhc2suY29udGV4dCA9IHB1c2hQcm92aWRlcihjb250ZXh0LCB2YWx1ZSk7XG4gIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBudWxsLCBjaGlsZHJlbik7XG4gIHRhc2suY29udGV4dCA9IHBvcFByb3ZpZGVyKGNvbnRleHQpO1xuXG4gIHtcbiAgICBpZiAocHJldlNuYXBzaG90ICE9PSB0YXNrLmNvbnRleHQpIHtcbiAgICAgIGVycm9yKCdQb3BwaW5nIHRoZSBjb250ZXh0IHByb3ZpZGVyIGRpZCBub3QgcmV0dXJuIGJhY2sgdG8gdGhlIG9yaWdpbmFsIHNuYXBzaG90LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJMYXp5Q29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIHByZXZUaGVuYWJsZVN0YXRlLCBsYXp5Q29tcG9uZW50LCBwcm9wcywgcmVmKSB7XG4gIHB1c2hCdWlsdEluQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrLCAnTGF6eScpO1xuICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcbiAgdmFyIENvbXBvbmVudCA9IGluaXQocGF5bG9hZCk7XG4gIHZhciByZXNvbHZlZFByb3BzID0gcmVzb2x2ZURlZmF1bHRQcm9wcyhDb21wb25lbnQsIHByb3BzKTtcbiAgcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCBwcmV2VGhlbmFibGVTdGF0ZSwgQ29tcG9uZW50LCByZXNvbHZlZFByb3BzLCByZWYpO1xuICBwb3BDb21wb25lbnRTdGFja0luREVWKHRhc2spO1xufVxuXG5mdW5jdGlvbiByZW5kZXJPZmZzY3JlZW4ocmVxdWVzdCwgdGFzaywgcHJvcHMpIHtcbiAgdmFyIG1vZGUgPSBwcm9wcy5tb2RlO1xuXG4gIGlmIChtb2RlID09PSAnaGlkZGVuJykgOyBlbHNlIHtcbiAgICAvLyBBIHZpc2libGUgT2Zmc2NyZWVuIGJvdW5kYXJ5IGlzIHRyZWF0ZWQgZXhhY3RseSBsaWtlIGEgZnJhZ21lbnQ6IGFcbiAgICAvLyBwdXJlIGluZGlyZWN0aW9uLlxuICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBudWxsLCBwcm9wcy5jaGlsZHJlbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCBwcmV2VGhlbmFibGVTdGF0ZSwgdHlwZSwgcHJvcHMsIHJlZikge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoc2hvdWxkQ29uc3RydWN0KHR5cGUpKSB7XG4gICAgICByZW5kZXJDbGFzc0NvbXBvbmVudChyZXF1ZXN0LCB0YXNrLCB0eXBlLCBwcm9wcyk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlckluZGV0ZXJtaW5hdGVDb21wb25lbnQocmVxdWVzdCwgdGFzaywgcHJldlRoZW5hYmxlU3RhdGUsIHR5cGUsIHByb3BzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVuZGVySG9zdEVsZW1lbnQocmVxdWVzdCwgdGFzaywgdHlwZSwgcHJvcHMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIC8vIExlZ2FjeUhpZGRlbiBhY3RzIHRoZSBzYW1lIGFzIGEgZnJhZ21lbnQuIFRoaXMgb25seSB3b3JrcyBiZWNhdXNlIHdlXG4gICAgLy8gY3VycmVudGx5IGFzc3VtZSB0aGF0IGV2ZXJ5IGluc3RhbmNlIG9mIExlZ2FjeUhpZGRlbiBpcyBhY2NvbXBhbmllZCBieSBhXG4gICAgLy8gaG9zdCBjb21wb25lbnQgd3JhcHBlci4gSW4gdGhlIGhpZGRlbiBtb2RlLCB0aGUgaG9zdCBjb21wb25lbnQgaXMgZ2l2ZW4gYVxuICAgIC8vIGBoaWRkZW5gIGF0dHJpYnV0ZSwgd2hpY2ggZW5zdXJlcyB0aGF0IHRoZSBpbml0aWFsIEhUTUwgaXMgbm90IHZpc2libGUuXG4gICAgLy8gVG8gc3VwcG9ydCB0aGUgdXNlIG9mIExlZ2FjeUhpZGRlbiBhcyBhIHRydWUgZnJhZ21lbnQsIHdpdGhvdXQgYW4gZXh0cmFcbiAgICAvLyBET00gbm9kZSwgd2Ugd291bGQgaGF2ZSB0byBoaWRlIHRoZSBpbml0aWFsIEhUTUwgaW4gc29tZSBvdGhlciB3YXkuXG4gICAgLy8gVE9ETzogRGVsZXRlIGluIExlZ2FjeUhpZGRlbi4gSXQncyBhbiB1bnN0YWJsZSBBUEkgb25seSB1c2VkIGluIHRoZVxuICAgIC8vIHd3dyBidWlsZC4gQXMgYSBtaWdyYXRpb24gc3RlcCwgd2UgY291bGQgYWRkIGEgc3BlY2lhbCBwcm9wIHRvIE9mZnNjcmVlblxuICAgIC8vIHRoYXQgc2ltdWxhdGVzIHRoZSBvbGQgYmVoYXZpb3IgKG5vIGhpZGluZywgbm8gY2hhbmdlIHRvIGVmZmVjdHMpLlxuICAgIGNhc2UgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFOlxuICAgIGNhc2UgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEU6XG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICB7XG4gICAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBudWxsLCBwcm9wcy5jaGlsZHJlbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgUkVBQ1RfT0ZGU0NSRUVOX1RZUEU6XG4gICAgICB7XG4gICAgICAgIHJlbmRlck9mZnNjcmVlbihyZXF1ZXN0LCB0YXNrLCBwcm9wcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAge1xuICAgICAgICBwdXNoQnVpbHRJbkNvbXBvbmVudFN0YWNrSW5ERVYodGFzaywgJ1N1c3BlbnNlTGlzdCcpOyAvLyBUT0RPOiBTdXNwZW5zZUxpc3Qgc2hvdWxkIGNvbnRyb2wgdGhlIGJvdW5kYXJpZXMuXG5cbiAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG51bGwsIHByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBSRUFDVF9TQ09QRV9UWVBFOlxuICAgICAge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVhY3RET01TZXJ2ZXIgZG9lcyBub3QgeWV0IHN1cHBvcnQgc2NvcGUgY29tcG9uZW50cy4nKTtcbiAgICAgIH1cblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHJlbmRlclN1c3BlbnNlQm91bmRhcnkocmVxdWVzdCwgdGFzaywgcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICByZW5kZXJGb3J3YXJkUmVmKHJlcXVlc3QsIHRhc2ssIHByZXZUaGVuYWJsZVN0YXRlLCB0eXBlLCBwcm9wcywgcmVmKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICByZW5kZXJNZW1vKHJlcXVlc3QsIHRhc2ssIHByZXZUaGVuYWJsZVN0YXRlLCB0eXBlLCBwcm9wcywgcmVmKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmVuZGVyQ29udGV4dFByb3ZpZGVyKHJlcXVlc3QsIHRhc2ssIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICByZW5kZXJDb250ZXh0Q29uc3VtZXIocmVxdWVzdCwgdGFzaywgdHlwZSwgcHJvcHMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHJlbmRlckxhenlDb21wb25lbnQocmVxdWVzdCwgdGFzaywgcHJldlRoZW5hYmxlU3RhdGUsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgaW5mbyA9ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgXCIgKyAnbmFtZWQgaW1wb3J0cy4nO1xuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gJyArICdjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpICcgKyAoXCJidXQgZ290OiBcIiArICh0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUpICsgXCIuXCIgKyBpbmZvKSk7XG59IC8vICRGbG93Rml4TWVbbWlzc2luZy1sb2NhbC1hbm5vdF1cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUl0ZXJhYmxlKGl0ZXJhYmxlLCBpdGVyYXRvckZuKSB7XG4gIHtcbiAgICAvLyBXZSBkb24ndCBzdXBwb3J0IHJlbmRlcmluZyBHZW5lcmF0b3JzIGJlY2F1c2UgaXQncyBhIG11dGF0aW9uLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEyOTk1XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgaXRlcmFibGVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0dlbmVyYXRvcicpIHtcbiAgICAgIGlmICghZGlkV2FybkFib3V0R2VuZXJhdG9ycykge1xuICAgICAgICBlcnJvcignVXNpbmcgR2VuZXJhdG9ycyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMgYmVjYXVzZSBlbnVtZXJhdGluZyBhIGdlbmVyYXRvciBtdXRhdGVzIGl0LiAnICsgJ1lvdSBtYXkgY29udmVydCBpdCB0byBhbiBhcnJheSB3aXRoIGBBcnJheS5mcm9tKClgIG9yIHRoZSAnICsgJ2BbLi4uc3ByZWFkXWAgb3BlcmF0b3IgYmVmb3JlIHJlbmRlcmluZy4gS2VlcCBpbiBtaW5kICcgKyAneW91IG1pZ2h0IG5lZWQgdG8gcG9seWZpbGwgdGhlc2UgZmVhdHVyZXMgZm9yIG9sZGVyIGJyb3dzZXJzLicpO1xuICAgICAgfVxuXG4gICAgICBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID0gdHJ1ZTtcbiAgICB9IC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuXG5cbiAgICBpZiAoaXRlcmFibGUuZW50cmllcyA9PT0gaXRlcmF0b3JGbikge1xuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNYXBzKSB7XG4gICAgICAgIGVycm9yKCdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4nKTtcbiAgICAgIH1cblxuICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCAvLyBUaGUgdGhlbmFibGUgc3RhdGUgcmV1c2VkIGZyb20gdGhlIHByZXZpb3VzIGF0dGVtcHQsIGlmIGFueS4gVGhpcyBpcyBhbG1vc3Rcbi8vIGFsd2F5cyBudWxsLCBleGNlcHQgd2hlbiBjYWxsZWQgYnkgcmV0cnlUYXNrLlxucHJldlRoZW5hYmxlU3RhdGUsIG5vZGUpIHtcbiAge1xuICAgIC8vIEluIERldiB3ZSB3cmFwIHJlbmRlck5vZGVEZXN0cnVjdGl2ZUltcGwgaW4gYSB0cnkgLyBjYXRjaCBzbyB3ZSBjYW4gY2FwdHVyZVxuICAgIC8vIGEgY29tcG9uZW50IHN0YWNrIGF0IHRoZSByaWdodCBwbGFjZSBpbiB0aGUgdHJlZS4gV2UgZG9uJ3QgZG8gdGhpcyBpbiByZW5kZXJOb2RlXG4gICAgLy8gYmVjdWFzZSBpdCBpcyBub3QgY2FsbGVkIGF0IGV2ZXJ5IGxheWVyIG9mIHRoZSB0cmVlIGFuZCB3ZSBtYXkgbG9zZSBmcmFtZXNcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHJlbmRlck5vZGVEZXN0cnVjdGl2ZUltcGwocmVxdWVzdCwgdGFzaywgcHJldlRoZW5hYmxlU3RhdGUsIG5vZGUpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCAmJiB0eXBlb2YgeC50aGVuID09PSAnZnVuY3Rpb24nKSA7IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGFuIGVycm9yLCBzdGFzaCB0aGUgY29tcG9uZW50IHN0YWNrIGlmIGl0IGlzIG51bGwuXG4gICAgICAgIGxhc3RCb3VuZGFyeUVycm9yQ29tcG9uZW50U3RhY2tEZXYgPSBsYXN0Qm91bmRhcnlFcnJvckNvbXBvbmVudFN0YWNrRGV2ICE9PSBudWxsID8gbGFzdEJvdW5kYXJ5RXJyb3JDb21wb25lbnRTdGFja0RldiA6IGdldEN1cnJlbnRTdGFja0luREVWKCk7XG4gICAgICB9IC8vIHJldGhyb3cgc28gbm9ybWFsIHN1c3BlbnNlIGxvZ2ljIGNhbiBoYW5kbGUgdGhyb3duIHZhbHVlIGFjY29yZGluZ2x5XG5cblxuICAgICAgdGhyb3cgeDtcbiAgICB9XG4gIH1cbn0gLy8gVGhpcyBmdW5jdGlvbiBieSBpdCBzZWxmIHJlbmRlcnMgYSBub2RlIGFuZCBjb25zdW1lcyB0aGUgdGFzayBieSBtdXRhdGluZyBpdFxuLy8gdG8gdXBkYXRlIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBzdGF0ZS5cblxuXG5mdW5jdGlvbiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmVJbXBsKHJlcXVlc3QsIHRhc2ssIHByZXZUaGVuYWJsZVN0YXRlLCBub2RlKSB7XG4gIC8vIFN0YXNoIHRoZSBub2RlIHdlJ3JlIHdvcmtpbmcgb24uIFdlJ2xsIHBpY2sgdXAgZnJvbSB0aGlzIHRhc2sgaW4gY2FzZVxuICAvLyBzb21ldGhpbmcgc3VzcGVuZHMuXG4gIHRhc2subm9kZSA9IG5vZGU7IC8vIEhhbmRsZSBvYmplY3QgdHlwZXNcblxuICBpZiAodHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIG5vZGUgIT09IG51bGwpIHtcbiAgICBzd2l0Y2ggKG5vZGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSBub2RlO1xuICAgICAgICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuICAgICAgICAgIHZhciBwcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gICAgICAgICAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICAgICAgICAgIHJlbmRlckVsZW1lbnQocmVxdWVzdCwgdGFzaywgcHJldlRoZW5hYmxlU3RhdGUsIHR5cGUsIHByb3BzLCByZWYpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvcnRhbHMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IHRoZSBzZXJ2ZXIgcmVuZGVyZXIuICcgKyAnUmVuZGVyIHRoZW0gY29uZGl0aW9uYWxseSBzbyB0aGF0IHRoZXkgb25seSBhcHBlYXIgb24gdGhlIGNsaWVudCByZW5kZXIuJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlOb2RlID0gbm9kZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlOb2RlLl9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eU5vZGUuX2luaXQ7XG4gICAgICAgICAgdmFyIHJlc29sdmVkTm9kZTtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlc29sdmVkTm9kZSA9IGluaXQocGF5bG9hZCk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCAmJiB0eXBlb2YgeC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBMYXp5IGluaXRpYWxpemVyIGlzIHN1c3BlbmRpbmcuIHB1c2ggYSB0ZW1wb3JhcnkgZnJhbWUgb250byB0aGUgc3RhY2sgc28gaXQgY2FuIGJlXG4gICAgICAgICAgICAgICAgLy8gcG9wcGVkIG9mZiBpbiBzcGF3bk5ld1N1c3BlbmRlZFRhc2suIFRoaXMgYWxpZ25zIHN0YWNrIGJlaGF2aW9yIGJldHdlZW4gTGF6eSBpbiBlbGVtZW50IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgLy8gdnMgQ29tcG9uZW50IHBvc2l0aW9uLiBXZSBkbyBub3Qgd2FudCB0aGUgZnJhbWUgZm9yIEVycm9ycyBzbyB3ZSBleGNsdXNpdmVseSBkbyB0aGlzIGluXG4gICAgICAgICAgICAgICAgLy8gdGhlIHdha2VhYmxlIGJyYW5jaFxuICAgICAgICAgICAgICAgIHB1c2hCdWlsdEluQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrLCAnTGF6eScpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhyb3cgeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbnVsbCwgcmVzb2x2ZWROb2RlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgcmVuZGVyQ2hpbGRyZW5BcnJheShyZXF1ZXN0LCB0YXNrLCBub2RlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAge1xuICAgICAgICB2YWxpZGF0ZUl0ZXJhYmxlKG5vZGUsIGl0ZXJhdG9yRm4pO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG5cbiAgICAgIGlmIChpdGVyYXRvcikge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGtub3cgaG93IG1hbnkgdG90YWwgY2hpbGRyZW4gYXJlIGluIHRoaXMgc2V0LCBzbyB0aGF0IHdlXG4gICAgICAgIC8vIGNhbiBhbGxvY2F0ZSBlbm91Z2ggaWQgc2xvdHMgdG8gYWNvbW1vZGF0ZSB0aGVtLiBTbyB3ZSBtdXN0IGV4aGF1c3RcbiAgICAgICAgLy8gdGhlIGl0ZXJhdG9yIGJlZm9yZSB3ZSBzdGFydCByZWN1cnNpdmVseSByZW5kZXJpbmcgdGhlIGNoaWxkcmVuLlxuICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIG5vdCBncmVhdCBidXQgSSB0aGluayBpdCdzIGluaGVyZW50IHRvIHRoZSBpZFxuICAgICAgICAvLyBnZW5lcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7IC8vIElmIHRoZXJlIGFyZSBub3QgZW50cmllcywgd2UgbmVlZCB0byBwdXNoIGFuIGVtcHR5IHNvIHdlIHN0YXJ0IGJ5IGNoZWNraW5nIHRoYXQuXG5cbiAgICAgICAgaWYgKCFzdGVwLmRvbmUpIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goc3RlcC52YWx1ZSk7XG4gICAgICAgICAgICBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIH0gd2hpbGUgKCFzdGVwLmRvbmUpO1xuXG4gICAgICAgICAgcmVuZGVyQ2hpbGRyZW5BcnJheShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gLy8gVXNhYmxlcyBhcmUgYSB2YWxpZCBSZWFjdCBub2RlIHR5cGUuIFdoZW4gUmVhY3QgZW5jb3VudGVycyBhIFVzYWJsZSBpblxuICAgIC8vIGEgY2hpbGQgcG9zaXRpb24sIGl0IHVud3JhcHMgaXQgdXNpbmcgdGhlIHNhbWUgYWxnb3JpdGhtIGFzIGB1c2VgLiBGb3JcbiAgICAvLyBleGFtcGxlLCBmb3IgcHJvbWlzZXMsIFJlYWN0IHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIHRvIHVud2luZCB0aGVcbiAgICAvLyBzdGFjaywgdGhlbiByZXBsYXkgdGhlIGNvbXBvbmVudCBvbmNlIHRoZSBwcm9taXNlIHJlc29sdmVzLlxuICAgIC8vXG4gICAgLy8gQSBkaWZmZXJlbmNlIGZyb20gYHVzZWAgaXMgdGhhdCBSZWFjdCB3aWxsIGtlZXAgdW53cmFwcGluZyB0aGUgdmFsdWVcbiAgICAvLyB1bnRpbCBpdCByZWFjaGVzIGEgbm9uLVVzYWJsZSB0eXBlLlxuICAgIC8vXG4gICAgLy8gZS5nLiBVc2FibGU8VXNhYmxlPFVzYWJsZTxUPj4+IHNob3VsZCByZXNvbHZlIHRvIFRcblxuXG4gICAgdmFyIG1heWJlVXNhYmxlID0gbm9kZTtcblxuICAgIGlmICh0eXBlb2YgbWF5YmVVc2FibGUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHRoZW5hYmxlID0gbWF5YmVVc2FibGU7XG4gICAgICByZXR1cm4gcmVuZGVyTm9kZURlc3RydWN0aXZlSW1wbChyZXF1ZXN0LCB0YXNrLCBudWxsLCB1bndyYXBUaGVuYWJsZSh0aGVuYWJsZSkpO1xuICAgIH1cblxuICAgIGlmIChtYXliZVVzYWJsZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IG1heWJlVXNhYmxlLiQkdHlwZW9mID09PSBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFKSB7XG4gICAgICB2YXIgY29udGV4dCA9IG1heWJlVXNhYmxlO1xuICAgICAgcmV0dXJuIHJlbmRlck5vZGVEZXN0cnVjdGl2ZUltcGwocmVxdWVzdCwgdGFzaywgbnVsbCwgcmVhZENvbnRleHQkMShjb250ZXh0KSk7XG4gICAgfSAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG5cblxuICAgIHZhciBjaGlsZFN0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChub2RlKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICsgKGNoaWxkU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMobm9kZSkuam9pbignLCAnKSArICd9JyA6IGNoaWxkU3RyaW5nKSArIFwiKS4gXCIgKyAnSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQuJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICAgIHNlZ21lbnQubGFzdFB1c2hlZFRleHQgPSBwdXNoVGV4dEluc3RhbmNlKHRhc2suYmxvY2tlZFNlZ21lbnQuY2h1bmtzLCBub2RlLCByZXF1ZXN0LnJlc3BvbnNlU3RhdGUsIHNlZ21lbnQubGFzdFB1c2hlZFRleHQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgX3NlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICAgIF9zZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gcHVzaFRleHRJbnN0YW5jZSh0YXNrLmJsb2NrZWRTZWdtZW50LmNodW5rcywgJycgKyBub2RlLCByZXF1ZXN0LnJlc3BvbnNlU3RhdGUsIF9zZWdtZW50Lmxhc3RQdXNoZWRUZXh0KTtcbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmICcgKyAneW91IHJldHVybiBhIENvbXBvbmVudCBpbnN0ZWFkIG9mIDxDb21wb25lbnQgLz4gZnJvbSByZW5kZXIuICcgKyAnT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNoaWxkcmVuQXJyYXkocmVxdWVzdCwgdGFzaywgY2hpbGRyZW4pIHtcbiAgdmFyIHRvdGFsQ2hpbGRyZW4gPSBjaGlsZHJlbi5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbENoaWxkcmVuOyBpKyspIHtcbiAgICB2YXIgcHJldlRyZWVDb250ZXh0ID0gdGFzay50cmVlQ29udGV4dDtcbiAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHVzaFRyZWVDb250ZXh0KHByZXZUcmVlQ29udGV4dCwgdG90YWxDaGlsZHJlbiwgaSk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gV2UgbmVlZCB0byB1c2UgdGhlIG5vbi1kZXN0cnVjdGl2ZSBmb3JtIHNvIHRoYXQgd2UgY2FuIHNhZmVseSBwb3AgYmFja1xuICAgICAgLy8gdXAgYW5kIHJlbmRlciB0aGUgc2libGluZyBpZiBzb21ldGhpbmcgc3VzcGVuZHMuXG4gICAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuW2ldKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGFzay50cmVlQ29udGV4dCA9IHByZXZUcmVlQ29udGV4dDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3Bhd25OZXdTdXNwZW5kZWRUYXNrKHJlcXVlc3QsIHRhc2ssIHRoZW5hYmxlU3RhdGUsIHgpIHtcbiAgLy8gU29tZXRoaW5nIHN1c3BlbmRlZCwgd2UnbGwgbmVlZCB0byBjcmVhdGUgYSBuZXcgc2VnbWVudCBhbmQgcmVzb2x2ZSBpdCBsYXRlci5cbiAgdmFyIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICB2YXIgaW5zZXJ0aW9uSW5kZXggPSBzZWdtZW50LmNodW5rcy5sZW5ndGg7XG4gIHZhciBuZXdTZWdtZW50ID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQocmVxdWVzdCwgaW5zZXJ0aW9uSW5kZXgsIG51bGwsIHNlZ21lbnQuZm9ybWF0Q29udGV4dCwgLy8gQWRvcHQgdGhlIHBhcmVudCBzZWdtZW50J3MgbGVhZGluZyB0ZXh0IGVtYmVkXG4gIHNlZ21lbnQubGFzdFB1c2hlZFRleHQsIC8vIEFzc3VtZSB3ZSBhcmUgdGV4dCBlbWJlZGRlZCBhdCB0aGUgdHJhaWxpbmcgZWRnZVxuICB0cnVlKTtcbiAgc2VnbWVudC5jaGlsZHJlbi5wdXNoKG5ld1NlZ21lbnQpOyAvLyBSZXNldCBsYXN0UHVzaGVkVGV4dCBmb3IgY3VycmVudCBTZWdtZW50IHNpbmNlIHRoZSBuZXcgU2VnbWVudCBcImNvbnN1bWVkXCIgaXRcblxuICBzZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gZmFsc2U7XG4gIHZhciBuZXdUYXNrID0gY3JlYXRlVGFzayhyZXF1ZXN0LCB0aGVuYWJsZVN0YXRlLCB0YXNrLm5vZGUsIHRhc2suYmxvY2tlZEJvdW5kYXJ5LCBuZXdTZWdtZW50LCB0YXNrLmFib3J0U2V0LCB0YXNrLmxlZ2FjeUNvbnRleHQsIHRhc2suY29udGV4dCwgdGFzay50cmVlQ29udGV4dCk7XG5cbiAge1xuICAgIGlmICh0YXNrLmNvbXBvbmVudFN0YWNrICE9PSBudWxsKSB7XG4gICAgICAvLyBXZSBwb3Agb25lIHRhc2sgb2ZmIHRoZSBzdGFjayBiZWNhdXNlIHRoZSBub2RlIHRoYXQgc3VzcGVuZGVkIHdpbGwgYmUgdHJpZWQgYWdhaW4sXG4gICAgICAvLyB3aGljaCB3aWxsIGFkZCBpdCBiYWNrIG9udG8gdGhlIHN0YWNrLlxuICAgICAgbmV3VGFzay5jb21wb25lbnRTdGFjayA9IHRhc2suY29tcG9uZW50U3RhY2sucGFyZW50O1xuICAgIH1cbiAgfVxuXG4gIHZhciBwaW5nID0gbmV3VGFzay5waW5nO1xuICB4LnRoZW4ocGluZywgcGluZyk7XG59IC8vIFRoaXMgaXMgYSBub24tZGVzdHJ1Y3RpdmUgZm9ybSBvZiByZW5kZXJpbmcgYSBub2RlLiBJZiBpdCBzdXNwZW5kcyBpdCBzcGF3bnNcbi8vIGEgbmV3IHRhc2sgYW5kIHJlc3RvcmVzIHRoZSBjb250ZXh0IG9mIHRoaXMgdGFzayB0byB3aGF0IGl0IHdhcyBiZWZvcmUuXG5cblxuZnVuY3Rpb24gcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBub2RlKSB7XG4gIC8vIFN0b3JlIGhvdyBtdWNoIHdlJ3ZlIHB1c2hlZCBhdCB0aGlzIHBvaW50IHNvIHdlIGNhbiByZXNldCBpdCBpbiBjYXNlIHNvbWV0aGluZ1xuICAvLyBzdXNwZW5kZWQgcGFydGlhbGx5IHRocm91Z2ggd3JpdGluZyBzb21ldGhpbmcuXG4gIHZhciBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gc2VnbWVudC5jaGlsZHJlbi5sZW5ndGg7XG4gIHZhciBjaHVua0xlbmd0aCA9IHNlZ21lbnQuY2h1bmtzLmxlbmd0aDsgLy8gU25hcHNob3QgdGhlIGN1cnJlbnQgY29udGV4dCBpbiBjYXNlIHNvbWV0aGluZyB0aHJvd3MgdG8gaW50ZXJydXB0IHRoZVxuICAvLyBwcm9jZXNzLlxuXG4gIHZhciBwcmV2aW91c0Zvcm1hdENvbnRleHQgPSB0YXNrLmJsb2NrZWRTZWdtZW50LmZvcm1hdENvbnRleHQ7XG4gIHZhciBwcmV2aW91c0xlZ2FjeUNvbnRleHQgPSB0YXNrLmxlZ2FjeUNvbnRleHQ7XG4gIHZhciBwcmV2aW91c0NvbnRleHQgPSB0YXNrLmNvbnRleHQ7XG4gIHZhciBwcmV2aW91c0NvbXBvbmVudFN0YWNrID0gbnVsbDtcblxuICB7XG4gICAgcHJldmlvdXNDb21wb25lbnRTdGFjayA9IHRhc2suY29tcG9uZW50U3RhY2s7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbnVsbCwgbm9kZSk7XG4gIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgcmVzZXRIb29rc1N0YXRlKCk7IC8vIFJlc2V0IHRoZSB3cml0ZSBwb2ludGVycyB0byB3aGVyZSB3ZSBzdGFydGVkLlxuXG4gICAgc2VnbWVudC5jaGlsZHJlbi5sZW5ndGggPSBjaGlsZHJlbkxlbmd0aDtcbiAgICBzZWdtZW50LmNodW5rcy5sZW5ndGggPSBjaHVua0xlbmd0aDtcbiAgICB2YXIgeCA9IHRocm93blZhbHVlID09PSBTdXNwZW5zZUV4Y2VwdGlvbiA/IC8vIFRoaXMgaXMgYSBzcGVjaWFsIHR5cGUgb2YgZXhjZXB0aW9uIHVzZWQgZm9yIFN1c3BlbnNlLiBGb3IgaGlzdG9yaWNhbFxuICAgIC8vIHJlYXNvbnMsIHRoZSByZXN0IG9mIHRoZSBTdXNwZW5zZSBpbXBsZW1lbnRhdGlvbiBleHBlY3RzIHRoZSB0aHJvd25cbiAgICAvLyB2YWx1ZSB0byBiZSBhIHRoZW5hYmxlLCBiZWNhdXNlIGJlZm9yZSBgdXNlYCBleGlzdGVkIHRoYXQgd2FzIHRoZVxuICAgIC8vICh1bnN0YWJsZSkgQVBJIGZvciBzdXNwZW5kaW5nLiBUaGlzIGltcGxlbWVudGF0aW9uIGRldGFpbCBjYW4gY2hhbmdlXG4gICAgLy8gbGF0ZXIsIG9uY2Ugd2UgZGVwcmVjYXRlIHRoZSBvbGQgQVBJIGluIGZhdm9yIG9mIGB1c2VgLlxuICAgIGdldFN1c3BlbmRlZFRoZW5hYmxlKCkgOiB0aHJvd25WYWx1ZTsgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuXG4gICAgaWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsICYmIHR5cGVvZiB4LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciB3YWtlYWJsZSA9IHg7XG4gICAgICB2YXIgdGhlbmFibGVTdGF0ZSA9IGdldFRoZW5hYmxlU3RhdGVBZnRlclN1c3BlbmRpbmcoKTtcbiAgICAgIHNwYXduTmV3U3VzcGVuZGVkVGFzayhyZXF1ZXN0LCB0YXNrLCB0aGVuYWJsZVN0YXRlLCB3YWtlYWJsZSk7IC8vIFJlc3RvcmUgdGhlIGNvbnRleHQuIFdlIGFzc3VtZSB0aGF0IHRoaXMgd2lsbCBiZSByZXN0b3JlZCBieSB0aGUgaW5uZXJcbiAgICAgIC8vIGZ1bmN0aW9ucyBpbiBjYXNlIG5vdGhpbmcgdGhyb3dzIHNvIHdlIGRvbid0IHVzZSBcImZpbmFsbHlcIiBoZXJlLlxuXG4gICAgICB0YXNrLmJsb2NrZWRTZWdtZW50LmZvcm1hdENvbnRleHQgPSBwcmV2aW91c0Zvcm1hdENvbnRleHQ7XG4gICAgICB0YXNrLmxlZ2FjeUNvbnRleHQgPSBwcmV2aW91c0xlZ2FjeUNvbnRleHQ7XG4gICAgICB0YXNrLmNvbnRleHQgPSBwcmV2aW91c0NvbnRleHQ7IC8vIFJlc3RvcmUgYWxsIGFjdGl2ZSBSZWFjdENvbnRleHRzIHRvIHdoYXQgdGhleSB3ZXJlIGJlZm9yZS5cblxuICAgICAgc3dpdGNoQ29udGV4dChwcmV2aW91c0NvbnRleHQpO1xuXG4gICAgICB7XG4gICAgICAgIHRhc2suY29tcG9uZW50U3RhY2sgPSBwcmV2aW91c0NvbXBvbmVudFN0YWNrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlc3RvcmUgdGhlIGNvbnRleHQuIFdlIGFzc3VtZSB0aGF0IHRoaXMgd2lsbCBiZSByZXN0b3JlZCBieSB0aGUgaW5uZXJcbiAgICAgIC8vIGZ1bmN0aW9ucyBpbiBjYXNlIG5vdGhpbmcgdGhyb3dzIHNvIHdlIGRvbid0IHVzZSBcImZpbmFsbHlcIiBoZXJlLlxuICAgICAgdGFzay5ibG9ja2VkU2VnbWVudC5mb3JtYXRDb250ZXh0ID0gcHJldmlvdXNGb3JtYXRDb250ZXh0O1xuICAgICAgdGFzay5sZWdhY3lDb250ZXh0ID0gcHJldmlvdXNMZWdhY3lDb250ZXh0O1xuICAgICAgdGFzay5jb250ZXh0ID0gcHJldmlvdXNDb250ZXh0OyAvLyBSZXN0b3JlIGFsbCBhY3RpdmUgUmVhY3RDb250ZXh0cyB0byB3aGF0IHRoZXkgd2VyZSBiZWZvcmUuXG5cbiAgICAgIHN3aXRjaENvbnRleHQocHJldmlvdXNDb250ZXh0KTtcblxuICAgICAge1xuICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgICAgIH0gLy8gV2UgYXNzdW1lIHRoYXQgd2UgZG9uJ3QgbmVlZCB0aGUgY29ycmVjdCBjb250ZXh0LlxuICAgICAgLy8gTGV0J3MgdGVybWluYXRlIHRoZSByZXN0IG9mIHRoZSB0cmVlIGFuZCBkb24ndCByZW5kZXIgYW55IHNpYmxpbmdzLlxuXG5cbiAgICAgIHRocm93IHg7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGVycm9yZWRUYXNrKHJlcXVlc3QsIGJvdW5kYXJ5LCBzZWdtZW50LCBlcnJvcikge1xuICAvLyBSZXBvcnQgdGhlIGVycm9yIHRvIGEgZ2xvYmFsIGhhbmRsZXIuXG4gIHZhciBlcnJvckRpZ2VzdCA9IGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuXG4gIGlmIChib3VuZGFyeSA9PT0gbnVsbCkge1xuICAgIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICB9IGVsc2Uge1xuICAgIGJvdW5kYXJ5LnBlbmRpbmdUYXNrcy0tO1xuXG4gICAgaWYgKCFib3VuZGFyeS5mb3JjZUNsaWVudFJlbmRlcikge1xuICAgICAgYm91bmRhcnkuZm9yY2VDbGllbnRSZW5kZXIgPSB0cnVlO1xuICAgICAgYm91bmRhcnkuZXJyb3JEaWdlc3QgPSBlcnJvckRpZ2VzdDtcblxuICAgICAge1xuICAgICAgICBjYXB0dXJlQm91bmRhcnlFcnJvckRldGFpbHNEZXYoYm91bmRhcnksIGVycm9yKTtcbiAgICAgIH0gLy8gUmVnYXJkbGVzcyBvZiB3aGF0IGhhcHBlbnMgbmV4dCwgdGhpcyBib3VuZGFyeSB3b24ndCBiZSBkaXNwbGF5ZWQsXG4gICAgICAvLyBzbyB3ZSBjYW4gZmx1c2ggaXQsIGlmIHRoZSBwYXJlbnQgYWxyZWFkeSBmbHVzaGVkLlxuXG5cbiAgICAgIGlmIChib3VuZGFyeS5wYXJlbnRGbHVzaGVkKSB7XG4gICAgICAgIC8vIFdlIGRvbid0IGhhdmUgYSBwcmVmZXJlbmNlIHdoZXJlIGluIHRoZSBxdWV1ZSB0aGlzIGdvZXMgc2luY2UgaXQncyBsaWtlbHlcbiAgICAgICAgLy8gdG8gZXJyb3Igb24gdGhlIGNsaWVudCBhbnl3YXkuIEhvd2V2ZXIsIGludGVudGlvbmFsbHkgY2xpZW50LXJlbmRlcmVkXG4gICAgICAgIC8vIGJvdW5kYXJpZXMgc2hvdWxkIGJlIGZsdXNoZWQgZWFybGllciBzbyB0aGF0IHRoZXkgY2FuIHN0YXJ0IG9uIHRoZSBjbGllbnQuXG4gICAgICAgIC8vIFdlIHJldXNlIHRoZSBzYW1lIHF1ZXVlIGZvciBlcnJvcnMuXG4gICAgICAgIHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzLS07XG5cbiAgaWYgKHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzID09PSAwKSB7XG4gICAgdmFyIG9uQWxsUmVhZHkgPSByZXF1ZXN0Lm9uQWxsUmVhZHk7XG4gICAgb25BbGxSZWFkeSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFib3J0VGFza1NvZnQodGFzaykge1xuICAvLyBUaGlzIGFib3J0cyB0YXNrIHdpdGhvdXQgYWJvcnRpbmcgdGhlIHBhcmVudCBib3VuZGFyeSB0aGF0IGl0IGJsb2Nrcy5cbiAgLy8gSXQncyB1c2VkIGZvciB3aGVuIHdlIGRpZG4ndCBuZWVkIHRoaXMgdGFzayB0byBjb21wbGV0ZSB0aGUgdHJlZS5cbiAgLy8gSWYgdGFzayB3YXMgbmVlZGVkLCB0aGVuIGl0IHNob3VsZCB1c2UgYWJvcnRUYXNrIGluc3RlYWQuXG4gIHZhciByZXF1ZXN0ID0gdGhpcztcbiAgdmFyIGJvdW5kYXJ5ID0gdGFzay5ibG9ja2VkQm91bmRhcnk7XG4gIHZhciBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcbiAgc2VnbWVudC5zdGF0dXMgPSBBQk9SVEVEO1xuICBmaW5pc2hlZFRhc2socmVxdWVzdCwgYm91bmRhcnksIHNlZ21lbnQpO1xufVxuXG5mdW5jdGlvbiBhYm9ydFRhc2sodGFzaywgcmVxdWVzdCwgZXJyb3IpIHtcbiAgLy8gVGhpcyBhYm9ydHMgdGhlIHRhc2sgYW5kIGFib3J0cyB0aGUgcGFyZW50IHRoYXQgaXQgYmxvY2tzLCBwdXR0aW5nIGl0IGludG9cbiAgLy8gY2xpZW50IHJlbmRlcmVkIG1vZGUuXG4gIHZhciBib3VuZGFyeSA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5O1xuICB2YXIgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG4gIHNlZ21lbnQuc3RhdHVzID0gQUJPUlRFRDtcblxuICBpZiAoYm91bmRhcnkgPT09IG51bGwpIHtcbiAgICByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcy0tOyAvLyBXZSBkaWRuJ3QgY29tcGxldGUgdGhlIHJvb3Qgc28gd2UgaGF2ZSBub3RoaW5nIHRvIHNob3cuIFdlIGNhbiBjbG9zZVxuICAgIC8vIHRoZSByZXF1ZXN0O1xuXG4gICAgaWYgKHJlcXVlc3Quc3RhdHVzICE9PSBDTE9TSU5HICYmIHJlcXVlc3Quc3RhdHVzICE9PSBDTE9TRUQpIHtcbiAgICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICAgICAgZmF0YWxFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJvdW5kYXJ5LnBlbmRpbmdUYXNrcy0tO1xuXG4gICAgaWYgKCFib3VuZGFyeS5mb3JjZUNsaWVudFJlbmRlcikge1xuICAgICAgYm91bmRhcnkuZm9yY2VDbGllbnRSZW5kZXIgPSB0cnVlO1xuICAgICAgYm91bmRhcnkuZXJyb3JEaWdlc3QgPSByZXF1ZXN0Lm9uRXJyb3IoZXJyb3IpO1xuXG4gICAgICB7XG4gICAgICAgIHZhciBlcnJvclByZWZpeCA9ICdUaGUgc2VydmVyIGRpZCBub3QgZmluaXNoIHRoaXMgU3VzcGVuc2UgYm91bmRhcnk6ICc7XG4gICAgICAgIHZhciBlcnJvck1lc3NhZ2U7XG5cbiAgICAgICAgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yUHJlZml4ICsgZXJyb3IubWVzc2FnZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvclByZWZpeCArIFN0cmluZyhlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJldmlvdXNUYXNrSW5EZXYgPSBjdXJyZW50VGFza0luREVWO1xuICAgICAgICBjdXJyZW50VGFza0luREVWID0gdGFzaztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNhcHR1cmVCb3VuZGFyeUVycm9yRGV0YWlsc0Rldihib3VuZGFyeSwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBjdXJyZW50VGFza0luREVWID0gcHJldmlvdXNUYXNrSW5EZXY7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGJvdW5kYXJ5LnBhcmVudEZsdXNoZWQpIHtcbiAgICAgICAgcmVxdWVzdC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSk7XG4gICAgICB9XG4gICAgfSAvLyBJZiB0aGlzIGJvdW5kYXJ5IHdhcyBzdGlsbCBwZW5kaW5nIHRoZW4gd2UgaGF2ZW4ndCBhbHJlYWR5IGNhbmNlbGxlZCBpdHMgZmFsbGJhY2tzLlxuICAgIC8vIFdlJ2xsIG5lZWQgdG8gYWJvcnQgdGhlIGZhbGxiYWNrcywgd2hpY2ggd2lsbCBhbHNvIGVycm9yIHRoYXQgcGFyZW50IGJvdW5kYXJ5LlxuXG5cbiAgICBib3VuZGFyeS5mYWxsYmFja0Fib3J0YWJsZVRhc2tzLmZvckVhY2goZnVuY3Rpb24gKGZhbGxiYWNrVGFzaykge1xuICAgICAgcmV0dXJuIGFib3J0VGFzayhmYWxsYmFja1Rhc2ssIHJlcXVlc3QsIGVycm9yKTtcbiAgICB9KTtcbiAgICBib3VuZGFyeS5mYWxsYmFja0Fib3J0YWJsZVRhc2tzLmNsZWFyKCk7XG4gICAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MtLTtcblxuICAgIGlmIChyZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcyA9PT0gMCkge1xuICAgICAgdmFyIG9uQWxsUmVhZHkgPSByZXF1ZXN0Lm9uQWxsUmVhZHk7XG4gICAgICBvbkFsbFJlYWR5KCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHF1ZXVlQ29tcGxldGVkU2VnbWVudChib3VuZGFyeSwgc2VnbWVudCkge1xuICBpZiAoc2VnbWVudC5jaHVua3MubGVuZ3RoID09PSAwICYmIHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIHNlZ21lbnQuY2hpbGRyZW5bMF0uYm91bmRhcnkgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIGFuIGVtcHR5IHNlZ21lbnQuIFRoZXJlJ3Mgbm90aGluZyB0byB3cml0ZSwgc28gd2UgY2FuIGluc3RlYWQgdHJhbnNmZXIgdGhlIElEXG4gICAgLy8gdG8gdGhlIGNoaWxkLiBUaGF0IHdheSBhbnkgZXhpc3RpbmcgcmVmZXJlbmNlcyBwb2ludCB0byB0aGUgY2hpbGQuXG4gICAgdmFyIGNoaWxkU2VnbWVudCA9IHNlZ21lbnQuY2hpbGRyZW5bMF07XG4gICAgY2hpbGRTZWdtZW50LmlkID0gc2VnbWVudC5pZDtcbiAgICBjaGlsZFNlZ21lbnQucGFyZW50Rmx1c2hlZCA9IHRydWU7XG5cbiAgICBpZiAoY2hpbGRTZWdtZW50LnN0YXR1cyA9PT0gQ09NUExFVEVEKSB7XG4gICAgICBxdWV1ZUNvbXBsZXRlZFNlZ21lbnQoYm91bmRhcnksIGNoaWxkU2VnbWVudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjb21wbGV0ZWRTZWdtZW50cyA9IGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzO1xuICAgIGNvbXBsZXRlZFNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoZWRUYXNrKHJlcXVlc3QsIGJvdW5kYXJ5LCBzZWdtZW50KSB7XG4gIGlmIChib3VuZGFyeSA9PT0gbnVsbCkge1xuICAgIGlmIChzZWdtZW50LnBhcmVudEZsdXNoZWQpIHtcbiAgICAgIGlmIChyZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgY2FuIG9ubHkgYmUgb25lIHJvb3Qgc2VnbWVudC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgfVxuXG4gICAgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzLS07XG5cbiAgICBpZiAocmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzID09PSAwKSB7XG4gICAgICAvLyBXZSBoYXZlIGNvbXBsZXRlZCB0aGUgc2hlbGwgc28gdGhlIHNoZWxsIGNhbid0IGVycm9yIGFueW1vcmUuXG4gICAgICByZXF1ZXN0Lm9uU2hlbGxFcnJvciA9IG5vb3A7XG4gICAgICB2YXIgb25TaGVsbFJlYWR5ID0gcmVxdWVzdC5vblNoZWxsUmVhZHk7XG4gICAgICBvblNoZWxsUmVhZHkoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYm91bmRhcnkucGVuZGluZ1Rhc2tzLS07XG5cbiAgICBpZiAoYm91bmRhcnkuZm9yY2VDbGllbnRSZW5kZXIpIDsgZWxzZSBpZiAoYm91bmRhcnkucGVuZGluZ1Rhc2tzID09PSAwKSB7XG4gICAgICAvLyBUaGlzIG11c3QgaGF2ZSBiZWVuIHRoZSBsYXN0IHNlZ21lbnQgd2Ugd2VyZSB3YWl0aW5nIG9uLiBUaGlzIGJvdW5kYXJ5IGlzIG5vdyBjb21wbGV0ZS5cbiAgICAgIGlmIChzZWdtZW50LnBhcmVudEZsdXNoZWQpIHtcbiAgICAgICAgLy8gT3VyIHBhcmVudCBzZWdtZW50IGFscmVhZHkgZmx1c2hlZCwgc28gd2UgbmVlZCB0byBzY2hlZHVsZSB0aGlzIHNlZ21lbnQgdG8gYmUgZW1pdHRlZC5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSBzZWdtZW50IHRoYXQgd2FzIGFib3J0ZWQsIHdlJ2xsIHdyaXRlIG90aGVyIGNvbnRlbnQgaW5zdGVhZCBzbyB3ZSBkb24ndCBuZWVkXG4gICAgICAgIC8vIHRvIGVtaXQgaXQuXG4gICAgICAgIGlmIChzZWdtZW50LnN0YXR1cyA9PT0gQ09NUExFVEVEKSB7XG4gICAgICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBzZWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYm91bmRhcnkucGFyZW50Rmx1c2hlZCkge1xuICAgICAgICAvLyBUaGUgc2VnbWVudCBtaWdodCBiZSBwYXJ0IG9mIGEgc2VnbWVudCB0aGF0IGRpZG4ndCBmbHVzaCB5ZXQsIGJ1dCBpZiB0aGUgYm91bmRhcnknc1xuICAgICAgICAvLyBwYXJlbnQgZmx1c2hlZCwgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGUgYm91bmRhcnkgdG8gYmUgZW1pdHRlZC5cbiAgICAgICAgcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpO1xuICAgICAgfSAvLyBXZSBjYW4gbm93IGNhbmNlbCBhbnkgcGVuZGluZyB0YXNrIG9uIHRoZSBmYWxsYmFjayBzaW5jZSB3ZSB3b24ndCBuZWVkIHRvIHNob3cgaXQgYW55bW9yZS5cbiAgICAgIC8vIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGFmdGVyIHdlIHJlYWQgdGhlIHBhcmVudEZsdXNoZWQgZmxhZ3MgYmVjYXVzZSBhYm9ydGluZyBjYW4gZmluaXNoXG4gICAgICAvLyB3b3JrIHdoaWNoIGNhbiB0cmlnZ2VyIHVzZXIgY29kZSwgd2hpY2ggY2FuIHN0YXJ0IGZsdXNoaW5nLCB3aGljaCBjYW4gY2hhbmdlIHRob3NlIGZsYWdzLlxuXG5cbiAgICAgIGJvdW5kYXJ5LmZhbGxiYWNrQWJvcnRhYmxlVGFza3MuZm9yRWFjaChhYm9ydFRhc2tTb2Z0LCByZXF1ZXN0KTtcbiAgICAgIGJvdW5kYXJ5LmZhbGxiYWNrQWJvcnRhYmxlVGFza3MuY2xlYXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNlZ21lbnQucGFyZW50Rmx1c2hlZCkge1xuICAgICAgICAvLyBPdXIgcGFyZW50IGFscmVhZHkgZmx1c2hlZCwgc28gd2UgbmVlZCB0byBzY2hlZHVsZSB0aGlzIHNlZ21lbnQgdG8gYmUgZW1pdHRlZC5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSBzZWdtZW50IHRoYXQgd2FzIGFib3J0ZWQsIHdlJ2xsIHdyaXRlIG90aGVyIGNvbnRlbnQgaW5zdGVhZCBzbyB3ZSBkb24ndCBuZWVkXG4gICAgICAgIC8vIHRvIGVtaXQgaXQuXG4gICAgICAgIGlmIChzZWdtZW50LnN0YXR1cyA9PT0gQ09NUExFVEVEKSB7XG4gICAgICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBzZWdtZW50KTtcbiAgICAgICAgICB2YXIgY29tcGxldGVkU2VnbWVudHMgPSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cztcblxuICAgICAgICAgIGlmIChjb21wbGV0ZWRTZWdtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgc2luY2Ugd2UgbGFzdCBmbHVzaGVkIHRoYXQgd2UgY29tcGxldGVkIGFueXRoaW5nLlxuICAgICAgICAgICAgLy8gV2UgY2FuIHNjaGVkdWxlIHRoaXMgYm91bmRhcnkgdG8gZW1pdCBpdHMgcGFydGlhbGx5IGNvbXBsZXRlZCBzZWdtZW50cyBlYXJseVxuICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgcGFyZW50IGhhcyBhbHJlYWR5IGJlZW4gZmx1c2hlZC5cbiAgICAgICAgICAgIGlmIChib3VuZGFyeS5wYXJlbnRGbHVzaGVkKSB7XG4gICAgICAgICAgICAgIHJlcXVlc3QucGFydGlhbEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MtLTtcblxuICBpZiAocmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgPT09IDApIHtcbiAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGNhbGxlZCBhdCB0aGUgdmVyeSBlbmQgc28gdGhhdCB3ZSBjYW4gc3luY2hyb25vdXNseSB3cml0ZSB0aGUgcmVzdWx0XG4gICAgLy8gaW4gdGhlIGNhbGxiYWNrIGlmIG5lZWRlZC5cbiAgICB2YXIgb25BbGxSZWFkeSA9IHJlcXVlc3Qub25BbGxSZWFkeTtcbiAgICBvbkFsbFJlYWR5KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmV0cnlUYXNrKHJlcXVlc3QsIHRhc2spIHtcbiAge1xuICAgIHZhciBibG9ja2VkQm91bmRhcnkgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeTtcbiAgICBzZXRDdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeVJlc291cmNlc1RhcmdldChyZXF1ZXN0LnJlc291cmNlcywgYmxvY2tlZEJvdW5kYXJ5ID8gYmxvY2tlZEJvdW5kYXJ5LnJlc291cmNlcyA6IG51bGwpO1xuICB9XG5cbiAgdmFyIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuXG4gIGlmIChzZWdtZW50LnN0YXR1cyAhPT0gUEVORElORykge1xuICAgIC8vIFdlIGNvbXBsZXRlZCB0aGlzIGJ5IG90aGVyIG1lYW5zIGJlZm9yZSB3ZSBoYWQgYSBjaGFuY2UgdG8gcmV0cnkgaXQuXG4gICAgcmV0dXJuO1xuICB9IC8vIFdlIHJlc3RvcmUgdGhlIGNvbnRleHQgdG8gd2hhdCBpdCB3YXMgd2hlbiB3ZSBzdXNwZW5kZWQuXG4gIC8vIFdlIGRvbid0IHJlc3RvcmUgaXQgYWZ0ZXIgd2UgbGVhdmUgYmVjYXVzZSBpdCdzIGxpa2VseSB0aGF0IHdlJ2xsIGVuZCB1cFxuICAvLyBuZWVkaW5nIGEgdmVyeSBzaW1pbGFyIGNvbnRleHQgc29vbiBhZ2Fpbi5cblxuXG4gIHN3aXRjaENvbnRleHQodGFzay5jb250ZXh0KTtcbiAgdmFyIHByZXZUYXNrSW5ERVYgPSBudWxsO1xuXG4gIHtcbiAgICBwcmV2VGFza0luREVWID0gY3VycmVudFRhc2tJbkRFVjtcbiAgICBjdXJyZW50VGFza0luREVWID0gdGFzaztcbiAgfVxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoO1xuICB2YXIgY2h1bmtMZW5ndGggPSBzZWdtZW50LmNodW5rcy5sZW5ndGg7XG5cbiAgdHJ5IHtcbiAgICAvLyBXZSBjYWxsIHRoZSBkZXN0cnVjdGl2ZSBmb3JtIHRoYXQgbXV0YXRlcyB0aGlzIHRhc2suIFRoYXQgd2F5IGlmIHNvbWV0aGluZ1xuICAgIC8vIHN1c3BlbmRzIGFnYWluLCB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdGFzayBpbnN0ZWFkIG9mIHNwYXduaW5nIGEgbmV3IG9uZS5cbiAgICAvLyBSZXNldCB0aGUgdGFzaydzIHRoZW5hYmxlIHN0YXRlIGJlZm9yZSBjb250aW51aW5nLCBzbyB0aGF0IGlmIGEgbGF0ZXJcbiAgICAvLyBjb21wb25lbnQgc3VzcGVuZHMgd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRhc2sgb2JqZWN0LiBJZiB0aGUgc2FtZVxuICAgIC8vIGNvbXBvbmVudCBzdXNwZW5kcyBhZ2FpbiwgdGhlIHRoZW5hYmxlIHN0YXRlIHdpbGwgYmUgcmVzdG9yZWQuXG4gICAgdmFyIHByZXZUaGVuYWJsZVN0YXRlID0gdGFzay50aGVuYWJsZVN0YXRlO1xuICAgIHRhc2sudGhlbmFibGVTdGF0ZSA9IG51bGw7XG4gICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIHByZXZUaGVuYWJsZVN0YXRlLCB0YXNrLm5vZGUpO1xuICAgIHB1c2hTZWdtZW50RmluYWxlKHNlZ21lbnQuY2h1bmtzLCByZXF1ZXN0LnJlc3BvbnNlU3RhdGUsIHNlZ21lbnQubGFzdFB1c2hlZFRleHQsIHNlZ21lbnQudGV4dEVtYmVkZGVkKTtcbiAgICB0YXNrLmFib3J0U2V0LmRlbGV0ZSh0YXNrKTtcbiAgICBzZWdtZW50LnN0YXR1cyA9IENPTVBMRVRFRDtcbiAgICBmaW5pc2hlZFRhc2socmVxdWVzdCwgdGFzay5ibG9ja2VkQm91bmRhcnksIHNlZ21lbnQpO1xuICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgIHJlc2V0SG9va3NTdGF0ZSgpOyAvLyBSZXNldCB0aGUgd3JpdGUgcG9pbnRlcnMgdG8gd2hlcmUgd2Ugc3RhcnRlZC5cblxuICAgIHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoID0gY2hpbGRyZW5MZW5ndGg7XG4gICAgc2VnbWVudC5jaHVua3MubGVuZ3RoID0gY2h1bmtMZW5ndGg7XG4gICAgdmFyIHggPSB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb24gPyAvLyBUaGlzIGlzIGEgc3BlY2lhbCB0eXBlIG9mIGV4Y2VwdGlvbiB1c2VkIGZvciBTdXNwZW5zZS4gRm9yIGhpc3RvcmljYWxcbiAgICAvLyByZWFzb25zLCB0aGUgcmVzdCBvZiB0aGUgU3VzcGVuc2UgaW1wbGVtZW50YXRpb24gZXhwZWN0cyB0aGUgdGhyb3duXG4gICAgLy8gdmFsdWUgdG8gYmUgYSB0aGVuYWJsZSwgYmVjYXVzZSBiZWZvcmUgYHVzZWAgZXhpc3RlZCB0aGF0IHdhcyB0aGVcbiAgICAvLyAodW5zdGFibGUpIEFQSSBmb3Igc3VzcGVuZGluZy4gVGhpcyBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgY2FuIGNoYW5nZVxuICAgIC8vIGxhdGVyLCBvbmNlIHdlIGRlcHJlY2F0ZSB0aGUgb2xkIEFQSSBpbiBmYXZvciBvZiBgdXNlYC5cbiAgICBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpIDogdGhyb3duVmFsdWU7IC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cblxuICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCAmJiB0eXBlb2YgeC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBTb21ldGhpbmcgc3VzcGVuZGVkIGFnYWluLCBsZXQncyBwaWNrIGl0IGJhY2sgdXAgbGF0ZXIuXG4gICAgICB2YXIgcGluZyA9IHRhc2sucGluZztcbiAgICAgIHgudGhlbihwaW5nLCBwaW5nKTtcbiAgICAgIHRhc2sudGhlbmFibGVTdGF0ZSA9IGdldFRoZW5hYmxlU3RhdGVBZnRlclN1c3BlbmRpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFzay5hYm9ydFNldC5kZWxldGUodGFzayk7XG4gICAgICBzZWdtZW50LnN0YXR1cyA9IEVSUk9SRUQ7XG4gICAgICBlcnJvcmVkVGFzayhyZXF1ZXN0LCB0YXNrLmJsb2NrZWRCb3VuZGFyeSwgc2VnbWVudCwgeCk7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHtcbiAgICAgIHNldEN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5UmVzb3VyY2VzVGFyZ2V0KHJlcXVlc3QucmVzb3VyY2VzLCBudWxsKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBjdXJyZW50VGFza0luREVWID0gcHJldlRhc2tJbkRFVjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGVyZm9ybVdvcmsocmVxdWVzdCkge1xuICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IENMT1NFRCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwcmV2Q29udGV4dCA9IGdldEFjdGl2ZUNvbnRleHQoKTtcbiAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBIb29rc0Rpc3BhdGNoZXI7XG4gIHZhciBwcmV2Q2FjaGVEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2Q2FjaGVEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50Q2FjaGUuY3VycmVudDtcbiAgICBSZWFjdEN1cnJlbnRDYWNoZS5jdXJyZW50ID0gRGVmYXVsdENhY2hlRGlzcGF0Y2hlcjtcbiAgfVxuXG4gIHZhciBwcmV2UmVxdWVzdCA9IGN1cnJlbnRSZXF1ZXN0O1xuICBjdXJyZW50UmVxdWVzdCA9IHJlcXVlc3Q7XG4gIHZhciBwcmV2R2V0Q3VycmVudFN0YWNrSW1wbDtcblxuICB7XG4gICAgcHJldkdldEN1cnJlbnRTdGFja0ltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaztcbiAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IGdldEN1cnJlbnRTdGFja0luREVWO1xuICB9XG5cbiAgdmFyIHByZXZSZXNwb25zZVN0YXRlID0gY3VycmVudFJlc3BvbnNlU3RhdGU7XG4gIHNldEN1cnJlbnRSZXNwb25zZVN0YXRlKHJlcXVlc3QucmVzcG9uc2VTdGF0ZSk7XG5cbiAgdHJ5IHtcbiAgICB2YXIgcGluZ2VkVGFza3MgPSByZXF1ZXN0LnBpbmdlZFRhc2tzO1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHBpbmdlZFRhc2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdGFzayA9IHBpbmdlZFRhc2tzW2ldO1xuICAgICAgcmV0cnlUYXNrKHJlcXVlc3QsIHRhc2spO1xuICAgIH1cblxuICAgIHBpbmdlZFRhc2tzLnNwbGljZSgwLCBpKTtcblxuICAgIGlmIChyZXF1ZXN0LmRlc3RpbmF0aW9uICE9PSBudWxsKSB7XG4gICAgICBmbHVzaENvbXBsZXRlZFF1ZXVlcyhyZXF1ZXN0LCByZXF1ZXN0LmRlc3RpbmF0aW9uKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gICAgZmF0YWxFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gIH0gZmluYWxseSB7XG4gICAgc2V0Q3VycmVudFJlc3BvbnNlU3RhdGUocHJldlJlc3BvbnNlU3RhdGUpO1xuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50Q2FjaGUuY3VycmVudCA9IHByZXZDYWNoZURpc3BhdGNoZXI7XG4gICAgfVxuXG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBwcmV2R2V0Q3VycmVudFN0YWNrSW1wbDtcbiAgICB9XG5cbiAgICBpZiAocHJldkRpc3BhdGNoZXIgPT09IEhvb2tzRGlzcGF0Y2hlcikge1xuICAgICAgLy8gVGhpcyBtZWFucyB0aGF0IHdlIHdlcmUgaW4gYSByZWVudHJhbnQgd29yayBsb29wLiBUaGlzIGNvdWxkIGhhcHBlblxuICAgICAgLy8gaW4gYSByZW5kZXJlciB0aGF0IHN1cHBvcnRzIHN5bmNocm9ub3VzIHdvcmsgbGlrZSByZW5kZXJUb1N0cmluZyxcbiAgICAgIC8vIHdoZW4gaXQncyBjYWxsZWQgZnJvbSB3aXRoaW4gYW5vdGhlciByZW5kZXJlci5cbiAgICAgIC8vIE5vcm1hbGx5IHdlIGRvbid0IGJvdGhlciBzd2l0Y2hpbmcgdGhlIGNvbnRleHRzIHRvIHRoZWlyIHJvb3QvZGVmYXVsdFxuICAgICAgLy8gdmFsdWVzIHdoZW4gbGVhdmluZyBiZWNhdXNlIHdlJ2xsIGxpa2VseSBuZWVkIHRoZSBzYW1lIG9yIHNpbWlsYXJcbiAgICAgIC8vIGNvbnRleHQgYWdhaW4uIEhvd2V2ZXIsIHdoZW4gd2UncmUgaW5zaWRlIGEgc3luY2hyb25vdXMgbG9vcCBsaWtlIHRoaXNcbiAgICAgIC8vIHdlJ2xsIHRvIHJlc3RvcmUgdGhlIGNvbnRleHQgdG8gd2hhdCBpdCB3YXMgYmVmb3JlIHJldHVybmluZy5cbiAgICAgIHN3aXRjaENvbnRleHQocHJldkNvbnRleHQpO1xuICAgIH1cblxuICAgIGN1cnJlbnRSZXF1ZXN0ID0gcHJldlJlcXVlc3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hTdWJ0cmVlKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50KSB7XG4gIHNlZ21lbnQucGFyZW50Rmx1c2hlZCA9IHRydWU7XG5cbiAgc3dpdGNoIChzZWdtZW50LnN0YXR1cykge1xuICAgIGNhc2UgUEVORElORzpcbiAgICAgIHtcbiAgICAgICAgLy8gV2UncmUgZW1pdHRpbmcgYSBwbGFjZWhvbGRlciBmb3IgdGhpcyBzZWdtZW50IHRvIGJlIGZpbGxlZCBpbiBsYXRlci5cbiAgICAgICAgLy8gVGhlcmVmb3JlIHdlJ2xsIG5lZWQgdG8gYXNzaWduIGl0IGFuIElEIC0gdG8gcmVmZXIgdG8gaXQgYnkuXG4gICAgICAgIHZhciBzZWdtZW50SUQgPSBzZWdtZW50LmlkID0gcmVxdWVzdC5uZXh0U2VnbWVudElkKys7IC8vIFdoZW4gdGhpcyBzZWdtZW50IGZpbmFsbHkgY29tcGxldGVzIGl0IHdvbid0IGJlIGVtYmVkZGVkIGluIHRleHQgc2luY2UgaXQgd2lsbCBmbHVzaCBzZXBhcmF0ZWx5XG5cbiAgICAgICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9IGZhbHNlO1xuICAgICAgICBzZWdtZW50LnRleHRFbWJlZGRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gd3JpdGVQbGFjZWhvbGRlcihkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZXNwb25zZVN0YXRlLCBzZWdtZW50SUQpO1xuICAgICAgfVxuXG4gICAgY2FzZSBDT01QTEVURUQ6XG4gICAgICB7XG4gICAgICAgIHNlZ21lbnQuc3RhdHVzID0gRkxVU0hFRDtcbiAgICAgICAgdmFyIHIgPSB0cnVlO1xuICAgICAgICB2YXIgY2h1bmtzID0gc2VnbWVudC5jaHVua3M7XG4gICAgICAgIHZhciBjaHVua0lkeCA9IDA7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHNlZ21lbnQuY2hpbGRyZW47XG5cbiAgICAgICAgZm9yICh2YXIgY2hpbGRJZHggPSAwOyBjaGlsZElkeCA8IGNoaWxkcmVuLmxlbmd0aDsgY2hpbGRJZHgrKykge1xuICAgICAgICAgIHZhciBuZXh0Q2hpbGQgPSBjaGlsZHJlbltjaGlsZElkeF07IC8vIFdyaXRlIGFsbCB0aGUgY2h1bmtzIHVwIHVudGlsIHRoZSBuZXh0IGNoaWxkLlxuXG4gICAgICAgICAgZm9yICg7IGNodW5rSWR4IDwgbmV4dENoaWxkLmluZGV4OyBjaHVua0lkeCsrKSB7XG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjaHVua3NbY2h1bmtJZHhdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByID0gZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBuZXh0Q2hpbGQpO1xuICAgICAgICB9IC8vIEZpbmFsbHkganVzdCB3cml0ZSBhbGwgdGhlIHJlbWFpbmluZyBjaHVua3NcblxuXG4gICAgICAgIGZvciAoOyBjaHVua0lkeCA8IGNodW5rcy5sZW5ndGggLSAxOyBjaHVua0lkeCsrKSB7XG4gICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2h1bmtzW2NodW5rSWR4XSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2h1bmtJZHggPCBjaHVua3MubGVuZ3RoKSB7XG4gICAgICAgICAgciA9IHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGNodW5rc1tjaHVua0lkeF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0ZWQsIGVycm9yZWQgb3IgYWxyZWFkeSBmbHVzaGVkIGJvdW5kYXJpZXMgc2hvdWxkIG5vdCBiZSBmbHVzaGVkIGFnYWluLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCkge1xuICB2YXIgYm91bmRhcnkgPSBzZWdtZW50LmJvdW5kYXJ5O1xuXG4gIGlmIChib3VuZGFyeSA9PT0gbnVsbCkge1xuICAgIC8vIE5vdCBhIHN1c3BlbnNlIGJvdW5kYXJ5LlxuICAgIHJldHVybiBmbHVzaFN1YnRyZWUocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQpO1xuICB9XG5cbiAgYm91bmRhcnkucGFyZW50Rmx1c2hlZCA9IHRydWU7IC8vIFRoaXMgc2VnbWVudCBpcyBhIFN1c3BlbnNlIGJvdW5kYXJ5LiBXZSBuZWVkIHRvIGRlY2lkZSB3aGV0aGVyIHRvXG4gIC8vIGVtaXQgdGhlIGNvbnRlbnQgb3IgdGhlIGZhbGxiYWNrIG5vdy5cblxuICBpZiAoYm91bmRhcnkuZm9yY2VDbGllbnRSZW5kZXIpIHtcbiAgICAvLyBFbWl0IGEgY2xpZW50IHJlbmRlcmVkIHN1c3BlbnNlIGJvdW5kYXJ5IHdyYXBwZXIuXG4gICAgLy8gV2UgbmV2ZXIgcXVldWUgdGhlIGlubmVyIGJvdW5kYXJ5IHNvIHdlJ2xsIG5ldmVyIGVtaXQgaXRzIGNvbnRlbnQgb3IgcGFydGlhbCBzZWdtZW50cy5cbiAgICB3cml0ZVN0YXJ0Q2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlc3BvbnNlU3RhdGUsIGJvdW5kYXJ5LmVycm9yRGlnZXN0LCBib3VuZGFyeS5lcnJvck1lc3NhZ2UsIGJvdW5kYXJ5LmVycm9yQ29tcG9uZW50U3RhY2spOyAvLyBGbHVzaCB0aGUgZmFsbGJhY2suXG5cbiAgICBmbHVzaFN1YnRyZWUocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQpO1xuICAgIHJldHVybiB3cml0ZUVuZENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbik7XG4gIH0gZWxzZSBpZiAoYm91bmRhcnkucGVuZGluZ1Rhc2tzID4gMCkge1xuICAgIC8vIFRoaXMgYm91bmRhcnkgaXMgc3RpbGwgbG9hZGluZy4gRW1pdCBhIHBlbmRpbmcgc3VzcGVuc2UgYm91bmRhcnkgd3JhcHBlci5cbiAgICAvLyBBc3NpZ24gYW4gSUQgdG8gcmVmZXIgdG8gdGhlIGZ1dHVyZSBjb250ZW50IGJ5LlxuICAgIGJvdW5kYXJ5LnJvb3RTZWdtZW50SUQgPSByZXF1ZXN0Lm5leHRTZWdtZW50SWQrKztcblxuICAgIGlmIChib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBJZiB0aGlzIGlzIGF0IGxlYXN0IHBhcnRpYWxseSBjb21wbGV0ZSwgd2UgY2FuIHF1ZXVlIGl0IHRvIGJlIHBhcnRpYWxseSBlbWl0dGVkIGVhcmx5LlxuICAgICAgcmVxdWVzdC5wYXJ0aWFsQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5KTtcbiAgICB9IC8vLyBUaGlzIGlzIHRoZSBmaXJzdCB0aW1lIHdlIHNob3VsZCBoYXZlIHJlZmVyZW5jZWQgdGhpcyBJRC5cblxuXG4gICAgdmFyIGlkID0gYm91bmRhcnkuaWQgPSBhc3NpZ25TdXNwZW5zZUJvdW5kYXJ5SUQocmVxdWVzdC5yZXNwb25zZVN0YXRlKTtcbiAgICB3cml0ZVN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24sIHJlcXVlc3QucmVzcG9uc2VTdGF0ZSwgaWQpOyAvLyBGbHVzaCB0aGUgZmFsbGJhY2suXG5cbiAgICBmbHVzaFN1YnRyZWUocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQpO1xuICAgIHJldHVybiB3cml0ZUVuZFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uKTtcbiAgfSBlbHNlIGlmIChib3VuZGFyeS5ieXRlU2l6ZSA+IHJlcXVlc3QucHJvZ3Jlc3NpdmVDaHVua1NpemUpIHtcbiAgICAvLyBUaGlzIGJvdW5kYXJ5IGlzIGxhcmdlIGFuZCB3aWxsIGJlIGVtaXR0ZWQgc2VwYXJhdGVseSBzbyB0aGF0IHdlIGNhbiBwcm9ncmVzc2l2ZWx5IHNob3dcbiAgICAvLyBvdGhlciBjb250ZW50LiBXZSBhZGQgaXQgdG8gdGhlIHF1ZXVlIGR1cmluZyB0aGUgZmx1c2ggYmVjYXVzZSB3ZSBoYXZlIHRvIGVuc3VyZSB0aGF0XG4gICAgLy8gdGhlIHBhcmVudCBmbHVzaGVzIGZpcnN0IHNvIHRoYXQgdGhlcmUncyBzb21ldGhpbmcgdG8gaW5qZWN0IGl0IGludG8uXG4gICAgLy8gV2UgYWxzbyBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IGl0J3MgZW1pdHRlZCBpbnRvIHRoZSBxdWV1ZSBpbiBhIGRldGVybWluaXN0aWMgc2xvdC5cbiAgICAvLyBJLmUuIHdlIGNhbid0IGluc2VydCBpdCBoZXJlIHdoZW4gaXQgY29tcGxldGVzLlxuICAgIC8vIEFzc2lnbiBhbiBJRCB0byByZWZlciB0byB0aGUgZnV0dXJlIGNvbnRlbnQgYnkuXG4gICAgYm91bmRhcnkucm9vdFNlZ21lbnRJRCA9IHJlcXVlc3QubmV4dFNlZ21lbnRJZCsrO1xuICAgIHJlcXVlc3QuY29tcGxldGVkQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5KTsgLy8gRW1pdCBhIHBlbmRpbmcgcmVuZGVyZWQgc3VzcGVuc2UgYm91bmRhcnkgd3JhcHBlci5cblxuICAgIHdyaXRlU3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZXNwb25zZVN0YXRlLCBib3VuZGFyeS5pZCk7IC8vIEZsdXNoIHRoZSBmYWxsYmFjay5cblxuICAgIGZsdXNoU3VidHJlZShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCk7XG4gICAgcmV0dXJuIHdyaXRlRW5kUGVuZGluZ1N1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24pO1xuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIGhvaXN0UmVzb3VyY2VzKHJlcXVlc3QucmVzb3VyY2VzLCBib3VuZGFyeS5yZXNvdXJjZXMpO1xuICAgIH0gLy8gV2UgY2FuIGlubGluZSB0aGlzIGJvdW5kYXJ5J3MgY29udGVudCBhcyBhIGNvbXBsZXRlIGJvdW5kYXJ5LlxuXG5cbiAgICB3cml0ZVN0YXJ0Q29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbik7XG4gICAgdmFyIGNvbXBsZXRlZFNlZ21lbnRzID0gYm91bmRhcnkuY29tcGxldGVkU2VnbWVudHM7XG5cbiAgICBpZiAoY29tcGxldGVkU2VnbWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgcHJldmlvdXNseSB1bnZpc2l0ZWQgYm91bmRhcnkgbXVzdCBoYXZlIGV4YWN0bHkgb25lIHJvb3Qgc2VnbWVudC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICB9XG5cbiAgICB2YXIgY29udGVudFNlZ21lbnQgPSBjb21wbGV0ZWRTZWdtZW50c1swXTtcbiAgICBmbHVzaFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIGNvbnRlbnRTZWdtZW50KTtcbiAgICByZXR1cm4gd3JpdGVFbmRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaENsaWVudFJlbmRlcmVkQm91bmRhcnkocmVxdWVzdCwgZGVzdGluYXRpb24sIGJvdW5kYXJ5KSB7XG4gIHJldHVybiB3cml0ZUNsaWVudFJlbmRlckJvdW5kYXJ5SW5zdHJ1Y3Rpb24oZGVzdGluYXRpb24sIHJlcXVlc3QucmVzcG9uc2VTdGF0ZSwgYm91bmRhcnkuaWQsIGJvdW5kYXJ5LmVycm9yRGlnZXN0LCBib3VuZGFyeS5lcnJvck1lc3NhZ2UsIGJvdW5kYXJ5LmVycm9yQ29tcG9uZW50U3RhY2spO1xufVxuXG5mdW5jdGlvbiBmbHVzaFNlZ21lbnRDb250YWluZXIocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQpIHtcbiAgd3JpdGVTdGFydFNlZ21lbnQoZGVzdGluYXRpb24sIHJlcXVlc3QucmVzcG9uc2VTdGF0ZSwgc2VnbWVudC5mb3JtYXRDb250ZXh0LCBzZWdtZW50LmlkKTtcbiAgZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50KTtcbiAgcmV0dXJuIHdyaXRlRW5kU2VnbWVudChkZXN0aW5hdGlvbiwgc2VnbWVudC5mb3JtYXRDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gZmx1c2hDb21wbGV0ZWRCb3VuZGFyeShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgYm91bmRhcnkpIHtcbiAge1xuICAgIHNldEN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5UmVzb3VyY2VzVGFyZ2V0KHJlcXVlc3QucmVzb3VyY2VzLCBib3VuZGFyeS5yZXNvdXJjZXMpO1xuICB9XG5cbiAgdmFyIGNvbXBsZXRlZFNlZ21lbnRzID0gYm91bmRhcnkuY29tcGxldGVkU2VnbWVudHM7XG4gIHZhciBpID0gMDtcblxuICBmb3IgKDsgaSA8IGNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNlZ21lbnQgPSBjb21wbGV0ZWRTZWdtZW50c1tpXTtcbiAgICBmbHVzaFBhcnRpYWxseUNvbXBsZXRlZFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIGJvdW5kYXJ5LCBzZWdtZW50KTtcbiAgfVxuXG4gIGNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aCA9IDA7XG5cbiAge1xuICAgIHdyaXRlUmVzb3VyY2VzRm9yQm91bmRhcnkoZGVzdGluYXRpb24sIGJvdW5kYXJ5LnJlc291cmNlcywgcmVxdWVzdC5yZXNwb25zZVN0YXRlKTtcbiAgfVxuXG4gIHJldHVybiB3cml0ZUNvbXBsZXRlZEJvdW5kYXJ5SW5zdHJ1Y3Rpb24oZGVzdGluYXRpb24sIHJlcXVlc3QucmVzcG9uc2VTdGF0ZSwgYm91bmRhcnkuaWQsIGJvdW5kYXJ5LnJvb3RTZWdtZW50SUQsIGJvdW5kYXJ5LnJlc291cmNlcyk7XG59XG5cbmZ1bmN0aW9uIGZsdXNoUGFydGlhbEJvdW5kYXJ5KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBib3VuZGFyeSkge1xuICB7XG4gICAgc2V0Q3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlSZXNvdXJjZXNUYXJnZXQocmVxdWVzdC5yZXNvdXJjZXMsIGJvdW5kYXJ5LnJlc291cmNlcyk7XG4gIH1cblxuICB2YXIgY29tcGxldGVkU2VnbWVudHMgPSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cztcbiAgdmFyIGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgY29tcGxldGVkU2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2VnbWVudCA9IGNvbXBsZXRlZFNlZ21lbnRzW2ldO1xuXG4gICAgaWYgKCFmbHVzaFBhcnRpYWxseUNvbXBsZXRlZFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIGJvdW5kYXJ5LCBzZWdtZW50KSkge1xuICAgICAgaSsrO1xuICAgICAgY29tcGxldGVkU2VnbWVudHMuc3BsaWNlKDAsIGkpOyAvLyBPbmx5IHdyaXRlIGFzIG11Y2ggYXMgdGhlIGJ1ZmZlciB3YW50cy4gU29tZXRoaW5nIGhpZ2hlciBwcmlvcml0eVxuICAgICAgLy8gbWlnaHQgd2FudCB0byB3cml0ZSBsYXRlci5cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBsZXRlZFNlZ21lbnRzLnNwbGljZSgwLCBpKTtcblxuICB7XG4gICAgLy8gVGhlIHdheSB0aGlzIGlzIHN0cnVjdHVyZWQgd2Ugb25seSB3cml0ZSByZXNvdXJjZXMgZm9yIHBhcnRpYWwgYm91bmRhcmllc1xuICAgIC8vIGlmIHRoZXJlIGlzIG5vIGJhY2twcmVzc3VyZS4gTGF0ZXIgYmVmb3JlIHdlIGNvbXBsZXRlIHRoZSBib3VuZGFyeSB3ZVxuICAgIC8vIHdpbGwgd3JpdGUgcmVzb3VyY2VzIHJlZ2FyZGxlc3Mgb2YgYmFja3ByZXNzdXJlIGJlZm9yZSB3ZSBlbWl0IHRoZVxuICAgIC8vIGNvbXBsZXRpb24gaW5zdHJ1Y3Rpb25cbiAgICByZXR1cm4gd3JpdGVSZXNvdXJjZXNGb3JCb3VuZGFyeShkZXN0aW5hdGlvbiwgYm91bmRhcnkucmVzb3VyY2VzLCByZXF1ZXN0LnJlc3BvbnNlU3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoUGFydGlhbGx5Q29tcGxldGVkU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgYm91bmRhcnksIHNlZ21lbnQpIHtcbiAgaWYgKHNlZ21lbnQuc3RhdHVzID09PSBGTFVTSEVEKSB7XG4gICAgLy8gV2UndmUgYWxyZWFkeSBmbHVzaGVkIHRoaXMgaW5saW5lLlxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIHNlZ21lbnRJRCA9IHNlZ21lbnQuaWQ7XG5cbiAgaWYgKHNlZ21lbnRJRCA9PT0gLTEpIHtcbiAgICAvLyBUaGlzIHNlZ21lbnQgd2Fzbid0IHByZXZpb3VzbHkgcmVmZXJyZWQgdG8uIFRoaXMgaGFwcGVucyBhdCB0aGUgcm9vdCBvZlxuICAgIC8vIGEgYm91bmRhcnkuIFdlIG1ha2Uga2luZCBvZiBhIGxlYXAgaGVyZSBhbmQgYXNzdW1lIHRoaXMgaXMgdGhlIHJvb3QuXG4gICAgdmFyIHJvb3RTZWdtZW50SUQgPSBzZWdtZW50LmlkID0gYm91bmRhcnkucm9vdFNlZ21lbnRJRDtcblxuICAgIGlmIChyb290U2VnbWVudElEID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHJvb3Qgc2VnbWVudCBJRCBtdXN0IGhhdmUgYmVlbiBhc3NpZ25lZCBieSBub3cuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZsdXNoU2VnbWVudENvbnRhaW5lcihyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgZmx1c2hTZWdtZW50Q29udGFpbmVyKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50KTtcbiAgICByZXR1cm4gd3JpdGVDb21wbGV0ZWRTZWdtZW50SW5zdHJ1Y3Rpb24oZGVzdGluYXRpb24sIHJlcXVlc3QucmVzcG9uc2VTdGF0ZSwgc2VnbWVudElEKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaENvbXBsZXRlZFF1ZXVlcyhyZXF1ZXN0LCBkZXN0aW5hdGlvbikge1xuICBiZWdpbldyaXRpbmcoKTtcblxuICB0cnkge1xuICAgIC8vIFRoZSBzdHJ1Y3R1cmUgb2YgdGhpcyBpcyB0byBnbyB0aHJvdWdoIGVhY2ggcXVldWUgb25lIGJ5IG9uZSBhbmQgd3JpdGVcbiAgICAvLyB1bnRpbCB0aGUgc2luayB0ZWxscyB1cyB0byBzdG9wLiBXaGVuIHdlIHNob3VsZCBzdG9wLCB3ZSBzdGlsbCBmaW5pc2ggd3JpdGluZ1xuICAgIC8vIHRoYXQgaXRlbSBmdWxseSBhbmQgdGhlbiB5aWVsZC4gQXQgdGhhdCBwb2ludCB3ZSByZW1vdmUgdGhlIGFscmVhZHkgY29tcGxldGVkXG4gICAgLy8gaXRlbXMgdXAgdW50aWwgdGhlIHBvaW50IHdlIGNvbXBsZXRlZCB0aGVtLlxuICAgIHZhciBpO1xuICAgIHZhciBjb21wbGV0ZWRSb290U2VnbWVudCA9IHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQ7XG5cbiAgICBpZiAoY29tcGxldGVkUm9vdFNlZ21lbnQgIT09IG51bGwpIHtcbiAgICAgIGlmIChyZXF1ZXN0LnBlbmRpbmdSb290VGFza3MgPT09IDApIHtcbiAgICAgICAgaWYgKGVuYWJsZUZsb2F0KSB7XG4gICAgICAgICAgd3JpdGVQcmVhbWJsZShkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZXNvdXJjZXMsIHJlcXVlc3QucmVzcG9uc2VTdGF0ZSwgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgPT09IDApO1xuICAgICAgICB9XG5cbiAgICAgICAgZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBjb21wbGV0ZWRSb290U2VnbWVudCk7XG4gICAgICAgIHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQgPSBudWxsO1xuICAgICAgICB3cml0ZUNvbXBsZXRlZFJvb3QoZGVzdGluYXRpb24sIHJlcXVlc3QucmVzcG9uc2VTdGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSBoYXZlbid0IGZsdXNoZWQgdGhlIHJvb3QgeWV0IHNvIHdlIGRvbid0IG5lZWQgdG8gY2hlY2sgYW55IG90aGVyIGJyYW5jaGVzIGZ1cnRoZXIgZG93blxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0LnBlbmRpbmdSb290VGFza3MgPiAwKSB7XG4gICAgICAvLyBXZSBoYXZlIG5vdCB5ZXQgZmx1c2hlZCB0aGUgcm9vdCBzZWdtZW50IHNvIHdlIGVhcmx5IHJldHVyblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbmFibGVGbG9hdCkge1xuICAgICAgd3JpdGVIb2lzdGFibGVzKGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlc291cmNlcywgcmVxdWVzdC5yZXNwb25zZVN0YXRlKTtcbiAgICB9IC8vIFdlIGVtaXQgY2xpZW50IHJlbmRlcmluZyBpbnN0cnVjdGlvbnMgZm9yIGFscmVhZHkgZW1pdHRlZCBib3VuZGFyaWVzIGZpcnN0LlxuICAgIC8vIFRoaXMgaXMgc28gdGhhdCB3ZSBjYW4gc2lnbmFsIHRvIHRoZSBjbGllbnQgdG8gc3RhcnQgY2xpZW50IHJlbmRlcmluZyB0aGVtIGFzXG4gICAgLy8gc29vbiBhcyBwb3NzaWJsZS5cblxuXG4gICAgdmFyIGNsaWVudFJlbmRlcmVkQm91bmRhcmllcyA9IHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGJvdW5kYXJ5ID0gY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzW2ldO1xuXG4gICAgICBpZiAoIWZsdXNoQ2xpZW50UmVuZGVyZWRCb3VuZGFyeShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgYm91bmRhcnkpKSB7XG4gICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICBpKys7XG4gICAgICAgIGNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpOyAvLyBOZXh0IHdlIGVtaXQgYW55IGNvbXBsZXRlIGJvdW5kYXJpZXMuIEl0J3MgYmV0dGVyIHRvIGZhdm9yIGJvdW5kYXJpZXNcbiAgICAvLyB0aGF0IGFyZSBjb21wbGV0ZWx5IGRvbmUgc2luY2Ugd2UgY2FuIGFjdHVhbGx5IHNob3cgdGhlbSwgdGhhbiBpdCBpcyB0byBlbWl0XG4gICAgLy8gYW55IGluZGl2aWR1YWwgc2VnbWVudHMgZnJvbSBhIHBhcnRpYWxseSBjb21wbGV0ZSBib3VuZGFyeS5cblxuICAgIHZhciBjb21wbGV0ZWRCb3VuZGFyaWVzID0gcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGNvbXBsZXRlZEJvdW5kYXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBfYm91bmRhcnkgPSBjb21wbGV0ZWRCb3VuZGFyaWVzW2ldO1xuXG4gICAgICBpZiAoIWZsdXNoQ29tcGxldGVkQm91bmRhcnkocmVxdWVzdCwgZGVzdGluYXRpb24sIF9ib3VuZGFyeSkpIHtcbiAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgIGkrKztcbiAgICAgICAgY29tcGxldGVkQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wbGV0ZWRCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTsgLy8gQWxsb3cgYW55dGhpbmcgd3JpdHRlbiBzbyBmYXIgdG8gZmx1c2ggdG8gdGhlIHVuZGVybHlpbmcgc2luayBiZWZvcmVcbiAgICAvLyB3ZSBjb250aW51ZSB3aXRoIGxvd2VyIHByaW9yaXRpZXMuXG5cbiAgICBjb21wbGV0ZVdyaXRpbmcoZGVzdGluYXRpb24pO1xuICAgIGJlZ2luV3JpdGluZyhkZXN0aW5hdGlvbik7IC8vIFRPRE86IEhlcmUgd2UnbGwgZW1pdCBkYXRhIHVzZWQgYnkgaHlkcmF0aW9uLlxuICAgIC8vIE5leHQgd2UgZW1pdCBhbnkgc2VnbWVudHMgb2YgYW55IGJvdW5kYXJpZXMgdGhhdCBhcmUgcGFydGlhbGx5IGNvbXBsZXRlXG4gICAgLy8gYnV0IG5vdCBkZWVwbHkgY29tcGxldGUuXG5cbiAgICB2YXIgcGFydGlhbEJvdW5kYXJpZXMgPSByZXF1ZXN0LnBhcnRpYWxCb3VuZGFyaWVzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHBhcnRpYWxCb3VuZGFyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX2JvdW5kYXJ5MiA9IHBhcnRpYWxCb3VuZGFyaWVzW2ldO1xuXG4gICAgICBpZiAoIWZsdXNoUGFydGlhbEJvdW5kYXJ5KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBfYm91bmRhcnkyKSkge1xuICAgICAgICByZXF1ZXN0LmRlc3RpbmF0aW9uID0gbnVsbDtcbiAgICAgICAgaSsrO1xuICAgICAgICBwYXJ0aWFsQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJ0aWFsQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7IC8vIE5leHQgd2UgY2hlY2sgdGhlIGNvbXBsZXRlZCBib3VuZGFyaWVzIGFnYWluLiBUaGlzIG1heSBoYXZlIGhhZFxuICAgIC8vIGJvdW5kYXJpZXMgYWRkZWQgdG8gaXQgaW4gY2FzZSB0aGV5IHdlcmUgdG9vIGxhcmdlZCB0byBiZSBpbmxpbmVkLlxuICAgIC8vIE5ldyBvbmVzIG1pZ2h0IGJlIGFkZGVkIGluIHRoaXMgbG9vcC5cblxuICAgIHZhciBsYXJnZUJvdW5kYXJpZXMgPSByZXF1ZXN0LmNvbXBsZXRlZEJvdW5kYXJpZXM7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGFyZ2VCb3VuZGFyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX2JvdW5kYXJ5MyA9IGxhcmdlQm91bmRhcmllc1tpXTtcblxuICAgICAgaWYgKCFmbHVzaENvbXBsZXRlZEJvdW5kYXJ5KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBfYm91bmRhcnkzKSkge1xuICAgICAgICByZXF1ZXN0LmRlc3RpbmF0aW9uID0gbnVsbDtcbiAgICAgICAgaSsrO1xuICAgICAgICBsYXJnZUJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGFyZ2VCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAocmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgPT09IDAgJiYgcmVxdWVzdC5waW5nZWRUYXNrcy5sZW5ndGggPT09IDAgJiYgcmVxdWVzdC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMubGVuZ3RoID09PSAwICYmIHJlcXVlc3QuY29tcGxldGVkQm91bmRhcmllcy5sZW5ndGggPT09IDAgLy8gV2UgZG9uJ3QgbmVlZCB0byBjaGVjayBhbnkgcGFydGlhbGx5IGNvbXBsZXRlZCBzZWdtZW50cyBiZWNhdXNlXG4gICAgLy8gZWl0aGVyIHRoZXkgaGF2ZSBwZW5kaW5nIHRhc2sgb3IgdGhleSdyZSBjb21wbGV0ZS5cbiAgICApIHtcbiAgICAgICAgcmVxdWVzdC5mbHVzaFNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gICAgICAgIHtcbiAgICAgICAgICB3cml0ZVBvc3RhbWJsZShkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZXNwb25zZVN0YXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBsZXRlV3JpdGluZyhkZXN0aW5hdGlvbik7XG4gICAgICAgIGZsdXNoQnVmZmVyZWQoZGVzdGluYXRpb24pO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAocmVxdWVzdC5hYm9ydGFibGVUYXNrcy5zaXplICE9PSAwKSB7XG4gICAgICAgICAgICBlcnJvcignVGhlcmUgd2FzIHN0aWxsIGFib3J0YWJsZSB0YXNrIGF0IHRoZSByb290IHdoZW4gd2UgY2xvc2VkLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBXZSdyZSBkb25lLlxuXG5cbiAgICAgICAgY2xvc2UoZGVzdGluYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgIGNvbXBsZXRlV3JpdGluZyhkZXN0aW5hdGlvbik7XG4gICAgICBmbHVzaEJ1ZmZlcmVkKGRlc3RpbmF0aW9uKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRXb3JrKHJlcXVlc3QpIHtcbiAgcmVxdWVzdC5mbHVzaFNjaGVkdWxlZCA9IHJlcXVlc3QuZGVzdGluYXRpb24gIT09IG51bGw7XG5cbiAge1xuICAgIHNjaGVkdWxlV29yayhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVxdWVzdFN0b3JhZ2UucnVuKHJlcXVlc3QsIHBlcmZvcm1Xb3JrLCByZXF1ZXN0KTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbnF1ZXVlRmx1c2gocmVxdWVzdCkge1xuICBpZiAocmVxdWVzdC5mbHVzaFNjaGVkdWxlZCA9PT0gZmFsc2UgJiYgLy8gSWYgdGhlcmUgYXJlIHBpbmdlZCB0YXNrcyB3ZSBhcmUgZ29pbmcgdG8gZmx1c2ggYW55d2F5IGFmdGVyIHdvcmsgY29tcGxldGVzXG4gIHJlcXVlc3QucGluZ2VkVGFza3MubGVuZ3RoID09PSAwICYmIC8vIElmIHRoZXJlIGlzIG5vIGRlc3RpbmF0aW9uIHRoZXJlIGlzIG5vdGhpbmcgd2UgY2FuIGZsdXNoIHRvLiBBIGZsdXNoIHdpbGxcbiAgLy8gaGFwcGVuIHdoZW4gd2Ugc3RhcnQgZmxvd2luZyBhZ2FpblxuICByZXF1ZXN0LmRlc3RpbmF0aW9uICE9PSBudWxsKSB7XG4gICAgdmFyIGRlc3RpbmF0aW9uID0gcmVxdWVzdC5kZXN0aW5hdGlvbjtcbiAgICByZXF1ZXN0LmZsdXNoU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBzY2hlZHVsZVdvcmsoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZsdXNoQ29tcGxldGVkUXVldWVzKHJlcXVlc3QsIGRlc3RpbmF0aW9uKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydEZsb3dpbmcocmVxdWVzdCwgZGVzdGluYXRpb24pIHtcbiAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSBDTE9TSU5HKSB7XG4gICAgcmVxdWVzdC5zdGF0dXMgPSBDTE9TRUQ7XG4gICAgY2xvc2VXaXRoRXJyb3IoZGVzdGluYXRpb24sIHJlcXVlc3QuZmF0YWxFcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSBDTE9TRUQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocmVxdWVzdC5kZXN0aW5hdGlvbiAhPT0gbnVsbCkge1xuICAgIC8vIFdlJ3JlIGFscmVhZHkgZmxvd2luZy5cbiAgICByZXR1cm47XG4gIH1cblxuICByZXF1ZXN0LmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG5cbiAgdHJ5IHtcbiAgICBmbHVzaENvbXBsZXRlZFF1ZXVlcyhyZXF1ZXN0LCBkZXN0aW5hdGlvbik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gICAgZmF0YWxFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gIH1cbn0gLy8gVGhpcyBpcyBjYWxsZWQgdG8gZWFybHkgdGVybWluYXRlIGEgcmVxdWVzdC4gSXQgcHV0cyBhbGwgcGVuZGluZyBib3VuZGFyaWVzIGluIGNsaWVudCByZW5kZXJlZCBzdGF0ZS5cblxuZnVuY3Rpb24gYWJvcnQocmVxdWVzdCwgcmVhc29uKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFib3J0YWJsZVRhc2tzID0gcmVxdWVzdC5hYm9ydGFibGVUYXNrcztcblxuICAgIGlmIChhYm9ydGFibGVUYXNrcy5zaXplID4gMCkge1xuICAgICAgdmFyIGVycm9yID0gcmVhc29uID09PSB1bmRlZmluZWQgPyBuZXcgRXJyb3IoJ1RoZSByZW5kZXIgd2FzIGFib3J0ZWQgYnkgdGhlIHNlcnZlciB3aXRob3V0IGEgcmVhc29uLicpIDogcmVhc29uO1xuICAgICAgYWJvcnRhYmxlVGFza3MuZm9yRWFjaChmdW5jdGlvbiAodGFzaykge1xuICAgICAgICByZXR1cm4gYWJvcnRUYXNrKHRhc2ssIHJlcXVlc3QsIGVycm9yKTtcbiAgICAgIH0pO1xuICAgICAgYWJvcnRhYmxlVGFza3MuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdC5kZXN0aW5hdGlvbiAhPT0gbnVsbCkge1xuICAgICAgZmx1c2hDb21wbGV0ZWRRdWV1ZXMocmVxdWVzdCwgcmVxdWVzdC5kZXN0aW5hdGlvbik7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICAgIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICB9XG59XG5mdW5jdGlvbiBmbHVzaFJlc291cmNlcyhyZXF1ZXN0KSB7XG4gIGVucXVldWVGbHVzaChyZXF1ZXN0KTtcbn1cbmZ1bmN0aW9uIGdldFJlc291cmNlcyhyZXF1ZXN0KSB7XG4gIHJldHVybiByZXF1ZXN0LnJlc291cmNlcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlRHJhaW5IYW5kbGVyKGRlc3RpbmF0aW9uLCByZXF1ZXN0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHN0YXJ0Rmxvd2luZyhyZXF1ZXN0LCBkZXN0aW5hdGlvbik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFib3J0SGFuZGxlcihyZXF1ZXN0LCByZWFzb24pIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYWJvcnQocmVxdWVzdCwgbmV3IEVycm9yKHJlYXNvbikpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSZXF1ZXN0SW1wbChjaGlsZHJlbiwgb3B0aW9ucykge1xuICB2YXIgcmVzb3VyY2VzID0gY3JlYXRlUmVzb3VyY2VzKCk7XG4gIHJldHVybiBjcmVhdGVSZXF1ZXN0KGNoaWxkcmVuLCByZXNvdXJjZXMsIGNyZWF0ZVJlc3BvbnNlU3RhdGUocmVzb3VyY2VzLCBvcHRpb25zID8gb3B0aW9ucy5pZGVudGlmaWVyUHJlZml4IDogdW5kZWZpbmVkLCBvcHRpb25zID8gb3B0aW9ucy5ub25jZSA6IHVuZGVmaW5lZCwgb3B0aW9ucyA/IG9wdGlvbnMuYm9vdHN0cmFwU2NyaXB0Q29udGVudCA6IHVuZGVmaW5lZCwgb3B0aW9ucyA/IG9wdGlvbnMuYm9vdHN0cmFwU2NyaXB0cyA6IHVuZGVmaW5lZCwgb3B0aW9ucyA/IG9wdGlvbnMuYm9vdHN0cmFwTW9kdWxlcyA6IHVuZGVmaW5lZCwgb3B0aW9ucyA/IG9wdGlvbnMudW5zdGFibGVfZXh0ZXJuYWxSdW50aW1lU3JjIDogdW5kZWZpbmVkKSwgY3JlYXRlUm9vdEZvcm1hdENvbnRleHQob3B0aW9ucyA/IG9wdGlvbnMubmFtZXNwYWNlVVJJIDogdW5kZWZpbmVkKSwgb3B0aW9ucyA/IG9wdGlvbnMucHJvZ3Jlc3NpdmVDaHVua1NpemUgOiB1bmRlZmluZWQsIG9wdGlvbnMgPyBvcHRpb25zLm9uRXJyb3IgOiB1bmRlZmluZWQsIG9wdGlvbnMgPyBvcHRpb25zLm9uQWxsUmVhZHkgOiB1bmRlZmluZWQsIG9wdGlvbnMgPyBvcHRpb25zLm9uU2hlbGxSZWFkeSA6IHVuZGVmaW5lZCwgb3B0aW9ucyA/IG9wdGlvbnMub25TaGVsbEVycm9yIDogdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xufVxuXG5mdW5jdGlvbiByZW5kZXJUb1BpcGVhYmxlU3RyZWFtKGNoaWxkcmVuLCBvcHRpb25zKSB7XG4gIHZhciByZXF1ZXN0ID0gY3JlYXRlUmVxdWVzdEltcGwoY2hpbGRyZW4sIG9wdGlvbnMpO1xuICB2YXIgaGFzU3RhcnRlZEZsb3dpbmcgPSBmYWxzZTtcbiAgc3RhcnRXb3JrKHJlcXVlc3QpO1xuICByZXR1cm4ge1xuICAgIHBpcGU6IGZ1bmN0aW9uIChkZXN0aW5hdGlvbikge1xuICAgICAgaWYgKGhhc1N0YXJ0ZWRGbG93aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVhY3QgY3VycmVudGx5IG9ubHkgc3VwcG9ydHMgcGlwaW5nIHRvIG9uZSB3cml0YWJsZSBzdHJlYW0uJyk7XG4gICAgICB9XG5cbiAgICAgIGhhc1N0YXJ0ZWRGbG93aW5nID0gdHJ1ZTtcbiAgICAgIHN0YXJ0Rmxvd2luZyhyZXF1ZXN0LCBkZXN0aW5hdGlvbik7XG4gICAgICBkZXN0aW5hdGlvbi5vbignZHJhaW4nLCBjcmVhdGVEcmFpbkhhbmRsZXIoZGVzdGluYXRpb24sIHJlcXVlc3QpKTtcbiAgICAgIGRlc3RpbmF0aW9uLm9uKCdlcnJvcicsIGNyZWF0ZUFib3J0SGFuZGxlcihyZXF1ZXN0LCAnVGhlIGRlc3RpbmF0aW9uIHN0cmVhbSBlcnJvcmVkIHdoaWxlIHdyaXRpbmcgZGF0YS4nKSk7XG4gICAgICBkZXN0aW5hdGlvbi5vbignY2xvc2UnLCBjcmVhdGVBYm9ydEhhbmRsZXIocmVxdWVzdCwgJ1RoZSBkZXN0aW5hdGlvbiBzdHJlYW0gY2xvc2VkIGVhcmx5LicpKTtcbiAgICAgIHJldHVybiBkZXN0aW5hdGlvbjtcbiAgICB9LFxuICAgIGFib3J0OiBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBhYm9ydChyZXF1ZXN0LCByZWFzb24pO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0cy5yZW5kZXJUb1BpcGVhYmxlU3RyZWFtID0gcmVuZGVyVG9QaXBlYWJsZVN0cmVhbTtcbmV4cG9ydHMudmVyc2lvbiA9IFJlYWN0VmVyc2lvbjtcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwiUmVhY3QiLCJyZXF1aXJlIiwidXRpbCIsImFzeW5jX2hvb2tzIiwiUmVhY3RET00iLCJSZWFjdFZlcnNpb24iLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwid2FybiIsImZvcm1hdCIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwicHJpbnRXYXJuaW5nIiwiZXJyb3IiLCJfbGVuMiIsIl9rZXkyIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiY29uY2F0IiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsInNjaGVkdWxlV29yayIsImNhbGxiYWNrIiwic2V0SW1tZWRpYXRlIiwiZmx1c2hCdWZmZXJlZCIsImRlc3RpbmF0aW9uIiwiZmx1c2giLCJWSUVXX1NJWkUiLCJjdXJyZW50VmlldyIsIndyaXR0ZW5CeXRlcyIsImRlc3RpbmF0aW9uSGFzQ2FwYWNpdHkkMSIsImJlZ2luV3JpdGluZyIsIlVpbnQ4QXJyYXkiLCJ3cml0ZVN0cmluZ0NodW5rIiwic3RyaW5nQ2h1bmsiLCJ3cml0ZVRvRGVzdGluYXRpb24iLCJzdWJhcnJheSIsInRleHRFbmNvZGVyIiwiZW5jb2RlIiwidGFyZ2V0IiwiX3RleHRFbmNvZGVyJGVuY29kZUluIiwiZW5jb2RlSW50byIsInJlYWQiLCJ3cml0dGVuIiwic2xpY2UiLCJ3cml0ZVZpZXdDaHVuayIsImNodW5rIiwiYnl0ZUxlbmd0aCIsInByZWNvbXB1dGVkQ2h1bmtTZXQiLCJoYXMiLCJieXRlc1RvV3JpdGUiLCJhbGxvd2FibGVCeXRlcyIsInNldCIsIndyaXRlQ2h1bmsiLCJ2aWV3IiwiY3VycmVudEhhc0NhcGFjaXR5Iiwid3JpdGUiLCJ3cml0ZUNodW5rQW5kUmV0dXJuIiwiY29tcGxldGVXcml0aW5nIiwiY2xvc2UiLCJlbmQiLCJUZXh0RW5jb2RlciIsInN0cmluZ1RvQ2h1bmsiLCJjb250ZW50IiwiU2V0Iiwic3RyaW5nVG9QcmVjb21wdXRlZENodW5rIiwicHJlY29tcHV0ZWRDaHVuayIsImFkZCIsImNsb25lUHJlY29tcHV0ZWRDaHVuayIsImNsb3NlV2l0aEVycm9yIiwiZGVzdHJveSIsIl9kZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJhc3NpZ24iLCJ0eXBlTmFtZSIsImhhc1RvU3RyaW5nVGFnIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ0eXBlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwid2lsbENvZXJjaW9uVGhyb3ciLCJ0ZXN0U3RyaW5nQ29lcmNpb24iLCJlIiwiY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbiIsImF0dHJpYnV0ZU5hbWUiLCJjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24iLCJwcm9wTmFtZSIsImNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uIiwiZW5hYmxlRmxvYXQiLCJoYXNPd25Qcm9wZXJ0eSIsIkFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIiLCJBVFRSSUJVVEVfTkFNRV9DSEFSIiwiVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgiLCJSZWdFeHAiLCJpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlIiwidmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlIiwiaXNBdHRyaWJ1dGVOYW1lU2FmZSIsInRlc3QiLCJ1bml0bGVzc051bWJlcnMiLCJpc1VuaXRsZXNzTnVtYmVyIiwiYWxpYXNlcyIsIk1hcCIsImdldEF0dHJpYnV0ZUFsaWFzIiwiZ2V0IiwiaGFzUmVhZE9ubHlWYWx1ZSIsImJ1dHRvbiIsImNoZWNrYm94IiwiaW1hZ2UiLCJoaWRkZW4iLCJyYWRpbyIsInJlc2V0Iiwic3VibWl0IiwiY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcyIsInRhZ05hbWUiLCJwcm9wcyIsIm9uQ2hhbmdlIiwib25JbnB1dCIsInJlYWRPbmx5IiwiZGlzYWJsZWQiLCJjaGVja2VkIiwiYXJpYVByb3BlcnRpZXMiLCJ3YXJuZWRQcm9wZXJ0aWVzJDEiLCJyQVJJQSQxIiwickFSSUFDYW1lbCQxIiwidmFsaWRhdGVQcm9wZXJ0eSQxIiwiYXJpYU5hbWUiLCJ0b0xvd2VyQ2FzZSIsImNvcnJlY3ROYW1lIiwibG93ZXJDYXNlZE5hbWUiLCJzdGFuZGFyZE5hbWUiLCJ2YWxpZGF0ZVByb3BlcnRpZXMkMiIsImludmFsaWRQcm9wcyIsImlzVmFsaWQiLCJwdXNoIiwidW5rbm93blByb3BTdHJpbmciLCJwcm9wIiwiam9pbiIsImRpZFdhcm5WYWx1ZU51bGwiLCJ2YWxpZGF0ZVByb3BlcnRpZXMkMSIsIm11bHRpcGxlIiwiaXNDdXN0b21FbGVtZW50IiwiaW5kZXhPZiIsInBvc3NpYmxlU3RhbmRhcmROYW1lcyIsImFjY2VwdCIsImFjY2VwdGNoYXJzZXQiLCJhY2Nlc3NrZXkiLCJhY3Rpb24iLCJhbGxvd2Z1bGxzY3JlZW4iLCJhbHQiLCJhcyIsImFzeW5jIiwiYXV0b2NhcGl0YWxpemUiLCJhdXRvY29tcGxldGUiLCJhdXRvY29ycmVjdCIsImF1dG9mb2N1cyIsImF1dG9wbGF5IiwiYXV0b3NhdmUiLCJjYXB0dXJlIiwiY2VsbHBhZGRpbmciLCJjZWxsc3BhY2luZyIsImNoYWxsZW5nZSIsImNoYXJzZXQiLCJjaGlsZHJlbiIsImNpdGUiLCJjbGFzcyIsImNsYXNzaWQiLCJjbGFzc25hbWUiLCJjb2xzIiwiY29sc3BhbiIsImNvbnRlbnRlZGl0YWJsZSIsImNvbnRleHRtZW51IiwiY29udHJvbHMiLCJjb250cm9sc2xpc3QiLCJjb29yZHMiLCJjcm9zc29yaWdpbiIsImRhbmdlcm91c2x5c2V0aW5uZXJodG1sIiwiZGF0YSIsImRhdGV0aW1lIiwiZGVmYXVsdCIsImRlZmF1bHRjaGVja2VkIiwiZGVmYXVsdHZhbHVlIiwiZGVmZXIiLCJkaXIiLCJkaXNhYmxlcGljdHVyZWlucGljdHVyZSIsImRpc2FibGVyZW1vdGVwbGF5YmFjayIsImRvd25sb2FkIiwiZHJhZ2dhYmxlIiwiZW5jdHlwZSIsImVudGVya2V5aGludCIsImZldGNocHJpb3JpdHkiLCJmb3IiLCJmb3JtIiwiZm9ybW1ldGhvZCIsImZvcm1hY3Rpb24iLCJmb3JtZW5jdHlwZSIsImZvcm1ub3ZhbGlkYXRlIiwiZm9ybXRhcmdldCIsImZyYW1lYm9yZGVyIiwiaGVhZGVycyIsImhlaWdodCIsImhpZ2giLCJocmVmIiwiaHJlZmxhbmciLCJodG1sZm9yIiwiaHR0cGVxdWl2IiwiaWNvbiIsImlkIiwiaW1hZ2VzaXplcyIsImltYWdlc3Jjc2V0IiwiaW5uZXJodG1sIiwiaW5wdXRtb2RlIiwiaW50ZWdyaXR5IiwiaXMiLCJpdGVtaWQiLCJpdGVtcHJvcCIsIml0ZW1yZWYiLCJpdGVtc2NvcGUiLCJpdGVtdHlwZSIsImtleXBhcmFtcyIsImtleXR5cGUiLCJraW5kIiwibGFiZWwiLCJsYW5nIiwibGlzdCIsImxvb3AiLCJsb3ciLCJtYW5pZmVzdCIsIm1hcmdpbndpZHRoIiwibWFyZ2luaGVpZ2h0IiwibWF4IiwibWF4bGVuZ3RoIiwibWVkaWEiLCJtZWRpYWdyb3VwIiwibWV0aG9kIiwibWluIiwibWlubGVuZ3RoIiwibXV0ZWQiLCJub21vZHVsZSIsIm5vbmNlIiwibm92YWxpZGF0ZSIsIm9wZW4iLCJvcHRpbXVtIiwicGF0dGVybiIsInBsYWNlaG9sZGVyIiwicGxheXNpbmxpbmUiLCJwb3N0ZXIiLCJwcmVsb2FkIiwicHJvZmlsZSIsInJhZGlvZ3JvdXAiLCJyZWFkb25seSIsInJlZmVycmVycG9saWN5IiwicmVsIiwicmVxdWlyZWQiLCJyZXZlcnNlZCIsInJvbGUiLCJyb3dzIiwicm93c3BhbiIsInNhbmRib3giLCJzY29wZSIsInNjb3BlZCIsInNjcm9sbGluZyIsInNlYW1sZXNzIiwic2VsZWN0ZWQiLCJzaGFwZSIsInNpemUiLCJzaXplcyIsInNwYW4iLCJzcGVsbGNoZWNrIiwic3JjIiwic3JjZG9jIiwic3JjbGFuZyIsInNyY3NldCIsInN0YXJ0Iiwic3RlcCIsInN0eWxlIiwic3VtbWFyeSIsInRhYmluZGV4IiwidGl0bGUiLCJ1c2VtYXAiLCJ3aWR0aCIsIndtb2RlIiwid3JhcCIsImFib3V0IiwiYWNjZW50aGVpZ2h0IiwiYWNjdW11bGF0ZSIsImFkZGl0aXZlIiwiYWxpZ25tZW50YmFzZWxpbmUiLCJhbGxvd3Jlb3JkZXIiLCJhbHBoYWJldGljIiwiYW1wbGl0dWRlIiwiYXJhYmljZm9ybSIsImFzY2VudCIsImF0dHJpYnV0ZW5hbWUiLCJhdHRyaWJ1dGV0eXBlIiwiYXV0b3JldmVyc2UiLCJhemltdXRoIiwiYmFzZWZyZXF1ZW5jeSIsImJhc2VsaW5lc2hpZnQiLCJiYXNlcHJvZmlsZSIsImJib3giLCJiZWdpbiIsImJpYXMiLCJieSIsImNhbGNtb2RlIiwiY2FwaGVpZ2h0IiwiY2xpcCIsImNsaXBwYXRoIiwiY2xpcHBhdGh1bml0cyIsImNsaXBydWxlIiwiY29sb3IiLCJjb2xvcmludGVycG9sYXRpb24iLCJjb2xvcmludGVycG9sYXRpb25maWx0ZXJzIiwiY29sb3Jwcm9maWxlIiwiY29sb3JyZW5kZXJpbmciLCJjb250ZW50c2NyaXB0dHlwZSIsImNvbnRlbnRzdHlsZXR5cGUiLCJjdXJzb3IiLCJjeCIsImN5IiwiZCIsImRhdGF0eXBlIiwiZGVjZWxlcmF0ZSIsImRlc2NlbnQiLCJkaWZmdXNlY29uc3RhbnQiLCJkaXJlY3Rpb24iLCJkaXNwbGF5IiwiZGl2aXNvciIsImRvbWluYW50YmFzZWxpbmUiLCJkdXIiLCJkeCIsImR5IiwiZWRnZW1vZGUiLCJlbGV2YXRpb24iLCJlbmFibGViYWNrZ3JvdW5kIiwiZXhwb25lbnQiLCJleHRlcm5hbHJlc291cmNlc3JlcXVpcmVkIiwiZmlsbCIsImZpbGxvcGFjaXR5IiwiZmlsbHJ1bGUiLCJmaWx0ZXIiLCJmaWx0ZXJyZXMiLCJmaWx0ZXJ1bml0cyIsImZsb29kb3BhY2l0eSIsImZsb29kY29sb3IiLCJmb2N1c2FibGUiLCJmb250ZmFtaWx5IiwiZm9udHNpemUiLCJmb250c2l6ZWFkanVzdCIsImZvbnRzdHJldGNoIiwiZm9udHN0eWxlIiwiZm9udHZhcmlhbnQiLCJmb250d2VpZ2h0IiwiZnJvbSIsImZ4IiwiZnkiLCJnMSIsImcyIiwiZ2x5cGhuYW1lIiwiZ2x5cGhvcmllbnRhdGlvbmhvcml6b250YWwiLCJnbHlwaG9yaWVudGF0aW9udmVydGljYWwiLCJnbHlwaHJlZiIsImdyYWRpZW50dHJhbnNmb3JtIiwiZ3JhZGllbnR1bml0cyIsImhhbmdpbmciLCJob3JpemFkdngiLCJob3Jpem9yaWdpbngiLCJpZGVvZ3JhcGhpYyIsImltYWdlcmVuZGVyaW5nIiwiaW4yIiwiaW4iLCJpbmxpc3QiLCJpbnRlcmNlcHQiLCJrMSIsImsyIiwiazMiLCJrNCIsImsiLCJrZXJuZWxtYXRyaXgiLCJrZXJuZWx1bml0bGVuZ3RoIiwia2VybmluZyIsImtleXBvaW50cyIsImtleXNwbGluZXMiLCJrZXl0aW1lcyIsImxlbmd0aGFkanVzdCIsImxldHRlcnNwYWNpbmciLCJsaWdodGluZ2NvbG9yIiwibGltaXRpbmdjb25lYW5nbGUiLCJsb2NhbCIsIm1hcmtlcmVuZCIsIm1hcmtlcmhlaWdodCIsIm1hcmtlcm1pZCIsIm1hcmtlcnN0YXJ0IiwibWFya2VydW5pdHMiLCJtYXJrZXJ3aWR0aCIsIm1hc2siLCJtYXNrY29udGVudHVuaXRzIiwibWFza3VuaXRzIiwibWF0aGVtYXRpY2FsIiwibW9kZSIsIm51bW9jdGF2ZXMiLCJvZmZzZXQiLCJvcGFjaXR5Iiwib3BlcmF0b3IiLCJvcmRlciIsIm9yaWVudCIsIm9yaWVudGF0aW9uIiwib3JpZ2luIiwib3ZlcmZsb3ciLCJvdmVybGluZXBvc2l0aW9uIiwib3ZlcmxpbmV0aGlja25lc3MiLCJwYWludG9yZGVyIiwicGFub3NlMSIsInBhdGhsZW5ndGgiLCJwYXR0ZXJuY29udGVudHVuaXRzIiwicGF0dGVybnRyYW5zZm9ybSIsInBhdHRlcm51bml0cyIsInBvaW50ZXJldmVudHMiLCJwb2ludHMiLCJwb2ludHNhdHgiLCJwb2ludHNhdHkiLCJwb2ludHNhdHoiLCJwcmVmaXgiLCJwcmVzZXJ2ZWFscGhhIiwicHJlc2VydmVhc3BlY3RyYXRpbyIsInByaW1pdGl2ZXVuaXRzIiwicHJvcGVydHkiLCJyIiwicmFkaXVzIiwicmVmeCIsInJlZnkiLCJyZW5kZXJpbmdpbnRlbnQiLCJyZXBlYXRjb3VudCIsInJlcGVhdGR1ciIsInJlcXVpcmVkZXh0ZW5zaW9ucyIsInJlcXVpcmVkZmVhdHVyZXMiLCJyZXNvdXJjZSIsInJlc3RhcnQiLCJyZXN1bHQiLCJyZXN1bHRzIiwicm90YXRlIiwicngiLCJyeSIsInNjYWxlIiwic2VjdXJpdHkiLCJzZWVkIiwic2hhcGVyZW5kZXJpbmciLCJzbG9wZSIsInNwYWNpbmciLCJzcGVjdWxhcmNvbnN0YW50Iiwic3BlY3VsYXJleHBvbmVudCIsInNwZWVkIiwic3ByZWFkbWV0aG9kIiwic3RhcnRvZmZzZXQiLCJzdGRkZXZpYXRpb24iLCJzdGVtaCIsInN0ZW12Iiwic3RpdGNodGlsZXMiLCJzdG9wY29sb3IiLCJzdG9wb3BhY2l0eSIsInN0cmlrZXRocm91Z2hwb3NpdGlvbiIsInN0cmlrZXRocm91Z2h0aGlja25lc3MiLCJzdHJpbmciLCJzdHJva2UiLCJzdHJva2VkYXNoYXJyYXkiLCJzdHJva2VkYXNob2Zmc2V0Iiwic3Ryb2tlbGluZWNhcCIsInN0cm9rZWxpbmVqb2luIiwic3Ryb2tlbWl0ZXJsaW1pdCIsInN0cm9rZXdpZHRoIiwic3Ryb2tlb3BhY2l0eSIsInN1cHByZXNzY29udGVudGVkaXRhYmxld2FybmluZyIsInN1cHByZXNzaHlkcmF0aW9ud2FybmluZyIsInN1cmZhY2VzY2FsZSIsInN5c3RlbWxhbmd1YWdlIiwidGFibGV2YWx1ZXMiLCJ0YXJnZXR4IiwidGFyZ2V0eSIsInRleHRhbmNob3IiLCJ0ZXh0ZGVjb3JhdGlvbiIsInRleHRsZW5ndGgiLCJ0ZXh0cmVuZGVyaW5nIiwidG8iLCJ0cmFuc2Zvcm0iLCJ0cmFuc2Zvcm1vcmlnaW4iLCJ0eXBlb2YiLCJ1MSIsInUyIiwidW5kZXJsaW5lcG9zaXRpb24iLCJ1bmRlcmxpbmV0aGlja25lc3MiLCJ1bmljb2RlIiwidW5pY29kZWJpZGkiLCJ1bmljb2RlcmFuZ2UiLCJ1bml0c3BlcmVtIiwidW5zZWxlY3RhYmxlIiwidmFscGhhYmV0aWMiLCJ2YWx1ZXMiLCJ2ZWN0b3JlZmZlY3QiLCJ2ZXJzaW9uIiwidmVydGFkdnkiLCJ2ZXJ0b3JpZ2lueCIsInZlcnRvcmlnaW55IiwidmhhbmdpbmciLCJ2aWRlb2dyYXBoaWMiLCJ2aWV3Ym94Iiwidmlld3RhcmdldCIsInZpc2liaWxpdHkiLCJ2bWF0aGVtYXRpY2FsIiwidm9jYWIiLCJ3aWR0aHMiLCJ3b3Jkc3BhY2luZyIsIndyaXRpbmdtb2RlIiwieDEiLCJ4MiIsIngiLCJ4Y2hhbm5lbHNlbGVjdG9yIiwieGhlaWdodCIsInhsaW5rYWN0dWF0ZSIsInhsaW5rYXJjcm9sZSIsInhsaW5raHJlZiIsInhsaW5rcm9sZSIsInhsaW5rc2hvdyIsInhsaW5rdGl0bGUiLCJ4bGlua3R5cGUiLCJ4bWxiYXNlIiwieG1sbGFuZyIsInhtbG5zIiwieG1sbnN4bGluayIsInhtbHNwYWNlIiwieTEiLCJ5MiIsInkiLCJ5Y2hhbm5lbHNlbGVjdG9yIiwieiIsInpvb21hbmRwYW4iLCJ3YXJuZWRQcm9wZXJ0aWVzIiwiRVZFTlRfTkFNRV9SRUdFWCIsIklOVkFMSURfRVZFTlRfTkFNRV9SRUdFWCIsInJBUklBIiwickFSSUFDYW1lbCIsInZhbGlkYXRlUHJvcGVydHkiLCJldmVudFJlZ2lzdHJ5IiwicmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyIsInBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMiLCJyZWdpc3RyYXRpb25OYW1lIiwidW5kZWZpbmVkIiwiaXNOYU4iLCJ3YXJuVW5rbm93blByb3BlcnRpZXMiLCJ1bmtub3duUHJvcHMiLCJ2YWxpZGF0ZVByb3BlcnRpZXMiLCJiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4iLCJtc1BhdHRlcm4kMSIsImh5cGhlblBhdHRlcm4iLCJiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4iLCJ3YXJuZWRTdHlsZU5hbWVzIiwid2FybmVkU3R5bGVWYWx1ZXMiLCJ3YXJuZWRGb3JOYU5WYWx1ZSIsIndhcm5lZEZvckluZmluaXR5VmFsdWUiLCJjYW1lbGl6ZSIsInJlcGxhY2UiLCJfIiwiY2hhcmFjdGVyIiwidG9VcHBlckNhc2UiLCJ3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSIsIndhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZSIsImNoYXJBdCIsIndhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiIsIndhcm5TdHlsZVZhbHVlSXNOYU4iLCJ3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkiLCJ3YXJuVmFsaWRTdHlsZSIsImlzRmluaXRlIiwibWF0Y2hIdG1sUmVnRXhwIiwiZXNjYXBlSHRtbCIsInN0ciIsIm1hdGNoIiwiZXhlYyIsImVzY2FwZSIsImh0bWwiLCJpbmRleCIsImxhc3RJbmRleCIsImNoYXJDb2RlQXQiLCJlc2NhcGVUZXh0Rm9yQnJvd3NlciIsInRleHQiLCJ1cHBlcmNhc2VQYXR0ZXJuIiwibXNQYXR0ZXJuIiwiaHlwaGVuYXRlU3R5bGVOYW1lIiwiaXNKYXZhU2NyaXB0UHJvdG9jb2wiLCJkaWRXYXJuIiwic2FuaXRpemVVUkwiLCJ1cmwiLCJzdHJpbmdpZmllZFVSTCIsIkpTT04iLCJzdHJpbmdpZnkiLCJpc0FycmF5SW1wbCIsImlzQXJyYXkiLCJhIiwiY2xpZW50UmVuZGVyQm91bmRhcnkiLCJjb21wbGV0ZUJvdW5kYXJ5IiwiY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXMiLCJjb21wbGV0ZVNlZ21lbnQiLCJmb3JtUmVwbGF5aW5nIiwiZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nT2JqZWN0Rm9yV2FybmluZyIsInRoaW5nIiwiZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmciLCJjb21wYXJlUmVzb3VyY2VQcm9wc0Zvcldhcm5pbmciLCJuZXdQcm9wcyIsImN1cnJlbnRQcm9wcyIsInByb3BEaWZmcyIsImFsbFByb3BzIiwia2V5cyIsImkiLCJuZXdWYWx1ZSIsImN1cnJlbnRWYWx1ZSIsIm1pc3NpbmciLCJleHRyYSIsImRpZmZlcmVudCIsIm9yaWdpbmFsIiwibGF0ZXN0IiwiZGVzY3JpYmVEaWZmZXJlbmNlc0ZvclN0eWxlc2hlZXRzIiwiZGlmZiIsImRlc2NyaXB0aW9uIiwicHJvcFZhbHVlIiwiX3Byb3BOYW1lIiwiX3Byb3BWYWx1ZSIsIl9wcm9wTmFtZTIiLCJsYXRlc3RWYWx1ZSIsIm9yaWdpbmFsVmFsdWUiLCJkZXNjcmliZURpZmZlcmVuY2VzRm9yU3R5bGVzaGVldE92ZXJQcmVpbml0IiwiX3Byb3BOYW1lMyIsImRlc2NyaWJlRGlmZmVyZW5jZXNGb3JQcmVpbml0T3ZlclN0eWxlc2hlZXQiLCJfcHJvcE5hbWU0IiwiX3Byb3BWYWx1ZTIiLCJfcHJvcE5hbWU1IiwiZGVzY3JpYmVEaWZmZXJlbmNlc0ZvclByZWluaXRzIiwiX3Byb3BOYW1lNiIsIl9wcm9wVmFsdWUzIiwiX3Byb3BOYW1lNyIsInByZWxvYWRPcHRpb25zRm9yQ29tcGFyaXNvbiIsImRlc2NyaWJlRGlmZmVyZW5jZXNGb3JQcmVsb2FkcyIsImluY2x1ZGVzIiwiX3Byb3BOYW1lOCIsIl9wcm9wVmFsdWU0IiwiX3Byb3BOYW1lOSIsImRlc2NyaWJlRGlmZmVyZW5jZXNGb3JQcmVsb2FkT3ZlckltcGxpY2l0UHJlbG9hZCIsIl9wcm9wTmFtZTEwIiwiX3Byb3BWYWx1ZTUiLCJfcHJvcE5hbWUxMSIsImRlc2NyaWJlRGlmZmVyZW5jZXNGb3JTY3JpcHRzIiwiX3Byb3BOYW1lMTIiLCJfcHJvcFZhbHVlNiIsIl9wcm9wTmFtZTEzIiwiZGVzY3JpYmVEaWZmZXJlbmNlc0ZvclNjcmlwdE92ZXJQcmVpbml0IiwiX3Byb3BOYW1lMTQiLCJkZXNjcmliZURpZmZlcmVuY2VzRm9yUHJlaW5pdE92ZXJTY3JpcHQiLCJfcHJvcE5hbWUxNSIsIlJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzIiwiUmVhY3RET01DdXJyZW50RGlzcGF0Y2hlciIsIkRpc3BhdGNoZXIiLCJSZWFjdERPTVNlcnZlckRpc3BhdGNoZXIiLCJwcmVmZXRjaEROUyIsInByZWNvbm5lY3QiLCJwcmVpbml0IiwicHJlcGFyZUhvc3REaXNwYXRjaGVyIiwiY3VycmVudCIsIlNjcmlwdFN0cmVhbWluZ0Zvcm1hdCIsIkRhdGFTdHJlYW1pbmdGb3JtYXQiLCJOb3RoaW5nU2VudCIsIlNlbnRDb21wbGV0ZVNlZ21lbnRGdW5jdGlvbiIsIlNlbnRDb21wbGV0ZUJvdW5kYXJ5RnVuY3Rpb24iLCJTZW50Q2xpZW50UmVuZGVyRnVuY3Rpb24iLCJTZW50U3R5bGVJbnNlcnRpb25GdW5jdGlvbiIsImRhdGFFbGVtZW50UXVvdGVkRW5kIiwic3RhcnRJbmxpbmVTY3JpcHQiLCJlbmRJbmxpbmVTY3JpcHQiLCJzdGFydFNjcmlwdFNyYyIsInN0YXJ0TW9kdWxlU3JjIiwic2NyaXB0Tm9uY2UiLCJzY3JpcHRJbnRlZ2lydHkiLCJzY3JpcHRDcm9zc09yaWdpbiIsImVuZEFzeW5jU2NyaXB0IiwiZXNjYXBlQm9vdHN0cmFwU2NyaXB0Q29udGVudCIsInNjcmlwdFRleHQiLCJzY3JpcHRSZWdleCIsInNjcmlwdFJlcGxhY2VyIiwicyIsInN1ZmZpeCIsImNyZWF0ZVJlc3BvbnNlU3RhdGUiLCJyZXNvdXJjZXMiLCJpZGVudGlmaWVyUHJlZml4IiwiYm9vdHN0cmFwU2NyaXB0Q29udGVudCIsImJvb3RzdHJhcFNjcmlwdHMiLCJib290c3RyYXBNb2R1bGVzIiwiZXh0ZXJuYWxSdW50aW1lQ29uZmlnIiwiaWRQcmVmaXgiLCJpbmxpbmVTY3JpcHRXaXRoTm9uY2UiLCJib290c3RyYXBDaHVua3MiLCJleHRlcm5hbFJ1bnRpbWVTY3JpcHQiLCJzdHJlYW1pbmdGb3JtYXQiLCJjaHVua3MiLCJwdXNoU2NyaXB0SW1wbCIsInNjcmlwdENvbmZpZyIsImNyb3NzT3JpZ2luIiwicHJlbG9hZEJvb3RzdHJhcFNjcmlwdCIsIl9pIiwiX3NjcmlwdENvbmZpZyIsIl9zcmMiLCJfaW50ZWdyaXR5IiwiX2Nyb3NzT3JpZ2luIiwicHJlbG9hZEJvb3RzdHJhcE1vZHVsZSIsInBsYWNlaG9sZGVyUHJlZml4Iiwic2VnbWVudFByZWZpeCIsImJvdW5kYXJ5UHJlZml4IiwibmV4dFN1c3BlbnNlSUQiLCJpbnN0cnVjdGlvbnMiLCJodG1sQ2h1bmtzIiwiaGVhZENodW5rcyIsImhhc0JvZHkiLCJjaGFyc2V0Q2h1bmtzIiwicHJlY29ubmVjdENodW5rcyIsInByZWxvYWRDaHVua3MiLCJob2lzdGFibGVDaHVua3MiLCJzdHlsZXNUb0hvaXN0IiwiUk9PVF9IVE1MX01PREUiLCJIVE1MX0hUTUxfTU9ERSIsIkhUTUxfTU9ERSIsIlNWR19NT0RFIiwiTUFUSE1MX01PREUiLCJIVE1MX1RBQkxFX01PREUiLCJIVE1MX1RBQkxFX0JPRFlfTU9ERSIsIkhUTUxfVEFCTEVfUk9XX01PREUiLCJIVE1MX0NPTEdST1VQX01PREUiLCJjcmVhdGVGb3JtYXRDb250ZXh0IiwiaW5zZXJ0aW9uTW9kZSIsInNlbGVjdGVkVmFsdWUiLCJub3NjcmlwdFRhZ0luU2NvcGUiLCJjcmVhdGVSb290Rm9ybWF0Q29udGV4dCIsIm5hbWVzcGFjZVVSSSIsImdldENoaWxkRm9ybWF0Q29udGV4dCIsInBhcmVudENvbnRleHQiLCJkZWZhdWx0VmFsdWUiLCJVTklOSVRJQUxJWkVEX1NVU1BFTlNFX0JPVU5EQVJZX0lEIiwiYXNzaWduU3VzcGVuc2VCb3VuZGFyeUlEIiwicmVzcG9uc2VTdGF0ZSIsImdlbmVyYXRlZElEIiwidG9TdHJpbmciLCJtYWtlSWQiLCJ0cmVlSWQiLCJsb2NhbElkIiwiZW5jb2RlSFRNTFRleHROb2RlIiwidGV4dFNlcGFyYXRvciIsInB1c2hUZXh0SW5zdGFuY2UiLCJ0ZXh0RW1iZWRkZWQiLCJwdXNoU2VnbWVudEZpbmFsZSIsImxhc3RQdXNoZWRUZXh0Iiwic3R5bGVOYW1lQ2FjaGUiLCJwcm9jZXNzU3R5bGVOYW1lIiwic3R5bGVOYW1lIiwic3R5bGVBdHRyaWJ1dGVTdGFydCIsInN0eWxlQXNzaWduIiwic3R5bGVTZXBhcmF0b3IiLCJwdXNoU3R5bGVBdHRyaWJ1dGUiLCJFcnJvciIsImlzRmlyc3QiLCJzdHlsZVZhbHVlIiwibmFtZUNodW5rIiwidmFsdWVDaHVuayIsImlzQ3VzdG9tUHJvcGVydHkiLCJ0cmltIiwiYXR0cmlidXRlRW5kIiwiYXR0cmlidXRlU2VwYXJhdG9yIiwiYXR0cmlidXRlQXNzaWduIiwiYXR0cmlidXRlRW1wdHlTdHJpbmciLCJwdXNoQm9vbGVhbkF0dHJpYnV0ZSIsInB1c2hTdHJpbmdBdHRyaWJ1dGUiLCJzdGFydEhpZGRlbklucHV0Q2h1bmsiLCJwdXNoQWRkaXRpb25hbEZvcm1GaWVsZCIsImVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyIsInB1c2hBZGRpdGlvbmFsRm9ybUZpZWxkcyIsImZvcm1EYXRhIiwiZm9yRWFjaCIsInB1c2hGb3JtQWN0aW9uQXR0cmlidXRlIiwiZm9ybUFjdGlvbiIsImZvcm1FbmNUeXBlIiwiZm9ybU1ldGhvZCIsImZvcm1UYXJnZXQiLCJwdXNoQXR0cmlidXRlIiwic2FuaXRpemVkVmFsdWUiLCJfc2FuaXRpemVkVmFsdWUiLCJlbmRPZlN0YXJ0VGFnIiwicHVzaElubmVySFRNTCIsImlubmVySFRNTCIsIl9faHRtbCIsImRpZFdhcm5EZWZhdWx0SW5wdXRWYWx1ZSIsImRpZFdhcm5EZWZhdWx0Q2hlY2tlZCIsImRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUiLCJkaWRXYXJuRGVmYXVsdFRleHRhcmVhVmFsdWUiLCJkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuIiwiZGlkV2FybkludmFsaWRPcHRpb25Jbm5lckhUTUwiLCJkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiIsImRpZFdhcm5Gb3JtQWN0aW9uVHlwZSIsImNoZWNrU2VsZWN0UHJvcCIsImFycmF5IiwicHVzaFN0YXJ0U2VsZWN0Iiwic3RhcnRDaHVua0ZvclRhZyIsInByb3BLZXkiLCJmbGF0dGVuT3B0aW9uQ2hpbGRyZW4iLCJDaGlsZHJlbiIsImNoaWxkIiwic2VsZWN0ZWRNYXJrZXJBdHRyaWJ1dGUiLCJwdXNoU3RhcnRPcHRpb24iLCJmb3JtYXRDb250ZXh0Iiwic3RyaW5nVmFsdWUiLCJ2IiwicHVzaFN0YXJ0Rm9ybSIsInB1c2hJbnB1dCIsImRlZmF1bHRDaGVja2VkIiwicHVzaFN0YXJ0QnV0dG9uIiwicHVzaFN0YXJ0VGV4dEFyZWEiLCJsZWFkaW5nTmV3bGluZSIsInB1c2hNZXRhIiwiaXRlbVByb3AiLCJwdXNoU2VsZkNsb3NpbmciLCJjaGFyU2V0IiwicHVzaExpbmsiLCJwcmVjZWRlbmNlIiwicHVzaExpbmtJbXBsIiwiZ2V0UmVzb3VyY2VLZXkiLCJvbkxvYWQiLCJvbkVycm9yIiwicHJvcERlc2NyaXB0aW9uIiwic3R5bGVzTWFwIiwiZGV2UmVzb3VyY2UiLCJnZXRBc1Jlc291cmNlREVWIiwiX19wcm92ZW5hbmNlIiwiZGlmZmVyZW5jZURlc2NyaXB0aW9uIiwiX19vcmlnaW5hbFByb3BzIiwiX2RpZmZlcmVuY2VEZXNjcmlwdGlvbiIsIl9fcHJvcHNFcXVpdmFsZW50IiwicmVzb3VyY2VQcm9wcyIsInN0eWxlc2hlZXRQcm9wc0Zyb21SYXdQcm9wcyIsInByZWxvYWRSZXNvdXJjZSIsInByZWxvYWRzTWFwIiwic3RhdGUiLCJOb1N0YXRlIiwiQmxvY2tlZCIsImFkb3B0UHJlbG9hZFByb3BzRm9yU3R5bGVzaGVldFByb3BzIiwiRmx1c2hlZCIsIlByZWxvYWRGbHVzaGVkIiwibWFya0FzUmVuZGVyZWRSZXNvdXJjZURFViIsInByZWNlZGVuY2VTZXQiLCJwcmVjZWRlbmNlcyIsImVtcHR5U3R5bGVSZXNvdXJjZSIsImhyZWZzIiwic3R5bGVQcmVjZWRlbmNlcyIsImJvdW5kYXJ5UmVzb3VyY2VzIiwicHVzaFN0eWxlIiwiY2hpbGRUeXBlIiwicHVzaFN0eWxlSW1wbCIsInB1c2hTdHlsZUNvbnRlbnRzIiwiZW5kVGFnMSIsImVuZFRhZzIiLCJnZXRJbWFnZVByZWxvYWRLZXkiLCJpbWFnZVNyY1NldCIsImltYWdlU2l6ZXMiLCJ1bmlxdWVQYXJ0IiwicHVzaEltZyIsInNyY1NldCIsImxvYWRpbmciLCJmZXRjaFByaW9yaXR5IiwicmVmZXJyZXJQb2xpY3kiLCJoaWdoSW1hZ2VQcmVsb2FkcyIsImJ1bGtQcmVsb2FkcyIsInRhZyIsInB1c2hTdGFydE1lbnVJdGVtIiwicHVzaFRpdGxlIiwiJCR0eXBlb2YiLCJwdXNoVGl0bGVJbXBsIiwicHVzaFN0YXJ0SGVhZCIsInB1c2hTdGFydEdlbmVyaWNFbGVtZW50IiwicHVzaFN0YXJ0SHRtbCIsIkRPQ1RZUEUiLCJwdXNoU2NyaXB0IiwiYXN5bmNQcm9wIiwic2NyaXB0c01hcCIsIl9kaWZmZXJlbmNlRGVzY3JpcHRpb24yIiwic2NyaXB0cyIsInNjcmlwdFByb3BzIiwiYWRvcHRQcmVsb2FkUHJvcHNGb3JTY3JpcHRQcm9wcyIsImRlc2NyaXB0aXZlU3RhdGVtZW50IiwicHVzaFN0YXJ0Q3VzdG9tRWxlbWVudCIsInB1c2hTdGFydFByZWZvcm1hdHRlZEVsZW1lbnQiLCJWQUxJRF9UQUdfUkVHRVgiLCJ2YWxpZGF0ZWRUYWdDYWNoZSIsInRhZ1N0YXJ0Q2h1bmsiLCJwdXNoU3RhcnRJbnN0YW5jZSIsInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyIsImNvbnRlbnRFZGl0YWJsZSIsInB1c2hFbmRJbnN0YW5jZSIsIndyaXRlQm9vdHN0cmFwIiwibGFzdENodW5rIiwid3JpdGVDb21wbGV0ZWRSb290IiwicGxhY2Vob2xkZXIxIiwicGxhY2Vob2xkZXIyIiwid3JpdGVQbGFjZWhvbGRlciIsImZvcm1hdHRlZElEIiwic3RhcnRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5Iiwic3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTEiLCJzdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5MiIsInN0YXJ0Q2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5IiwiZW5kU3VzcGVuc2VCb3VuZGFyeSIsImNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMSIsImNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yQXR0ckludGVyc3RpdGlhbCIsImNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUEiLCJjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFCIiwiY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQyIsImNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMiIsIndyaXRlU3RhcnRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5Iiwid3JpdGVTdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5Iiwid3JpdGVTdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSIsImVycm9yRGlnZXN0IiwiZXJyb3JNZXNzc2FnZSIsImVycm9yQ29tcG9uZW50U3RhY2siLCJ3cml0ZUVuZENvbXBsZXRlZFN1c3BlbnNlQm91bmRhcnkiLCJ3cml0ZUVuZFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5Iiwid3JpdGVFbmRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkiLCJzdGFydFNlZ21lbnRIVE1MIiwic3RhcnRTZWdtZW50SFRNTDIiLCJlbmRTZWdtZW50SFRNTCIsInN0YXJ0U2VnbWVudFNWRyIsInN0YXJ0U2VnbWVudFNWRzIiLCJlbmRTZWdtZW50U1ZHIiwic3RhcnRTZWdtZW50TWF0aE1MIiwic3RhcnRTZWdtZW50TWF0aE1MMiIsImVuZFNlZ21lbnRNYXRoTUwiLCJzdGFydFNlZ21lbnRUYWJsZSIsInN0YXJ0U2VnbWVudFRhYmxlMiIsImVuZFNlZ21lbnRUYWJsZSIsInN0YXJ0U2VnbWVudFRhYmxlQm9keSIsInN0YXJ0U2VnbWVudFRhYmxlQm9keTIiLCJlbmRTZWdtZW50VGFibGVCb2R5Iiwic3RhcnRTZWdtZW50VGFibGVSb3ciLCJzdGFydFNlZ21lbnRUYWJsZVJvdzIiLCJlbmRTZWdtZW50VGFibGVSb3ciLCJzdGFydFNlZ21lbnRDb2xHcm91cCIsInN0YXJ0U2VnbWVudENvbEdyb3VwMiIsImVuZFNlZ21lbnRDb2xHcm91cCIsIndyaXRlU3RhcnRTZWdtZW50Iiwid3JpdGVFbmRTZWdtZW50IiwiY29tcGxldGVTZWdtZW50U2NyaXB0MUZ1bGwiLCJjb21wbGV0ZVNlZ21lbnRTY3JpcHQxUGFydGlhbCIsImNvbXBsZXRlU2VnbWVudFNjcmlwdDIiLCJjb21wbGV0ZVNlZ21lbnRTY3JpcHRFbmQiLCJjb21wbGV0ZVNlZ21lbnREYXRhMSIsImNvbXBsZXRlU2VnbWVudERhdGEyIiwiY29tcGxldGVTZWdtZW50RGF0YUVuZCIsIndyaXRlQ29tcGxldGVkU2VnbWVudEluc3RydWN0aW9uIiwiY29udGVudFNlZ21lbnRJRCIsInNjcmlwdEZvcm1hdCIsImNvbXBsZXRlQm91bmRhcnlTY3JpcHQxRnVsbCIsImNvbXBsZXRlQm91bmRhcnlTY3JpcHQxUGFydGlhbCIsImNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MUZ1bGxCb3RoIiwiY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNTY3JpcHQxRnVsbFBhcnRpYWwiLCJjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFQYXJ0aWFsIiwiY29tcGxldGVCb3VuZGFyeVNjcmlwdDIiLCJjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0M2EiLCJjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0M2IiLCJjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0RW5kIiwiY29tcGxldGVCb3VuZGFyeURhdGExIiwiY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNEYXRhMSIsImNvbXBsZXRlQm91bmRhcnlEYXRhMiIsImNvbXBsZXRlQm91bmRhcnlEYXRhM2EiLCJjb21wbGV0ZUJvdW5kYXJ5RGF0YUVuZCIsIndyaXRlQ29tcGxldGVkQm91bmRhcnlJbnN0cnVjdGlvbiIsImJvdW5kYXJ5SUQiLCJyZXF1aXJlc1N0eWxlSW5zZXJ0aW9uIiwiZm9ybWF0dGVkQ29udGVudElEIiwid3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jaWVzSW5KUyIsIndyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY2llc0luQXR0ciIsIndyaXRlTW9yZSIsImNsaWVudFJlbmRlclNjcmlwdDFGdWxsIiwiY2xpZW50UmVuZGVyU2NyaXB0MVBhcnRpYWwiLCJjbGllbnRSZW5kZXJTY3JpcHQxQSIsImNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsIiwiY2xpZW50UmVuZGVyU2NyaXB0RW5kIiwiY2xpZW50UmVuZGVyRGF0YTEiLCJjbGllbnRSZW5kZXJEYXRhMiIsImNsaWVudFJlbmRlckRhdGEzIiwiY2xpZW50UmVuZGVyRGF0YTQiLCJjbGllbnRSZW5kZXJEYXRhRW5kIiwid3JpdGVDbGllbnRSZW5kZXJCb3VuZGFyeUluc3RydWN0aW9uIiwiZXJyb3JNZXNzYWdlIiwiZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzIiwicmVnZXhGb3JKU1N0cmluZ3NJbkluc3RydWN0aW9uU2NyaXB0cyIsImlucHV0IiwiZXNjYXBlZCIsInJlZ2V4Rm9ySlNTdHJpbmdzSW5TY3JpcHRzIiwiZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMiLCJsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4xIiwibGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMiIsImxhdGVTdHlsZVRhZ1Jlc291cmNlT3BlbjMiLCJsYXRlU3R5bGVUYWdUZW1wbGF0ZUNsb3NlIiwiY3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlIYXNTdHlsZXNUb0hvaXN0IiwiZGVzdGluYXRpb25IYXNDYXBhY2l0eSIsImZsdXNoU3R5bGVUYWdzTGF0ZUZvckJvdW5kYXJ5IiwiRmx1c2hlZEluUHJlYW1ibGUiLCJzcGFjZVNlcGFyYXRvciIsIndyaXRlUmVzb3VyY2VzRm9yQm91bmRhcnkiLCJmbHVzaFJlc291cmNlSW5QcmVhbWJsZSIsImZsdXNoUmVzb3VyY2VMYXRlIiwiRmx1c2hlZExhdGUiLCJwcmVjZWRlbmNlU3R5bGVUYWdSZXNvdXJjZSIsImRpZEZsdXNoUHJlY2VkZW5jZSIsImZsdXNoU3R5bGVJblByZWFtYmxlIiwiZGVsZXRlIiwic3R5bGVUYWdSZXNvdXJjZU9wZW4xIiwic3R5bGVUYWdSZXNvdXJjZU9wZW4yIiwic3R5bGVUYWdSZXNvdXJjZU9wZW4zIiwic3R5bGVUYWdSZXNvdXJjZUNsb3NlIiwiZmx1c2hBbGxTdHlsZXNJblByZWFtYmxlIiwiY2xlYXIiLCJwcmVsb2FkTGF0ZVN0eWxlIiwicHJlbG9hZFByb3BzIiwicHJlbG9hZEFzU3R5bGVQcm9wc0Zyb21Qcm9wcyIsInByZWxvYWRMYXRlU3R5bGVzIiwid3JpdGVQcmVhbWJsZSIsIndpbGxGbHVzaEFsbFNlZ21lbnRzIiwiX3Jlc3BvbnNlU3RhdGUkZXh0ZXJuIiwiaW50ZXJuYWxQcmVpbml0U2NyaXB0IiwicHJlY29ubmVjdHMiLCJmb250UHJlbG9hZHMiLCJ3cml0ZUhvaXN0YWJsZXMiLCJ3cml0ZVBvc3RhbWJsZSIsImFycmF5Rmlyc3RPcGVuQnJhY2tldCIsImFycmF5U3Vic2VxdWVudE9wZW5CcmFja2V0IiwiYXJyYXlJbnRlcnN0aXRpYWwiLCJhcnJheUNsb3NlQnJhY2tldCIsIm5leHRBcnJheU9wZW5CcmFja0NodW5rIiwid3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jeUhyZWZPbmx5SW5KUyIsIndyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY3lJbkpTIiwiY29lcmNlZEhyZWYiLCJjb2VyY2VkUHJlY2VkZW5jZSIsIndyaXRlU3R5bGVSZXNvdXJjZUF0dHJpYnV0ZUluSlMiLCJhdHRyaWJ1dGVWYWx1ZSIsIndyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY3lIcmVmT25seUluQXR0ciIsIndyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY3lJbkF0dHIiLCJ3cml0ZVN0eWxlUmVzb3VyY2VBdHRyaWJ1dGVJbkF0dHIiLCJjcmVhdGVSZXNvdXJjZXMiLCJwcmVjb25uZWN0c01hcCIsImNyZWF0ZUJvdW5kYXJ5UmVzb3VyY2VzIiwic2V0Q3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlSZXNvdXJjZXNUYXJnZXQiLCJvcHRpb25zIiwicmVxdWVzdCIsInJlc29sdmVSZXF1ZXN0IiwiZ2V0UmVzb3VyY2VzIiwiZmx1c2hSZXNvdXJjZXMiLCJlbmNvdW50ZXJlZCIsIl9fb3JpZ2luYWxPcHRpb25zIiwiX2RpZmZlcmVuY2VEZXNjcmlwdGlvbjMiLCJfX2ltcGxpZWRQcm9wcyIsImVsZW1lbnREZXNjcmlwdGlvbiIsInByZWxvYWRQcm9wc0Zyb21QcmVsb2FkT3B0aW9ucyIsIm1hcmtBc0ltcGVyYXRpdmVSZXNvdXJjZURFViIsInN0eWxlc2hlZXRQcm9wc0Zyb21QcmVpbml0T3B0aW9ucyIsInByb3BzRXF1aXZhbGVudCIsIl9kaWZmZXJlbmNlRGVzY3JpcHRpb240IiwiX3Jlc291cmNlIiwiX2RldlJlc291cmNlIiwiX3Byb3BzRXF1aXZhbGVudCIsInNjcmlwdFByb3BzRnJvbVByZWluaXRPcHRpb25zIiwiX2RpZmZlcmVuY2VEZXNjcmlwdGlvbjUiLCJfZGlmZmVyZW5jZURlc2NyaXB0aW9uNiIsIl9yZXNvdXJjZVByb3BzIiwiaHJlZkxhbmciLCJyYXdQcm9wcyIsImhvaXN0U3R5bGVSZXNvdXJjZSIsImhvaXN0UmVzb3VyY2VzIiwic291cmNlIiwiY3VycmVudEJvdW5kYXJ5UmVzb3VyY2VzIiwib3JpZ2luYWxQcm9wcyIsInByb3ZlbmFuY2UiLCJvcmlnaW5hbEhyZWYiLCJvcmlnaW5hbE9wdGlvbnMiLCJfX29yaWdpbmFsSHJlZiIsInJlcXVlc3RTdG9yYWdlIiwiQXN5bmNMb2NhbFN0b3JhZ2UiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUiLCJSRUFDVF9NRU1PX1RZUEUiLCJSRUFDVF9MQVpZX1RZUEUiLCJSRUFDVF9TQ09QRV9UWVBFIiwiUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUiLCJSRUFDVF9PRkZTQ1JFRU5fVFlQRSIsIlJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSIsIlJFQUNUX0NBQ0hFX1RZUEUiLCJSRUFDVF9TRVJWRVJfQ09OVEVYVF9ERUZBVUxUX1ZBTFVFX05PVF9MT0FERUQiLCJNQVlCRV9JVEVSQVRPUl9TWU1CT0wiLCJpdGVyYXRvciIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwiZ2V0SXRlcmF0b3JGbiIsIm1heWJlSXRlcmFibGUiLCJtYXliZUl0ZXJhdG9yIiwiZ2V0V3JhcHBlZE5hbWUiLCJvdXRlclR5cGUiLCJpbm5lclR5cGUiLCJ3cmFwcGVyTmFtZSIsImRpc3BsYXlOYW1lIiwiZnVuY3Rpb25OYW1lIiwiZ2V0Q29udGV4dE5hbWUiLCJnZXRDb21wb25lbnROYW1lRnJvbVR5cGUiLCJjb250ZXh0IiwicHJvdmlkZXIiLCJfY29udGV4dCIsInJlbmRlciIsIm91dGVyTmFtZSIsImxhenlDb21wb25lbnQiLCJwYXlsb2FkIiwiX3BheWxvYWQiLCJpbml0IiwiX2luaXQiLCJjb250ZXh0MiIsIl9nbG9iYWxOYW1lIiwiZGlzYWJsZWREZXB0aCIsInByZXZMb2ciLCJwcmV2SW5mbyIsInByZXZXYXJuIiwicHJldkVycm9yIiwicHJldkdyb3VwIiwicHJldkdyb3VwQ29sbGFwc2VkIiwicHJldkdyb3VwRW5kIiwiZGlzYWJsZWRMb2ciLCJfX3JlYWN0RGlzYWJsZWRMb2ciLCJkaXNhYmxlTG9ncyIsImxvZyIsImluZm8iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicmVlbmFibGVMb2dzIiwiUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxIiwiUmVhY3RDdXJyZW50RGlzcGF0Y2hlciIsImRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lIiwib3duZXJGbiIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwiV2Vha01hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwiY29udHJvbCIsInByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UiLCJwcmVwYXJlU3RhY2tUcmFjZSIsInByZXZpb3VzRGlzcGF0Y2hlciIsIkZha2UiLCJSZWZsZWN0IiwibWF5YmVQcm9taXNlIiwiY2F0Y2giLCJzYW1wbGUiLCJzYW1wbGVMaW5lcyIsInNwbGl0IiwiY29udHJvbExpbmVzIiwiYyIsIl9mcmFtZSIsInN5bnRoZXRpY0ZyYW1lIiwiZGVzY3JpYmVDbGFzc0NvbXBvbmVudEZyYW1lIiwiY3RvciIsImRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSIsInNob3VsZENvbnN0cnVjdCQxIiwiQ29tcG9uZW50IiwiaXNSZWFjdENvbXBvbmVudCIsImRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFViIsImxvZ2dlZFR5cGVGYWlsdXJlcyIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSIsInNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50IiwiZWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJ3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQiLCJlbXB0eUNvbnRleHRPYmplY3QiLCJmcmVlemUiLCJnZXRNYXNrZWRDb250ZXh0IiwidW5tYXNrZWRDb250ZXh0IiwiY29udGV4dFR5cGVzIiwicHJvY2Vzc0NoaWxkQ29udGV4dCIsImluc3RhbmNlIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJnZXRDaGlsZENvbnRleHQiLCJjaGlsZENvbnRleHQiLCJjb250ZXh0S2V5IiwicmVuZGVyZXJTaWdpbCIsInJvb3RDb250ZXh0U25hcHNob3QiLCJjdXJyZW50QWN0aXZlU25hcHNob3QiLCJwb3BOb2RlIiwicHJldiIsIl9jdXJyZW50VmFsdWUiLCJwYXJlbnRWYWx1ZSIsInB1c2hOb2RlIiwibmV4dCIsInBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yIiwicGFyZW50UHJldiIsInBhcmVudCIsInBhcmVudE5leHQiLCJwb3BBbGxQcmV2aW91cyIsInB1c2hBbGxOZXh0IiwicG9wUHJldmlvdXNUb0NvbW1vbkxldmVsIiwiZGVwdGgiLCJwb3BOZXh0VG9Db21tb25MZXZlbCIsInN3aXRjaENvbnRleHQiLCJuZXdTbmFwc2hvdCIsInB1c2hQcm92aWRlciIsIm5leHRWYWx1ZSIsInByZXZWYWx1ZSIsIl9jdXJyZW50UmVuZGVyZXIiLCJwcmV2Tm9kZSIsIm5ld05vZGUiLCJwb3BQcm92aWRlciIsInByZXZTbmFwc2hvdCIsIl9kZWZhdWx0VmFsdWUiLCJnZXRBY3RpdmVDb250ZXh0IiwicmVhZENvbnRleHQkMSIsIl9yZWFjdEludGVybmFscyIsImRpZFdhcm5BYm91dE5vb3BVcGRhdGVGb3JDb21wb25lbnQiLCJkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50IiwiZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlIiwiZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlIiwiZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZSIsImRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSIsImRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlIiwiZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMiLCJkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUiLCJkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2siLCJ3YXJuT25JbnZhbGlkQ2FsbGJhY2siLCJjYWxsZXJOYW1lIiwid2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlIiwicGFydGlhbFN0YXRlIiwid2Fybk5vb3AiLCJwdWJsaWNJbnN0YW5jZSIsIl9jb25zdHJ1Y3RvciIsIndhcm5pbmdLZXkiLCJjbGFzc0NvbXBvbmVudFVwZGF0ZXIiLCJpc01vdW50ZWQiLCJpbnN0IiwiZW5xdWV1ZVNldFN0YXRlIiwiaW50ZXJuYWxzIiwicXVldWUiLCJlbnF1ZXVlUmVwbGFjZVN0YXRlIiwiZW5xdWV1ZUZvcmNlVXBkYXRlIiwiYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJwcmV2U3RhdGUiLCJuZXh0UHJvcHMiLCJuZXdTdGF0ZSIsImNvbnN0cnVjdENsYXNzSW5zdGFuY2UiLCJtYXNrZWRMZWdhY3lDb250ZXh0IiwiY29udGV4dFR5cGUiLCJhZGRlbmR1bSIsImdldFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiZm91bmRXaWxsTW91bnROYW1lIiwiZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSIsImZvdW5kV2lsbFVwZGF0ZU5hbWUiLCJjb21wb25lbnRXaWxsTW91bnQiLCJfX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudFdpbGxVcGRhdGUiLCJVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSIsIl9jb21wb25lbnROYW1lIiwibmV3QXBpTmFtZSIsImNoZWNrQ2xhc3NJbnN0YW5jZSIsInJlbmRlclByZXNlbnQiLCJnZXRJbml0aWFsU3RhdGUiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsImdldERlZmF1bHRQcm9wcyIsInByb3BUeXBlcyIsImNvbXBvbmVudFNob3VsZFVwZGF0ZSIsImlzUHVyZVJlYWN0Q29tcG9uZW50Iiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwiY29tcG9uZW50RGlkVW5tb3VudCIsImNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsImhhc011dGF0ZWRQcm9wcyIsImRlZmF1bHRQcm9wcyIsImNvbXBvbmVudERpZFVwZGF0ZSIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsImNhbGxDb21wb25lbnRXaWxsTW91bnQiLCJvbGRTdGF0ZSIsInByb2Nlc3NVcGRhdGVRdWV1ZSIsImludGVybmFsSW5zdGFuY2UiLCJvbGRRdWV1ZSIsIm9sZFJlcGxhY2UiLCJuZXh0U3RhdGUiLCJkb250TXV0YXRlIiwicGFydGlhbCIsIm1vdW50Q2xhc3NJbnN0YW5jZSIsImluaXRpYWxTdGF0ZSIsInVwZGF0ZXIiLCJlbXB0eVRyZWVDb250ZXh0IiwiZ2V0VHJlZUlkIiwiaWRXaXRoTGVhZGluZ0JpdCIsImdldExlYWRpbmdCaXQiLCJwdXNoVHJlZUNvbnRleHQiLCJiYXNlQ29udGV4dCIsInRvdGFsQ2hpbGRyZW4iLCJiYXNlSWRXaXRoTGVhZGluZ0JpdCIsImJhc2VPdmVyZmxvdyIsImJhc2VMZW5ndGgiLCJnZXRCaXRMZW5ndGgiLCJiYXNlSWQiLCJzbG90IiwibnVtYmVyT2ZPdmVyZmxvd0JpdHMiLCJuZXdPdmVyZmxvd0JpdHMiLCJuZXdPdmVyZmxvdyIsInJlc3RPZkJhc2VJZCIsInJlc3RPZkJhc2VMZW5ndGgiLCJyZXN0T2ZMZW5ndGgiLCJyZXN0T2ZOZXdCaXRzIiwibmV3Qml0cyIsIl9pZCIsIl9vdmVyZmxvdyIsIm51bWJlciIsImNsejMyIiwiTWF0aCIsImNsejMyRmFsbGJhY2siLCJMTjIiLCJhc1VpbnQiLCJTdXNwZW5zZUV4Y2VwdGlvbiIsImNyZWF0ZVRoZW5hYmxlU3RhdGUiLCJub29wJDIiLCJ0cmFja1VzZWRUaGVuYWJsZSIsInRoZW5hYmxlU3RhdGUiLCJ0aGVuYWJsZSIsInByZXZpb3VzIiwidGhlbiIsInN0YXR1cyIsImZ1bGZpbGxlZFZhbHVlIiwicmVqZWN0ZWRFcnJvciIsInJlYXNvbiIsInBlbmRpbmdUaGVuYWJsZSIsImZ1bGZpbGxlZFRoZW5hYmxlIiwicmVqZWN0ZWRUaGVuYWJsZSIsInN1c3BlbmRlZFRoZW5hYmxlIiwiZ2V0U3VzcGVuZGVkVGhlbmFibGUiLCJvYmplY3RJcyIsImN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCIsImN1cnJlbnRseVJlbmRlcmluZ1Rhc2siLCJmaXJzdFdvcmtJblByb2dyZXNzSG9vayIsIndvcmtJblByb2dyZXNzSG9vayIsImlzUmVSZW5kZXIiLCJkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlIiwibG9jYWxJZENvdW50ZXIiLCJ0aGVuYWJsZUluZGV4Q291bnRlciIsInJlbmRlclBoYXNlVXBkYXRlcyIsIm51bWJlck9mUmVSZW5kZXJzIiwiUkVfUkVOREVSX0xJTUlUIiwiaXNJbkhvb2tVc2VyQ29kZUluRGV2IiwiY3VycmVudEhvb2tOYW1lSW5EZXYiLCJyZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50IiwiYXJlSG9va0lucHV0c0VxdWFsIiwibmV4dERlcHMiLCJwcmV2RGVwcyIsImNyZWF0ZUhvb2siLCJtZW1vaXplZFN0YXRlIiwiY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rIiwicHJlcGFyZVRvVXNlSG9va3MiLCJ0YXNrIiwiY29tcG9uZW50SWRlbnRpdHkiLCJwcmV2VGhlbmFibGVTdGF0ZSIsImZpbmlzaEhvb2tzIiwicmVmT3JDb250ZXh0IiwicmVzZXRIb29rc1N0YXRlIiwiZ2V0VGhlbmFibGVTdGF0ZUFmdGVyU3VzcGVuZGluZyIsImNoZWNrRGlkUmVuZGVySWRIb29rIiwiZGlkUmVuZGVySWRIb29rIiwicmVhZENvbnRleHQiLCJ1c2VDb250ZXh0IiwiYmFzaWNTdGF0ZVJlZHVjZXIiLCJ1c2VTdGF0ZSIsInVzZVJlZHVjZXIiLCJyZWR1Y2VyIiwiaW5pdGlhbEFyZyIsImRpc3BhdGNoIiwiZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSIsInVwZGF0ZSIsIl9xdWV1ZSIsImxhc3QiLCJfZGlzcGF0Y2giLCJkaXNwYXRjaEFjdGlvbiIsInVzZU1lbW8iLCJuZXh0Q3JlYXRlIiwiZGVwcyIsInVzZVJlZiIsImluaXRpYWxWYWx1ZSIsInByZXZpb3VzUmVmIiwicmVmIiwic2VhbCIsImxhc3RSZW5kZXJQaGFzZVVwZGF0ZSIsInVzZUNhbGxiYWNrIiwidXNlU3luY0V4dGVybmFsU3RvcmUiLCJzdWJzY3JpYmUiLCJnZXRTbmFwc2hvdCIsImdldFNlcnZlclNuYXBzaG90IiwidXNlRGVmZXJyZWRWYWx1ZSIsInVuc3VwcG9ydGVkU3RhcnRUcmFuc2l0aW9uIiwidXNlVHJhbnNpdGlvbiIsInVzZUlkIiwidHJlZUNvbnRleHQiLCJjdXJyZW50UmVzcG9uc2VTdGF0ZSIsInVzZSIsInVzYWJsZSIsInVud3JhcFRoZW5hYmxlIiwidW5zdXBwb3J0ZWRSZWZyZXNoIiwidXNlQ2FjaGVSZWZyZXNoIiwibm9vcCQxIiwiSG9va3NEaXNwYXRjaGVyIiwidXNlSW5zZXJ0aW9uRWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsInVzZUVmZmVjdCIsInVzZURlYnVnVmFsdWUiLCJzZXRDdXJyZW50UmVzcG9uc2VTdGF0ZSIsImdldENhY2hlU2lnbmFsIiwiZ2V0Q2FjaGVGb3JUeXBlIiwicmVzb3VyY2VUeXBlIiwiRGVmYXVsdENhY2hlRGlzcGF0Y2hlciIsImdldFN0YWNrQnlDb21wb25lbnRTdGFja05vZGUiLCJjb21wb25lbnRTdGFjayIsIm5vZGUiLCJSZWFjdEN1cnJlbnRDYWNoZSIsIlBFTkRJTkciLCJDT01QTEVURUQiLCJGTFVTSEVEIiwiQUJPUlRFRCIsIkVSUk9SRUQiLCJPUEVOIiwiQ0xPU0lORyIsIkNMT1NFRCIsIkRFRkFVTFRfUFJPR1JFU1NJVkVfQ0hVTktfU0laRSIsImRlZmF1bHRFcnJvckhhbmRsZXIiLCJub29wIiwiY3JlYXRlUmVxdWVzdCIsInJvb3RGb3JtYXRDb250ZXh0IiwicHJvZ3Jlc3NpdmVDaHVua1NpemUiLCJvbkFsbFJlYWR5Iiwib25TaGVsbFJlYWR5Iiwib25TaGVsbEVycm9yIiwib25GYXRhbEVycm9yIiwicGluZ2VkVGFza3MiLCJhYm9ydFNldCIsImZsdXNoU2NoZWR1bGVkIiwiZmF0YWxFcnJvciIsIm5leHRTZWdtZW50SWQiLCJhbGxQZW5kaW5nVGFza3MiLCJwZW5kaW5nUm9vdFRhc2tzIiwiY29tcGxldGVkUm9vdFNlZ21lbnQiLCJhYm9ydGFibGVUYXNrcyIsImNsaWVudFJlbmRlcmVkQm91bmRhcmllcyIsImNvbXBsZXRlZEJvdW5kYXJpZXMiLCJwYXJ0aWFsQm91bmRhcmllcyIsInJvb3RTZWdtZW50IiwiY3JlYXRlUGVuZGluZ1NlZ21lbnQiLCJwYXJlbnRGbHVzaGVkIiwicm9vdFRhc2siLCJjcmVhdGVUYXNrIiwiY3VycmVudFJlcXVlc3QiLCJzdG9yZSIsImdldFN0b3JlIiwicGluZ1Rhc2siLCJwZXJmb3JtV29yayIsImNyZWF0ZVN1c3BlbnNlQm91bmRhcnkiLCJmYWxsYmFja0Fib3J0YWJsZVRhc2tzIiwicm9vdFNlZ21lbnRJRCIsInBlbmRpbmdUYXNrcyIsImZvcmNlQ2xpZW50UmVuZGVyIiwiY29tcGxldGVkU2VnbWVudHMiLCJieXRlU2l6ZSIsImJsb2NrZWRCb3VuZGFyeSIsImJsb2NrZWRTZWdtZW50IiwibGVnYWN5Q29udGV4dCIsInBpbmciLCJib3VuZGFyeSIsImN1cnJlbnRUYXNrSW5ERVYiLCJnZXRDdXJyZW50U3RhY2tJbkRFViIsInB1c2hCdWlsdEluQ29tcG9uZW50U3RhY2tJbkRFViIsInB1c2hGdW5jdGlvbkNvbXBvbmVudFN0YWNrSW5ERVYiLCJwdXNoQ2xhc3NDb21wb25lbnRTdGFja0luREVWIiwicG9wQ29tcG9uZW50U3RhY2tJbkRFViIsImxhc3RCb3VuZGFyeUVycm9yQ29tcG9uZW50U3RhY2tEZXYiLCJjYXB0dXJlQm91bmRhcnlFcnJvckRldGFpbHNEZXYiLCJsb2dSZWNvdmVyYWJsZUVycm9yIiwicmVuZGVyU3VzcGVuc2VCb3VuZGFyeSIsInBhcmVudEJvdW5kYXJ5IiwicGFyZW50U2VnbWVudCIsImZhbGxiYWNrIiwiZmFsbGJhY2tBYm9ydFNldCIsIm5ld0JvdW5kYXJ5IiwiaW5zZXJ0aW9uSW5kZXgiLCJib3VuZGFyeVNlZ21lbnQiLCJjb250ZW50Um9vdFNlZ21lbnQiLCJyZW5kZXJOb2RlIiwicXVldWVDb21wbGV0ZWRTZWdtZW50Iiwic3VzcGVuZGVkRmFsbGJhY2tUYXNrIiwicmVuZGVySG9zdEVsZW1lbnQiLCJzZWdtZW50IiwicHJldkNvbnRleHQiLCJzaG91bGRDb25zdHJ1Y3QiLCJyZW5kZXJXaXRoSG9va3MiLCJzZWNvbmRBcmciLCJmaW5pc2hDbGFzc0NvbXBvbmVudCIsIm5leHRDaGlsZHJlbiIsImRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMiLCJwcmV2aW91c0NvbnRleHQiLCJtZXJnZWRDb250ZXh0IiwicmVuZGVyTm9kZURlc3RydWN0aXZlIiwicmVuZGVyQ2xhc3NDb21wb25lbnQiLCJtYXNrZWRDb250ZXh0IiwiZGlkV2FybkFib3V0QmFkQ2xhc3MiLCJkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50IiwiZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50IiwiZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudCIsImRpZFdhcm5BYm91dERlZmF1bHRQcm9wc09uRnVuY3Rpb25Db21wb25lbnQiLCJkaWRXYXJuQWJvdXRHZW5lcmF0b3JzIiwiZGlkV2FybkFib3V0TWFwcyIsImhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lciIsInJlbmRlckluZGV0ZXJtaW5hdGVDb21wb25lbnQiLCJoYXNJZCIsIl9jb21wb25lbnROYW1lMiIsInZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldiIsInByZXZUcmVlQ29udGV4dCIsIl9jb21wb25lbnROYW1lMyIsIl9jb21wb25lbnROYW1lNCIsInJlc29sdmVEZWZhdWx0UHJvcHMiLCJiYXNlUHJvcHMiLCJyZW5kZXJGb3J3YXJkUmVmIiwicmVuZGVyTWVtbyIsInJlc29sdmVkUHJvcHMiLCJyZW5kZXJFbGVtZW50IiwicmVuZGVyQ29udGV4dENvbnN1bWVyIiwiQ29uc3VtZXIiLCJuZXdDaGlsZHJlbiIsInJlbmRlckNvbnRleHRQcm92aWRlciIsInJlbmRlckxhenlDb21wb25lbnQiLCJyZW5kZXJPZmZzY3JlZW4iLCJ2YWxpZGF0ZUl0ZXJhYmxlIiwiaXRlcmFibGUiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInJlbmRlck5vZGVEZXN0cnVjdGl2ZUltcGwiLCJsYXp5Tm9kZSIsInJlc29sdmVkTm9kZSIsInJlbmRlckNoaWxkcmVuQXJyYXkiLCJkb25lIiwibWF5YmVVc2FibGUiLCJjaGlsZFN0cmluZyIsIl9zZWdtZW50Iiwic3Bhd25OZXdTdXNwZW5kZWRUYXNrIiwibmV3U2VnbWVudCIsIm5ld1Rhc2siLCJjaGlsZHJlbkxlbmd0aCIsImNodW5rTGVuZ3RoIiwicHJldmlvdXNGb3JtYXRDb250ZXh0IiwicHJldmlvdXNMZWdhY3lDb250ZXh0IiwicHJldmlvdXNDb21wb25lbnRTdGFjayIsInRocm93blZhbHVlIiwid2FrZWFibGUiLCJlcnJvcmVkVGFzayIsImFib3J0VGFza1NvZnQiLCJmaW5pc2hlZFRhc2siLCJhYm9ydFRhc2siLCJlcnJvclByZWZpeCIsInByZXZpb3VzVGFza0luRGV2IiwiZmFsbGJhY2tUYXNrIiwiY2hpbGRTZWdtZW50IiwicmV0cnlUYXNrIiwicHJldlRhc2tJbkRFViIsInByZXZEaXNwYXRjaGVyIiwicHJldkNhY2hlRGlzcGF0Y2hlciIsInByZXZSZXF1ZXN0IiwicHJldkdldEN1cnJlbnRTdGFja0ltcGwiLCJnZXRDdXJyZW50U3RhY2siLCJwcmV2UmVzcG9uc2VTdGF0ZSIsInNwbGljZSIsImZsdXNoQ29tcGxldGVkUXVldWVzIiwiZmx1c2hTdWJ0cmVlIiwic2VnbWVudElEIiwiY2h1bmtJZHgiLCJjaGlsZElkeCIsIm5leHRDaGlsZCIsImZsdXNoU2VnbWVudCIsImNvbnRlbnRTZWdtZW50IiwiZmx1c2hDbGllbnRSZW5kZXJlZEJvdW5kYXJ5IiwiZmx1c2hTZWdtZW50Q29udGFpbmVyIiwiZmx1c2hDb21wbGV0ZWRCb3VuZGFyeSIsImZsdXNoUGFydGlhbGx5Q29tcGxldGVkU2VnbWVudCIsImZsdXNoUGFydGlhbEJvdW5kYXJ5IiwiX2JvdW5kYXJ5IiwiX2JvdW5kYXJ5MiIsImxhcmdlQm91bmRhcmllcyIsIl9ib3VuZGFyeTMiLCJzdGFydFdvcmsiLCJydW4iLCJlbnF1ZXVlRmx1c2giLCJzdGFydEZsb3dpbmciLCJhYm9ydCIsImNyZWF0ZURyYWluSGFuZGxlciIsImNyZWF0ZUFib3J0SGFuZGxlciIsImNyZWF0ZVJlcXVlc3RJbXBsIiwidW5zdGFibGVfZXh0ZXJuYWxSdW50aW1lU3JjIiwicmVuZGVyVG9QaXBlYWJsZVN0cmVhbSIsImhhc1N0YXJ0ZWRGbG93aW5nIiwicGlwZSIsIm9uIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server.node.development.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/compiled/react-dom/server-rendering-stub.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-dom/server-rendering-stub.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-dom-server-rendering-stub.development.js */ \"(rsc)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-rendering-stub.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWRvbS9zZXJ2ZXItcmVuZGVyaW5nLXN0dWIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxLQUF5QixFQUFjLEVBRTFDLE1BQU07SUFDTEMsd01BQXlCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2FoZWd1cnUtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtZG9tL3NlcnZlci1yZW5kZXJpbmctc3R1Yi5qcz9kZmFhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20tc2VydmVyLXJlbmRlcmluZy1zdHViLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS1zZXJ2ZXItcmVuZGVyaW5nLXN0dWIuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/compiled/react-dom/server-rendering-stub.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/compiled/react-dom/server.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-dom/server.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = __webpack_require__(/*! ./server.node */ \"(rsc)/./node_modules/next/dist/compiled/react-dom/server.node.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWRvbS9zZXJ2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsNkhBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2FoZWd1cnUtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtZG9tL3NlcnZlci5qcz8xMWEzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NlcnZlci5ub2RlJyk7XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/compiled/react-dom/server.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/compiled/react-dom/server.node.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-dom/server.node.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar l, s;\nif (false) {} else {\n    l = __webpack_require__(/*! ./cjs/react-dom-server-legacy.node.development.js */ \"(rsc)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-legacy.node.development.js\");\n    s = __webpack_require__(/*! ./cjs/react-dom-server.node.development.js */ \"(rsc)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server.node.development.js\");\n}\nexports.version = l.version;\nexports.renderToString = l.renderToString;\nexports.renderToStaticMarkup = l.renderToStaticMarkup;\nexports.renderToNodeStream = l.renderToNodeStream;\nexports.renderToStaticNodeStream = l.renderToStaticNodeStream;\nexports.renderToPipeableStream = s.renderToPipeableStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWRvbS9zZXJ2ZXIubm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLEdBQUdDO0FBQ1AsSUFBSUMsS0FBeUIsRUFBYyxFQUcxQyxNQUFNO0lBQ0xGLElBQUlHLG1CQUFPQSxDQUFDO0lBQ1pGLElBQUlFLG1CQUFPQSxDQUFDO0FBQ2Q7QUFFQUMsZUFBZSxHQUFHSixFQUFFSyxPQUFPO0FBQzNCRCxzQkFBc0IsR0FBR0osRUFBRU0sY0FBYztBQUN6Q0YsNEJBQTRCLEdBQUdKLEVBQUVPLG9CQUFvQjtBQUNyREgsMEJBQTBCLEdBQUdKLEVBQUVRLGtCQUFrQjtBQUNqREosZ0NBQWdDLEdBQUdKLEVBQUVTLHdCQUF3QjtBQUM3REwsOEJBQThCLEdBQUdILEVBQUVTLHNCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovL3dhaGVndXJ1LXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWRvbS9zZXJ2ZXIubm9kZS5qcz80MDQ1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGwsIHM7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBsID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLXNlcnZlci1sZWdhY3kubm9kZS5wcm9kdWN0aW9uLm1pbi5qcycpO1xuICBzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLXNlcnZlci5ub2RlLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBsID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLXNlcnZlci1sZWdhY3kubm9kZS5kZXZlbG9wbWVudC5qcycpO1xuICBzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLXNlcnZlci5ub2RlLmRldmVsb3BtZW50LmpzJyk7XG59XG5cbmV4cG9ydHMudmVyc2lvbiA9IGwudmVyc2lvbjtcbmV4cG9ydHMucmVuZGVyVG9TdHJpbmcgPSBsLnJlbmRlclRvU3RyaW5nO1xuZXhwb3J0cy5yZW5kZXJUb1N0YXRpY01hcmt1cCA9IGwucmVuZGVyVG9TdGF0aWNNYXJrdXA7XG5leHBvcnRzLnJlbmRlclRvTm9kZVN0cmVhbSA9IGwucmVuZGVyVG9Ob2RlU3RyZWFtO1xuZXhwb3J0cy5yZW5kZXJUb1N0YXRpY05vZGVTdHJlYW0gPSBsLnJlbmRlclRvU3RhdGljTm9kZVN0cmVhbTtcbmV4cG9ydHMucmVuZGVyVG9QaXBlYWJsZVN0cmVhbSA9IHMucmVuZGVyVG9QaXBlYWJsZVN0cmVhbTtcbiJdLCJuYW1lcyI6WyJsIiwicyIsInByb2Nlc3MiLCJyZXF1aXJlIiwiZXhwb3J0cyIsInZlcnNpb24iLCJyZW5kZXJUb1N0cmluZyIsInJlbmRlclRvU3RhdGljTWFya3VwIiwicmVuZGVyVG9Ob2RlU3RyZWFtIiwicmVuZGVyVG9TdGF0aWNOb2RlU3RyZWFtIiwicmVuZGVyVG9QaXBlYWJsZVN0cmVhbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/compiled/react-dom/server.node.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/compiled/react/cjs/react.development.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react.development.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/**\n * @license React\n * react.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n        }\n        var ReactVersion = \"18.3.0-canary-1a001dac6-20230812\";\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_SERVER_CONTEXT_TYPE = Symbol.for(\"react.server_context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for(\"react.default_value\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        /**\n * Keeps track of the current dispatcher.\n */ var ReactCurrentDispatcher$1 = {\n            current: null\n        };\n        /**\n * Keeps track of the current Cache dispatcher.\n */ var ReactCurrentCache = {\n            current: null\n        };\n        /**\n * Keeps track of the current batch's configuration such as how long an update\n * should suspend for if it needs to.\n */ var ReactCurrentBatchConfig = {\n            transition: null\n        };\n        var ReactCurrentActQueue = {\n            current: null,\n            // Used to reproduce behavior of `batchedUpdates` in legacy mode.\n            isBatchingLegacy: false,\n            didScheduleLegacyUpdate: false,\n            // Tracks whether something called `use` during the current batch of work.\n            // Determines whether we should yield to microtasks to unwrap already resolved\n            // promises without suspending.\n            didUsePromise: false\n        };\n        /**\n * Keeps track of the current owner.\n *\n * The current owner is the component who should own any components that are\n * currently being constructed.\n */ var ReactCurrentOwner = {\n            /**\n   * @internal\n   * @type {ReactComponent}\n   */ current: null\n        };\n        var ReactDebugCurrentFrame$1 = {};\n        var currentExtraStackFrame = null;\n        function setExtraStackFrame(stack) {\n            {\n                currentExtraStackFrame = stack;\n            }\n        }\n        {\n            ReactDebugCurrentFrame$1.setExtraStackFrame = function(stack) {\n                {\n                    currentExtraStackFrame = stack;\n                }\n            }; // Stack implementation injected by the current renderer.\n            ReactDebugCurrentFrame$1.getCurrentStack = null;\n            ReactDebugCurrentFrame$1.getStackAddendum = function() {\n                var stack = \"\"; // Add an extra top frame while an element is being validated\n                if (currentExtraStackFrame) {\n                    stack += currentExtraStackFrame;\n                } // Delegate to the injected renderer-specific implementation\n                var impl = ReactDebugCurrentFrame$1.getCurrentStack;\n                if (impl) {\n                    stack += impl() || \"\";\n                }\n                return stack;\n            };\n        }\n        // -----------------------------------------------------------------------------\n        var enableScopeAPI = false; // Experimental Create Event Handle API.\n        var enableCacheElement = false;\n        var enableTransitionTracing = false; // No known bugs, but needs performance testing\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        // stuff. Intended to enable React core members to more easily debug scheduling\n        // issues in DEV builds.\n        var enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n        var ContextRegistry$1 = {};\n        var ReactSharedInternals = {\n            ReactCurrentDispatcher: ReactCurrentDispatcher$1,\n            ReactCurrentCache: ReactCurrentCache,\n            ReactCurrentBatchConfig: ReactCurrentBatchConfig,\n            ReactCurrentOwner: ReactCurrentOwner\n        };\n        {\n            ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame$1;\n            ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;\n        }\n        {\n            ReactSharedInternals.ContextRegistry = ContextRegistry$1;\n        }\n        // by calls to these methods by a Babel plugin.\n        //\n        // In PROD (or in packages without access to React internals),\n        // they are left as they are instead.\n        function warn(format) {\n            {\n                {\n                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    printWarning(\"warn\", format, args);\n                }\n            }\n        }\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        var didWarnStateUpdateForUnmountedComponent = {};\n        function warnNoop(publicInstance, callerName) {\n            {\n                var _constructor = publicInstance.constructor;\n                var componentName = _constructor && (_constructor.displayName || _constructor.name) || \"ReactClass\";\n                var warningKey = componentName + \".\" + callerName;\n                if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n                    return;\n                }\n                error(\"Can't call %s on a component that is not yet mounted. \" + \"This is a no-op, but it might indicate a bug in your application. \" + \"Instead, assign to `this.state` directly or define a `state = {};` \" + \"class property with the desired state in the %s component.\", callerName, componentName);\n                didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n            }\n        }\n        /**\n * This is the abstract API for an update queue.\n */ var ReactNoopUpdateQueue = {\n            /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */ isMounted: function(publicInstance) {\n                return false;\n            },\n            /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */ enqueueForceUpdate: function(publicInstance, callback, callerName) {\n                warnNoop(publicInstance, \"forceUpdate\");\n            },\n            /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */ enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {\n                warnNoop(publicInstance, \"replaceState\");\n            },\n            /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */ enqueueSetState: function(publicInstance, partialState, callback, callerName) {\n                warnNoop(publicInstance, \"setState\");\n            }\n        };\n        var assign = Object.assign;\n        var emptyObject = {};\n        {\n            Object.freeze(emptyObject);\n        }\n        /**\n * Base class helpers for the updating state of a component.\n */ function Component(props, context, updater) {\n            this.props = props;\n            this.context = context; // If a component has string refs, we will assign a different object later.\n            this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the\n            // renderer.\n            this.updater = updater || ReactNoopUpdateQueue;\n        }\n        Component.prototype.isReactComponent = {};\n        /**\n * Sets a subset of the state. Always use this to mutate\n * state. You should treat `this.state` as immutable.\n *\n * There is no guarantee that `this.state` will be immediately updated, so\n * accessing `this.state` after calling this method may return the old value.\n *\n * There is no guarantee that calls to `setState` will run synchronously,\n * as they may eventually be batched together.  You can provide an optional\n * callback that will be executed when the call to setState is actually\n * completed.\n *\n * When a function is provided to setState, it will be called at some point in\n * the future (not synchronously). It will be called with the up to date\n * component arguments (state, props, context). These values can be different\n * from this.* because your function may be called after receiveProps but before\n * shouldComponentUpdate, and this new state, props, and context will not yet be\n * assigned to this.\n *\n * @param {object|function} partialState Next partial state or function to\n *        produce next partial state to be merged with current state.\n * @param {?function} callback Called after state is updated.\n * @final\n * @protected\n */ Component.prototype.setState = function(partialState, callback) {\n            if (typeof partialState !== \"object\" && typeof partialState !== \"function\" && partialState != null) {\n                throw new Error(\"setState(...): takes an object of state variables to update or a \" + \"function which returns an object of state variables.\");\n            }\n            this.updater.enqueueSetState(this, partialState, callback, \"setState\");\n        };\n        /**\n * Forces an update. This should only be invoked when it is known with\n * certainty that we are **not** in a DOM transaction.\n *\n * You may want to call this when you know that some deeper aspect of the\n * component's state has changed but `setState` was not called.\n *\n * This will not invoke `shouldComponentUpdate`, but it will invoke\n * `componentWillUpdate` and `componentDidUpdate`.\n *\n * @param {?function} callback Called after update is complete.\n * @final\n * @protected\n */ Component.prototype.forceUpdate = function(callback) {\n            this.updater.enqueueForceUpdate(this, callback, \"forceUpdate\");\n        };\n        /**\n * Deprecated APIs. These APIs used to exist on classic React classes but since\n * we would like to deprecate them, we're not going to move them over to this\n * modern base class. Instead, we define a getter that warns if it's accessed.\n */ {\n            var deprecatedAPIs = {\n                isMounted: [\n                    \"isMounted\",\n                    \"Instead, make sure to clean up subscriptions and pending requests in \" + \"componentWillUnmount to prevent memory leaks.\"\n                ],\n                replaceState: [\n                    \"replaceState\",\n                    \"Refactor your code to use setState instead (see \" + \"https://github.com/facebook/react/issues/3236).\"\n                ]\n            };\n            var defineDeprecationWarning = function(methodName, info) {\n                Object.defineProperty(Component.prototype, methodName, {\n                    get: function() {\n                        warn(\"%s(...) is deprecated in plain JavaScript React classes. %s\", info[0], info[1]);\n                        return undefined;\n                    }\n                });\n            };\n            for(var fnName in deprecatedAPIs){\n                if (deprecatedAPIs.hasOwnProperty(fnName)) {\n                    defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n                }\n            }\n        }\n        function ComponentDummy() {}\n        ComponentDummy.prototype = Component.prototype;\n        /**\n * Convenience component with default shallow equality check for sCU.\n */ function PureComponent(props, context, updater) {\n            this.props = props;\n            this.context = context; // If a component has string refs, we will assign a different object later.\n            this.refs = emptyObject;\n            this.updater = updater || ReactNoopUpdateQueue;\n        }\n        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\n        pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.\n        assign(pureComponentPrototype, Component.prototype);\n        pureComponentPrototype.isPureReactComponent = true;\n        // an immutable object with a single mutable value\n        function createRef() {\n            var refObject = {\n                current: null\n            };\n            {\n                Object.seal(refObject);\n            }\n            return refObject;\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            {\n                if (typeof type.tag === \"number\") {\n                    error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                }\n            }\n            if (typeof type === \"function\") {\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                    case REACT_SERVER_CONTEXT_TYPE:\n                        {\n                            var context2 = type;\n                            return (context2.displayName || context2._globalName) + \".Provider\";\n                        }\n                }\n            }\n            return null;\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var RESERVED_PROPS = {\n            key: true,\n            ref: true,\n            __self: true,\n            __source: true\n        };\n        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;\n        {\n            didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n            {\n                if (hasOwnProperty.call(config, \"ref\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.ref !== undefined;\n        }\n        function hasValidKey(config) {\n            {\n                if (hasOwnProperty.call(config, \"key\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.key !== undefined;\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n            var warnAboutAccessingKey = function() {\n                {\n                    if (!specialPropKeyWarningShown) {\n                        specialPropKeyWarningShown = true;\n                        error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                }\n            };\n            warnAboutAccessingKey.isReactWarning = true;\n            Object.defineProperty(props, \"key\", {\n                get: warnAboutAccessingKey,\n                configurable: true\n            });\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n            var warnAboutAccessingRef = function() {\n                {\n                    if (!specialPropRefWarningShown) {\n                        specialPropRefWarningShown = true;\n                        error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                }\n            };\n            warnAboutAccessingRef.isReactWarning = true;\n            Object.defineProperty(props, \"ref\", {\n                get: warnAboutAccessingRef,\n                configurable: true\n            });\n        }\n        function warnIfStringRefCannotBeAutoConverted(config) {\n            {\n                if (typeof config.ref === \"string\" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {\n                    var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n                    if (!didWarnAboutStringRefs[componentName]) {\n                        error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", componentName, config.ref);\n                        didWarnAboutStringRefs[componentName] = true;\n                    }\n                }\n            }\n        }\n        /**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */ function ReactElement(type, key, ref, self, source, owner, props) {\n            var element = {\n                // This tag allows us to uniquely identify this as a React Element\n                $$typeof: REACT_ELEMENT_TYPE,\n                // Built-in properties that belong on the element\n                type: type,\n                key: key,\n                ref: ref,\n                props: props,\n                // Record the component responsible for creating this element.\n                _owner: owner\n            };\n            {\n                // The validation flag is currently mutative. We put it on\n                // an external backing store so that we can freeze the whole object.\n                // This can be replaced with a WeakMap once they are implemented in\n                // commonly used development environments.\n                element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n                // the validation flag non-enumerable (where possible, which should\n                // include every environment we run tests in), so the test framework\n                // ignores it.\n                Object.defineProperty(element._store, \"validated\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: true,\n                    value: false\n                }); // self and source are DEV only properties.\n                Object.defineProperty(element, \"_self\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: self\n                }); // Two elements created in two different places should be considered\n                // equal for testing purposes and therefore we hide it from enumeration.\n                Object.defineProperty(element, \"_source\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: source\n                });\n                if (Object.freeze) {\n                    Object.freeze(element.props);\n                    Object.freeze(element);\n                }\n            }\n            return element;\n        }\n        /**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */ function createElement$1(type, config, children) {\n            var propName; // Reserved names are extracted\n            var props = {};\n            var key = null;\n            var ref = null;\n            var self = null;\n            var source = null;\n            if (config != null) {\n                if (hasValidRef(config)) {\n                    ref = config.ref;\n                    {\n                        warnIfStringRefCannotBeAutoConverted(config);\n                    }\n                }\n                if (hasValidKey(config)) {\n                    {\n                        checkKeyStringCoercion(config.key);\n                    }\n                    key = \"\" + config.key;\n                }\n                self = config.__self === undefined ? null : config.__self;\n                source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object\n                for(propName in config){\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                        props[propName] = config[propName];\n                    }\n                }\n            } // Children can be more than one argument, and those are transferred onto\n            // the newly allocated props object.\n            var childrenLength = arguments.length - 2;\n            if (childrenLength === 1) {\n                props.children = children;\n            } else if (childrenLength > 1) {\n                var childArray = Array(childrenLength);\n                for(var i = 0; i < childrenLength; i++){\n                    childArray[i] = arguments[i + 2];\n                }\n                {\n                    if (Object.freeze) {\n                        Object.freeze(childArray);\n                    }\n                }\n                props.children = childArray;\n            } // Resolve default props\n            if (type && type.defaultProps) {\n                var defaultProps = type.defaultProps;\n                for(propName in defaultProps){\n                    if (props[propName] === undefined) {\n                        props[propName] = defaultProps[propName];\n                    }\n                }\n            }\n            {\n                if (key || ref) {\n                    var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                    if (key) {\n                        defineKeyPropWarningGetter(props, displayName);\n                    }\n                    if (ref) {\n                        defineRefPropWarningGetter(props, displayName);\n                    }\n                }\n            }\n            return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n        }\n        function cloneAndReplaceKey(oldElement, newKey) {\n            var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n            return newElement;\n        }\n        /**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */ function cloneElement$1(element, config, children) {\n            if (element === null || element === undefined) {\n                throw new Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + element + \".\");\n            }\n            var propName; // Original props are copied\n            var props = assign({}, element.props); // Reserved names are extracted\n            var key = element.key;\n            var ref = element.ref; // Self is preserved since the owner is preserved.\n            var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a\n            // transpiler, and the original source is probably a better indicator of the\n            // true owner.\n            var source = element._source; // Owner will be preserved, unless ref is overridden\n            var owner = element._owner;\n            if (config != null) {\n                if (hasValidRef(config)) {\n                    // Silently steal the ref from the parent.\n                    ref = config.ref;\n                    owner = ReactCurrentOwner.current;\n                }\n                if (hasValidKey(config)) {\n                    {\n                        checkKeyStringCoercion(config.key);\n                    }\n                    key = \"\" + config.key;\n                } // Remaining properties override existing props\n                var defaultProps;\n                if (element.type && element.type.defaultProps) {\n                    defaultProps = element.type.defaultProps;\n                }\n                for(propName in config){\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                        if (config[propName] === undefined && defaultProps !== undefined) {\n                            // Resolve default props\n                            props[propName] = defaultProps[propName];\n                        } else {\n                            props[propName] = config[propName];\n                        }\n                    }\n                }\n            } // Children can be more than one argument, and those are transferred onto\n            // the newly allocated props object.\n            var childrenLength = arguments.length - 2;\n            if (childrenLength === 1) {\n                props.children = children;\n            } else if (childrenLength > 1) {\n                var childArray = Array(childrenLength);\n                for(var i = 0; i < childrenLength; i++){\n                    childArray[i] = arguments[i + 2];\n                }\n                props.children = childArray;\n            }\n            return ReactElement(element.type, key, ref, self, source, owner, props);\n        }\n        /**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */ function isValidElement(object) {\n            return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n        }\n        var SEPARATOR = \".\";\n        var SUBSEPARATOR = \":\";\n        /**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */ function escape(key) {\n            var escapeRegex = /[=:]/g;\n            var escaperLookup = {\n                \"=\": \"=0\",\n                \":\": \"=2\"\n            };\n            var escapedString = key.replace(escapeRegex, function(match) {\n                return escaperLookup[match];\n            });\n            return \"$\" + escapedString;\n        }\n        /**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */ var didWarnAboutMaps = false;\n        var userProvidedKeyEscapeRegex = /\\/+/g;\n        function escapeUserProvidedKey(text) {\n            return text.replace(userProvidedKeyEscapeRegex, \"$&/\");\n        }\n        /**\n * Generate a key string that identifies a element within a set.\n *\n * @param {*} element A element that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */ function getElementKey(element, index) {\n            // Do some typechecking here since we call this blindly. We want to ensure\n            // that we don't block potential future ES APIs.\n            if (typeof element === \"object\" && element !== null && element.key != null) {\n                // Explicit key\n                {\n                    checkKeyStringCoercion(element.key);\n                }\n                return escape(\"\" + element.key);\n            } // Implicit key determined by the index in the set\n            return index.toString(36);\n        }\n        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n            var type = typeof children;\n            if (type === \"undefined\" || type === \"boolean\") {\n                // All of the above are perceived as null.\n                children = null;\n            }\n            var invokeCallback = false;\n            if (children === null) {\n                invokeCallback = true;\n            } else {\n                switch(type){\n                    case \"string\":\n                    case \"number\":\n                        invokeCallback = true;\n                        break;\n                    case \"object\":\n                        switch(children.$$typeof){\n                            case REACT_ELEMENT_TYPE:\n                            case REACT_PORTAL_TYPE:\n                                invokeCallback = true;\n                        }\n                }\n            }\n            if (invokeCallback) {\n                var _child = children;\n                var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array\n                // so that it's consistent if the number of children grows:\n                var childKey = nameSoFar === \"\" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;\n                if (isArray(mappedChild)) {\n                    var escapedChildKey = \"\";\n                    if (childKey != null) {\n                        escapedChildKey = escapeUserProvidedKey(childKey) + \"/\";\n                    }\n                    mapIntoArray(mappedChild, array, escapedChildKey, \"\", function(c) {\n                        return c;\n                    });\n                } else if (mappedChild != null) {\n                    if (isValidElement(mappedChild)) {\n                        {\n                            // The `if` statement here prevents auto-disabling of the safe\n                            // coercion ESLint rule, so we must manually disable it below.\n                            // $FlowFixMe[incompatible-type] Flow incorrectly thinks React.Portal doesn't have a key\n                            if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {\n                                checkKeyStringCoercion(mappedChild.key);\n                            }\n                        }\n                        mappedChild = cloneAndReplaceKey(mappedChild, // traverseAllChildren used to do for objects as children\n                        escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey(\"\" + mappedChild.key // eslint-disable-line react-internal/safe-string-coercion\n                        ) + \"/\" : \"\") + childKey);\n                    }\n                    array.push(mappedChild);\n                }\n                return 1;\n            }\n            var child;\n            var nextName;\n            var subtreeCount = 0; // Count of children found in the current subtree.\n            var nextNamePrefix = nameSoFar === \"\" ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n            if (isArray(children)) {\n                for(var i = 0; i < children.length; i++){\n                    child = children[i];\n                    nextName = nextNamePrefix + getElementKey(child, i);\n                    subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n                }\n            } else {\n                var iteratorFn = getIteratorFn(children);\n                if (typeof iteratorFn === \"function\") {\n                    var iterableChildren = children;\n                    {\n                        // Warn about using Maps as children\n                        if (iteratorFn === iterableChildren.entries) {\n                            if (!didWarnAboutMaps) {\n                                warn(\"Using Maps as children is not supported. \" + \"Use an array of keyed ReactElements instead.\");\n                            }\n                            didWarnAboutMaps = true;\n                        }\n                    }\n                    var iterator = iteratorFn.call(iterableChildren);\n                    var step;\n                    var ii = 0; // $FlowFixMe[incompatible-use] `iteratorFn` might return null according to typing.\n                    while(!(step = iterator.next()).done){\n                        child = step.value;\n                        nextName = nextNamePrefix + getElementKey(child, ii++);\n                        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n                    }\n                } else if (type === \"object\") {\n                    // eslint-disable-next-line react-internal/safe-string-coercion\n                    var childrenString = String(children);\n                    throw new Error(\"Objects are not valid as a React child (found: \" + (childrenString === \"[object Object]\" ? \"object with keys {\" + Object.keys(children).join(\", \") + \"}\" : childrenString) + \"). \" + \"If you meant to render a collection of children, use an array \" + \"instead.\");\n                }\n            }\n            return subtreeCount;\n        }\n        /**\n * Maps children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n *\n * The provided mapFunction(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */ function mapChildren(children, func, context) {\n            if (children == null) {\n                return children;\n            }\n            var result = [];\n            var count = 0;\n            mapIntoArray(children, result, \"\", \"\", function(child) {\n                return func.call(context, child, count++);\n            });\n            return result;\n        }\n        /**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrencount\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */ function countChildren(children) {\n            var n = 0;\n            mapChildren(children, function() {\n                n++; // Don't return anything\n            });\n            return n;\n        }\n        /**\n * Iterates through children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */ function forEachChildren(children, forEachFunc, forEachContext) {\n            mapChildren(children, function() {\n                forEachFunc.apply(this, arguments); // Don't return anything.\n            }, forEachContext);\n        }\n        /**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n */ function toArray(children) {\n            return mapChildren(children, function(child) {\n                return child;\n            }) || [];\n        }\n        /**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n *\n * The current implementation of this function assumes that a single child gets\n * passed without a wrapper, but the purpose of this helper function is to\n * abstract away the particular structure of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactElement} The first and only `ReactElement` contained in the\n * structure.\n */ function onlyChild(children) {\n            if (!isValidElement(children)) {\n                throw new Error(\"React.Children.only expected to receive a single React element child.\");\n            }\n            return children;\n        }\n        function createContext(defaultValue) {\n            // TODO: Second argument used to be an optional `calculateChangedBits`\n            // function. Warn to reserve for future use?\n            var context = {\n                $$typeof: REACT_CONTEXT_TYPE,\n                // As a workaround to support multiple concurrent renderers, we categorize\n                // some renderers as primary and others as secondary. We only expect\n                // there to be two concurrent renderers at most: React Native (primary) and\n                // Fabric (secondary); React DOM (primary) and React ART (secondary).\n                // Secondary renderers store their context values on separate fields.\n                _currentValue: defaultValue,\n                _currentValue2: defaultValue,\n                // Used to track how many concurrent renderers this context currently\n                // supports within in a single renderer. Such as parallel server rendering.\n                _threadCount: 0,\n                // These are circular\n                Provider: null,\n                Consumer: null,\n                // Add these to use same hidden class in VM as ServerContext\n                _defaultValue: null,\n                _globalName: null\n            };\n            context.Provider = {\n                $$typeof: REACT_PROVIDER_TYPE,\n                _context: context\n            };\n            var hasWarnedAboutUsingNestedContextConsumers = false;\n            var hasWarnedAboutUsingConsumerProvider = false;\n            var hasWarnedAboutDisplayNameOnConsumer = false;\n            {\n                // A separate object, but proxies back to the original context object for\n                // backwards compatibility. It has a different $$typeof, so we can properly\n                // warn for the incorrect usage of Context as a Consumer.\n                var Consumer = {\n                    $$typeof: REACT_CONTEXT_TYPE,\n                    _context: context\n                }; // $FlowFixMe[prop-missing]: Flow complains about not setting a value, which is intentional here\n                Object.defineProperties(Consumer, {\n                    Provider: {\n                        get: function() {\n                            if (!hasWarnedAboutUsingConsumerProvider) {\n                                hasWarnedAboutUsingConsumerProvider = true;\n                                error(\"Rendering <Context.Consumer.Provider> is not supported and will be removed in \" + \"a future major release. Did you mean to render <Context.Provider> instead?\");\n                            }\n                            return context.Provider;\n                        },\n                        set: function(_Provider) {\n                            context.Provider = _Provider;\n                        }\n                    },\n                    _currentValue: {\n                        get: function() {\n                            return context._currentValue;\n                        },\n                        set: function(_currentValue) {\n                            context._currentValue = _currentValue;\n                        }\n                    },\n                    _currentValue2: {\n                        get: function() {\n                            return context._currentValue2;\n                        },\n                        set: function(_currentValue2) {\n                            context._currentValue2 = _currentValue2;\n                        }\n                    },\n                    _threadCount: {\n                        get: function() {\n                            return context._threadCount;\n                        },\n                        set: function(_threadCount) {\n                            context._threadCount = _threadCount;\n                        }\n                    },\n                    Consumer: {\n                        get: function() {\n                            if (!hasWarnedAboutUsingNestedContextConsumers) {\n                                hasWarnedAboutUsingNestedContextConsumers = true;\n                                error(\"Rendering <Context.Consumer.Consumer> is not supported and will be removed in \" + \"a future major release. Did you mean to render <Context.Consumer> instead?\");\n                            }\n                            return context.Consumer;\n                        }\n                    },\n                    displayName: {\n                        get: function() {\n                            return context.displayName;\n                        },\n                        set: function(displayName) {\n                            if (!hasWarnedAboutDisplayNameOnConsumer) {\n                                warn(\"Setting `displayName` on Context.Consumer has no effect. \" + \"You should set it directly on the context with Context.displayName = '%s'.\", displayName);\n                                hasWarnedAboutDisplayNameOnConsumer = true;\n                            }\n                        }\n                    }\n                }); // $FlowFixMe[prop-missing]: Flow complains about missing properties because it doesn't understand defineProperty\n                context.Consumer = Consumer;\n            }\n            {\n                context._currentRenderer = null;\n                context._currentRenderer2 = null;\n            }\n            return context;\n        }\n        var Uninitialized = -1;\n        var Pending = 0;\n        var Resolved = 1;\n        var Rejected = 2;\n        function lazyInitializer(payload) {\n            if (payload._status === Uninitialized) {\n                var ctor = payload._result;\n                var thenable = ctor(); // Transition to the next state.\n                // This might throw either because it's missing or throws. If so, we treat it\n                // as still uninitialized and try again next time. Which is the same as what\n                // happens if the ctor or any wrappers processing the ctor throws. This might\n                // end up fixing it if the resolution was a concurrency bug.\n                thenable.then(function(moduleObject) {\n                    if (payload._status === Pending || payload._status === Uninitialized) {\n                        // Transition to the next state.\n                        var resolved = payload;\n                        resolved._status = Resolved;\n                        resolved._result = moduleObject;\n                    }\n                }, function(error) {\n                    if (payload._status === Pending || payload._status === Uninitialized) {\n                        // Transition to the next state.\n                        var rejected = payload;\n                        rejected._status = Rejected;\n                        rejected._result = error;\n                    }\n                });\n                if (payload._status === Uninitialized) {\n                    // In case, we're still uninitialized, then we're waiting for the thenable\n                    // to resolve. Set it as pending in the meantime.\n                    var pending = payload;\n                    pending._status = Pending;\n                    pending._result = thenable;\n                }\n            }\n            if (payload._status === Resolved) {\n                var moduleObject = payload._result;\n                {\n                    if (moduleObject === undefined) {\n                        error(\"lazy: Expected the result of a dynamic imp\" + \"ort() call. \" + \"Instead received: %s\\n\\nYour code should look like: \\n  \" + // Break up imports to avoid accidentally parsing them as dependencies.\n                        \"const MyComponent = lazy(() => imp\" + \"ort('./MyComponent'))\\n\\n\" + \"Did you accidentally put curly braces around the import?\", moduleObject);\n                    }\n                }\n                {\n                    if (!(\"default\" in moduleObject)) {\n                        error(\"lazy: Expected the result of a dynamic imp\" + \"ort() call. \" + \"Instead received: %s\\n\\nYour code should look like: \\n  \" + // Break up imports to avoid accidentally parsing them as dependencies.\n                        \"const MyComponent = lazy(() => imp\" + \"ort('./MyComponent'))\", moduleObject);\n                    }\n                }\n                return moduleObject.default;\n            } else {\n                throw payload._result;\n            }\n        }\n        function lazy(ctor) {\n            var payload = {\n                // We use these fields to store the result.\n                _status: Uninitialized,\n                _result: ctor\n            };\n            var lazyType = {\n                $$typeof: REACT_LAZY_TYPE,\n                _payload: payload,\n                _init: lazyInitializer\n            };\n            {\n                // In production, this would just set it on the object.\n                var defaultProps;\n                var propTypes; // $FlowFixMe[prop-missing]\n                Object.defineProperties(lazyType, {\n                    defaultProps: {\n                        configurable: true,\n                        get: function() {\n                            return defaultProps;\n                        },\n                        // $FlowFixMe[missing-local-annot]\n                        set: function(newDefaultProps) {\n                            error(\"React.lazy(...): It is not supported to assign `defaultProps` to \" + \"a lazy component import. Either specify them where the component \" + \"is defined, or create a wrapping component around it.\");\n                            defaultProps = newDefaultProps; // Match production behavior more closely:\n                            // $FlowFixMe[prop-missing]\n                            Object.defineProperty(lazyType, \"defaultProps\", {\n                                enumerable: true\n                            });\n                        }\n                    },\n                    propTypes: {\n                        configurable: true,\n                        get: function() {\n                            return propTypes;\n                        },\n                        // $FlowFixMe[missing-local-annot]\n                        set: function(newPropTypes) {\n                            error(\"React.lazy(...): It is not supported to assign `propTypes` to \" + \"a lazy component import. Either specify them where the component \" + \"is defined, or create a wrapping component around it.\");\n                            propTypes = newPropTypes; // Match production behavior more closely:\n                            // $FlowFixMe[prop-missing]\n                            Object.defineProperty(lazyType, \"propTypes\", {\n                                enumerable: true\n                            });\n                        }\n                    }\n                });\n            }\n            return lazyType;\n        }\n        function forwardRef(render) {\n            {\n                if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\n                    error(\"forwardRef requires a render function but received a `memo` \" + \"component. Instead of forwardRef(memo(...)), use \" + \"memo(forwardRef(...)).\");\n                } else if (typeof render !== \"function\") {\n                    error(\"forwardRef requires a render function but was given %s.\", render === null ? \"null\" : typeof render);\n                } else {\n                    if (render.length !== 0 && render.length !== 2) {\n                        error(\"forwardRef render functions accept exactly two parameters: props and ref. %s\", render.length === 1 ? \"Did you forget to use the ref parameter?\" : \"Any additional parameter will be undefined.\");\n                    }\n                }\n                if (render != null) {\n                    if (render.defaultProps != null || render.propTypes != null) {\n                        error(\"forwardRef render functions do not support propTypes or defaultProps. \" + \"Did you accidentally pass a React component?\");\n                    }\n                }\n            }\n            var elementType = {\n                $$typeof: REACT_FORWARD_REF_TYPE,\n                render: render\n            };\n            {\n                var ownName;\n                Object.defineProperty(elementType, \"displayName\", {\n                    enumerable: false,\n                    configurable: true,\n                    get: function() {\n                        return ownName;\n                    },\n                    set: function(name) {\n                        ownName = name; // The inner component shouldn't inherit this display name in most cases,\n                        // because the component may be used elsewhere.\n                        // But it's nice for anonymous functions to inherit the name,\n                        // so that our component-stack generation logic will display their frames.\n                        // An anonymous function generally suggests a pattern like:\n                        //   React.forwardRef((props, ref) => {...});\n                        // This kind of inner function is not used elsewhere so the side effect is okay.\n                        if (!render.name && !render.displayName) {\n                            render.displayName = name;\n                        }\n                    }\n                });\n            }\n            return elementType;\n        }\n        var REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\");\n        function isValidElementType(type) {\n            if (typeof type === \"string\" || typeof type === \"function\") {\n                return true;\n            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                return true;\n            }\n            if (typeof type === \"object\" && type !== null) {\n                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                // types supported by any Flight configuration anywhere since\n                // we don't know which Flight build this will end up being used\n                // with.\n                type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function memo(type, compare) {\n            {\n                if (!isValidElementType(type)) {\n                    error(\"memo: The first argument must be a component. Instead \" + \"received: %s\", type === null ? \"null\" : typeof type);\n                }\n            }\n            var elementType = {\n                $$typeof: REACT_MEMO_TYPE,\n                type: type,\n                compare: compare === undefined ? null : compare\n            };\n            {\n                var ownName;\n                Object.defineProperty(elementType, \"displayName\", {\n                    enumerable: false,\n                    configurable: true,\n                    get: function() {\n                        return ownName;\n                    },\n                    set: function(name) {\n                        ownName = name; // The inner component shouldn't inherit this display name in most cases,\n                        // because the component may be used elsewhere.\n                        // But it's nice for anonymous functions to inherit the name,\n                        // so that our component-stack generation logic will display their frames.\n                        // An anonymous function generally suggests a pattern like:\n                        //   React.memo((props) => {...});\n                        // This kind of inner function is not used elsewhere so the side effect is okay.\n                        if (!type.name && !type.displayName) {\n                            type.displayName = name;\n                        }\n                    }\n                });\n            }\n            return elementType;\n        }\n        var UNTERMINATED = 0;\n        var TERMINATED = 1;\n        var ERRORED = 2;\n        function createCacheRoot() {\n            return new WeakMap();\n        }\n        function createCacheNode() {\n            return {\n                s: UNTERMINATED,\n                // status, represents whether the cached computation returned a value or threw an error\n                v: undefined,\n                // value, either the cached result or an error, depending on s\n                o: null,\n                // object cache, a WeakMap where non-primitive arguments are stored\n                p: null // primitive cache, a regular Map where primitive arguments are stored.\n            };\n        }\n        function cache(fn) {\n            return function() {\n                var dispatcher = ReactCurrentCache.current;\n                if (!dispatcher) {\n                    // If there is no dispatcher, then we treat this as not being cached.\n                    // $FlowFixMe[incompatible-call]: We don't want to use rest arguments since we transpile the code.\n                    return fn.apply(null, arguments);\n                }\n                var fnMap = dispatcher.getCacheForType(createCacheRoot);\n                var fnNode = fnMap.get(fn);\n                var cacheNode;\n                if (fnNode === undefined) {\n                    cacheNode = createCacheNode();\n                    fnMap.set(fn, cacheNode);\n                } else {\n                    cacheNode = fnNode;\n                }\n                for(var i = 0, l = arguments.length; i < l; i++){\n                    var arg = arguments[i];\n                    if (typeof arg === \"function\" || typeof arg === \"object\" && arg !== null) {\n                        // Objects go into a WeakMap\n                        var objectCache = cacheNode.o;\n                        if (objectCache === null) {\n                            cacheNode.o = objectCache = new WeakMap();\n                        }\n                        var objectNode = objectCache.get(arg);\n                        if (objectNode === undefined) {\n                            cacheNode = createCacheNode();\n                            objectCache.set(arg, cacheNode);\n                        } else {\n                            cacheNode = objectNode;\n                        }\n                    } else {\n                        // Primitives go into a regular Map\n                        var primitiveCache = cacheNode.p;\n                        if (primitiveCache === null) {\n                            cacheNode.p = primitiveCache = new Map();\n                        }\n                        var primitiveNode = primitiveCache.get(arg);\n                        if (primitiveNode === undefined) {\n                            cacheNode = createCacheNode();\n                            primitiveCache.set(arg, cacheNode);\n                        } else {\n                            cacheNode = primitiveNode;\n                        }\n                    }\n                }\n                if (cacheNode.s === TERMINATED) {\n                    return cacheNode.v;\n                }\n                if (cacheNode.s === ERRORED) {\n                    throw cacheNode.v;\n                }\n                try {\n                    // $FlowFixMe[incompatible-call]: We don't want to use rest arguments since we transpile the code.\n                    var result = fn.apply(null, arguments);\n                    var terminatedNode = cacheNode;\n                    terminatedNode.s = TERMINATED;\n                    terminatedNode.v = result;\n                    return result;\n                } catch (error) {\n                    // We store the first error that's thrown and rethrow it.\n                    var erroredNode = cacheNode;\n                    erroredNode.s = ERRORED;\n                    erroredNode.v = error;\n                    throw error;\n                }\n            };\n        }\n        function resolveDispatcher() {\n            var dispatcher = ReactCurrentDispatcher$1.current;\n            {\n                if (dispatcher === null) {\n                    error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for\" + \" one of the following reasons:\\n\" + \"1. You might have mismatching versions of React and the renderer (such as React DOM)\\n\" + \"2. You might be breaking the Rules of Hooks\\n\" + \"3. You might have more than one copy of React in the same app\\n\" + \"See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.\");\n                }\n            }\n            // intentionally don't throw our own error because this is in a hot path.\n            // Also helps ensure this is inlined.\n            return dispatcher;\n        }\n        function useContext(Context) {\n            var dispatcher = resolveDispatcher();\n            {\n                // TODO: add a more generic warning for invalid values.\n                if (Context._context !== undefined) {\n                    var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs\n                    // and nobody should be using this in existing code.\n                    if (realContext.Consumer === Context) {\n                        error(\"Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be \" + \"removed in a future major release. Did you mean to call useContext(Context) instead?\");\n                    } else if (realContext.Provider === Context) {\n                        error(\"Calling useContext(Context.Provider) is not supported. \" + \"Did you mean to call useContext(Context) instead?\");\n                    }\n                }\n            }\n            return dispatcher.useContext(Context);\n        }\n        function useState(initialState) {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useState(initialState);\n        }\n        function useReducer(reducer, initialArg, init) {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useReducer(reducer, initialArg, init);\n        }\n        function useRef(initialValue) {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useRef(initialValue);\n        }\n        function useEffect(create, deps) {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useEffect(create, deps);\n        }\n        function useInsertionEffect(create, deps) {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useInsertionEffect(create, deps);\n        }\n        function useLayoutEffect(create, deps) {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useLayoutEffect(create, deps);\n        }\n        function useCallback(callback, deps) {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useCallback(callback, deps);\n        }\n        function useMemo(create, deps) {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useMemo(create, deps);\n        }\n        function useImperativeHandle(ref, create, deps) {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useImperativeHandle(ref, create, deps);\n        }\n        function useDebugValue(value, formatterFn) {\n            {\n                var dispatcher = resolveDispatcher();\n                return dispatcher.useDebugValue(value, formatterFn);\n            }\n        }\n        function useTransition() {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useTransition();\n        }\n        function useDeferredValue(value) {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useDeferredValue(value);\n        }\n        function useId() {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useId();\n        }\n        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        }\n        function useCacheRefresh() {\n            var dispatcher = resolveDispatcher(); // $FlowFixMe[not-a-function] This is unstable, thus optional\n            return dispatcher.useCacheRefresh();\n        }\n        function use(usable) {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.use(usable);\n        }\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            var control;\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            try {\n                // This should throw.\n                if (construct) {\n                    // Something should be setting the props in the constructor.\n                    var Fake = function() {\n                        throw Error();\n                    }; // $FlowFixMe[prop-missing]\n                    Object.defineProperty(Fake.prototype, \"props\", {\n                        set: function() {\n                            // We use a throwing setter instead of frozen or non-writable props\n                            // because that won't throw in a non-strict mode function.\n                            throw Error();\n                        }\n                    });\n                    if (typeof Reflect === \"object\" && Reflect.construct) {\n                        // We construct a different control for this case to include any extra\n                        // frames added by the construct call.\n                        try {\n                            Reflect.construct(Fake, []);\n                        } catch (x) {\n                            control = x;\n                        }\n                        Reflect.construct(fn, [], Fake);\n                    } else {\n                        try {\n                            Fake.call();\n                        } catch (x) {\n                            control = x;\n                        } // $FlowFixMe[prop-missing] found when upgrading Flow\n                        fn.call(Fake.prototype);\n                    }\n                } else {\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        control = x;\n                    } // TODO(luna): This will currently only throw if the function component\n                    // tries to access React/ReactDOM/props. We should probably make this throw\n                    // in simple components too\n                    var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                    // component, which we don't yet support. Attach a noop catch handler to\n                    // silence the error.\n                    // TODO: Implement component stacks for async client components?\n                    if (maybePromise && typeof maybePromise.catch === \"function\") {\n                        maybePromise.catch(function() {});\n                    }\n                }\n            } catch (sample) {\n                // This is inlined manually because closure doesn't do it for us.\n                if (sample && control && typeof sample.stack === \"string\") {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sample.stack.split(\"\\n\");\n                    var controlLines = control.stack.split(\"\\n\");\n                    var s = sampleLines.length - 1;\n                    var c = controlLines.length - 1;\n                    while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                        // We expect at least one stack frame to be shared.\n                        // Typically this will be the root most one. However, stack frames may be\n                        // cut off due to maximum stack limits. In this case, one maybe cut off\n                        // earlier than the other. We assume that the sample is longer or the same\n                        // and there for cut off earlier. So we should find the root most frame in\n                        // the sample somewhere in the control.\n                        c--;\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        }\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement$1(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                    }\n                }\n            }\n        }\n        var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    setExtraStackFrame(stack);\n                } else {\n                    setExtraStackFrame(null);\n                }\n            }\n        }\n        var propTypesMisspellWarningShown;\n        {\n            propTypesMisspellWarningShown = false;\n        }\n        function getDeclarationErrorAddendum() {\n            if (ReactCurrentOwner.current) {\n                var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n                if (name) {\n                    return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                }\n            }\n            return \"\";\n        }\n        function getSourceInfoErrorAddendum(source) {\n            if (source !== undefined) {\n                var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                var lineNumber = source.lineNumber;\n                return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n            }\n            return \"\";\n        }\n        function getSourceInfoErrorAddendumForProps(elementProps) {\n            if (elementProps !== null && elementProps !== undefined) {\n                return getSourceInfoErrorAddendum(elementProps.__source);\n            }\n            return \"\";\n        }\n        /**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */ var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n            var info = getDeclarationErrorAddendum();\n            if (!info) {\n                var parentName = typeof parentType === \"string\" ? parentType : parentType.displayName || parentType.name;\n                if (parentName) {\n                    info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                }\n            }\n            return info;\n        }\n        /**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */ function validateExplicitKey(element, parentType) {\n            if (!element._store || element._store.validated || element.key != null) {\n                return;\n            }\n            element._store.validated = true;\n            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                return;\n            }\n            ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n            // property, it may be the creator of the child that's responsible for\n            // assigning it a key.\n            var childOwner = \"\";\n            if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n                // Give the component that originally created this child.\n                childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n            }\n            {\n                setCurrentlyValidatingElement(element);\n                error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n                setCurrentlyValidatingElement(null);\n            }\n        }\n        /**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */ function validateChildKeys(node, parentType) {\n            if (typeof node !== \"object\" || !node) {\n                return;\n            }\n            if (node.$$typeof === REACT_CLIENT_REFERENCE) ;\n            else if (isArray(node)) {\n                for(var i = 0; i < node.length; i++){\n                    var child = node[i];\n                    if (isValidElement(child)) {\n                        validateExplicitKey(child, parentType);\n                    }\n                }\n            } else if (isValidElement(node)) {\n                // This element was passed in a valid location.\n                if (node._store) {\n                    node._store.validated = true;\n                }\n            } else {\n                var iteratorFn = getIteratorFn(node);\n                if (typeof iteratorFn === \"function\") {\n                    // Entry iterators used to provide implicit keys,\n                    // but now we print a separate warning for them later.\n                    if (iteratorFn !== node.entries) {\n                        var iterator = iteratorFn.call(node);\n                        var step;\n                        while(!(step = iterator.next()).done){\n                            if (isValidElement(step.value)) {\n                                validateExplicitKey(step.value, parentType);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */ function validatePropTypes(element) {\n            {\n                var type = element.type;\n                if (type === null || type === undefined || typeof type === \"string\") {\n                    return;\n                }\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    return;\n                }\n                var propTypes;\n                if (typeof type === \"function\") {\n                    propTypes = type.propTypes;\n                } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n                // Inner props are checked in the reconciler.\n                type.$$typeof === REACT_MEMO_TYPE)) {\n                    propTypes = type.propTypes;\n                } else {\n                    return;\n                }\n                if (propTypes) {\n                    // Intentionally inside to avoid triggering lazy initializers:\n                    var name = getComponentNameFromType(type);\n                    checkPropTypes(propTypes, element.props, \"prop\", name, element);\n                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                    propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n                    var _name = getComponentNameFromType(type);\n                    error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n                }\n                if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n                }\n            }\n        }\n        /**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */ function validateFragmentProps(fragment) {\n            {\n                var keys = Object.keys(fragment.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== \"children\" && key !== \"key\") {\n                        setCurrentlyValidatingElement(fragment);\n                        error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n                        setCurrentlyValidatingElement(null);\n                        break;\n                    }\n                }\n                if (fragment.ref !== null) {\n                    setCurrentlyValidatingElement(fragment);\n                    error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n                    setCurrentlyValidatingElement(null);\n                }\n            }\n        }\n        function createElementWithValidation(type, props, children) {\n            var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n            // succeed and there will likely be errors in render.\n            if (!validType) {\n                var info = \"\";\n                if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                    info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                }\n                var sourceInfo = getSourceInfoErrorAddendumForProps(props);\n                if (sourceInfo) {\n                    info += sourceInfo;\n                } else {\n                    info += getDeclarationErrorAddendum();\n                }\n                var typeString;\n                if (type === null) {\n                    typeString = \"null\";\n                } else if (isArray(type)) {\n                    typeString = \"array\";\n                } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                    typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                    info = \" Did you accidentally export a JSX literal instead of a component?\";\n                } else {\n                    typeString = typeof type;\n                }\n                {\n                    error(\"React.createElement: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                }\n            }\n            var element = createElement$1.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.\n            // TODO: Drop this when these are no longer allowed as the type argument.\n            if (element == null) {\n                return element;\n            } // Skip key warning if the type isn't valid since our key validation logic\n            // doesn't expect a non-string/function type and can throw confusing errors.\n            // We don't want exception behavior to differ between dev and prod.\n            // (Rendering will throw with a helpful message and as soon as the type is\n            // fixed, the key warnings will appear.)\n            if (validType) {\n                for(var i = 2; i < arguments.length; i++){\n                    validateChildKeys(arguments[i], type);\n                }\n            }\n            if (type === REACT_FRAGMENT_TYPE) {\n                validateFragmentProps(element);\n            } else {\n                validatePropTypes(element);\n            }\n            return element;\n        }\n        var didWarnAboutDeprecatedCreateFactory = false;\n        function createFactoryWithValidation(type) {\n            var validatedFactory = createElementWithValidation.bind(null, type);\n            validatedFactory.type = type;\n            {\n                if (!didWarnAboutDeprecatedCreateFactory) {\n                    didWarnAboutDeprecatedCreateFactory = true;\n                    warn(\"React.createFactory() is deprecated and will be removed in \" + \"a future major release. Consider using JSX \" + \"or use React.createElement() directly instead.\");\n                } // Legacy hook: remove it\n                Object.defineProperty(validatedFactory, \"type\", {\n                    enumerable: false,\n                    get: function() {\n                        warn(\"Factory.type is deprecated. Access the class directly \" + \"before passing it to createFactory.\");\n                        Object.defineProperty(this, \"type\", {\n                            value: type\n                        });\n                        return type;\n                    }\n                });\n            }\n            return validatedFactory;\n        }\n        function cloneElementWithValidation(element, props, children) {\n            var newElement = cloneElement$1.apply(this, arguments);\n            for(var i = 2; i < arguments.length; i++){\n                validateChildKeys(arguments[i], newElement.type);\n            }\n            validatePropTypes(newElement);\n            return newElement;\n        }\n        var ContextRegistry = ReactSharedInternals.ContextRegistry;\n        function createServerContext(globalName, defaultValue) {\n            var wasDefined = true;\n            if (!ContextRegistry[globalName]) {\n                wasDefined = false;\n                var _context = {\n                    $$typeof: REACT_SERVER_CONTEXT_TYPE,\n                    // As a workaround to support multiple concurrent renderers, we categorize\n                    // some renderers as primary and others as secondary. We only expect\n                    // there to be two concurrent renderers at most: React Native (primary) and\n                    // Fabric (secondary); React DOM (primary) and React ART (secondary).\n                    // Secondary renderers store their context values on separate fields.\n                    _currentValue: defaultValue,\n                    _currentValue2: defaultValue,\n                    _defaultValue: defaultValue,\n                    // Used to track how many concurrent renderers this context currently\n                    // supports within in a single renderer. Such as parallel server rendering.\n                    _threadCount: 0,\n                    // These are circular\n                    Provider: null,\n                    Consumer: null,\n                    _globalName: globalName\n                };\n                _context.Provider = {\n                    $$typeof: REACT_PROVIDER_TYPE,\n                    _context: _context\n                };\n                {\n                    var hasWarnedAboutUsingConsumer;\n                    _context._currentRenderer = null;\n                    _context._currentRenderer2 = null;\n                    Object.defineProperties(_context, {\n                        Consumer: {\n                            get: function() {\n                                if (!hasWarnedAboutUsingConsumer) {\n                                    error(\"Consumer pattern is not supported by ReactServerContext\");\n                                    hasWarnedAboutUsingConsumer = true;\n                                }\n                                return null;\n                            }\n                        }\n                    });\n                }\n                ContextRegistry[globalName] = _context;\n            }\n            var context = ContextRegistry[globalName];\n            if (context._defaultValue === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {\n                context._defaultValue = defaultValue;\n                if (context._currentValue === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {\n                    context._currentValue = defaultValue;\n                }\n                if (context._currentValue2 === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {\n                    context._currentValue2 = defaultValue;\n                }\n            } else if (wasDefined) {\n                throw new Error(\"ServerContext: \" + globalName + \" already defined\");\n            }\n            return context;\n        }\n        function startTransition(scope, options) {\n            var prevTransition = ReactCurrentBatchConfig.transition;\n            ReactCurrentBatchConfig.transition = {};\n            var currentTransition = ReactCurrentBatchConfig.transition;\n            {\n                ReactCurrentBatchConfig.transition._updatedFibers = new Set();\n            }\n            try {\n                scope();\n            } finally{\n                ReactCurrentBatchConfig.transition = prevTransition;\n                {\n                    if (prevTransition === null && currentTransition._updatedFibers) {\n                        var updatedFibersCount = currentTransition._updatedFibers.size;\n                        currentTransition._updatedFibers.clear();\n                        if (updatedFibersCount > 10) {\n                            warn(\"Detected a large number of updates inside startTransition. \" + \"If this is due to a subscription please re-write it to use React provided hooks. \" + \"Otherwise concurrent mode guarantees are off the table.\");\n                        }\n                    }\n                }\n            }\n        }\n        var didWarnAboutMessageChannel = false;\n        var enqueueTaskImpl = null;\n        function enqueueTask(task) {\n            if (enqueueTaskImpl === null) {\n                try {\n                    // read require off the module object to get around the bundlers.\n                    // we don't want them to detect a require and bundle a Node polyfill.\n                    var requireString = (\"require\" + Math.random()).slice(0, 7);\n                    var nodeRequire = module && module[requireString]; // assuming we're in node, let's try to get node's\n                    // version of setImmediate, bypassing fake timers if any.\n                    enqueueTaskImpl = nodeRequire.call(module, \"timers\").setImmediate;\n                } catch (_err) {\n                    // we're in a browser\n                    // we can't use regular timers because they may still be faked\n                    // so we try MessageChannel+postMessage instead\n                    enqueueTaskImpl = function(callback) {\n                        {\n                            if (didWarnAboutMessageChannel === false) {\n                                didWarnAboutMessageChannel = true;\n                                if (typeof MessageChannel === \"undefined\") {\n                                    error(\"This browser does not have a MessageChannel implementation, \" + \"so enqueuing tasks via await act(async () => ...) will fail. \" + \"Please file an issue at https://github.com/facebook/react/issues \" + \"if you encounter this warning.\");\n                                }\n                            }\n                        }\n                        var channel = new MessageChannel();\n                        channel.port1.onmessage = callback;\n                        channel.port2.postMessage(undefined);\n                    };\n                }\n            }\n            return enqueueTaskImpl(task);\n        }\n        // number of `act` scopes on the stack.\n        var actScopeDepth = 0; // We only warn the first time you neglect to await an async `act` scope.\n        var didWarnNoAwaitAct = false;\n        function act(callback) {\n            {\n                // When ReactCurrentActQueue.current is not null, it signals to React that\n                // we're currently inside an `act` scope. React will push all its tasks to\n                // this queue instead of scheduling them with platform APIs.\n                //\n                // We set this to an empty array when we first enter an `act` scope, and\n                // only unset it once we've left the outermost `act` scope — remember that\n                // `act` calls can be nested.\n                //\n                // If we're already inside an `act` scope, reuse the existing queue.\n                var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;\n                var prevActQueue = ReactCurrentActQueue.current;\n                var prevActScopeDepth = actScopeDepth;\n                actScopeDepth++;\n                var queue = ReactCurrentActQueue.current = prevActQueue !== null ? prevActQueue : []; // Used to reproduce behavior of `batchedUpdates` in legacy mode. Only\n                // set to `true` while the given callback is executed, not for updates\n                // triggered during an async event, because this is how the legacy\n                // implementation of `act` behaved.\n                ReactCurrentActQueue.isBatchingLegacy = true;\n                var result; // This tracks whether the `act` call is awaited. In certain cases, not\n                // awaiting it is a mistake, so we will detect that and warn.\n                var didAwaitActCall = false;\n                try {\n                    // Reset this to `false` right before entering the React work loop. The\n                    // only place we ever read this fields is just below, right after running\n                    // the callback. So we don't need to reset after the callback runs.\n                    ReactCurrentActQueue.didScheduleLegacyUpdate = false;\n                    result = callback();\n                    var didScheduleLegacyUpdate = ReactCurrentActQueue.didScheduleLegacyUpdate; // Replicate behavior of original `act` implementation in legacy mode,\n                    // which flushed updates immediately after the scope function exits, even\n                    // if it's an async function.\n                    if (!prevIsBatchingLegacy && didScheduleLegacyUpdate) {\n                        flushActQueue(queue);\n                    } // `isBatchingLegacy` gets reset using the regular stack, not the async\n                    // one used to track `act` scopes. Why, you may be wondering? Because\n                    // that's how it worked before version 18. Yes, it's confusing! We should\n                    // delete legacy mode!!\n                    ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\n                } catch (error) {\n                    // `isBatchingLegacy` gets reset using the regular stack, not the async\n                    // one used to track `act` scopes. Why, you may be wondering? Because\n                    // that's how it worked before version 18. Yes, it's confusing! We should\n                    // delete legacy mode!!\n                    ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\n                    popActScope(prevActQueue, prevActScopeDepth);\n                    throw error;\n                }\n                if (result !== null && typeof result === \"object\" && // $FlowFixMe[method-unbinding]\n                typeof result.then === \"function\") {\n                    // A promise/thenable was returned from the callback. Wait for it to\n                    // resolve before flushing the queue.\n                    //\n                    // If `act` were implemented as an async function, this whole block could\n                    // be a single `await` call. That's really the only difference between\n                    // this branch and the next one.\n                    var thenable = result; // Warn if the an `act` call with an async scope is not awaited. In a\n                    // future release, consider making this an error.\n                    queueSeveralMicrotasks(function() {\n                        if (!didAwaitActCall && !didWarnNoAwaitAct) {\n                            didWarnNoAwaitAct = true;\n                            error(\"You called act(async () => ...) without await. \" + \"This could lead to unexpected testing behaviour, \" + \"interleaving multiple act calls and mixing their \" + \"scopes. \" + \"You should - await act(async () => ...);\");\n                        }\n                    });\n                    return {\n                        then: function(resolve, reject) {\n                            didAwaitActCall = true;\n                            thenable.then(function(returnValue) {\n                                popActScope(prevActQueue, prevActScopeDepth);\n                                if (prevActScopeDepth === 0) {\n                                    // We're exiting the outermost `act` scope. Flush the queue.\n                                    try {\n                                        flushActQueue(queue);\n                                        enqueueTask(function() {\n                                            return recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                                        });\n                                    } catch (error) {\n                                        // `thenable` might not be a real promise, and `flushActQueue`\n                                        // might throw, so we need to wrap `flushActQueue` in a\n                                        // try/catch.\n                                        reject(error);\n                                    }\n                                } else {\n                                    resolve(returnValue);\n                                }\n                            }, function(error) {\n                                popActScope(prevActQueue, prevActScopeDepth);\n                                reject(error);\n                            });\n                        }\n                    };\n                } else {\n                    var returnValue = result; // The callback is not an async function. Exit the current\n                    // scope immediately.\n                    popActScope(prevActQueue, prevActScopeDepth);\n                    if (prevActScopeDepth === 0) {\n                        // We're exiting the outermost `act` scope. Flush the queue.\n                        flushActQueue(queue); // If the queue is not empty, it implies that we intentionally yielded\n                        // to the main thread, because something suspended. We will continue\n                        // in an asynchronous task.\n                        //\n                        // Warn if something suspends but the `act` call is not awaited.\n                        // In a future release, consider making this an error.\n                        if (queue.length !== 0) {\n                            queueSeveralMicrotasks(function() {\n                                if (!didAwaitActCall && !didWarnNoAwaitAct) {\n                                    didWarnNoAwaitAct = true;\n                                    error(\"A component suspended inside an `act` scope, but the \" + \"`act` call was not awaited. When testing React \" + \"components that depend on asynchronous data, you must \" + \"await the result:\\n\\n\" + \"await act(() => ...)\");\n                                }\n                            });\n                        } // Like many things in this module, this is next part is confusing.\n                        //\n                        // We do not currently require every `act` call that is passed a\n                        // callback to be awaited, through arguably we should. Since this\n                        // callback was synchronous, we need to exit the current scope before\n                        // returning.\n                        //\n                        // However, if thenable we're about to return *is* awaited, we'll\n                        // immediately restore the current scope. So it shouldn't observable.\n                        //\n                        // This doesn't affect the case where the scope callback is async,\n                        // because we always require those calls to be awaited.\n                        //\n                        // TODO: In a future version, consider always requiring all `act` calls\n                        // to be awaited, regardless of whether the callback is sync or async.\n                        ReactCurrentActQueue.current = null;\n                    }\n                    return {\n                        then: function(resolve, reject) {\n                            didAwaitActCall = true;\n                            if (prevActScopeDepth === 0) {\n                                // If the `act` call is awaited, restore the queue we were\n                                // using before (see long comment above) so we can flush it.\n                                ReactCurrentActQueue.current = queue;\n                                enqueueTask(function() {\n                                    return recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                                });\n                            } else {\n                                resolve(returnValue);\n                            }\n                        }\n                    };\n                }\n            }\n        }\n        function popActScope(prevActQueue, prevActScopeDepth) {\n            {\n                if (prevActScopeDepth !== actScopeDepth - 1) {\n                    error(\"You seem to have overlapping act() calls, this is not supported. \" + \"Be sure to await previous act() calls before making a new one. \");\n                }\n                actScopeDepth = prevActScopeDepth;\n            }\n        }\n        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {\n            {\n                // Check if any tasks were scheduled asynchronously.\n                var queue = ReactCurrentActQueue.current;\n                if (queue !== null) {\n                    if (queue.length !== 0) {\n                        // Async tasks were scheduled, mostly likely in a microtask.\n                        // Keep flushing until there are no more.\n                        try {\n                            flushActQueue(queue); // The work we just performed may have schedule additional async\n                            // tasks. Wait a macrotask and check again.\n                            enqueueTask(function() {\n                                return recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                            });\n                        } catch (error) {\n                            // Leave remaining tasks on the queue if something throws.\n                            reject(error);\n                        }\n                    } else {\n                        // The queue is empty. We can finish.\n                        ReactCurrentActQueue.current = null;\n                        resolve(returnValue);\n                    }\n                } else {\n                    resolve(returnValue);\n                }\n            }\n        }\n        var isFlushing = false;\n        function flushActQueue(queue) {\n            {\n                if (!isFlushing) {\n                    // Prevent re-entrance.\n                    isFlushing = true;\n                    var i = 0;\n                    try {\n                        for(; i < queue.length; i++){\n                            var callback = queue[i];\n                            do {\n                                ReactCurrentActQueue.didUsePromise = false;\n                                var continuation = callback(false);\n                                if (continuation !== null) {\n                                    if (ReactCurrentActQueue.didUsePromise) {\n                                        // The component just suspended. Yield to the main thread in\n                                        // case the promise is already resolved. If so, it will ping in\n                                        // a microtask and we can resume without unwinding the stack.\n                                        queue[i] = callback;\n                                        queue.splice(0, i);\n                                        return;\n                                    }\n                                    callback = continuation;\n                                } else {\n                                    break;\n                                }\n                            }while (true);\n                        } // We flushed the entire queue.\n                        queue.length = 0;\n                    } catch (error) {\n                        // If something throws, leave the remaining callbacks on the queue.\n                        queue.splice(0, i + 1);\n                        throw error;\n                    } finally{\n                        isFlushing = false;\n                    }\n                }\n            }\n        } // Some of our warnings attempt to detect if the `act` call is awaited by\n        // checking in an asynchronous task. Wait a few microtasks before checking. The\n        // only reason one isn't sufficient is we want to accommodate the case where an\n        // `act` call is returned from an async function without first being awaited,\n        // since that's a somewhat common pattern. If you do this too many times in a\n        // nested sequence, you might get a warning, but you can always fix by awaiting\n        // the call.\n        //\n        // A macrotask would also work (and is the fallback) but depending on the test\n        // environment it may cause the warning to fire too late.\n        var queueSeveralMicrotasks = typeof queueMicrotask === \"function\" ? function(callback) {\n            queueMicrotask(function() {\n                return queueMicrotask(callback);\n            });\n        } : enqueueTask;\n        var createElement = createElementWithValidation;\n        var cloneElement = cloneElementWithValidation;\n        var createFactory = createFactoryWithValidation;\n        var Children = {\n            map: mapChildren,\n            forEach: forEachChildren,\n            count: countChildren,\n            toArray: toArray,\n            only: onlyChild\n        };\n        exports.Children = Children;\n        exports.Component = Component;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.Profiler = REACT_PROFILER_TYPE;\n        exports.PureComponent = PureComponent;\n        exports.StrictMode = REACT_STRICT_MODE_TYPE;\n        exports.Suspense = REACT_SUSPENSE_TYPE;\n        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;\n        exports.cache = cache;\n        exports.cloneElement = cloneElement;\n        exports.createContext = createContext;\n        exports.createElement = createElement;\n        exports.createFactory = createFactory;\n        exports.createRef = createRef;\n        exports.createServerContext = createServerContext;\n        exports.forwardRef = forwardRef;\n        exports.isValidElement = isValidElement;\n        exports.lazy = lazy;\n        exports.memo = memo;\n        exports.startTransition = startTransition;\n        exports.unstable_act = act;\n        exports.unstable_useCacheRefresh = useCacheRefresh;\n        exports.use = use;\n        exports.useCallback = useCallback;\n        exports.useContext = useContext;\n        exports.useDebugValue = useDebugValue;\n        exports.useDeferredValue = useDeferredValue;\n        exports.useEffect = useEffect;\n        exports.useId = useId;\n        exports.useImperativeHandle = useImperativeHandle;\n        exports.useInsertionEffect = useInsertionEffect;\n        exports.useLayoutEffect = useLayoutEffect;\n        exports.useMemo = useMemo;\n        exports.useReducer = useReducer;\n        exports.useRef = useRef;\n        exports.useState = useState;\n        exports.useSyncExternalStore = useSyncExternalStore;\n        exports.useTransition = useTransition;\n        exports.version = ReactVersion;\n        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n        }\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7O0NBUUMsR0FFRDtBQUVBLElBQUlBLElBQXFDLEVBQUU7SUFDeEM7UUFFTztRQUVWLHlDQUF5QyxHQUN6QyxJQUNFLE9BQU9DLG1DQUFtQyxlQUMxQyxPQUFPQSwrQkFBK0JDLDJCQUEyQixLQUMvRCxZQUNGO1lBQ0FELCtCQUErQkMsMkJBQTJCLENBQUMsSUFBSUM7UUFDakU7UUFDVSxJQUFJQyxlQUFlO1FBRTdCLFlBQVk7UUFDWix3Q0FBd0M7UUFDeEMsa0ZBQWtGO1FBQ2xGLHNEQUFzRDtRQUN0RCxJQUFJQyxxQkFBcUJDLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJQyxvQkFBb0JGLE9BQU9DLEdBQUcsQ0FBQztRQUNuQyxJQUFJRSxzQkFBc0JILE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJRyx5QkFBeUJKLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJSSxzQkFBc0JMLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJSyxzQkFBc0JOLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJTSxxQkFBcUJQLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJTyw0QkFBNEJSLE9BQU9DLEdBQUcsQ0FBQztRQUMzQyxJQUFJUSx5QkFBeUJULE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJUyxzQkFBc0JWLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJVSwyQkFBMkJYLE9BQU9DLEdBQUcsQ0FBQztRQUMxQyxJQUFJVyxrQkFBa0JaLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJWSxrQkFBa0JiLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJYSx1QkFBdUJkLE9BQU9DLEdBQUcsQ0FBQztRQUN0QyxJQUFJYyxtQkFBbUJmLE9BQU9DLEdBQUcsQ0FBQztRQUNsQyxJQUFJZSxnREFBZ0RoQixP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c0osbUJBQW1CLEdBQUduSztRQUN0Qm1LLGtCQUFrQixHQUFHbEw7UUFDckJrTCxxQkFBcUIsR0FBR2hLO1FBQ3hCZ0ssd0JBQXdCLEdBQUc3SjtRQUMzQjZKLGlCQUFpQixHQUFHeEs7UUFDcEJ3SyxhQUFhLEdBQUc1SjtRQUNoQjRKLDJCQUEyQixHQUFHaks7UUFDOUJpSywwQkFBMEIsR0FBR3JLO1FBQzdCcUssdUJBQXVCLEdBQUdwSztRQUMxQm9LLGVBQWUsR0FBR2xLO1FBQ2xCa0ssa0JBQWtCLEdBQUc3SztRQUNyQjZLLGNBQWMsR0FBRzFLO1FBQ2pCMEssZ0JBQWdCLEdBQUcvSztRQUNuQitLLDRCQUE0QixHQUFHM0o7UUFDL0IySixxQkFBcUIsR0FBRzlKO1FBQ3hCOEosZUFBZSxHQUFHdGY7UUFDUix5Q0FBeUMsR0FDbkQsSUFDRSxPQUFPSCxtQ0FBbUMsZUFDMUMsT0FBT0EsK0JBQStCa2dCLDBCQUEwQixLQUM5RCxZQUNGO1lBQ0FsZ0IsK0JBQStCa2dCLDBCQUEwQixDQUFDLElBQUloZ0I7UUFDaEU7SUFFRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2FoZWd1cnUtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzP2EyNWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQobmV3IEVycm9yKCkpO1xufVxuICAgICAgICAgIHZhciBSZWFjdFZlcnNpb24gPSAnMTguMy4wLWNhbmFyeS0xYTAwMWRhYzYtMjAyMzA4MTInO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc2VydmVyX2NvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIFJFQUNUX1NFUlZFUl9DT05URVhUX0RFRkFVTFRfVkFMVUVfTk9UX0xPQURFRCA9IFN5bWJvbC5mb3IoJ3JlYWN0LmRlZmF1bHRfdmFsdWUnKTtcbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBkaXNwYXRjaGVyLlxuICovXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxID0ge1xuICBjdXJyZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IENhY2hlIGRpc3BhdGNoZXIuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRDYWNoZSA9IHtcbiAgY3VycmVudDogbnVsbFxufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBiYXRjaCdzIGNvbmZpZ3VyYXRpb24gc3VjaCBhcyBob3cgbG9uZyBhbiB1cGRhdGVcbiAqIHNob3VsZCBzdXNwZW5kIGZvciBpZiBpdCBuZWVkcyB0by5cbiAqL1xudmFyIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnID0ge1xuICB0cmFuc2l0aW9uOiBudWxsXG59O1xuXG52YXIgUmVhY3RDdXJyZW50QWN0UXVldWUgPSB7XG4gIGN1cnJlbnQ6IG51bGwsXG4gIC8vIFVzZWQgdG8gcmVwcm9kdWNlIGJlaGF2aW9yIG9mIGBiYXRjaGVkVXBkYXRlc2AgaW4gbGVnYWN5IG1vZGUuXG4gIGlzQmF0Y2hpbmdMZWdhY3k6IGZhbHNlLFxuICBkaWRTY2hlZHVsZUxlZ2FjeVVwZGF0ZTogZmFsc2UsXG4gIC8vIFRyYWNrcyB3aGV0aGVyIHNvbWV0aGluZyBjYWxsZWQgYHVzZWAgZHVyaW5nIHRoZSBjdXJyZW50IGJhdGNoIG9mIHdvcmsuXG4gIC8vIERldGVybWluZXMgd2hldGhlciB3ZSBzaG91bGQgeWllbGQgdG8gbWljcm90YXNrcyB0byB1bndyYXAgYWxyZWFkeSByZXNvbHZlZFxuICAvLyBwcm9taXNlcyB3aXRob3V0IHN1c3BlbmRpbmcuXG4gIGRpZFVzZVByb21pc2U6IGZhbHNlXG59O1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVyLlxuICpcbiAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcbiAqIGN1cnJlbnRseSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqL1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSB7fTtcbnZhciBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gbnVsbDtcbmZ1bmN0aW9uIHNldEV4dHJhU3RhY2tGcmFtZShzdGFjaykge1xuICB7XG4gICAgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IHN0YWNrO1xuICB9XG59XG5cbntcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZSA9IGZ1bmN0aW9uIChzdGFjaykge1xuICAgIHtcbiAgICAgIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBzdGFjaztcbiAgICB9XG4gIH07IC8vIFN0YWNrIGltcGxlbWVudGF0aW9uIGluamVjdGVkIGJ5IHRoZSBjdXJyZW50IHJlbmRlcmVyLlxuXG5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLmdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YWNrID0gJyc7IC8vIEFkZCBhbiBleHRyYSB0b3AgZnJhbWUgd2hpbGUgYW4gZWxlbWVudCBpcyBiZWluZyB2YWxpZGF0ZWRcblxuICAgIGlmIChjdXJyZW50RXh0cmFTdGFja0ZyYW1lKSB7XG4gICAgICBzdGFjayArPSBjdXJyZW50RXh0cmFTdGFja0ZyYW1lO1xuICAgIH0gLy8gRGVsZWdhdGUgdG8gdGhlIGluamVjdGVkIHJlbmRlcmVyLXNwZWNpZmljIGltcGxlbWVudGF0aW9uXG5cblxuICAgIHZhciBpbXBsID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLmdldEN1cnJlbnRTdGFjaztcblxuICAgIGlmIChpbXBsKSB7XG4gICAgICBzdGFjayArPSBpbXBsKCkgfHwgJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG4vLyBzdHVmZi4gSW50ZW5kZWQgdG8gZW5hYmxlIFJlYWN0IGNvcmUgbWVtYmVycyB0byBtb3JlIGVhc2lseSBkZWJ1ZyBzY2hlZHVsaW5nXG4vLyBpc3N1ZXMgaW4gREVWIGJ1aWxkcy5cblxudmFyIGVuYWJsZURlYnVnVHJhY2luZyA9IGZhbHNlOyAvLyBUcmFjayB3aGljaCBGaWJlcihzKSBzY2hlZHVsZSByZW5kZXIgd29yay5cblxudmFyIENvbnRleHRSZWdpc3RyeSQxID0ge307XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IHtcbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjogUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLFxuICBSZWFjdEN1cnJlbnRDYWNoZTogUmVhY3RDdXJyZW50Q2FjaGUsXG4gIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnOiBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyxcbiAgUmVhY3RDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyXG59O1xuXG57XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDE7XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudEFjdFF1ZXVlID0gUmVhY3RDdXJyZW50QWN0UXVldWU7XG59XG5cbntcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuQ29udGV4dFJlZ2lzdHJ5ID0gQ29udGV4dFJlZ2lzdHJ5JDE7XG59XG5cbi8vIGJ5IGNhbGxzIHRvIHRoZXNlIG1ldGhvZHMgYnkgYSBCYWJlbCBwbHVnaW4uXG4vL1xuLy8gSW4gUFJPRCAob3IgaW4gcGFja2FnZXMgd2l0aG91dCBhY2Nlc3MgdG8gUmVhY3QgaW50ZXJuYWxzKSxcbi8vIHRoZXkgYXJlIGxlZnQgYXMgdGhleSBhcmUgaW5zdGVhZC5cblxuZnVuY3Rpb24gd2Fybihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnd2FybicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBfY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IF9jb25zdHJ1Y3RvciAmJiAoX2NvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IF9jb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgXCIuXCIgKyBjYWxsZXJOYW1lO1xuXG4gICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVycm9yKFwiQ2FuJ3QgY2FsbCAlcyBvbiBhIGNvbXBvbmVudCB0aGF0IGlzIG5vdCB5ZXQgbW91bnRlZC4gXCIgKyAnVGhpcyBpcyBhIG5vLW9wLCBidXQgaXQgbWlnaHQgaW5kaWNhdGUgYSBidWcgaW4geW91ciBhcHBsaWNhdGlvbi4gJyArICdJbnN0ZWFkLCBhc3NpZ24gdG8gYHRoaXMuc3RhdGVgIGRpcmVjdGx5IG9yIGRlZmluZSBhIGBzdGF0ZSA9IHt9O2AgJyArICdjbGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBkZXNpcmVkIHN0YXRlIGluIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0gPSB0cnVlO1xuICB9XG59XG4vKipcbiAqIFRoaXMgaXMgdGhlIGFic3RyYWN0IEFQSSBmb3IgYW4gdXBkYXRlIHF1ZXVlLlxuICovXG5cblxudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IE5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gIH1cbn07XG5cbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxue1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cblxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDsgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG4vKipcbiAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXG4gKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcbiAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAqIGNvbXBsZXRlZC5cbiAqXG4gKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cbiAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxuICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcbiAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXG4gKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxuICogYXNzaWduZWQgdG8gdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xuICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBwYXJ0aWFsU3RhdGUgIT09ICdvYmplY3QnICYmIHR5cGVvZiBwYXJ0aWFsU3RhdGUgIT09ICdmdW5jdGlvbicgJiYgcGFydGlhbFN0YXRlICE9IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgJyArICdmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuJyk7XG4gIH1cblxuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xufTtcbi8qKlxuICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gKlxuICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gKlxuICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAqXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZS5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5cblxuQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbn07XG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xuXG5cbntcbiAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcbiAgICByZXBsYWNlU3RhdGU6IFsncmVwbGFjZVN0YXRlJywgJ1JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlICcgKyAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS4nXVxuICB9O1xuXG4gIHZhciBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5mbykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2FybignJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXMnLCBpbmZvWzBdLCBpbmZvWzFdKTtcblxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQ29tcG9uZW50RHVtbXkoKSB7fVxuXG5Db21wb25lbnREdW1teS5wcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuLyoqXG4gKiBDb252ZW5pZW5jZSBjb21wb25lbnQgd2l0aCBkZWZhdWx0IHNoYWxsb3cgZXF1YWxpdHkgY2hlY2sgZm9yIHNDVS5cbiAqL1xuXG5mdW5jdGlvbiBQdXJlQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgLy8gSWYgYSBjb21wb25lbnQgaGFzIHN0cmluZyByZWZzLCB3ZSB3aWxsIGFzc2lnbiBhIGRpZmZlcmVudCBvYmplY3QgbGF0ZXIuXG5cbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbnZhciBwdXJlQ29tcG9uZW50UHJvdG90eXBlID0gUHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuY29uc3RydWN0b3IgPSBQdXJlQ29tcG9uZW50OyAvLyBBdm9pZCBhbiBleHRyYSBwcm90b3R5cGUganVtcCBmb3IgdGhlc2UgbWV0aG9kcy5cblxuYXNzaWduKHB1cmVDb21wb25lbnRQcm90b3R5cGUsIENvbXBvbmVudC5wcm90b3R5cGUpO1xucHVyZUNvbXBvbmVudFByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG5cbi8vIGFuIGltbXV0YWJsZSBvYmplY3Qgd2l0aCBhIHNpbmdsZSBtdXRhYmxlIHZhbHVlXG5mdW5jdGlvbiBjcmVhdGVSZWYoKSB7XG4gIHZhciByZWZPYmplY3QgPSB7XG4gICAgY3VycmVudDogbnVsbFxuICB9O1xuXG4gIHtcbiAgICBPYmplY3Quc2VhbChyZWZPYmplY3QpO1xuICB9XG5cbiAgcmV0dXJuIHJlZk9iamVjdDtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vKlxuICogVGhlIGAnJyArIHZhbHVlYCBwYXR0ZXJuICh1c2VkIGluIHBlcmYtc2Vuc2l0aXZlIGNvZGUpIHRocm93cyBmb3IgU3ltYm9sXG4gKiBhbmQgVGVtcG9yYWwuKiB0eXBlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIyMDY0LlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgd2lsbCB0aHJvdyBhbiBlYXNpZXItdG8tdW5kZXJzdGFuZCxcbiAqIGVhc2llci10by1kZWJ1ZyBleGNlcHRpb24gd2l0aCBhIGNsZWFyIGVycm9ycyBtZXNzYWdlIG1lc3NhZ2UgZXhwbGFpbmluZyB0aGVcbiAqIHByb2JsZW0uIChJbnN0ZWFkIG9mIGEgY29uZnVzaW5nIGV4Y2VwdGlvbiB0aHJvd24gaW5zaWRlIHRoZSBpbXBsZW1lbnRhdGlvblxuICogb2YgdGhlIGB2YWx1ZWAgb2JqZWN0KS5cbiAqL1xuLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cbmZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XG4gIHtcbiAgICAvLyB0b1N0cmluZ1RhZyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZWQgdHlwZXMgbGlrZSBUZW1wb3JhbC5JbnN0YW50XG4gICAgdmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWc7XG4gICAgdmFyIHR5cGUgPSBoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ09iamVjdCc7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cblxuICAgIHJldHVybiB0eXBlO1xuICB9XG59IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5cblxuZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcbiAge1xuICAgIHRyeSB7XG4gICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgLy8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXG4gIC8vIGhhcHBlbmVkOiB5b3Ugc3VwcGxpZWQgYW4gb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBSZWFjdCAoYXMgYSBwcm9wLCBrZXksXG4gIC8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cbiAgLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4gIC8vXG4gIC8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xuICAvLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxuICAvLyBgdmFsdWVPZmAgb3IgYFtTeW1ib2wudG9QcmltaXRpdmVdYCBtZXRob2QgdGhhdCB0aHJvd3Mgd2lsbCBhbHNvIGNhdXNlIHRoaXNcbiAgLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXG4gIC8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxuICAvLyBtZXRob2RzIGFyZSBuZWVkZWQgdG8gcGVyZm9ybSBhY2N1cmF0ZSBhcml0aG1ldGljIG9yIGNvbXBhcmlzb24uKVxuICAvL1xuICAvLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXG4gIC8vIHBhc3NpbmcgaXQgdG8gUmVhY3QuIFRoZSBtb3N0IHJlbGlhYmxlIHdheSBpcyB1c3VhbGx5IGBTdHJpbmcodmFsdWUpYC5cbiAgLy9cbiAgLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cbiAgLy8gQmVmb3JlIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlIHNob3VsZCBiZSBgY29uc29sZS5lcnJvcmAgb3V0cHV0XG4gIC8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcbiAgLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBjb25zb2xlIG91dHB1dCBhbHNvIHNob3dzIHRoZSBjb21wb25lbnQgYW5kIGl0c1xuICAvLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXG4gIC8vXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICByZXR1cm4gJycgKyB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lO1xuXG4gIGlmIChkaXNwbGF5TmFtZSkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgfVxuXG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XG59IC8vIEtlZXAgaW4gc3luYyB3aXRoIHJlYWN0LXJlY29uY2lsZXIvZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlclxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufSAvLyBOb3RlIHRoYXQgdGhlIHJlY29uY2lsZXIgcGFja2FnZSBzaG91bGQgZ2VuZXJhbGx5IHByZWZlciB0byB1c2UgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcigpIGluc3RlYWQuXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY29udGV4dDIgPSB0eXBlO1xuICAgICAgICAgIHJldHVybiAoY29udGV4dDIuZGlzcGxheU5hbWUgfHwgY29udGV4dDIuX2dsb2JhbE5hbWUpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duLCBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biwgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgY29uZmlnLl9fc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gY29uZmlnLl9fc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGNvbXBvbmVudE5hbWUsIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG5mdW5jdGlvbiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIga2V5ID0gbnVsbDtcbiAgdmFyIHJlZiA9IG51bGw7XG4gIHZhciBzZWxmID0gbnVsbDtcbiAgdmFyIHNvdXJjZSA9IG51bGw7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG5cbiAgICAgIHtcbiAgICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG5cblxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcblxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkQXJyYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbn1cbmZ1bmN0aW9uIGNsb25lQW5kUmVwbGFjZUtleShvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG4vKipcbiAqIENsb25lIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IHVzaW5nIGVsZW1lbnQgYXMgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjbG9uZWVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnQkMShlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIGlmIChlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlJlYWN0LmNsb25lRWxlbWVudCguLi4pOiBUaGUgYXJndW1lbnQgbXVzdCBiZSBhIFJlYWN0IGVsZW1lbnQsIGJ1dCB5b3UgcGFzc2VkIFwiICsgZWxlbWVudCArIFwiLlwiKTtcbiAgfVxuXG4gIHZhciBwcm9wTmFtZTsgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxuXG4gIHZhciBwcm9wcyA9IGFzc2lnbih7fSwgZWxlbWVudC5wcm9wcyk7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjsgLy8gU2VsZiBpcyBwcmVzZXJ2ZWQgc2luY2UgdGhlIG93bmVyIGlzIHByZXNlcnZlZC5cblxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7IC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuXG4gIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7IC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG5cblxuICAgIHZhciBkZWZhdWx0UHJvcHM7XG5cbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgfVxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgaWYgKGNvbmZpZ1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuXG5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG5cbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuXG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuXG52YXIgU0VQQVJBVE9SID0gJy4nO1xudmFyIFNVQlNFUEFSQVRPUiA9ICc6Jztcbi8qKlxuICogRXNjYXBlIGFuZCB3cmFwIGtleSBzbyBpdCBpcyBzYWZlIHRvIHVzZSBhcyBhIHJlYWN0aWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlc2NhcGVkIGtleS5cbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGUoa2V5KSB7XG4gIHZhciBlc2NhcGVSZWdleCA9IC9bPTpdL2c7XG4gIHZhciBlc2NhcGVyTG9va3VwID0ge1xuICAgICc9JzogJz0wJyxcbiAgICAnOic6ICc9MidcbiAgfTtcbiAgdmFyIGVzY2FwZWRTdHJpbmcgPSBrZXkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcbiAgcmV0dXJuICckJyArIGVzY2FwZWRTdHJpbmc7XG59XG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuXG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gdGV4dC5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCAnJCYvJyk7XG59XG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBlbGVtZW50IHdpdGhpbiBhIHNldC5cbiAqXG4gKiBAcGFyYW0geyp9IGVsZW1lbnQgQSBlbGVtZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRFbGVtZW50S2V5KGVsZW1lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdvYmplY3QnICYmIGVsZW1lbnQgIT09IG51bGwgJiYgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHtcbiAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oZWxlbWVudC5rZXkpO1xuICAgIH1cblxuICAgIHJldHVybiBlc2NhcGUoJycgKyBlbGVtZW50LmtleSk7XG4gIH0gLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcblxuXG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG59XG5cbmZ1bmN0aW9uIG1hcEludG9BcnJheShjaGlsZHJlbiwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5hbWVTb0ZhciwgY2FsbGJhY2spIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIHZhciBpbnZva2VDYWxsYmFjayA9IGZhbHNlO1xuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBzd2l0Y2ggKGNoaWxkcmVuLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfVxuICB9XG5cbiAgaWYgKGludm9rZUNhbGxiYWNrKSB7XG4gICAgdmFyIF9jaGlsZCA9IGNoaWxkcmVuO1xuICAgIHZhciBtYXBwZWRDaGlsZCA9IGNhbGxiYWNrKF9jaGlsZCk7IC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93czpcblxuICAgIHZhciBjaGlsZEtleSA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRFbGVtZW50S2V5KF9jaGlsZCwgMCkgOiBuYW1lU29GYXI7XG5cbiAgICBpZiAoaXNBcnJheShtYXBwZWRDaGlsZCkpIHtcbiAgICAgIHZhciBlc2NhcGVkQ2hpbGRLZXkgPSAnJztcblxuICAgICAgaWYgKGNoaWxkS2V5ICE9IG51bGwpIHtcbiAgICAgICAgZXNjYXBlZENoaWxkS2V5ID0gZXNjYXBlVXNlclByb3ZpZGVkS2V5KGNoaWxkS2V5KSArICcvJztcbiAgICAgIH1cblxuICAgICAgbWFwSW50b0FycmF5KG1hcHBlZENoaWxkLCBhcnJheSwgZXNjYXBlZENoaWxkS2V5LCAnJywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChtYXBwZWRDaGlsZCkpIHtcbiAgICAgICAge1xuICAgICAgICAgIC8vIFRoZSBgaWZgIHN0YXRlbWVudCBoZXJlIHByZXZlbnRzIGF1dG8tZGlzYWJsaW5nIG9mIHRoZSBzYWZlXG4gICAgICAgICAgLy8gY29lcmNpb24gRVNMaW50IHJ1bGUsIHNvIHdlIG11c3QgbWFudWFsbHkgZGlzYWJsZSBpdCBiZWxvdy5cbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBSZWFjdC5Qb3J0YWwgZG9lc24ndCBoYXZlIGEga2V5XG4gICAgICAgICAgaWYgKG1hcHBlZENoaWxkLmtleSAmJiAoIV9jaGlsZCB8fCBfY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpKSB7XG4gICAgICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKG1hcHBlZENoaWxkLmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWFwcGVkQ2hpbGQgPSBjbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAgICBlc2NhcGVkUHJlZml4ICsgKCAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBSZWFjdC5Qb3J0YWwgZG9lc24ndCBoYXZlIGEga2V5XG4gICAgICAgIG1hcHBlZENoaWxkLmtleSAmJiAoIV9jaGlsZCB8fCBfY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gZXNjYXBlVXNlclByb3ZpZGVkS2V5KCAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hZGRpdGlvbl1cbiAgICAgICAgJycgKyBtYXBwZWRDaGlsZC5rZXkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgICAgICApICsgJy8nIDogJycpICsgY2hpbGRLZXkpO1xuICAgICAgfVxuXG4gICAgICBhcnJheS5wdXNoKG1hcHBlZENoaWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZDtcbiAgdmFyIG5leHROYW1lO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cblxuICB2YXIgbmV4dE5hbWVQcmVmaXggPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xuXG4gIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0RWxlbWVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gbWFwSW50b0FycmF5KGNoaWxkLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmV4dE5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGl0ZXJhYmxlQ2hpbGRyZW4gPSBjaGlsZHJlbjtcblxuICAgICAge1xuICAgICAgICAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gPT09IGl0ZXJhYmxlQ2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgIGlmICghZGlkV2FybkFib3V0TWFwcykge1xuICAgICAgICAgICAgd2FybignVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1VzZSBhbiBhcnJheSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGl0ZXJhYmxlQ2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICB2YXIgaWkgPSAwOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGBpdGVyYXRvckZuYCBtaWdodCByZXR1cm4gbnVsbCBhY2NvcmRpbmcgdG8gdHlwaW5nLlxuXG4gICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldEVsZW1lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICBzdWJ0cmVlQ291bnQgKz0gbWFwSW50b0FycmF5KGNoaWxkLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmV4dE5hbWUsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9IFN0cmluZyhjaGlsZHJlbik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICsgKGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZykgKyBcIikuIFwiICsgJ0lmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm1hcFxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmdW5jIFRoZSBtYXAgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICovXG5cblxuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBjb3VudCA9IDA7XG4gIG1hcEludG9BcnJheShjaGlsZHJlbiwgcmVzdWx0LCAnJywgJycsIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGNvdW50KyspO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzXG4gKiBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbmNvdW50XG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cblxuXG5mdW5jdGlvbiBjb3VudENoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHZhciBuID0gMDtcbiAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICgpIHtcbiAgICBuKys7IC8vIERvbid0IHJldHVybiBhbnl0aGluZ1xuICB9KTtcbiAgcmV0dXJuIG47XG59XG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbmZvcmVhY2hcbiAqXG4gKiBUaGUgcHJvdmlkZWQgZm9yRWFjaEZ1bmMoY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZm9yRWFjaEZ1bmNcbiAqIEBwYXJhbSB7Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCBmb3IgZm9yRWFjaENvbnRleHQuXG4gKi9cblxuXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgLy8gJEZsb3dGaXhNZVttaXNzaW5nLXRoaXMtYW5ub3RdXG4gIGZ1bmN0aW9uICgpIHtcbiAgICBmb3JFYWNoRnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBEb24ndCByZXR1cm4gYW55dGhpbmcuXG4gIH0sIGZvckVhY2hDb250ZXh0KTtcbn1cbi8qKlxuICogRmxhdHRlbiBhIGNoaWxkcmVuIG9iamVjdCAodHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gKSBhbmRcbiAqIHJldHVybiBhbiBhcnJheSB3aXRoIGFwcHJvcHJpYXRlbHkgcmUta2V5ZWQgY2hpbGRyZW4uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVudG9hcnJheVxuICovXG5cblxuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICByZXR1cm4gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZDtcbiAgfSkgfHwgW107XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVub25seVxuICpcbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcbiAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXG4gKiBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZSBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0RWxlbWVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5cblxuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gIGlmICghaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC4nKTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUpIHtcbiAgLy8gVE9ETzogU2Vjb25kIGFyZ3VtZW50IHVzZWQgdG8gYmUgYW4gb3B0aW9uYWwgYGNhbGN1bGF0ZUNoYW5nZWRCaXRzYFxuICAvLyBmdW5jdGlvbi4gV2FybiB0byByZXNlcnZlIGZvciBmdXR1cmUgdXNlP1xuICB2YXIgY29udGV4dCA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgIC8vIEFzIGEgd29ya2Fyb3VuZCB0byBzdXBwb3J0IG11bHRpcGxlIGNvbmN1cnJlbnQgcmVuZGVyZXJzLCB3ZSBjYXRlZ29yaXplXG4gICAgLy8gc29tZSByZW5kZXJlcnMgYXMgcHJpbWFyeSBhbmQgb3RoZXJzIGFzIHNlY29uZGFyeS4gV2Ugb25seSBleHBlY3RcbiAgICAvLyB0aGVyZSB0byBiZSB0d28gY29uY3VycmVudCByZW5kZXJlcnMgYXQgbW9zdDogUmVhY3QgTmF0aXZlIChwcmltYXJ5KSBhbmRcbiAgICAvLyBGYWJyaWMgKHNlY29uZGFyeSk7IFJlYWN0IERPTSAocHJpbWFyeSkgYW5kIFJlYWN0IEFSVCAoc2Vjb25kYXJ5KS5cbiAgICAvLyBTZWNvbmRhcnkgcmVuZGVyZXJzIHN0b3JlIHRoZWlyIGNvbnRleHQgdmFsdWVzIG9uIHNlcGFyYXRlIGZpZWxkcy5cbiAgICBfY3VycmVudFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgX2N1cnJlbnRWYWx1ZTI6IGRlZmF1bHRWYWx1ZSxcbiAgICAvLyBVc2VkIHRvIHRyYWNrIGhvdyBtYW55IGNvbmN1cnJlbnQgcmVuZGVyZXJzIHRoaXMgY29udGV4dCBjdXJyZW50bHlcbiAgICAvLyBzdXBwb3J0cyB3aXRoaW4gaW4gYSBzaW5nbGUgcmVuZGVyZXIuIFN1Y2ggYXMgcGFyYWxsZWwgc2VydmVyIHJlbmRlcmluZy5cbiAgICBfdGhyZWFkQ291bnQ6IDAsXG4gICAgLy8gVGhlc2UgYXJlIGNpcmN1bGFyXG4gICAgUHJvdmlkZXI6IG51bGwsXG4gICAgQ29uc3VtZXI6IG51bGwsXG4gICAgLy8gQWRkIHRoZXNlIHRvIHVzZSBzYW1lIGhpZGRlbiBjbGFzcyBpbiBWTSBhcyBTZXJ2ZXJDb250ZXh0XG4gICAgX2RlZmF1bHRWYWx1ZTogbnVsbCxcbiAgICBfZ2xvYmFsTmFtZTogbnVsbFxuICB9O1xuICBjb250ZXh0LlByb3ZpZGVyID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9QUk9WSURFUl9UWVBFLFxuICAgIF9jb250ZXh0OiBjb250ZXh0XG4gIH07XG4gIHZhciBoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycyA9IGZhbHNlO1xuICB2YXIgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIgPSBmYWxzZTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyID0gZmFsc2U7XG5cbiAge1xuICAgIC8vIEEgc2VwYXJhdGUgb2JqZWN0LCBidXQgcHJveGllcyBiYWNrIHRvIHRoZSBvcmlnaW5hbCBjb250ZXh0IG9iamVjdCBmb3JcbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gSXQgaGFzIGEgZGlmZmVyZW50ICQkdHlwZW9mLCBzbyB3ZSBjYW4gcHJvcGVybHlcbiAgICAvLyB3YXJuIGZvciB0aGUgaW5jb3JyZWN0IHVzYWdlIG9mIENvbnRleHQgYXMgYSBDb25zdW1lci5cbiAgICB2YXIgQ29uc3VtZXIgPSB7XG4gICAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgICAgX2NvbnRleHQ6IGNvbnRleHRcbiAgICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ106IEZsb3cgY29tcGxhaW5zIGFib3V0IG5vdCBzZXR0aW5nIGEgdmFsdWUsIHdoaWNoIGlzIGludGVudGlvbmFsIGhlcmVcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENvbnN1bWVyLCB7XG4gICAgICBQcm92aWRlcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciA9IHRydWU7XG5cbiAgICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuUHJvdmlkZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuUHJvdmlkZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuUHJvdmlkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9Qcm92aWRlcikge1xuICAgICAgICAgIGNvbnRleHQuUHJvdmlkZXIgPSBfUHJvdmlkZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY3VycmVudFZhbHVlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBfY3VycmVudFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2N1cnJlbnRWYWx1ZTI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUyKSB7XG4gICAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlMiA9IF9jdXJyZW50VmFsdWUyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX3RocmVhZENvdW50OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll90aHJlYWRDb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX3RocmVhZENvdW50KSB7XG4gICAgICAgICAgY29udGV4dC5fdGhyZWFkQ291bnQgPSBfdGhyZWFkQ291bnQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBDb25zdW1lcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycyA9IHRydWU7XG5cbiAgICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuQ29uc3VtZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuQ29uc3VtZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuQ29uc3VtZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkaXNwbGF5TmFtZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5kaXNwbGF5TmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyKSB7XG4gICAgICAgICAgICB3YXJuKCdTZXR0aW5nIGBkaXNwbGF5TmFtZWAgb24gQ29udGV4dC5Db25zdW1lciBoYXMgbm8gZWZmZWN0LiAnICsgXCJZb3Ugc2hvdWxkIHNldCBpdCBkaXJlY3RseSBvbiB0aGUgY29udGV4dCB3aXRoIENvbnRleHQuZGlzcGxheU5hbWUgPSAnJXMnLlwiLCBkaXNwbGF5TmFtZSk7XG5cbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddOiBGbG93IGNvbXBsYWlucyBhYm91dCBtaXNzaW5nIHByb3BlcnRpZXMgYmVjYXVzZSBpdCBkb2Vzbid0IHVuZGVyc3RhbmQgZGVmaW5lUHJvcGVydHlcblxuICAgIGNvbnRleHQuQ29uc3VtZXIgPSBDb25zdW1lcjtcbiAgfVxuXG4gIHtcbiAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSBudWxsO1xuICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbnZhciBVbmluaXRpYWxpemVkID0gLTE7XG52YXIgUGVuZGluZyA9IDA7XG52YXIgUmVzb2x2ZWQgPSAxO1xudmFyIFJlamVjdGVkID0gMjtcblxuZnVuY3Rpb24gbGF6eUluaXRpYWxpemVyKHBheWxvYWQpIHtcbiAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gVW5pbml0aWFsaXplZCkge1xuICAgIHZhciBjdG9yID0gcGF5bG9hZC5fcmVzdWx0O1xuICAgIHZhciB0aGVuYWJsZSA9IGN0b3IoKTsgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICAvLyBUaGlzIG1pZ2h0IHRocm93IGVpdGhlciBiZWNhdXNlIGl0J3MgbWlzc2luZyBvciB0aHJvd3MuIElmIHNvLCB3ZSB0cmVhdCBpdFxuICAgIC8vIGFzIHN0aWxsIHVuaW5pdGlhbGl6ZWQgYW5kIHRyeSBhZ2FpbiBuZXh0IHRpbWUuIFdoaWNoIGlzIHRoZSBzYW1lIGFzIHdoYXRcbiAgICAvLyBoYXBwZW5zIGlmIHRoZSBjdG9yIG9yIGFueSB3cmFwcGVycyBwcm9jZXNzaW5nIHRoZSBjdG9yIHRocm93cy4gVGhpcyBtaWdodFxuICAgIC8vIGVuZCB1cCBmaXhpbmcgaXQgaWYgdGhlIHJlc29sdXRpb24gd2FzIGEgY29uY3VycmVuY3kgYnVnLlxuXG4gICAgdGhlbmFibGUudGhlbihmdW5jdGlvbiAobW9kdWxlT2JqZWN0KSB7XG4gICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBQZW5kaW5nIHx8IHBheWxvYWQuX3N0YXR1cyA9PT0gVW5pbml0aWFsaXplZCkge1xuICAgICAgICAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgICAgICB2YXIgcmVzb2x2ZWQgPSBwYXlsb2FkO1xuICAgICAgICByZXNvbHZlZC5fc3RhdHVzID0gUmVzb2x2ZWQ7XG4gICAgICAgIHJlc29sdmVkLl9yZXN1bHQgPSBtb2R1bGVPYmplY3Q7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBQZW5kaW5nIHx8IHBheWxvYWQuX3N0YXR1cyA9PT0gVW5pbml0aWFsaXplZCkge1xuICAgICAgICAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBwYXlsb2FkO1xuICAgICAgICByZWplY3RlZC5fc3RhdHVzID0gUmVqZWN0ZWQ7XG4gICAgICAgIHJlamVjdGVkLl9yZXN1bHQgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIC8vIEluIGNhc2UsIHdlJ3JlIHN0aWxsIHVuaW5pdGlhbGl6ZWQsIHRoZW4gd2UncmUgd2FpdGluZyBmb3IgdGhlIHRoZW5hYmxlXG4gICAgICAvLyB0byByZXNvbHZlLiBTZXQgaXQgYXMgcGVuZGluZyBpbiB0aGUgbWVhbnRpbWUuXG4gICAgICB2YXIgcGVuZGluZyA9IHBheWxvYWQ7XG4gICAgICBwZW5kaW5nLl9zdGF0dXMgPSBQZW5kaW5nO1xuICAgICAgcGVuZGluZy5fcmVzdWx0ID0gdGhlbmFibGU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUmVzb2x2ZWQpIHtcbiAgICB2YXIgbW9kdWxlT2JqZWN0ID0gcGF5bG9hZC5fcmVzdWx0O1xuXG4gICAge1xuICAgICAgaWYgKG1vZHVsZU9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVycm9yKCdsYXp5OiBFeHBlY3RlZCB0aGUgcmVzdWx0IG9mIGEgZHluYW1pYyBpbXAnICsgJ29ydCgpIGNhbGwuICcgKyAnSW5zdGVhZCByZWNlaXZlZDogJXNcXG5cXG5Zb3VyIGNvZGUgc2hvdWxkIGxvb2sgbGlrZTogXFxuICAnICsgLy8gQnJlYWsgdXAgaW1wb3J0cyB0byBhdm9pZCBhY2NpZGVudGFsbHkgcGFyc2luZyB0aGVtIGFzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgJ2NvbnN0IE15Q29tcG9uZW50ID0gbGF6eSgoKSA9PiBpbXAnICsgXCJvcnQoJy4vTXlDb21wb25lbnQnKSlcXG5cXG5cIiArICdEaWQgeW91IGFjY2lkZW50YWxseSBwdXQgY3VybHkgYnJhY2VzIGFyb3VuZCB0aGUgaW1wb3J0PycsIG1vZHVsZU9iamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKCEoJ2RlZmF1bHQnIGluIG1vZHVsZU9iamVjdCkpIHtcbiAgICAgICAgZXJyb3IoJ2xhenk6IEV4cGVjdGVkIHRoZSByZXN1bHQgb2YgYSBkeW5hbWljIGltcCcgKyAnb3J0KCkgY2FsbC4gJyArICdJbnN0ZWFkIHJlY2VpdmVkOiAlc1xcblxcbllvdXIgY29kZSBzaG91bGQgbG9vayBsaWtlOiBcXG4gICcgKyAvLyBCcmVhayB1cCBpbXBvcnRzIHRvIGF2b2lkIGFjY2lkZW50YWxseSBwYXJzaW5nIHRoZW0gYXMgZGVwZW5kZW5jaWVzLlxuICAgICAgICAnY29uc3QgTXlDb21wb25lbnQgPSBsYXp5KCgpID0+IGltcCcgKyBcIm9ydCgnLi9NeUNvbXBvbmVudCcpKVwiLCBtb2R1bGVPYmplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtb2R1bGVPYmplY3QuZGVmYXVsdDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBwYXlsb2FkLl9yZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGF6eShjdG9yKSB7XG4gIHZhciBwYXlsb2FkID0ge1xuICAgIC8vIFdlIHVzZSB0aGVzZSBmaWVsZHMgdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAgICBfc3RhdHVzOiBVbmluaXRpYWxpemVkLFxuICAgIF9yZXN1bHQ6IGN0b3JcbiAgfTtcbiAgdmFyIGxhenlUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9MQVpZX1RZUEUsXG4gICAgX3BheWxvYWQ6IHBheWxvYWQsXG4gICAgX2luaXQ6IGxhenlJbml0aWFsaXplclxuICB9O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kdWN0aW9uLCB0aGlzIHdvdWxkIGp1c3Qgc2V0IGl0IG9uIHRoZSBvYmplY3QuXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcbiAgICB2YXIgcHJvcFR5cGVzOyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGxhenlUeXBlLCB7XG4gICAgICBkZWZhdWx0UHJvcHM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdFByb3BzO1xuICAgICAgICB9LFxuICAgICAgICAvLyAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0RlZmF1bHRQcm9wcykge1xuICAgICAgICAgIGVycm9yKCdSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBkZWZhdWx0UHJvcHNgIHRvICcgKyAnYSBsYXp5IGNvbXBvbmVudCBpbXBvcnQuIEVpdGhlciBzcGVjaWZ5IHRoZW0gd2hlcmUgdGhlIGNvbXBvbmVudCAnICsgJ2lzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuJyk7XG5cbiAgICAgICAgICBkZWZhdWx0UHJvcHMgPSBuZXdEZWZhdWx0UHJvcHM7IC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuICAgICAgICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAnZGVmYXVsdFByb3BzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJvcFR5cGVzOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BUeXBlcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gJEZsb3dGaXhNZVttaXNzaW5nLWxvY2FsLWFubm90XVxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdQcm9wVHlwZXMpIHtcbiAgICAgICAgICBlcnJvcignUmVhY3QubGF6eSguLi4pOiBJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIGFzc2lnbiBgcHJvcFR5cGVzYCB0byAnICsgJ2EgbGF6eSBjb21wb25lbnQgaW1wb3J0LiBFaXRoZXIgc3BlY2lmeSB0aGVtIHdoZXJlIHRoZSBjb21wb25lbnQgJyArICdpcyBkZWZpbmVkLCBvciBjcmVhdGUgYSB3cmFwcGluZyBjb21wb25lbnQgYXJvdW5kIGl0LicpO1xuXG4gICAgICAgICAgcHJvcFR5cGVzID0gbmV3UHJvcFR5cGVzOyAvLyBNYXRjaCBwcm9kdWN0aW9uIGJlaGF2aW9yIG1vcmUgY2xvc2VseTpcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ3Byb3BUeXBlcycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGxhenlUeXBlO1xufVxuXG5mdW5jdGlvbiBmb3J3YXJkUmVmKHJlbmRlcikge1xuICB7XG4gICAgaWYgKHJlbmRlciAhPSBudWxsICYmIHJlbmRlci4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICBlcnJvcignZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgcmVjZWl2ZWQgYSBgbWVtb2AgJyArICdjb21wb25lbnQuIEluc3RlYWQgb2YgZm9yd2FyZFJlZihtZW1vKC4uLikpLCB1c2UgJyArICdtZW1vKGZvcndhcmRSZWYoLi4uKSkuJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgd2FzIGdpdmVuICVzLicsIHJlbmRlciA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiByZW5kZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVuZGVyLmxlbmd0aCAhPT0gMCAmJiByZW5kZXIubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgYWNjZXB0IGV4YWN0bHkgdHdvIHBhcmFtZXRlcnM6IHByb3BzIGFuZCByZWYuICVzJywgcmVuZGVyLmxlbmd0aCA9PT0gMSA/ICdEaWQgeW91IGZvcmdldCB0byB1c2UgdGhlIHJlZiBwYXJhbWV0ZXI/JyA6ICdBbnkgYWRkaXRpb25hbCBwYXJhbWV0ZXIgd2lsbCBiZSB1bmRlZmluZWQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlbmRlciAhPSBudWxsKSB7XG4gICAgICBpZiAocmVuZGVyLmRlZmF1bHRQcm9wcyAhPSBudWxsIHx8IHJlbmRlci5wcm9wVHlwZXMgIT0gbnVsbCkge1xuICAgICAgICBlcnJvcignZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGRvIG5vdCBzdXBwb3J0IHByb3BUeXBlcyBvciBkZWZhdWx0UHJvcHMuICcgKyAnRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyBhIFJlYWN0IGNvbXBvbmVudD8nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudFR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUsXG4gICAgcmVuZGVyOiByZW5kZXJcbiAgfTtcblxuICB7XG4gICAgdmFyIG93bk5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCAnZGlzcGxheU5hbWUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb3duTmFtZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIG93bk5hbWUgPSBuYW1lOyAvLyBUaGUgaW5uZXIgY29tcG9uZW50IHNob3VsZG4ndCBpbmhlcml0IHRoaXMgZGlzcGxheSBuYW1lIGluIG1vc3QgY2FzZXMsXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIGNvbXBvbmVudCBtYXkgYmUgdXNlZCBlbHNld2hlcmUuXG4gICAgICAgIC8vIEJ1dCBpdCdzIG5pY2UgZm9yIGFub255bW91cyBmdW5jdGlvbnMgdG8gaW5oZXJpdCB0aGUgbmFtZSxcbiAgICAgICAgLy8gc28gdGhhdCBvdXIgY29tcG9uZW50LXN0YWNrIGdlbmVyYXRpb24gbG9naWMgd2lsbCBkaXNwbGF5IHRoZWlyIGZyYW1lcy5cbiAgICAgICAgLy8gQW4gYW5vbnltb3VzIGZ1bmN0aW9uIGdlbmVyYWxseSBzdWdnZXN0cyBhIHBhdHRlcm4gbGlrZTpcbiAgICAgICAgLy8gICBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7Li4ufSk7XG4gICAgICAgIC8vIFRoaXMga2luZCBvZiBpbm5lciBmdW5jdGlvbiBpcyBub3QgdXNlZCBlbHNld2hlcmUgc28gdGhlIHNpZGUgZWZmZWN0IGlzIG9rYXkuXG5cbiAgICAgICAgaWYgKCFyZW5kZXIubmFtZSAmJiAhcmVuZGVyLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgcmVuZGVyLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRUeXBlO1xufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgIC8vIHdpdGguXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxIHx8IHR5cGUuZ2V0TW9kdWxlSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBtZW1vKHR5cGUsIGNvbXBhcmUpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICBlcnJvcignbWVtbzogVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBjb21wb25lbnQuIEluc3RlYWQgJyArICdyZWNlaXZlZDogJXMnLCB0eXBlID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTUVNT19UWVBFLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgY29tcGFyZTogY29tcGFyZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbXBhcmVcbiAgfTtcblxuICB7XG4gICAgdmFyIG93bk5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCAnZGlzcGxheU5hbWUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb3duTmFtZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIG93bk5hbWUgPSBuYW1lOyAvLyBUaGUgaW5uZXIgY29tcG9uZW50IHNob3VsZG4ndCBpbmhlcml0IHRoaXMgZGlzcGxheSBuYW1lIGluIG1vc3QgY2FzZXMsXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIGNvbXBvbmVudCBtYXkgYmUgdXNlZCBlbHNld2hlcmUuXG4gICAgICAgIC8vIEJ1dCBpdCdzIG5pY2UgZm9yIGFub255bW91cyBmdW5jdGlvbnMgdG8gaW5oZXJpdCB0aGUgbmFtZSxcbiAgICAgICAgLy8gc28gdGhhdCBvdXIgY29tcG9uZW50LXN0YWNrIGdlbmVyYXRpb24gbG9naWMgd2lsbCBkaXNwbGF5IHRoZWlyIGZyYW1lcy5cbiAgICAgICAgLy8gQW4gYW5vbnltb3VzIGZ1bmN0aW9uIGdlbmVyYWxseSBzdWdnZXN0cyBhIHBhdHRlcm4gbGlrZTpcbiAgICAgICAgLy8gICBSZWFjdC5tZW1vKChwcm9wcykgPT4gey4uLn0pO1xuICAgICAgICAvLyBUaGlzIGtpbmQgb2YgaW5uZXIgZnVuY3Rpb24gaXMgbm90IHVzZWQgZWxzZXdoZXJlIHNvIHRoZSBzaWRlIGVmZmVjdCBpcyBva2F5LlxuXG4gICAgICAgIGlmICghdHlwZS5uYW1lICYmICF0eXBlLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgdHlwZS5kaXNwbGF5TmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50VHlwZTtcbn1cblxudmFyIFVOVEVSTUlOQVRFRCA9IDA7XG52YXIgVEVSTUlOQVRFRCA9IDE7XG52YXIgRVJST1JFRCA9IDI7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlUm9vdCgpIHtcbiAgcmV0dXJuIG5ldyBXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlTm9kZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBzOiBVTlRFUk1JTkFURUQsXG4gICAgLy8gc3RhdHVzLCByZXByZXNlbnRzIHdoZXRoZXIgdGhlIGNhY2hlZCBjb21wdXRhdGlvbiByZXR1cm5lZCBhIHZhbHVlIG9yIHRocmV3IGFuIGVycm9yXG4gICAgdjogdW5kZWZpbmVkLFxuICAgIC8vIHZhbHVlLCBlaXRoZXIgdGhlIGNhY2hlZCByZXN1bHQgb3IgYW4gZXJyb3IsIGRlcGVuZGluZyBvbiBzXG4gICAgbzogbnVsbCxcbiAgICAvLyBvYmplY3QgY2FjaGUsIGEgV2Vha01hcCB3aGVyZSBub24tcHJpbWl0aXZlIGFyZ3VtZW50cyBhcmUgc3RvcmVkXG4gICAgcDogbnVsbCAvLyBwcmltaXRpdmUgY2FjaGUsIGEgcmVndWxhciBNYXAgd2hlcmUgcHJpbWl0aXZlIGFyZ3VtZW50cyBhcmUgc3RvcmVkLlxuXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNhY2hlKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnRDYWNoZS5jdXJyZW50O1xuXG4gICAgaWYgKCFkaXNwYXRjaGVyKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBubyBkaXNwYXRjaGVyLCB0aGVuIHdlIHRyZWF0IHRoaXMgYXMgbm90IGJlaW5nIGNhY2hlZC5cbiAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBXZSBkb24ndCB3YW50IHRvIHVzZSByZXN0IGFyZ3VtZW50cyBzaW5jZSB3ZSB0cmFuc3BpbGUgdGhlIGNvZGUuXG4gICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICB2YXIgZm5NYXAgPSBkaXNwYXRjaGVyLmdldENhY2hlRm9yVHlwZShjcmVhdGVDYWNoZVJvb3QpO1xuICAgIHZhciBmbk5vZGUgPSBmbk1hcC5nZXQoZm4pO1xuICAgIHZhciBjYWNoZU5vZGU7XG5cbiAgICBpZiAoZm5Ob2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNhY2hlTm9kZSA9IGNyZWF0ZUNhY2hlTm9kZSgpO1xuICAgICAgZm5NYXAuc2V0KGZuLCBjYWNoZU5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWNoZU5vZGUgPSBmbk5vZGU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGwpIHtcbiAgICAgICAgLy8gT2JqZWN0cyBnbyBpbnRvIGEgV2Vha01hcFxuICAgICAgICB2YXIgb2JqZWN0Q2FjaGUgPSBjYWNoZU5vZGUubztcblxuICAgICAgICBpZiAob2JqZWN0Q2FjaGUgPT09IG51bGwpIHtcbiAgICAgICAgICBjYWNoZU5vZGUubyA9IG9iamVjdENhY2hlID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvYmplY3ROb2RlID0gb2JqZWN0Q2FjaGUuZ2V0KGFyZyk7XG5cbiAgICAgICAgaWYgKG9iamVjdE5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNhY2hlTm9kZSA9IGNyZWF0ZUNhY2hlTm9kZSgpO1xuICAgICAgICAgIG9iamVjdENhY2hlLnNldChhcmcsIGNhY2hlTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FjaGVOb2RlID0gb2JqZWN0Tm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUHJpbWl0aXZlcyBnbyBpbnRvIGEgcmVndWxhciBNYXBcbiAgICAgICAgdmFyIHByaW1pdGl2ZUNhY2hlID0gY2FjaGVOb2RlLnA7XG5cbiAgICAgICAgaWYgKHByaW1pdGl2ZUNhY2hlID09PSBudWxsKSB7XG4gICAgICAgICAgY2FjaGVOb2RlLnAgPSBwcmltaXRpdmVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmltaXRpdmVOb2RlID0gcHJpbWl0aXZlQ2FjaGUuZ2V0KGFyZyk7XG5cbiAgICAgICAgaWYgKHByaW1pdGl2ZU5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNhY2hlTm9kZSA9IGNyZWF0ZUNhY2hlTm9kZSgpO1xuICAgICAgICAgIHByaW1pdGl2ZUNhY2hlLnNldChhcmcsIGNhY2hlTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FjaGVOb2RlID0gcHJpbWl0aXZlTm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjYWNoZU5vZGUucyA9PT0gVEVSTUlOQVRFRCkge1xuICAgICAgcmV0dXJuIGNhY2hlTm9kZS52O1xuICAgIH1cblxuICAgIGlmIChjYWNoZU5vZGUucyA9PT0gRVJST1JFRCkge1xuICAgICAgdGhyb3cgY2FjaGVOb2RlLnY7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBXZSBkb24ndCB3YW50IHRvIHVzZSByZXN0IGFyZ3VtZW50cyBzaW5jZSB3ZSB0cmFuc3BpbGUgdGhlIGNvZGUuXG4gICAgICB2YXIgcmVzdWx0ID0gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIHZhciB0ZXJtaW5hdGVkTm9kZSA9IGNhY2hlTm9kZTtcbiAgICAgIHRlcm1pbmF0ZWROb2RlLnMgPSBURVJNSU5BVEVEO1xuICAgICAgdGVybWluYXRlZE5vZGUudiA9IHJlc3VsdDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIFdlIHN0b3JlIHRoZSBmaXJzdCBlcnJvciB0aGF0J3MgdGhyb3duIGFuZCByZXRocm93IGl0LlxuICAgICAgdmFyIGVycm9yZWROb2RlID0gY2FjaGVOb2RlO1xuICAgICAgZXJyb3JlZE5vZGUucyA9IEVSUk9SRUQ7XG4gICAgICBlcnJvcmVkTm9kZS52ID0gZXJyb3I7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVEaXNwYXRjaGVyKCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuXG4gIHtcbiAgICBpZiAoZGlzcGF0Y2hlciA9PT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3InICsgJyBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbicgKyAnMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuJyArICcyLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuJyArICczLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS4nKTtcbiAgICB9XG4gIH0gLy8gV2lsbCByZXN1bHQgaW4gYSBudWxsIGFjY2VzcyBlcnJvciBpZiBhY2Nlc3NlZCBvdXRzaWRlIHJlbmRlciBwaGFzZS4gV2VcbiAgLy8gaW50ZW50aW9uYWxseSBkb24ndCB0aHJvdyBvdXIgb3duIGVycm9yIGJlY2F1c2UgdGhpcyBpcyBpbiBhIGhvdCBwYXRoLlxuICAvLyBBbHNvIGhlbHBzIGVuc3VyZSB0aGlzIGlzIGlubGluZWQuXG5cblxuICByZXR1cm4gZGlzcGF0Y2hlcjtcbn1cbmZ1bmN0aW9uIHVzZUNvbnRleHQoQ29udGV4dCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG5cbiAge1xuICAgIC8vIFRPRE86IGFkZCBhIG1vcmUgZ2VuZXJpYyB3YXJuaW5nIGZvciBpbnZhbGlkIHZhbHVlcy5cbiAgICBpZiAoQ29udGV4dC5fY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgcmVhbENvbnRleHQgPSBDb250ZXh0Ll9jb250ZXh0OyAvLyBEb24ndCBkZWR1cGxpY2F0ZSBiZWNhdXNlIHRoaXMgbGVnaXRpbWF0ZWx5IGNhdXNlcyBidWdzXG4gICAgICAvLyBhbmQgbm9ib2R5IHNob3VsZCBiZSB1c2luZyB0aGlzIGluIGV4aXN0aW5nIGNvZGUuXG5cbiAgICAgIGlmIChyZWFsQ29udGV4dC5Db25zdW1lciA9PT0gQ29udGV4dCkge1xuICAgICAgICBlcnJvcignQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuQ29uc3VtZXIpIGlzIG5vdCBzdXBwb3J0ZWQsIG1heSBjYXVzZSBidWdzLCBhbmQgd2lsbCBiZSAnICsgJ3JlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgfSBlbHNlIGlmIChyZWFsQ29udGV4dC5Qcm92aWRlciA9PT0gQ29udGV4dCkge1xuICAgICAgICBlcnJvcignQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuUHJvdmlkZXIpIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUNvbnRleHQoQ29udGV4dCk7XG59XG5mdW5jdGlvbiB1c2VTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VTdGF0ZShpbml0aWFsU3RhdGUpO1xufVxuZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbn1cbmZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VSZWYoaW5pdGlhbFZhbHVlKTtcbn1cbmZ1bmN0aW9uIHVzZUVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlTWVtbyhjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VNZW1vKGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICB7XG4gICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKTtcbiAgfVxufVxuZnVuY3Rpb24gdXNlVHJhbnNpdGlvbigpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VUcmFuc2l0aW9uKCk7XG59XG5mdW5jdGlvbiB1c2VEZWZlcnJlZFZhbHVlKHZhbHVlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiB1c2VJZCgpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VJZCgpO1xufVxuZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG59XG5mdW5jdGlvbiB1c2VDYWNoZVJlZnJlc2goKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTsgLy8gJEZsb3dGaXhNZVtub3QtYS1mdW5jdGlvbl0gVGhpcyBpcyB1bnN0YWJsZSwgdGh1cyBvcHRpb25hbFxuXG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUNhY2hlUmVmcmVzaCgpO1xufVxuZnVuY3Rpb24gdXNlKHVzYWJsZSkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZSh1c2FibGUpO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgLy8gaW4gc2ltcGxlIGNvbXBvbmVudHMgdG9vXG5cblxuICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgIC8vIHNpbGVuY2UgdGhlIGVycm9yLlxuICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbWF5YmVQcm9taXNlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcbiAgICAgICAgICAgICAgICAvLyBzcGxpY2UgaXQgaW4gdG8gbWFrZSB0aGUgc3RhY2sgbW9yZSByZWFkYWJsZS5cblxuXG4gICAgICAgICAgICAgICAgaWYgKGZuLmRpc3BsYXlOYW1lICYmIF9mcmFtZS5pbmNsdWRlcygnPGFub255bW91cz4nKSkge1xuICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIHNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xuXG57XG4gIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW1Gb3JQcm9wcyhlbGVtZW50UHJvcHMpIHtcbiAgaWYgKGVsZW1lbnRQcm9wcyAhPT0gbnVsbCAmJiBlbGVtZW50UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShlbGVtZW50UHJvcHMuX19zb3VyY2UpO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuXG4gICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5mbztcbn1cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cbiAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICB9XG5cbiAge1xuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcgfHwgIW5vZGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAobm9kZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSkgOyBlbHNlIGlmIChpc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChmcmFnbWVudCk7XG5cbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICBpZiAoIXZhbGlkVHlwZSkge1xuICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtRm9yUHJvcHMocHJvcHMpO1xuXG4gICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZVN0cmluZztcblxuICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBlcnJvcignUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQkMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICBpZiAodmFsaWRUeXBlKSB7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSA9IGZhbHNlO1xuZnVuY3Rpb24gY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uKHR5cGUpIHtcbiAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24uYmluZChudWxsLCB0eXBlKTtcbiAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTtcblxuICB7XG4gICAgaWYgKCFkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSkge1xuICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkgPSB0cnVlO1xuXG4gICAgICB3YXJuKCdSZWFjdC5jcmVhdGVGYWN0b3J5KCkgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gQ29uc2lkZXIgdXNpbmcgSlNYICcgKyAnb3IgdXNlIFJlYWN0LmNyZWF0ZUVsZW1lbnQoKSBkaXJlY3RseSBpbnN0ZWFkLicpO1xuICAgIH0gLy8gTGVnYWN5IGhvb2s6IHJlbW92ZSBpdFxuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKCdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJyk7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xufVxuZnVuY3Rpb24gY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24oZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciBuZXdFbGVtZW50ID0gY2xvbmVFbGVtZW50JDEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgbmV3RWxlbWVudC50eXBlKTtcbiAgfVxuXG4gIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxudmFyIENvbnRleHRSZWdpc3RyeSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkNvbnRleHRSZWdpc3RyeTtcbmZ1bmN0aW9uIGNyZWF0ZVNlcnZlckNvbnRleHQoZ2xvYmFsTmFtZSwgZGVmYXVsdFZhbHVlKSB7XG5cbiAgdmFyIHdhc0RlZmluZWQgPSB0cnVlO1xuXG4gIGlmICghQ29udGV4dFJlZ2lzdHJ5W2dsb2JhbE5hbWVdKSB7XG4gICAgd2FzRGVmaW5lZCA9IGZhbHNlO1xuICAgIHZhciBfY29udGV4dCA9IHtcbiAgICAgICQkdHlwZW9mOiBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFLFxuICAgICAgLy8gQXMgYSB3b3JrYXJvdW5kIHRvIHN1cHBvcnQgbXVsdGlwbGUgY29uY3VycmVudCByZW5kZXJlcnMsIHdlIGNhdGVnb3JpemVcbiAgICAgIC8vIHNvbWUgcmVuZGVyZXJzIGFzIHByaW1hcnkgYW5kIG90aGVycyBhcyBzZWNvbmRhcnkuIFdlIG9ubHkgZXhwZWN0XG4gICAgICAvLyB0aGVyZSB0byBiZSB0d28gY29uY3VycmVudCByZW5kZXJlcnMgYXQgbW9zdDogUmVhY3QgTmF0aXZlIChwcmltYXJ5KSBhbmRcbiAgICAgIC8vIEZhYnJpYyAoc2Vjb25kYXJ5KTsgUmVhY3QgRE9NIChwcmltYXJ5KSBhbmQgUmVhY3QgQVJUIChzZWNvbmRhcnkpLlxuICAgICAgLy8gU2Vjb25kYXJ5IHJlbmRlcmVycyBzdG9yZSB0aGVpciBjb250ZXh0IHZhbHVlcyBvbiBzZXBhcmF0ZSBmaWVsZHMuXG4gICAgICBfY3VycmVudFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgICBfY3VycmVudFZhbHVlMjogZGVmYXVsdFZhbHVlLFxuICAgICAgX2RlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuICAgICAgLy8gVXNlZCB0byB0cmFjayBob3cgbWFueSBjb25jdXJyZW50IHJlbmRlcmVycyB0aGlzIGNvbnRleHQgY3VycmVudGx5XG4gICAgICAvLyBzdXBwb3J0cyB3aXRoaW4gaW4gYSBzaW5nbGUgcmVuZGVyZXIuIFN1Y2ggYXMgcGFyYWxsZWwgc2VydmVyIHJlbmRlcmluZy5cbiAgICAgIF90aHJlYWRDb3VudDogMCxcbiAgICAgIC8vIFRoZXNlIGFyZSBjaXJjdWxhclxuICAgICAgUHJvdmlkZXI6IG51bGwsXG4gICAgICBDb25zdW1lcjogbnVsbCxcbiAgICAgIF9nbG9iYWxOYW1lOiBnbG9iYWxOYW1lXG4gICAgfTtcbiAgICBfY29udGV4dC5Qcm92aWRlciA9IHtcbiAgICAgICQkdHlwZW9mOiBSRUFDVF9QUk9WSURFUl9UWVBFLFxuICAgICAgX2NvbnRleHQ6IF9jb250ZXh0XG4gICAgfTtcblxuICAgIHtcbiAgICAgIHZhciBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXI7XG4gICAgICBfY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gbnVsbDtcbiAgICAgIF9jb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gbnVsbDtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF9jb250ZXh0LCB7XG4gICAgICAgIENvbnN1bWVyOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lcikge1xuICAgICAgICAgICAgICBlcnJvcignQ29uc3VtZXIgcGF0dGVybiBpcyBub3Qgc3VwcG9ydGVkIGJ5IFJlYWN0U2VydmVyQ29udGV4dCcpO1xuXG4gICAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lciA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgQ29udGV4dFJlZ2lzdHJ5W2dsb2JhbE5hbWVdID0gX2NvbnRleHQ7XG4gIH1cblxuICB2YXIgY29udGV4dCA9IENvbnRleHRSZWdpc3RyeVtnbG9iYWxOYW1lXTtcblxuICBpZiAoY29udGV4dC5fZGVmYXVsdFZhbHVlID09PSBSRUFDVF9TRVJWRVJfQ09OVEVYVF9ERUZBVUxUX1ZBTFVFX05PVF9MT0FERUQpIHtcbiAgICBjb250ZXh0Ll9kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG5cbiAgICBpZiAoY29udGV4dC5fY3VycmVudFZhbHVlID09PSBSRUFDVF9TRVJWRVJfQ09OVEVYVF9ERUZBVUxUX1ZBTFVFX05PVF9MT0FERUQpIHtcbiAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoY29udGV4dC5fY3VycmVudFZhbHVlMiA9PT0gUkVBQ1RfU0VSVkVSX0NPTlRFWFRfREVGQVVMVF9WQUxVRV9OT1RfTE9BREVEKSB7XG4gICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgfSBlbHNlIGlmICh3YXNEZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2VydmVyQ29udGV4dDogXCIgKyBnbG9iYWxOYW1lICsgXCIgYWxyZWFkeSBkZWZpbmVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvbihzY29wZSwgb3B0aW9ucykge1xuICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZy50cmFuc2l0aW9uO1xuICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZy50cmFuc2l0aW9uID0ge307XG4gIHZhciBjdXJyZW50VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb247XG5cbiAge1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgPSBuZXcgU2V0KCk7XG4gIH1cblxuICB0cnkge1xuICAgIHNjb3BlKCk7XG4gIH0gZmluYWxseSB7XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuXG4gICAge1xuICAgICAgaWYgKHByZXZUcmFuc2l0aW9uID09PSBudWxsICYmIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzKSB7XG4gICAgICAgIHZhciB1cGRhdGVkRmliZXJzQ291bnQgPSBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5zaXplO1xuXG4gICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLmNsZWFyKCk7XG5cbiAgICAgICAgaWYgKHVwZGF0ZWRGaWJlcnNDb3VudCA+IDEwKSB7XG4gICAgICAgICAgd2FybignRGV0ZWN0ZWQgYSBsYXJnZSBudW1iZXIgb2YgdXBkYXRlcyBpbnNpZGUgc3RhcnRUcmFuc2l0aW9uLiAnICsgJ0lmIHRoaXMgaXMgZHVlIHRvIGEgc3Vic2NyaXB0aW9uIHBsZWFzZSByZS13cml0ZSBpdCB0byB1c2UgUmVhY3QgcHJvdmlkZWQgaG9va3MuICcgKyAnT3RoZXJ3aXNlIGNvbmN1cnJlbnQgbW9kZSBndWFyYW50ZWVzIGFyZSBvZmYgdGhlIHRhYmxlLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRNZXNzYWdlQ2hhbm5lbCA9IGZhbHNlO1xudmFyIGVucXVldWVUYXNrSW1wbCA9IG51bGw7XG5mdW5jdGlvbiBlbnF1ZXVlVGFzayh0YXNrKSB7XG4gIGlmIChlbnF1ZXVlVGFza0ltcGwgPT09IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgLy8gcmVhZCByZXF1aXJlIG9mZiB0aGUgbW9kdWxlIG9iamVjdCB0byBnZXQgYXJvdW5kIHRoZSBidW5kbGVycy5cbiAgICAgIC8vIHdlIGRvbid0IHdhbnQgdGhlbSB0byBkZXRlY3QgYSByZXF1aXJlIGFuZCBidW5kbGUgYSBOb2RlIHBvbHlmaWxsLlxuICAgICAgdmFyIHJlcXVpcmVTdHJpbmcgPSAoJ3JlcXVpcmUnICsgTWF0aC5yYW5kb20oKSkuc2xpY2UoMCwgNyk7XG4gICAgICB2YXIgbm9kZVJlcXVpcmUgPSBtb2R1bGUgJiYgbW9kdWxlW3JlcXVpcmVTdHJpbmddOyAvLyBhc3N1bWluZyB3ZSdyZSBpbiBub2RlLCBsZXQncyB0cnkgdG8gZ2V0IG5vZGUnc1xuICAgICAgLy8gdmVyc2lvbiBvZiBzZXRJbW1lZGlhdGUsIGJ5cGFzc2luZyBmYWtlIHRpbWVycyBpZiBhbnkuXG5cbiAgICAgIGVucXVldWVUYXNrSW1wbCA9IG5vZGVSZXF1aXJlLmNhbGwobW9kdWxlLCAndGltZXJzJykuc2V0SW1tZWRpYXRlO1xuICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgIC8vIHdlJ3JlIGluIGEgYnJvd3NlclxuICAgICAgLy8gd2UgY2FuJ3QgdXNlIHJlZ3VsYXIgdGltZXJzIGJlY2F1c2UgdGhleSBtYXkgc3RpbGwgYmUgZmFrZWRcbiAgICAgIC8vIHNvIHdlIHRyeSBNZXNzYWdlQ2hhbm5lbCtwb3N0TWVzc2FnZSBpbnN0ZWFkXG4gICAgICBlbnF1ZXVlVGFza0ltcGwgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmIChkaWRXYXJuQWJvdXRNZXNzYWdlQ2hhbm5lbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dE1lc3NhZ2VDaGFubmVsID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBoYXZlIGEgTWVzc2FnZUNoYW5uZWwgaW1wbGVtZW50YXRpb24sICcgKyAnc28gZW5xdWV1aW5nIHRhc2tzIHZpYSBhd2FpdCBhY3QoYXN5bmMgKCkgPT4gLi4uKSB3aWxsIGZhaWwuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3VlcyAnICsgJ2lmIHlvdSBlbmNvdW50ZXIgdGhpcyB3YXJuaW5nLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gY2FsbGJhY2s7XG4gICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UodW5kZWZpbmVkKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVucXVldWVUYXNrSW1wbCh0YXNrKTtcbn1cblxuLy8gbnVtYmVyIG9mIGBhY3RgIHNjb3BlcyBvbiB0aGUgc3RhY2suXG5cbnZhciBhY3RTY29wZURlcHRoID0gMDsgLy8gV2Ugb25seSB3YXJuIHRoZSBmaXJzdCB0aW1lIHlvdSBuZWdsZWN0IHRvIGF3YWl0IGFuIGFzeW5jIGBhY3RgIHNjb3BlLlxuXG52YXIgZGlkV2Fybk5vQXdhaXRBY3QgPSBmYWxzZTtcbmZ1bmN0aW9uIGFjdChjYWxsYmFjaykge1xuICB7XG4gICAgLy8gV2hlbiBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5jdXJyZW50IGlzIG5vdCBudWxsLCBpdCBzaWduYWxzIHRvIFJlYWN0IHRoYXRcbiAgICAvLyB3ZSdyZSBjdXJyZW50bHkgaW5zaWRlIGFuIGBhY3RgIHNjb3BlLiBSZWFjdCB3aWxsIHB1c2ggYWxsIGl0cyB0YXNrcyB0b1xuICAgIC8vIHRoaXMgcXVldWUgaW5zdGVhZCBvZiBzY2hlZHVsaW5nIHRoZW0gd2l0aCBwbGF0Zm9ybSBBUElzLlxuICAgIC8vXG4gICAgLy8gV2Ugc2V0IHRoaXMgdG8gYW4gZW1wdHkgYXJyYXkgd2hlbiB3ZSBmaXJzdCBlbnRlciBhbiBgYWN0YCBzY29wZSwgYW5kXG4gICAgLy8gb25seSB1bnNldCBpdCBvbmNlIHdlJ3ZlIGxlZnQgdGhlIG91dGVybW9zdCBgYWN0YCBzY29wZSDigJQgcmVtZW1iZXIgdGhhdFxuICAgIC8vIGBhY3RgIGNhbGxzIGNhbiBiZSBuZXN0ZWQuXG4gICAgLy9cbiAgICAvLyBJZiB3ZSdyZSBhbHJlYWR5IGluc2lkZSBhbiBgYWN0YCBzY29wZSwgcmV1c2UgdGhlIGV4aXN0aW5nIHF1ZXVlLlxuICAgIHZhciBwcmV2SXNCYXRjaGluZ0xlZ2FjeSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlLmlzQmF0Y2hpbmdMZWdhY3k7XG4gICAgdmFyIHByZXZBY3RRdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQ7XG4gICAgdmFyIHByZXZBY3RTY29wZURlcHRoID0gYWN0U2NvcGVEZXB0aDtcbiAgICBhY3RTY29wZURlcHRoKys7XG4gICAgdmFyIHF1ZXVlID0gUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudCA9IHByZXZBY3RRdWV1ZSAhPT0gbnVsbCA/IHByZXZBY3RRdWV1ZSA6IFtdOyAvLyBVc2VkIHRvIHJlcHJvZHVjZSBiZWhhdmlvciBvZiBgYmF0Y2hlZFVwZGF0ZXNgIGluIGxlZ2FjeSBtb2RlLiBPbmx5XG4gICAgLy8gc2V0IHRvIGB0cnVlYCB3aGlsZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgaXMgZXhlY3V0ZWQsIG5vdCBmb3IgdXBkYXRlc1xuICAgIC8vIHRyaWdnZXJlZCBkdXJpbmcgYW4gYXN5bmMgZXZlbnQsIGJlY2F1c2UgdGhpcyBpcyBob3cgdGhlIGxlZ2FjeVxuICAgIC8vIGltcGxlbWVudGF0aW9uIG9mIGBhY3RgIGJlaGF2ZWQuXG5cbiAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5pc0JhdGNoaW5nTGVnYWN5ID0gdHJ1ZTtcbiAgICB2YXIgcmVzdWx0OyAvLyBUaGlzIHRyYWNrcyB3aGV0aGVyIHRoZSBgYWN0YCBjYWxsIGlzIGF3YWl0ZWQuIEluIGNlcnRhaW4gY2FzZXMsIG5vdFxuICAgIC8vIGF3YWl0aW5nIGl0IGlzIGEgbWlzdGFrZSwgc28gd2Ugd2lsbCBkZXRlY3QgdGhhdCBhbmQgd2Fybi5cblxuICAgIHZhciBkaWRBd2FpdEFjdENhbGwgPSBmYWxzZTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBSZXNldCB0aGlzIHRvIGBmYWxzZWAgcmlnaHQgYmVmb3JlIGVudGVyaW5nIHRoZSBSZWFjdCB3b3JrIGxvb3AuIFRoZVxuICAgICAgLy8gb25seSBwbGFjZSB3ZSBldmVyIHJlYWQgdGhpcyBmaWVsZHMgaXMganVzdCBiZWxvdywgcmlnaHQgYWZ0ZXIgcnVubmluZ1xuICAgICAgLy8gdGhlIGNhbGxiYWNrLiBTbyB3ZSBkb24ndCBuZWVkIHRvIHJlc2V0IGFmdGVyIHRoZSBjYWxsYmFjayBydW5zLlxuICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuZGlkU2NoZWR1bGVMZWdhY3lVcGRhdGUgPSBmYWxzZTtcbiAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKCk7XG4gICAgICB2YXIgZGlkU2NoZWR1bGVMZWdhY3lVcGRhdGUgPSBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5kaWRTY2hlZHVsZUxlZ2FjeVVwZGF0ZTsgLy8gUmVwbGljYXRlIGJlaGF2aW9yIG9mIG9yaWdpbmFsIGBhY3RgIGltcGxlbWVudGF0aW9uIGluIGxlZ2FjeSBtb2RlLFxuICAgICAgLy8gd2hpY2ggZmx1c2hlZCB1cGRhdGVzIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBzY29wZSBmdW5jdGlvbiBleGl0cywgZXZlblxuICAgICAgLy8gaWYgaXQncyBhbiBhc3luYyBmdW5jdGlvbi5cblxuICAgICAgaWYgKCFwcmV2SXNCYXRjaGluZ0xlZ2FjeSAmJiBkaWRTY2hlZHVsZUxlZ2FjeVVwZGF0ZSkge1xuICAgICAgICBmbHVzaEFjdFF1ZXVlKHF1ZXVlKTtcbiAgICAgIH0gLy8gYGlzQmF0Y2hpbmdMZWdhY3lgIGdldHMgcmVzZXQgdXNpbmcgdGhlIHJlZ3VsYXIgc3RhY2ssIG5vdCB0aGUgYXN5bmNcbiAgICAgIC8vIG9uZSB1c2VkIHRvIHRyYWNrIGBhY3RgIHNjb3Blcy4gV2h5LCB5b3UgbWF5IGJlIHdvbmRlcmluZz8gQmVjYXVzZVxuICAgICAgLy8gdGhhdCdzIGhvdyBpdCB3b3JrZWQgYmVmb3JlIHZlcnNpb24gMTguIFllcywgaXQncyBjb25mdXNpbmchIFdlIHNob3VsZFxuICAgICAgLy8gZGVsZXRlIGxlZ2FjeSBtb2RlISFcblxuXG4gICAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5pc0JhdGNoaW5nTGVnYWN5ID0gcHJldklzQmF0Y2hpbmdMZWdhY3k7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIGBpc0JhdGNoaW5nTGVnYWN5YCBnZXRzIHJlc2V0IHVzaW5nIHRoZSByZWd1bGFyIHN0YWNrLCBub3QgdGhlIGFzeW5jXG4gICAgICAvLyBvbmUgdXNlZCB0byB0cmFjayBgYWN0YCBzY29wZXMuIFdoeSwgeW91IG1heSBiZSB3b25kZXJpbmc/IEJlY2F1c2VcbiAgICAgIC8vIHRoYXQncyBob3cgaXQgd29ya2VkIGJlZm9yZSB2ZXJzaW9uIDE4LiBZZXMsIGl0J3MgY29uZnVzaW5nISBXZSBzaG91bGRcbiAgICAgIC8vIGRlbGV0ZSBsZWdhY3kgbW9kZSEhXG4gICAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5pc0JhdGNoaW5nTGVnYWN5ID0gcHJldklzQmF0Y2hpbmdMZWdhY3k7XG4gICAgICBwb3BBY3RTY29wZShwcmV2QWN0UXVldWUsIHByZXZBY3RTY29wZURlcHRoKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQgIT09IG51bGwgJiYgdHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICAgIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQSBwcm9taXNlL3RoZW5hYmxlIHdhcyByZXR1cm5lZCBmcm9tIHRoZSBjYWxsYmFjay4gV2FpdCBmb3IgaXQgdG9cbiAgICAgIC8vIHJlc29sdmUgYmVmb3JlIGZsdXNoaW5nIHRoZSBxdWV1ZS5cbiAgICAgIC8vXG4gICAgICAvLyBJZiBgYWN0YCB3ZXJlIGltcGxlbWVudGVkIGFzIGFuIGFzeW5jIGZ1bmN0aW9uLCB0aGlzIHdob2xlIGJsb2NrIGNvdWxkXG4gICAgICAvLyBiZSBhIHNpbmdsZSBgYXdhaXRgIGNhbGwuIFRoYXQncyByZWFsbHkgdGhlIG9ubHkgZGlmZmVyZW5jZSBiZXR3ZWVuXG4gICAgICAvLyB0aGlzIGJyYW5jaCBhbmQgdGhlIG5leHQgb25lLlxuICAgICAgdmFyIHRoZW5hYmxlID0gcmVzdWx0OyAvLyBXYXJuIGlmIHRoZSBhbiBgYWN0YCBjYWxsIHdpdGggYW4gYXN5bmMgc2NvcGUgaXMgbm90IGF3YWl0ZWQuIEluIGFcbiAgICAgIC8vIGZ1dHVyZSByZWxlYXNlLCBjb25zaWRlciBtYWtpbmcgdGhpcyBhbiBlcnJvci5cblxuICAgICAgcXVldWVTZXZlcmFsTWljcm90YXNrcyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghZGlkQXdhaXRBY3RDYWxsICYmICFkaWRXYXJuTm9Bd2FpdEFjdCkge1xuICAgICAgICAgIGRpZFdhcm5Ob0F3YWl0QWN0ID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdZb3UgY2FsbGVkIGFjdChhc3luYyAoKSA9PiAuLi4pIHdpdGhvdXQgYXdhaXQuICcgKyAnVGhpcyBjb3VsZCBsZWFkIHRvIHVuZXhwZWN0ZWQgdGVzdGluZyBiZWhhdmlvdXIsICcgKyAnaW50ZXJsZWF2aW5nIG11bHRpcGxlIGFjdCBjYWxscyBhbmQgbWl4aW5nIHRoZWlyICcgKyAnc2NvcGVzLiAnICsgJ1lvdSBzaG91bGQgLSBhd2FpdCBhY3QoYXN5bmMgKCkgPT4gLi4uKTsnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgZGlkQXdhaXRBY3RDYWxsID0gdHJ1ZTtcbiAgICAgICAgICB0aGVuYWJsZS50aGVuKGZ1bmN0aW9uIChyZXR1cm5WYWx1ZSkge1xuICAgICAgICAgICAgcG9wQWN0U2NvcGUocHJldkFjdFF1ZXVlLCBwcmV2QWN0U2NvcGVEZXB0aCk7XG5cbiAgICAgICAgICAgIGlmIChwcmV2QWN0U2NvcGVEZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAvLyBXZSdyZSBleGl0aW5nIHRoZSBvdXRlcm1vc3QgYGFjdGAgc2NvcGUuIEZsdXNoIHRoZSBxdWV1ZS5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmbHVzaEFjdFF1ZXVlKHF1ZXVlKTtcbiAgICAgICAgICAgICAgICBlbnF1ZXVlVGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gKC8vIFJlY3Vyc2l2ZWx5IGZsdXNoIHRhc2tzIHNjaGVkdWxlZCBieSBhIG1pY3JvdGFzay5cbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhyZXR1cm5WYWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBgdGhlbmFibGVgIG1pZ2h0IG5vdCBiZSBhIHJlYWwgcHJvbWlzZSwgYW5kIGBmbHVzaEFjdFF1ZXVlYFxuICAgICAgICAgICAgICAgIC8vIG1pZ2h0IHRocm93LCBzbyB3ZSBuZWVkIHRvIHdyYXAgYGZsdXNoQWN0UXVldWVgIGluIGFcbiAgICAgICAgICAgICAgICAvLyB0cnkvY2F0Y2guXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBwb3BBY3RTY29wZShwcmV2QWN0UXVldWUsIHByZXZBY3RTY29wZURlcHRoKTtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXR1cm5WYWx1ZSA9IHJlc3VsdDsgLy8gVGhlIGNhbGxiYWNrIGlzIG5vdCBhbiBhc3luYyBmdW5jdGlvbi4gRXhpdCB0aGUgY3VycmVudFxuICAgICAgLy8gc2NvcGUgaW1tZWRpYXRlbHkuXG5cbiAgICAgIHBvcEFjdFNjb3BlKHByZXZBY3RRdWV1ZSwgcHJldkFjdFNjb3BlRGVwdGgpO1xuXG4gICAgICBpZiAocHJldkFjdFNjb3BlRGVwdGggPT09IDApIHtcbiAgICAgICAgLy8gV2UncmUgZXhpdGluZyB0aGUgb3V0ZXJtb3N0IGBhY3RgIHNjb3BlLiBGbHVzaCB0aGUgcXVldWUuXG4gICAgICAgIGZsdXNoQWN0UXVldWUocXVldWUpOyAvLyBJZiB0aGUgcXVldWUgaXMgbm90IGVtcHR5LCBpdCBpbXBsaWVzIHRoYXQgd2UgaW50ZW50aW9uYWxseSB5aWVsZGVkXG4gICAgICAgIC8vIHRvIHRoZSBtYWluIHRocmVhZCwgYmVjYXVzZSBzb21ldGhpbmcgc3VzcGVuZGVkLiBXZSB3aWxsIGNvbnRpbnVlXG4gICAgICAgIC8vIGluIGFuIGFzeW5jaHJvbm91cyB0YXNrLlxuICAgICAgICAvL1xuICAgICAgICAvLyBXYXJuIGlmIHNvbWV0aGluZyBzdXNwZW5kcyBidXQgdGhlIGBhY3RgIGNhbGwgaXMgbm90IGF3YWl0ZWQuXG4gICAgICAgIC8vIEluIGEgZnV0dXJlIHJlbGVhc2UsIGNvbnNpZGVyIG1ha2luZyB0aGlzIGFuIGVycm9yLlxuXG4gICAgICAgIGlmIChxdWV1ZS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBxdWV1ZVNldmVyYWxNaWNyb3Rhc2tzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghZGlkQXdhaXRBY3RDYWxsICYmICFkaWRXYXJuTm9Bd2FpdEFjdCkge1xuICAgICAgICAgICAgICBkaWRXYXJuTm9Bd2FpdEFjdCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgZXJyb3IoJ0EgY29tcG9uZW50IHN1c3BlbmRlZCBpbnNpZGUgYW4gYGFjdGAgc2NvcGUsIGJ1dCB0aGUgJyArICdgYWN0YCBjYWxsIHdhcyBub3QgYXdhaXRlZC4gV2hlbiB0ZXN0aW5nIFJlYWN0ICcgKyAnY29tcG9uZW50cyB0aGF0IGRlcGVuZCBvbiBhc3luY2hyb25vdXMgZGF0YSwgeW91IG11c3QgJyArICdhd2FpdCB0aGUgcmVzdWx0OlxcblxcbicgKyAnYXdhaXQgYWN0KCgpID0+IC4uLiknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBMaWtlIG1hbnkgdGhpbmdzIGluIHRoaXMgbW9kdWxlLCB0aGlzIGlzIG5leHQgcGFydCBpcyBjb25mdXNpbmcuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdlIGRvIG5vdCBjdXJyZW50bHkgcmVxdWlyZSBldmVyeSBgYWN0YCBjYWxsIHRoYXQgaXMgcGFzc2VkIGFcbiAgICAgICAgLy8gY2FsbGJhY2sgdG8gYmUgYXdhaXRlZCwgdGhyb3VnaCBhcmd1YWJseSB3ZSBzaG91bGQuIFNpbmNlIHRoaXNcbiAgICAgICAgLy8gY2FsbGJhY2sgd2FzIHN5bmNocm9ub3VzLCB3ZSBuZWVkIHRvIGV4aXQgdGhlIGN1cnJlbnQgc2NvcGUgYmVmb3JlXG4gICAgICAgIC8vIHJldHVybmluZy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSG93ZXZlciwgaWYgdGhlbmFibGUgd2UncmUgYWJvdXQgdG8gcmV0dXJuICppcyogYXdhaXRlZCwgd2UnbGxcbiAgICAgICAgLy8gaW1tZWRpYXRlbHkgcmVzdG9yZSB0aGUgY3VycmVudCBzY29wZS4gU28gaXQgc2hvdWxkbid0IG9ic2VydmFibGUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoaXMgZG9lc24ndCBhZmZlY3QgdGhlIGNhc2Ugd2hlcmUgdGhlIHNjb3BlIGNhbGxiYWNrIGlzIGFzeW5jLFxuICAgICAgICAvLyBiZWNhdXNlIHdlIGFsd2F5cyByZXF1aXJlIHRob3NlIGNhbGxzIHRvIGJlIGF3YWl0ZWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRPRE86IEluIGEgZnV0dXJlIHZlcnNpb24sIGNvbnNpZGVyIGFsd2F5cyByZXF1aXJpbmcgYWxsIGBhY3RgIGNhbGxzXG4gICAgICAgIC8vIHRvIGJlIGF3YWl0ZWQsIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgY2FsbGJhY2sgaXMgc3luYyBvciBhc3luYy5cblxuXG4gICAgICAgIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgZGlkQXdhaXRBY3RDYWxsID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChwcmV2QWN0U2NvcGVEZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGBhY3RgIGNhbGwgaXMgYXdhaXRlZCwgcmVzdG9yZSB0aGUgcXVldWUgd2Ugd2VyZVxuICAgICAgICAgICAgLy8gdXNpbmcgYmVmb3JlIChzZWUgbG9uZyBjb21tZW50IGFib3ZlKSBzbyB3ZSBjYW4gZmx1c2ggaXQuXG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5jdXJyZW50ID0gcXVldWU7XG4gICAgICAgICAgICBlbnF1ZXVlVGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoLy8gUmVjdXJzaXZlbHkgZmx1c2ggdGFza3Mgc2NoZWR1bGVkIGJ5IGEgbWljcm90YXNrLlxuICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5Rmx1c2hBc3luY0FjdFdvcmsocmV0dXJuVmFsdWUsIHJlc29sdmUsIHJlamVjdClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHJldHVyblZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvcEFjdFNjb3BlKHByZXZBY3RRdWV1ZSwgcHJldkFjdFNjb3BlRGVwdGgpIHtcbiAge1xuICAgIGlmIChwcmV2QWN0U2NvcGVEZXB0aCAhPT0gYWN0U2NvcGVEZXB0aCAtIDEpIHtcbiAgICAgIGVycm9yKCdZb3Ugc2VlbSB0byBoYXZlIG92ZXJsYXBwaW5nIGFjdCgpIGNhbGxzLCB0aGlzIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnQmUgc3VyZSB0byBhd2FpdCBwcmV2aW91cyBhY3QoKSBjYWxscyBiZWZvcmUgbWFraW5nIGEgbmV3IG9uZS4gJyk7XG4gICAgfVxuXG4gICAgYWN0U2NvcGVEZXB0aCA9IHByZXZBY3RTY29wZURlcHRoO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5Rmx1c2hBc3luY0FjdFdvcmsocmV0dXJuVmFsdWUsIHJlc29sdmUsIHJlamVjdCkge1xuICB7XG4gICAgLy8gQ2hlY2sgaWYgYW55IHRhc2tzIHdlcmUgc2NoZWR1bGVkIGFzeW5jaHJvbm91c2x5LlxuICAgIHZhciBxdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQ7XG5cbiAgICBpZiAocXVldWUgIT09IG51bGwpIHtcbiAgICAgIGlmIChxdWV1ZS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgLy8gQXN5bmMgdGFza3Mgd2VyZSBzY2hlZHVsZWQsIG1vc3RseSBsaWtlbHkgaW4gYSBtaWNyb3Rhc2suXG4gICAgICAgIC8vIEtlZXAgZmx1c2hpbmcgdW50aWwgdGhlcmUgYXJlIG5vIG1vcmUuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZmx1c2hBY3RRdWV1ZShxdWV1ZSk7IC8vIFRoZSB3b3JrIHdlIGp1c3QgcGVyZm9ybWVkIG1heSBoYXZlIHNjaGVkdWxlIGFkZGl0aW9uYWwgYXN5bmNcbiAgICAgICAgICAvLyB0YXNrcy4gV2FpdCBhIG1hY3JvdGFzayBhbmQgY2hlY2sgYWdhaW4uXG5cbiAgICAgICAgICBlbnF1ZXVlVGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhyZXR1cm5WYWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAvLyBMZWF2ZSByZW1haW5pbmcgdGFza3Mgb24gdGhlIHF1ZXVlIGlmIHNvbWV0aGluZyB0aHJvd3MuXG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIHF1ZXVlIGlzIGVtcHR5LiBXZSBjYW4gZmluaXNoLlxuICAgICAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgcmVzb2x2ZShyZXR1cm5WYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmUocmV0dXJuVmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgaXNGbHVzaGluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmbHVzaEFjdFF1ZXVlKHF1ZXVlKSB7XG4gIHtcbiAgICBpZiAoIWlzRmx1c2hpbmcpIHtcbiAgICAgIC8vIFByZXZlbnQgcmUtZW50cmFuY2UuXG4gICAgICBpc0ZsdXNoaW5nID0gdHJ1ZTtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICg7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBjYWxsYmFjayA9IHF1ZXVlW2ldO1xuXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuZGlkVXNlUHJvbWlzZSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGNvbnRpbnVhdGlvbiA9IGNhbGxiYWNrKGZhbHNlKTtcblxuICAgICAgICAgICAgaWYgKGNvbnRpbnVhdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoUmVhY3RDdXJyZW50QWN0UXVldWUuZGlkVXNlUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBjb21wb25lbnQganVzdCBzdXNwZW5kZWQuIFlpZWxkIHRvIHRoZSBtYWluIHRocmVhZCBpblxuICAgICAgICAgICAgICAgIC8vIGNhc2UgdGhlIHByb21pc2UgaXMgYWxyZWFkeSByZXNvbHZlZC4gSWYgc28sIGl0IHdpbGwgcGluZyBpblxuICAgICAgICAgICAgICAgIC8vIGEgbWljcm90YXNrIGFuZCB3ZSBjYW4gcmVzdW1lIHdpdGhvdXQgdW53aW5kaW5nIHRoZSBzdGFjay5cbiAgICAgICAgICAgICAgICBxdWV1ZVtpXSA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIHF1ZXVlLnNwbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjYWxsYmFjayA9IGNvbnRpbnVhdGlvbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgICB9IC8vIFdlIGZsdXNoZWQgdGhlIGVudGlyZSBxdWV1ZS5cblxuXG4gICAgICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBJZiBzb21ldGhpbmcgdGhyb3dzLCBsZWF2ZSB0aGUgcmVtYWluaW5nIGNhbGxiYWNrcyBvbiB0aGUgcXVldWUuXG4gICAgICAgIHF1ZXVlLnNwbGljZSgwLCBpICsgMSk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaXNGbHVzaGluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSAvLyBTb21lIG9mIG91ciB3YXJuaW5ncyBhdHRlbXB0IHRvIGRldGVjdCBpZiB0aGUgYGFjdGAgY2FsbCBpcyBhd2FpdGVkIGJ5XG4vLyBjaGVja2luZyBpbiBhbiBhc3luY2hyb25vdXMgdGFzay4gV2FpdCBhIGZldyBtaWNyb3Rhc2tzIGJlZm9yZSBjaGVja2luZy4gVGhlXG4vLyBvbmx5IHJlYXNvbiBvbmUgaXNuJ3Qgc3VmZmljaWVudCBpcyB3ZSB3YW50IHRvIGFjY29tbW9kYXRlIHRoZSBjYXNlIHdoZXJlIGFuXG4vLyBgYWN0YCBjYWxsIGlzIHJldHVybmVkIGZyb20gYW4gYXN5bmMgZnVuY3Rpb24gd2l0aG91dCBmaXJzdCBiZWluZyBhd2FpdGVkLFxuLy8gc2luY2UgdGhhdCdzIGEgc29tZXdoYXQgY29tbW9uIHBhdHRlcm4uIElmIHlvdSBkbyB0aGlzIHRvbyBtYW55IHRpbWVzIGluIGFcbi8vIG5lc3RlZCBzZXF1ZW5jZSwgeW91IG1pZ2h0IGdldCBhIHdhcm5pbmcsIGJ1dCB5b3UgY2FuIGFsd2F5cyBmaXggYnkgYXdhaXRpbmdcbi8vIHRoZSBjYWxsLlxuLy9cbi8vIEEgbWFjcm90YXNrIHdvdWxkIGFsc28gd29yayAoYW5kIGlzIHRoZSBmYWxsYmFjaykgYnV0IGRlcGVuZGluZyBvbiB0aGUgdGVzdFxuLy8gZW52aXJvbm1lbnQgaXQgbWF5IGNhdXNlIHRoZSB3YXJuaW5nIHRvIGZpcmUgdG9vIGxhdGUuXG5cblxudmFyIHF1ZXVlU2V2ZXJhbE1pY3JvdGFza3MgPSB0eXBlb2YgcXVldWVNaWNyb3Rhc2sgPT09ICdmdW5jdGlvbicgPyBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgcXVldWVNaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBxdWV1ZU1pY3JvdGFzayhjYWxsYmFjayk7XG4gIH0pO1xufSA6IGVucXVldWVUYXNrO1xuXG52YXIgY3JlYXRlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiA7XG52YXIgY2xvbmVFbGVtZW50ID0gY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24gO1xudmFyIGNyZWF0ZUZhY3RvcnkgPSBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24gO1xudmFyIENoaWxkcmVuID0ge1xuICBtYXA6IG1hcENoaWxkcmVuLFxuICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICB0b0FycmF5OiB0b0FycmF5LFxuICBvbmx5OiBvbmx5Q2hpbGRcbn07XG5cbmV4cG9ydHMuQ2hpbGRyZW4gPSBDaGlsZHJlbjtcbmV4cG9ydHMuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuZXhwb3J0cy5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG5leHBvcnRzLlByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbmV4cG9ydHMuUHVyZUNvbXBvbmVudCA9IFB1cmVDb21wb25lbnQ7XG5leHBvcnRzLlN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xuZXhwb3J0cy5TdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG5leHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gUmVhY3RTaGFyZWRJbnRlcm5hbHM7XG5leHBvcnRzLmNhY2hlID0gY2FjaGU7XG5leHBvcnRzLmNsb25lRWxlbWVudCA9IGNsb25lRWxlbWVudDtcbmV4cG9ydHMuY3JlYXRlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ7XG5leHBvcnRzLmNyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50O1xuZXhwb3J0cy5jcmVhdGVGYWN0b3J5ID0gY3JlYXRlRmFjdG9yeTtcbmV4cG9ydHMuY3JlYXRlUmVmID0gY3JlYXRlUmVmO1xuZXhwb3J0cy5jcmVhdGVTZXJ2ZXJDb250ZXh0ID0gY3JlYXRlU2VydmVyQ29udGV4dDtcbmV4cG9ydHMuZm9yd2FyZFJlZiA9IGZvcndhcmRSZWY7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50ID0gaXNWYWxpZEVsZW1lbnQ7XG5leHBvcnRzLmxhenkgPSBsYXp5O1xuZXhwb3J0cy5tZW1vID0gbWVtbztcbmV4cG9ydHMuc3RhcnRUcmFuc2l0aW9uID0gc3RhcnRUcmFuc2l0aW9uO1xuZXhwb3J0cy51bnN0YWJsZV9hY3QgPSBhY3Q7XG5leHBvcnRzLnVuc3RhYmxlX3VzZUNhY2hlUmVmcmVzaCA9IHVzZUNhY2hlUmVmcmVzaDtcbmV4cG9ydHMudXNlID0gdXNlO1xuZXhwb3J0cy51c2VDYWxsYmFjayA9IHVzZUNhbGxiYWNrO1xuZXhwb3J0cy51c2VDb250ZXh0ID0gdXNlQ29udGV4dDtcbmV4cG9ydHMudXNlRGVidWdWYWx1ZSA9IHVzZURlYnVnVmFsdWU7XG5leHBvcnRzLnVzZURlZmVycmVkVmFsdWUgPSB1c2VEZWZlcnJlZFZhbHVlO1xuZXhwb3J0cy51c2VFZmZlY3QgPSB1c2VFZmZlY3Q7XG5leHBvcnRzLnVzZUlkID0gdXNlSWQ7XG5leHBvcnRzLnVzZUltcGVyYXRpdmVIYW5kbGUgPSB1c2VJbXBlcmF0aXZlSGFuZGxlO1xuZXhwb3J0cy51c2VJbnNlcnRpb25FZmZlY3QgPSB1c2VJbnNlcnRpb25FZmZlY3Q7XG5leHBvcnRzLnVzZUxheW91dEVmZmVjdCA9IHVzZUxheW91dEVmZmVjdDtcbmV4cG9ydHMudXNlTWVtbyA9IHVzZU1lbW87XG5leHBvcnRzLnVzZVJlZHVjZXIgPSB1c2VSZWR1Y2VyO1xuZXhwb3J0cy51c2VSZWYgPSB1c2VSZWY7XG5leHBvcnRzLnVzZVN0YXRlID0gdXNlU3RhdGU7XG5leHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlID0gdXNlU3luY0V4dGVybmFsU3RvcmU7XG5leHBvcnRzLnVzZVRyYW5zaXRpb24gPSB1c2VUcmFuc2l0aW9uO1xuZXhwb3J0cy52ZXJzaW9uID0gUmVhY3RWZXJzaW9uO1xuICAgICAgICAgIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCA9PT1cbiAgICAnZnVuY3Rpb24nXG4pIHtcbiAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKG5ldyBFcnJvcigpKTtcbn1cbiAgICAgICAgXG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIl9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsInJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCIsIkVycm9yIiwiUmVhY3RWZXJzaW9uIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiU3ltYm9sIiwiZm9yIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJSRUFDVF9GUkFHTUVOVF9UWVBFIiwiUkVBQ1RfU1RSSUNUX01PREVfVFlQRSIsIlJFQUNUX1BST0ZJTEVSX1RZUEUiLCJSRUFDVF9QUk9WSURFUl9UWVBFIiwiUkVBQ1RfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRSIsIlJFQUNUX0ZPUldBUkRfUkVGX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIiwiUkVBQ1RfTUVNT19UWVBFIiwiUkVBQ1RfTEFaWV9UWVBFIiwiUkVBQ1RfT0ZGU0NSRUVOX1RZUEUiLCJSRUFDVF9DQUNIRV9UWVBFIiwiUkVBQ1RfU0VSVkVSX0NPTlRFWFRfREVGQVVMVF9WQUxVRV9OT1RfTE9BREVEIiwiTUFZQkVfSVRFUkFUT1JfU1lNQk9MIiwiaXRlcmF0b3IiLCJGQVVYX0lURVJBVE9SX1NZTUJPTCIsImdldEl0ZXJhdG9yRm4iLCJtYXliZUl0ZXJhYmxlIiwibWF5YmVJdGVyYXRvciIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIkMSIsImN1cnJlbnQiLCJSZWFjdEN1cnJlbnRDYWNoZSIsIlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnIiwidHJhbnNpdGlvbiIsIlJlYWN0Q3VycmVudEFjdFF1ZXVlIiwiaXNCYXRjaGluZ0xlZ2FjeSIsImRpZFNjaGVkdWxlTGVnYWN5VXBkYXRlIiwiZGlkVXNlUHJvbWlzZSIsIlJlYWN0Q3VycmVudE93bmVyIiwiUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxIiwiY3VycmVudEV4dHJhU3RhY2tGcmFtZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsInN0YWNrIiwiZ2V0Q3VycmVudFN0YWNrIiwiZ2V0U3RhY2tBZGRlbmR1bSIsImltcGwiLCJlbmFibGVTY29wZUFQSSIsImVuYWJsZUNhY2hlRWxlbWVudCIsImVuYWJsZVRyYW5zaXRpb25UcmFjaW5nIiwiZW5hYmxlTGVnYWN5SGlkZGVuIiwiZW5hYmxlRGVidWdUcmFjaW5nIiwiQ29udGV4dFJlZ2lzdHJ5JDEiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwiQ29udGV4dFJlZ2lzdHJ5Iiwid2FybiIsImZvcm1hdCIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwicHJpbnRXYXJuaW5nIiwiZXJyb3IiLCJfbGVuMiIsIl9rZXkyIiwibGV2ZWwiLCJjb25jYXQiLCJhcmdzV2l0aEZvcm1hdCIsIm1hcCIsIml0ZW0iLCJTdHJpbmciLCJ1bnNoaWZ0IiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJhcHBseSIsImNhbGwiLCJjb25zb2xlIiwiZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50Iiwid2Fybk5vb3AiLCJwdWJsaWNJbnN0YW5jZSIsImNhbGxlck5hbWUiLCJfY29uc3RydWN0b3IiLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudE5hbWUiLCJkaXNwbGF5TmFtZSIsIm5hbWUiLCJ3YXJuaW5nS2V5IiwiUmVhY3ROb29wVXBkYXRlUXVldWUiLCJpc01vdW50ZWQiLCJlbnF1ZXVlRm9yY2VVcGRhdGUiLCJjYWxsYmFjayIsImVucXVldWVSZXBsYWNlU3RhdGUiLCJjb21wbGV0ZVN0YXRlIiwiZW5xdWV1ZVNldFN0YXRlIiwicGFydGlhbFN0YXRlIiwiYXNzaWduIiwiT2JqZWN0IiwiZW1wdHlPYmplY3QiLCJmcmVlemUiLCJDb21wb25lbnQiLCJwcm9wcyIsImNvbnRleHQiLCJ1cGRhdGVyIiwicmVmcyIsImlzUmVhY3RDb21wb25lbnQiLCJzZXRTdGF0ZSIsImZvcmNlVXBkYXRlIiwiZGVwcmVjYXRlZEFQSXMiLCJyZXBsYWNlU3RhdGUiLCJkZWZpbmVEZXByZWNhdGlvbldhcm5pbmciLCJtZXRob2ROYW1lIiwiaW5mbyIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwidW5kZWZpbmVkIiwiZm5OYW1lIiwiaGFzT3duUHJvcGVydHkiLCJDb21wb25lbnREdW1teSIsIlB1cmVDb21wb25lbnQiLCJwdXJlQ29tcG9uZW50UHJvdG90eXBlIiwiaXNQdXJlUmVhY3RDb21wb25lbnQiLCJjcmVhdGVSZWYiLCJyZWZPYmplY3QiLCJzZWFsIiwiaXNBcnJheUltcGwiLCJpc0FycmF5IiwiYSIsInR5cGVOYW1lIiwidmFsdWUiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwidHlwZSIsIndpbGxDb2VyY2lvblRocm93IiwidGVzdFN0cmluZ0NvZXJjaW9uIiwiZSIsImNoZWNrS2V5U3RyaW5nQ29lcmNpb24iLCJnZXRXcmFwcGVkTmFtZSIsIm91dGVyVHlwZSIsImlubmVyVHlwZSIsIndyYXBwZXJOYW1lIiwiZnVuY3Rpb25OYW1lIiwiZ2V0Q29udGV4dE5hbWUiLCJnZXRDb21wb25lbnROYW1lRnJvbVR5cGUiLCJ0YWciLCIkJHR5cGVvZiIsInByb3ZpZGVyIiwiX2NvbnRleHQiLCJyZW5kZXIiLCJvdXRlck5hbWUiLCJsYXp5Q29tcG9uZW50IiwicGF5bG9hZCIsIl9wYXlsb2FkIiwiaW5pdCIsIl9pbml0IiwieCIsImNvbnRleHQyIiwiX2dsb2JhbE5hbWUiLCJSRVNFUlZFRF9QUk9QUyIsImtleSIsInJlZiIsIl9fc2VsZiIsIl9fc291cmNlIiwic3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24iLCJzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biIsImRpZFdhcm5BYm91dFN0cmluZ1JlZnMiLCJoYXNWYWxpZFJlZiIsImNvbmZpZyIsImdldHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImlzUmVhY3RXYXJuaW5nIiwiaGFzVmFsaWRLZXkiLCJkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlciIsIndhcm5BYm91dEFjY2Vzc2luZ0tleSIsImNvbmZpZ3VyYWJsZSIsImRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nUmVmIiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwic3RhdGVOb2RlIiwiUmVhY3RFbGVtZW50Iiwic2VsZiIsInNvdXJjZSIsIm93bmVyIiwiZWxlbWVudCIsIl9vd25lciIsIl9zdG9yZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImNyZWF0ZUVsZW1lbnQkMSIsImNoaWxkcmVuIiwicHJvcE5hbWUiLCJjaGlsZHJlbkxlbmd0aCIsImNoaWxkQXJyYXkiLCJpIiwiZGVmYXVsdFByb3BzIiwiY2xvbmVBbmRSZXBsYWNlS2V5Iiwib2xkRWxlbWVudCIsIm5ld0tleSIsIm5ld0VsZW1lbnQiLCJfc2VsZiIsIl9zb3VyY2UiLCJjbG9uZUVsZW1lbnQkMSIsImlzVmFsaWRFbGVtZW50Iiwib2JqZWN0IiwiU0VQQVJBVE9SIiwiU1VCU0VQQVJBVE9SIiwiZXNjYXBlIiwiZXNjYXBlUmVnZXgiLCJlc2NhcGVyTG9va3VwIiwiZXNjYXBlZFN0cmluZyIsInJlcGxhY2UiLCJtYXRjaCIsImRpZFdhcm5BYm91dE1hcHMiLCJ1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCIsImVzY2FwZVVzZXJQcm92aWRlZEtleSIsInRleHQiLCJnZXRFbGVtZW50S2V5IiwiaW5kZXgiLCJ0b1N0cmluZyIsIm1hcEludG9BcnJheSIsImFycmF5IiwiZXNjYXBlZFByZWZpeCIsIm5hbWVTb0ZhciIsImludm9rZUNhbGxiYWNrIiwiX2NoaWxkIiwibWFwcGVkQ2hpbGQiLCJjaGlsZEtleSIsImVzY2FwZWRDaGlsZEtleSIsImMiLCJwdXNoIiwiY2hpbGQiLCJuZXh0TmFtZSIsInN1YnRyZWVDb3VudCIsIm5leHROYW1lUHJlZml4IiwiaXRlcmF0b3JGbiIsIml0ZXJhYmxlQ2hpbGRyZW4iLCJlbnRyaWVzIiwic3RlcCIsImlpIiwibmV4dCIsImRvbmUiLCJjaGlsZHJlblN0cmluZyIsImtleXMiLCJqb2luIiwibWFwQ2hpbGRyZW4iLCJmdW5jIiwicmVzdWx0IiwiY291bnQiLCJjb3VudENoaWxkcmVuIiwibiIsImZvckVhY2hDaGlsZHJlbiIsImZvckVhY2hGdW5jIiwiZm9yRWFjaENvbnRleHQiLCJ0b0FycmF5Iiwib25seUNoaWxkIiwiY3JlYXRlQ29udGV4dCIsImRlZmF1bHRWYWx1ZSIsIl9jdXJyZW50VmFsdWUiLCJfY3VycmVudFZhbHVlMiIsIl90aHJlYWRDb3VudCIsIlByb3ZpZGVyIiwiQ29uc3VtZXIiLCJfZGVmYXVsdFZhbHVlIiwiaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMiLCJoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciIsImhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyIiwiZGVmaW5lUHJvcGVydGllcyIsInNldCIsIl9Qcm92aWRlciIsIl9jdXJyZW50UmVuZGVyZXIiLCJfY3VycmVudFJlbmRlcmVyMiIsIlVuaW5pdGlhbGl6ZWQiLCJQZW5kaW5nIiwiUmVzb2x2ZWQiLCJSZWplY3RlZCIsImxhenlJbml0aWFsaXplciIsIl9zdGF0dXMiLCJjdG9yIiwiX3Jlc3VsdCIsInRoZW5hYmxlIiwidGhlbiIsIm1vZHVsZU9iamVjdCIsInJlc29sdmVkIiwicmVqZWN0ZWQiLCJwZW5kaW5nIiwiZGVmYXVsdCIsImxhenkiLCJsYXp5VHlwZSIsInByb3BUeXBlcyIsIm5ld0RlZmF1bHRQcm9wcyIsIm5ld1Byb3BUeXBlcyIsImZvcndhcmRSZWYiLCJlbGVtZW50VHlwZSIsIm93bk5hbWUiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJnZXRNb2R1bGVJZCIsIm1lbW8iLCJjb21wYXJlIiwiVU5URVJNSU5BVEVEIiwiVEVSTUlOQVRFRCIsIkVSUk9SRUQiLCJjcmVhdGVDYWNoZVJvb3QiLCJXZWFrTWFwIiwiY3JlYXRlQ2FjaGVOb2RlIiwicyIsInYiLCJvIiwicCIsImNhY2hlIiwiZm4iLCJkaXNwYXRjaGVyIiwiZm5NYXAiLCJnZXRDYWNoZUZvclR5cGUiLCJmbk5vZGUiLCJjYWNoZU5vZGUiLCJsIiwiYXJnIiwib2JqZWN0Q2FjaGUiLCJvYmplY3ROb2RlIiwicHJpbWl0aXZlQ2FjaGUiLCJNYXAiLCJwcmltaXRpdmVOb2RlIiwidGVybWluYXRlZE5vZGUiLCJlcnJvcmVkTm9kZSIsInJlc29sdmVEaXNwYXRjaGVyIiwidXNlQ29udGV4dCIsIkNvbnRleHQiLCJyZWFsQ29udGV4dCIsInVzZVN0YXRlIiwiaW5pdGlhbFN0YXRlIiwidXNlUmVkdWNlciIsInJlZHVjZXIiLCJpbml0aWFsQXJnIiwidXNlUmVmIiwiaW5pdGlhbFZhbHVlIiwidXNlRWZmZWN0IiwiY3JlYXRlIiwiZGVwcyIsInVzZUluc2VydGlvbkVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUNhbGxiYWNrIiwidXNlTWVtbyIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJ1c2VEZWJ1Z1ZhbHVlIiwiZm9ybWF0dGVyRm4iLCJ1c2VUcmFuc2l0aW9uIiwidXNlRGVmZXJyZWRWYWx1ZSIsInVzZUlkIiwidXNlU3luY0V4dGVybmFsU3RvcmUiLCJzdWJzY3JpYmUiLCJnZXRTbmFwc2hvdCIsImdldFNlcnZlclNuYXBzaG90IiwidXNlQ2FjaGVSZWZyZXNoIiwidXNlIiwidXNhYmxlIiwiZGlzYWJsZWREZXB0aCIsInByZXZMb2ciLCJwcmV2SW5mbyIsInByZXZXYXJuIiwicHJldkVycm9yIiwicHJldkdyb3VwIiwicHJldkdyb3VwQ29sbGFwc2VkIiwicHJldkdyb3VwRW5kIiwiZGlzYWJsZWRMb2ciLCJfX3JlYWN0RGlzYWJsZWRMb2ciLCJkaXNhYmxlTG9ncyIsImxvZyIsImdyb3VwIiwiZ3JvdXBDb2xsYXBzZWQiLCJncm91cEVuZCIsInJlZW5hYmxlTG9ncyIsInByZWZpeCIsImRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lIiwib3duZXJGbiIsInRyaW0iLCJyZWVudHJ5IiwiY29tcG9uZW50RnJhbWVDYWNoZSIsIlBvc3NpYmx5V2Vha01hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJjb25zdHJ1Y3QiLCJmcmFtZSIsImNvbnRyb2wiLCJwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlIiwicHJlcGFyZVN0YWNrVHJhY2UiLCJwcmV2aW91c0Rpc3BhdGNoZXIiLCJGYWtlIiwiUmVmbGVjdCIsIm1heWJlUHJvbWlzZSIsImNhdGNoIiwic2FtcGxlIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsIl9mcmFtZSIsImluY2x1ZGVzIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxIiwiY2hlY2tQcm9wVHlwZXMiLCJ0eXBlU3BlY3MiLCJ2YWx1ZXMiLCJsb2NhdGlvbiIsImhhcyIsImJpbmQiLCJ0eXBlU3BlY05hbWUiLCJlcnJvciQxIiwiZXJyIiwiZXgiLCJtZXNzYWdlIiwiUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSIsInNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50IiwicHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24iLCJnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0iLCJnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bSIsImZpbGVOYW1lIiwibGluZU51bWJlciIsImdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtRm9yUHJvcHMiLCJlbGVtZW50UHJvcHMiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJ2YWxpZGF0ZVByb3BUeXBlcyIsIlByb3BUeXBlcyIsIl9uYW1lIiwiZ2V0RGVmYXVsdFByb3BzIiwiaXNSZWFjdENsYXNzQXBwcm92ZWQiLCJ2YWxpZGF0ZUZyYWdtZW50UHJvcHMiLCJmcmFnbWVudCIsImNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJ0eXBlU3RyaW5nIiwiZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkiLCJjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24iLCJ2YWxpZGF0ZWRGYWN0b3J5IiwiY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24iLCJjcmVhdGVTZXJ2ZXJDb250ZXh0IiwiZ2xvYmFsTmFtZSIsIndhc0RlZmluZWQiLCJoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXIiLCJzdGFydFRyYW5zaXRpb24iLCJzY29wZSIsIm9wdGlvbnMiLCJwcmV2VHJhbnNpdGlvbiIsImN1cnJlbnRUcmFuc2l0aW9uIiwiX3VwZGF0ZWRGaWJlcnMiLCJTZXQiLCJ1cGRhdGVkRmliZXJzQ291bnQiLCJzaXplIiwiY2xlYXIiLCJkaWRXYXJuQWJvdXRNZXNzYWdlQ2hhbm5lbCIsImVucXVldWVUYXNrSW1wbCIsImVucXVldWVUYXNrIiwidGFzayIsInJlcXVpcmVTdHJpbmciLCJNYXRoIiwicmFuZG9tIiwic2xpY2UiLCJub2RlUmVxdWlyZSIsIm1vZHVsZSIsInNldEltbWVkaWF0ZSIsIl9lcnIiLCJNZXNzYWdlQ2hhbm5lbCIsImNoYW5uZWwiLCJwb3J0MSIsIm9ubWVzc2FnZSIsInBvcnQyIiwicG9zdE1lc3NhZ2UiLCJhY3RTY29wZURlcHRoIiwiZGlkV2Fybk5vQXdhaXRBY3QiLCJhY3QiLCJwcmV2SXNCYXRjaGluZ0xlZ2FjeSIsInByZXZBY3RRdWV1ZSIsInByZXZBY3RTY29wZURlcHRoIiwicXVldWUiLCJkaWRBd2FpdEFjdENhbGwiLCJmbHVzaEFjdFF1ZXVlIiwicG9wQWN0U2NvcGUiLCJxdWV1ZVNldmVyYWxNaWNyb3Rhc2tzIiwicmVzb2x2ZSIsInJlamVjdCIsInJldHVyblZhbHVlIiwicmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayIsImlzRmx1c2hpbmciLCJjb250aW51YXRpb24iLCJzcGxpY2UiLCJxdWV1ZU1pY3JvdGFzayIsImNyZWF0ZUVsZW1lbnQiLCJjbG9uZUVsZW1lbnQiLCJjcmVhdGVGYWN0b3J5IiwiQ2hpbGRyZW4iLCJmb3JFYWNoIiwib25seSIsImV4cG9ydHMiLCJGcmFnbWVudCIsIlByb2ZpbGVyIiwiU3RyaWN0TW9kZSIsIlN1c3BlbnNlIiwiX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJ1bnN0YWJsZV9hY3QiLCJ1bnN0YWJsZV91c2VDYWNoZVJlZnJlc2giLCJ2ZXJzaW9uIiwicmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/compiled/react/cjs/react.development.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/compiled/react/index.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react.development.js */ \"(rsc)/./node_modules/next/dist/compiled/react/cjs/react.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLGdKQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL3dhaGVndXJ1LXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2luZGV4LmpzP2RlMzciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/compiled/react/index.js\n");

/***/ })

};
;